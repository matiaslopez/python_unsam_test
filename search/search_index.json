{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programaci\u00f3n en Python En el marco del proyecto de Inteligencia Artificial Interdisciplinaria , la Escuela de Ciencia y Tecnolog\u00eda de la UNSAM vuelve a dictar en 2021 el curso de programaci\u00f3n en Python. \u00bfDe qu\u00e9 es el curso? Este es un curso cuatrimestral de algoritmos y programaci\u00f3n en Python. Se realiza en forma virtual y tendr\u00e1 una combinaci\u00f3n de clases sincr\u00f3nicas y asincr\u00f3nicas, con ejercicios para entregar semanalmente. Es un curso de programaci\u00f3n en Python que prepara a les estudiantes para poder programar algoritmos y comprender los m\u00e9todos desarrollados por otres. Est\u00e1 orientado a preparar a le estudiante para profundizar en temas de an\u00e1lisis y visualizaci\u00f3n de datos, aprendizaje autom\u00e1tico, modelado matem\u00e1tico y desarrollo de scripts . El curso comienza el 4 de agosto y se dicta semanalmente. Los d\u00edas mi\u00e9rcoles de 14hs de 16hs hay clases de consultas. El material de las clases te\u00f3ricas, tanto escrito como videos, estar\u00e1 disponible en este repositorio de manera que el curso (salvo los parciales) se puede hacer casi completamente de manera asincr\u00f3nica. Es un curso gratuito y anunciaremos oportunamente la inscripci\u00f3n. Audiencia. \u00bfPara qui\u00e9n est\u00e1 pensado? El curso est\u00e1 orientado a estudiantes de grado y posgrado e investigadores con algunos conocimientos previos de programaci\u00f3n, aunque no asumimos ning\u00fan conocimiento del lenguaje Python. Es un curso intenso y desafiante, que invita a pensar y a desarrollar algoritmos. Contenidos El objetivo de este curso es ense\u00f1ar los fundamentos del lenguaje Python y algunos conceptos del dise\u00f1o de algoritmos. El curso est\u00e1 orientado al manejo de datos, a la escritura de scripts y a una organizaci\u00f3n adecuada de los programas. Estudiaremos un poco de teor\u00eda de algoritmos, incluyendo conceptos b\u00e1sicos de la teor\u00eda de la complejidad y algunas estructuras de datos no triviales. Introduciremos la programaci\u00f3n orientada a objetos. Al final de este curso les estudiantes deber\u00edan poder escribir sus propios programas en Python as\u00ed como entender y modificar programas escritos por otres. Requerimientos Para hacer este curso solo hace falta tener instalado el Python 3.6 (o uno m\u00e1s nuevo), comprometerse a leer las clases y a hacer los ejercicios de las gu\u00edas semanales, lo que demandar\u00e1 alrededor de 15 horas de dedicaci\u00f3n semanal (en algunos casos menos, en algunos casos m\u00e1s, dependiendo del estudiante). Pedimos tener alguna experiencia previa programando, aunque sea poca. Este no es un curso de introducci\u00f3n a la inform\u00e1tica. Dedicaci\u00f3n y duraci\u00f3n Este es un curso cuatrimestral de grado y posgrado. Las clases te\u00f3ricas estar\u00e1n escritas. Habr\u00e1 gu\u00edas de ejercicios de entrega semanal obligatoria y encuentros on-line con exposiciones breves por parte de los docentes y espacio para consultas. Las clases sincr\u00f3nicas virtuales ser\u00e1n de un par de horas semanales, los mi\u00e9rcoles a las 14hs. Habr\u00e1 tambi\u00e9n un grupo de Slack (mensajer\u00eda on-line) para consultas y debates entre estudiantes en tiempo real. El curso demanda unas quince horas semanales de dedicaci\u00f3n, durante cuatro meses. Docentes El curso lo dictan dos profesores de la ECyT-UNSAM que son tambi\u00e9n investigadores del CONICET: Oscar Filevich es Lic. en Biolog\u00eda, Dr. en Qu\u00edmica y trabaja en neurofisiolog\u00eda; Rafael Grimson es Lic. en Matem\u00e1tica, Dr. en Computaci\u00f3n y trabaja en temas ambientales, una JTP (Manuela Cerdiero) y dos ayudantes (Iv\u00e1n Pedr\u00f3n y Daniela Alban). Adem\u00e1s, contamos con Matias L\u00f3pez-Rosenfeld como profesor invitado. Preinscripci\u00f3n La preinscripci\u00f3n al curso a\u00fan no abri\u00f3. Si quer\u00e9s que te informemos cuando la abramos complet\u00e1 este formulario .","title":"Inicio"},{"location":"#programacion-en-python","text":"En el marco del proyecto de Inteligencia Artificial Interdisciplinaria , la Escuela de Ciencia y Tecnolog\u00eda de la UNSAM vuelve a dictar en 2021 el curso de programaci\u00f3n en Python.","title":"Programaci\u00f3n en Python"},{"location":"#de-que-es-el-curso","text":"Este es un curso cuatrimestral de algoritmos y programaci\u00f3n en Python. Se realiza en forma virtual y tendr\u00e1 una combinaci\u00f3n de clases sincr\u00f3nicas y asincr\u00f3nicas, con ejercicios para entregar semanalmente. Es un curso de programaci\u00f3n en Python que prepara a les estudiantes para poder programar algoritmos y comprender los m\u00e9todos desarrollados por otres. Est\u00e1 orientado a preparar a le estudiante para profundizar en temas de an\u00e1lisis y visualizaci\u00f3n de datos, aprendizaje autom\u00e1tico, modelado matem\u00e1tico y desarrollo de scripts . El curso comienza el 4 de agosto y se dicta semanalmente. Los d\u00edas mi\u00e9rcoles de 14hs de 16hs hay clases de consultas. El material de las clases te\u00f3ricas, tanto escrito como videos, estar\u00e1 disponible en este repositorio de manera que el curso (salvo los parciales) se puede hacer casi completamente de manera asincr\u00f3nica. Es un curso gratuito y anunciaremos oportunamente la inscripci\u00f3n.","title":"\u00bfDe qu\u00e9 es el curso?"},{"location":"#audiencia-para-quien-esta-pensado","text":"El curso est\u00e1 orientado a estudiantes de grado y posgrado e investigadores con algunos conocimientos previos de programaci\u00f3n, aunque no asumimos ning\u00fan conocimiento del lenguaje Python. Es un curso intenso y desafiante, que invita a pensar y a desarrollar algoritmos.","title":"Audiencia. \u00bfPara qui\u00e9n est\u00e1 pensado?"},{"location":"#contenidos","text":"El objetivo de este curso es ense\u00f1ar los fundamentos del lenguaje Python y algunos conceptos del dise\u00f1o de algoritmos. El curso est\u00e1 orientado al manejo de datos, a la escritura de scripts y a una organizaci\u00f3n adecuada de los programas. Estudiaremos un poco de teor\u00eda de algoritmos, incluyendo conceptos b\u00e1sicos de la teor\u00eda de la complejidad y algunas estructuras de datos no triviales. Introduciremos la programaci\u00f3n orientada a objetos. Al final de este curso les estudiantes deber\u00edan poder escribir sus propios programas en Python as\u00ed como entender y modificar programas escritos por otres.","title":"Contenidos"},{"location":"#requerimientos","text":"Para hacer este curso solo hace falta tener instalado el Python 3.6 (o uno m\u00e1s nuevo), comprometerse a leer las clases y a hacer los ejercicios de las gu\u00edas semanales, lo que demandar\u00e1 alrededor de 15 horas de dedicaci\u00f3n semanal (en algunos casos menos, en algunos casos m\u00e1s, dependiendo del estudiante). Pedimos tener alguna experiencia previa programando, aunque sea poca. Este no es un curso de introducci\u00f3n a la inform\u00e1tica.","title":"Requerimientos"},{"location":"#dedicacion-y-duracion","text":"Este es un curso cuatrimestral de grado y posgrado. Las clases te\u00f3ricas estar\u00e1n escritas. Habr\u00e1 gu\u00edas de ejercicios de entrega semanal obligatoria y encuentros on-line con exposiciones breves por parte de los docentes y espacio para consultas. Las clases sincr\u00f3nicas virtuales ser\u00e1n de un par de horas semanales, los mi\u00e9rcoles a las 14hs. Habr\u00e1 tambi\u00e9n un grupo de Slack (mensajer\u00eda on-line) para consultas y debates entre estudiantes en tiempo real. El curso demanda unas quince horas semanales de dedicaci\u00f3n, durante cuatro meses.","title":"Dedicaci\u00f3n y duraci\u00f3n"},{"location":"#docentes","text":"El curso lo dictan dos profesores de la ECyT-UNSAM que son tambi\u00e9n investigadores del CONICET: Oscar Filevich es Lic. en Biolog\u00eda, Dr. en Qu\u00edmica y trabaja en neurofisiolog\u00eda; Rafael Grimson es Lic. en Matem\u00e1tica, Dr. en Computaci\u00f3n y trabaja en temas ambientales, una JTP (Manuela Cerdiero) y dos ayudantes (Iv\u00e1n Pedr\u00f3n y Daniela Alban). Adem\u00e1s, contamos con Matias L\u00f3pez-Rosenfeld como profesor invitado.","title":"Docentes"},{"location":"#preinscripcion","text":"La preinscripci\u00f3n al curso a\u00fan no abri\u00f3. Si quer\u00e9s que te informemos cuando la abramos complet\u00e1 este formulario .","title":"Preinscripci\u00f3n"},{"location":"01_Introduccion/00_Resumen/","text":"Contenidos | Pr\u00f3ximo (2 Estructuras y funciones) 1. Introducci\u00f3n a Python El objetivo de este primera clase es introducir algunos conceptos b\u00e1sicos de Python. Comenzando desde cero vas a aprender a editar, ejecutar y debuguear peque\u00f1os programas. Tambi\u00e9n presentamos algunos tipos de datos de Python: n\u00famero enteros, n\u00fameros de punto flotante, cadenas y listas. 1.1 Python 1.2 Un primer programa 1.3 N\u00fameros 1.4 Cadenas 1.5 Listas 1.6 Cierre de la clase Contenidos | Pr\u00f3ximo (2 Estructuras y funciones)","title":"00 Resumen"},{"location":"01_Introduccion/00_Resumen/#1-introduccion-a-python","text":"El objetivo de este primera clase es introducir algunos conceptos b\u00e1sicos de Python. Comenzando desde cero vas a aprender a editar, ejecutar y debuguear peque\u00f1os programas. Tambi\u00e9n presentamos algunos tipos de datos de Python: n\u00famero enteros, n\u00fameros de punto flotante, cadenas y listas. 1.1 Python 1.2 Un primer programa 1.3 N\u00fameros 1.4 Cadenas 1.5 Listas 1.6 Cierre de la clase Contenidos | Pr\u00f3ximo (2 Estructuras y funciones)","title":"1. Introducci\u00f3n a Python"},{"location":"01_Introduccion/01_Python/","text":"Contenidos | Pr\u00f3ximo (2 Un primer programa) 1.1 Python \u00bfQu\u00e9 es Python? Python es un lenguaje interpretado de alto nivel. Frecuentemente se lo clasifica como lenguaje de \"scripting\" . La sintaxis del Python tiene elementos de lenguaje C de programaci\u00f3n. Python fue creado por Guido van Rossum a principios de la d\u00e9cada del '90 y lo nombr\u00f3 as\u00ed en honor de Monty Python. \u00bfD\u00f3nde conseguir Python? Te recomendamos instalar Python 3.6 o m\u00e1s nuevo. En la documentaci\u00f3n previa hablamos sobre c\u00f3mo instalar Python para este curso . \u00bfPara qu\u00e9 fue creado Python? El objetivo original de su autor fue crear un lenguaje de programaci\u00f3n con el que pudiera realizar las tareas de administraci\u00f3n de un sistema f\u00e1cilmente. En alg\u00fan sentido los scripts de la terminal no eran suficientemente poderosos y programar esas tareas en C resultaba demasiado tedioso. Python fue creado para llenar ese hueco en el medio. \u00bfC\u00f3mo ejecuto Python en mi m\u00e1quina? Existen diferentes entornos en los que pod\u00e9s correr Python en tu computadora. Es importante saber que Python est\u00e1 instalado normalmente como un programa que se ejecuta desde la consola. Desde la terminal deber\u00edas poder ejecutar python as\u00ed: bash $ python Python 3.8.1 (default, Feb 20 2020, 09:29:22) [Clang 10.0.0 (clang-1000.10.44.4)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> print(\"hello world\") hello world >>> Si es la primera vez que ves una consola o terminal, ser\u00eda conveniente que pares aqu\u00ed, leas un tutorial corto sobre c\u00f3mo usar la consola de tu sistema operativo y luego vuelvas para seguir leyendo. Existen diversos entornos fuera de la terminal en los que se puede escribir y ejecutar c\u00f3digo Python. Pero para nosotros es importante que primero aprendas a usarlo desde la terminal: si lo sab\u00e9s usar bien desde la terminal (que es su entorno natural) lo podr\u00e1s usar en cualquier otro entorno. Ya en la pr\u00f3xima clase usar\u00e1s Python dentro de un entorno de desarrollo. Por ahora, te recomendamos usarlo de esta manera que acabamos de explicar. Ejercicios Ejercicio 1.1: Python como calculadora En tu m\u00e1quina, inici\u00e1 Python y usalo como calculadora para resolver el siguiente problema: \u00bfCu\u00e1ntas horas son 105 minutos? \u00bfCu\u00e1ntos kil\u00f3metros son 20 millas? (un kil\u00f3metro corresponde a 0,6214 millas) >>> 105/60 1.75 >>> 20 / 0.6214 32.1853878339234 tip: Us\u00e1 el gui\u00f3n bajo (underscore, _) para referirte al resultado del \u00faltimo c\u00e1lculo. Si alguien corre una carrera de 20 millas en 105 minutos, \u00bfcu\u00e1l fue tu velocidad promedio en km/h? >>> _/1.75 18.391650190813372 Ejercicio 1.2: Obtener ayuda Us\u00e1 el comando help() para obtener ayuda sobre la funci\u00f3n abs() . Luego, us\u00e1 el help() para obtener la ayuda sobre la funci\u00f3n round() . Tipe\u00e1 help() s\u00f3lo para entrar en la ayuda en modo interactivo. El help() no funciona con los comandos b\u00e1sicos de Python como for , if , while , etc. Si tipe\u00e1s help(for) vas a obtener un error. Pod\u00e9s probar usando comillas como en help(\"for\") , en algunos entornos funciona bien. Si no, siempre pod\u00e9s hacer una b\u00fasqueda en internet. La documentaci\u00f3n oficial en ingl\u00e9s de Python se encuentra en http://docs.python.org . Por ejemplo, encontr\u00e1 ah\u00ed la documentaci\u00f3n sobre la funci\u00f3n abs() (ayuda: est\u00e1 dentro de \"library reference\" y relacionado a las \"built-in functions\"). Ejercicio 1.3: Copy-paste Este curso est\u00e1 estructurado como una serie de p\u00e1ginas web tradicionales en las que les incentivamos a probar interactivamente fragmentos de c\u00f3digo en sus int\u00e9rpretes de Python escribi\u00e9ndolos a mano . Si est\u00e1s aprendiendo Python por primera vez, esta forma \"lenta\" de hacer las cosas es la que recomendamos. Vas a entender mejor yendo lento y escribiendo los comandos vos mismo mientras pens\u00e1s en lo que est\u00e1s tipeando. Es importante que tip\u00e9es los comandos a mano. Para usar copy-paste quiz\u00e1s mejor ni hacerlos. Parte del objetivo de los ejercicios es entrenar tus manos, tus ojos y tu cabeza en leer, escribir y mirar c\u00f3digo tal como dice Zed Shaw en su libro . Usar copy-paste excesivamente es como hacerte trampa a vos misme. Es como tratar de aprender a tocar la guitarra escuchando discos: es probable que no aprendas nunca. Si, de todas formas, en alg\u00fan momento necesit\u00e1s hacer \"copy-paste\" de fragmentos de c\u00f3digo, seleccion\u00e1 el c\u00f3digo que viene luego del s\u00edmbolo >>> y hasta la siguiente linea en blanco o el siguiente >>> (el que aparezca primero). Seleccion\u00e1 \"copy\" en el navegador (Ctrl-C), and\u00e1 al int\u00e9rprete de Python y pon\u00e9 \"paste\" (Ctrl-V o Crtl-shift-V) para pegarlo. Para ejecutar el c\u00f3digo es posible que tengas que apretar \"Enter\" luego de pegarlo. Us\u00e1 copy-paste para ejecutar los siguientes comandos: >>> 12 + 20 32 >>> (3 + 4 + 5 + 6) 18 >>> for i in range(5): print(i) 0 1 2 3 4 >>> Advertencia: Cuando ten\u00e9s algo como el c\u00f3digo de arriba, no es posible copiar y pegar en el entorno b\u00e1sico de Python m\u00e1s de un comando por vez. El s\u00edmbolo >>> lo impide. Contenidos | Pr\u00f3ximo (2 Un primer programa)","title":"01 Python"},{"location":"01_Introduccion/01_Python/#11-python","text":"","title":"1.1 Python"},{"location":"01_Introduccion/01_Python/#que-es-python","text":"Python es un lenguaje interpretado de alto nivel. Frecuentemente se lo clasifica como lenguaje de \"scripting\" . La sintaxis del Python tiene elementos de lenguaje C de programaci\u00f3n. Python fue creado por Guido van Rossum a principios de la d\u00e9cada del '90 y lo nombr\u00f3 as\u00ed en honor de Monty Python.","title":"\u00bfQu\u00e9 es Python?"},{"location":"01_Introduccion/01_Python/#donde-conseguir-python","text":"Te recomendamos instalar Python 3.6 o m\u00e1s nuevo. En la documentaci\u00f3n previa hablamos sobre c\u00f3mo instalar Python para este curso .","title":"\u00bfD\u00f3nde conseguir Python?"},{"location":"01_Introduccion/01_Python/#para-que-fue-creado-python","text":"El objetivo original de su autor fue crear un lenguaje de programaci\u00f3n con el que pudiera realizar las tareas de administraci\u00f3n de un sistema f\u00e1cilmente. En alg\u00fan sentido los scripts de la terminal no eran suficientemente poderosos y programar esas tareas en C resultaba demasiado tedioso. Python fue creado para llenar ese hueco en el medio.","title":"\u00bfPara qu\u00e9 fue creado Python?"},{"location":"01_Introduccion/01_Python/#como-ejecuto-python-en-mi-maquina","text":"Existen diferentes entornos en los que pod\u00e9s correr Python en tu computadora. Es importante saber que Python est\u00e1 instalado normalmente como un programa que se ejecuta desde la consola. Desde la terminal deber\u00edas poder ejecutar python as\u00ed: bash $ python Python 3.8.1 (default, Feb 20 2020, 09:29:22) [Clang 10.0.0 (clang-1000.10.44.4)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> print(\"hello world\") hello world >>> Si es la primera vez que ves una consola o terminal, ser\u00eda conveniente que pares aqu\u00ed, leas un tutorial corto sobre c\u00f3mo usar la consola de tu sistema operativo y luego vuelvas para seguir leyendo. Existen diversos entornos fuera de la terminal en los que se puede escribir y ejecutar c\u00f3digo Python. Pero para nosotros es importante que primero aprendas a usarlo desde la terminal: si lo sab\u00e9s usar bien desde la terminal (que es su entorno natural) lo podr\u00e1s usar en cualquier otro entorno. Ya en la pr\u00f3xima clase usar\u00e1s Python dentro de un entorno de desarrollo. Por ahora, te recomendamos usarlo de esta manera que acabamos de explicar.","title":"\u00bfC\u00f3mo ejecuto Python en mi m\u00e1quina?"},{"location":"01_Introduccion/01_Python/#ejercicios","text":"","title":"Ejercicios"},{"location":"01_Introduccion/01_Python/#ejercicio-11-python-como-calculadora","text":"En tu m\u00e1quina, inici\u00e1 Python y usalo como calculadora para resolver el siguiente problema: \u00bfCu\u00e1ntas horas son 105 minutos? \u00bfCu\u00e1ntos kil\u00f3metros son 20 millas? (un kil\u00f3metro corresponde a 0,6214 millas) >>> 105/60 1.75 >>> 20 / 0.6214 32.1853878339234 tip: Us\u00e1 el gui\u00f3n bajo (underscore, _) para referirte al resultado del \u00faltimo c\u00e1lculo. Si alguien corre una carrera de 20 millas en 105 minutos, \u00bfcu\u00e1l fue tu velocidad promedio en km/h? >>> _/1.75 18.391650190813372","title":"Ejercicio 1.1: Python como  calculadora"},{"location":"01_Introduccion/01_Python/#ejercicio-12-obtener-ayuda","text":"Us\u00e1 el comando help() para obtener ayuda sobre la funci\u00f3n abs() . Luego, us\u00e1 el help() para obtener la ayuda sobre la funci\u00f3n round() . Tipe\u00e1 help() s\u00f3lo para entrar en la ayuda en modo interactivo. El help() no funciona con los comandos b\u00e1sicos de Python como for , if , while , etc. Si tipe\u00e1s help(for) vas a obtener un error. Pod\u00e9s probar usando comillas como en help(\"for\") , en algunos entornos funciona bien. Si no, siempre pod\u00e9s hacer una b\u00fasqueda en internet. La documentaci\u00f3n oficial en ingl\u00e9s de Python se encuentra en http://docs.python.org . Por ejemplo, encontr\u00e1 ah\u00ed la documentaci\u00f3n sobre la funci\u00f3n abs() (ayuda: est\u00e1 dentro de \"library reference\" y relacionado a las \"built-in functions\").","title":"Ejercicio 1.2: Obtener ayuda"},{"location":"01_Introduccion/01_Python/#ejercicio-13-copy-paste","text":"Este curso est\u00e1 estructurado como una serie de p\u00e1ginas web tradicionales en las que les incentivamos a probar interactivamente fragmentos de c\u00f3digo en sus int\u00e9rpretes de Python escribi\u00e9ndolos a mano . Si est\u00e1s aprendiendo Python por primera vez, esta forma \"lenta\" de hacer las cosas es la que recomendamos. Vas a entender mejor yendo lento y escribiendo los comandos vos mismo mientras pens\u00e1s en lo que est\u00e1s tipeando. Es importante que tip\u00e9es los comandos a mano. Para usar copy-paste quiz\u00e1s mejor ni hacerlos. Parte del objetivo de los ejercicios es entrenar tus manos, tus ojos y tu cabeza en leer, escribir y mirar c\u00f3digo tal como dice Zed Shaw en su libro . Usar copy-paste excesivamente es como hacerte trampa a vos misme. Es como tratar de aprender a tocar la guitarra escuchando discos: es probable que no aprendas nunca. Si, de todas formas, en alg\u00fan momento necesit\u00e1s hacer \"copy-paste\" de fragmentos de c\u00f3digo, seleccion\u00e1 el c\u00f3digo que viene luego del s\u00edmbolo >>> y hasta la siguiente linea en blanco o el siguiente >>> (el que aparezca primero). Seleccion\u00e1 \"copy\" en el navegador (Ctrl-C), and\u00e1 al int\u00e9rprete de Python y pon\u00e9 \"paste\" (Ctrl-V o Crtl-shift-V) para pegarlo. Para ejecutar el c\u00f3digo es posible que tengas que apretar \"Enter\" luego de pegarlo. Us\u00e1 copy-paste para ejecutar los siguientes comandos: >>> 12 + 20 32 >>> (3 + 4 + 5 + 6) 18 >>> for i in range(5): print(i) 0 1 2 3 4 >>> Advertencia: Cuando ten\u00e9s algo como el c\u00f3digo de arriba, no es posible copiar y pegar en el entorno b\u00e1sico de Python m\u00e1s de un comando por vez. El s\u00edmbolo >>> lo impide. Contenidos | Pr\u00f3ximo (2 Un primer programa)","title":"Ejercicio 1.3: Copy-paste"},{"location":"01_Introduccion/02_Hello_world/","text":"Contenidos | Anterior (1 Python) | Pr\u00f3ximo (3 N\u00fameros) 1.2 Un primer programa En esta secci\u00f3n vas a crear tu primer programa en Python, ejecutarlo y debuguearlo. Ejecutando Python Los programas en Python siempre son ejecutados en un int\u00e9rprete de Python. El int\u00e9rprete es una aplicaci\u00f3n que funciona en la consola y se ejecuta desde la terminal. python3 Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Les programadores no suelen tener problemas en usar el int\u00e9rprete de esta forma, aunque no es la m\u00e1s c\u00f3moda para principiantes. M\u00e1s adelante vamos a proponerles usar entornos de desarrollo m\u00e1s sofisticados, pero por el momento qued\u00e9mosnos con la incomodidad que nos va a ense\u00f1ar cosas \u00fatiles. Modo interactivo Cuando ejecut\u00e1s Python, entr\u00e1s al modo interactivo en el que pod\u00e9s experimentar. Si escrib\u00eds un comando, se va a ejecutar inmediatamente. No hay ning\u00fan ciclo de edici\u00f3n-compilaci\u00f3n-ejecuci\u00f3n-debug en Python, como hay en otros lenguajes. >>> print('hello world') hello world >>> 37*42 1554 >>> for i in range(5): ... print(i) ... 0 1 2 3 4 >>> Esta forma de escribir c\u00f3digo (en una consola del lenguaje) que se eval\u00faa inmediatamente e imprime el resultado, se denomina bucle de Lectura-Evaluaci\u00f3n-Impresi\u00f3n (REPL por las siglas en ingl\u00e9s de \u00abRead-Eval-Print-Loop\u00bb). Asegurate de poder interactuar con el int\u00e9rprete antes de seguir. Veamos en mayor detalle c\u00f3mo funciona este REPL: >>> es el s\u00edmbolo del int\u00e9rprete para comenzar un nuevo comando. ... es el s\u00edmbolo del int\u00e9rprete para continuar con un comando comenzado antes. Dej\u00e1 una l\u00ednea en blanco para terminar lo que ya ingresaste. El s\u00edmbolo ... puede mostrarse o no dependiendo de tu entorno. En este curso lo mostraremos como l\u00edneas en blanco para facilitar el copy-paste de fragmentos de c\u00f3digo (del que ya dijimos, \u00a1no hay que abusar!). Antes vimos que el gui\u00f3n bajo _ guarda el \u00faltimo resultado. >>> 37 * 42 1554 >>> _ * 2 3108 >>> _ + 50 3158 >>> Esto solo es v\u00e1lido en el modo interactivo que estamos viendo. No uses el gui\u00f3n bajo en un programa. Crear programas Los programas se guardan en archivos .py . # hello.py print('hello world') Pod\u00e9s crear estos archivos con tu editor de texto favorito. M\u00e1s adelante vamos a proponerles usar el spyder que es un entorno de desarrollo integrado (IDE por \u00abIntegrated Development Environment\u00bb, entorno de desarrollo integrado) que permite tener en la pantalla un editor y un int\u00e9rprete al mismo tiempo, entre otras cosas. Pero por ahora usemos el block de notas, el gedit o tu editor favorito para seguir estos ejemplos. Ejecutar programas Para ejecutar un programa, correlo en la terminal con el comando python seguido del nombre del archivo a ejecutar. Por ejemplo, en una l\u00ednea de comandos Unix (por ejemplo Ubuntu): bash % python hello.py hello world bash % O en una terminal de Windows: C:\\SomeFolder>hello.py hello world C:\\SomeFolder>c:\\python36\\python hello.py hello world Obervaci\u00f3n: En Windows puede ser necesario especificar el camino (path) completo al int\u00e9rprete de Python como en c:\\python36\\python . Sin embargo, si Python est\u00e1 instalado del modo usual, podr\u00eda alcanzar con que tip\u00e9es el nombre del programa como en hello.py . Ten\u00e9 en cuenta que con estos comandos est\u00e1s corriendo el c\u00f3digo de Python desde la l\u00ednea de comandos de tu sistema operativo. El c\u00f3digo se ejecuta, Python termina y el control vuelve a la terminal, saliendo de Python. Si necesit\u00e1s ejecutarlo y seguir dentro del int\u00e9rprete de Python pod\u00e9s usar python -i hello.py . Si est\u00e1s dentro del int\u00e9rprete de Python y quer\u00e9s salir y volver a la l\u00ednea de comandos, pod\u00e9s hacerlo mediante el comando exit() . Un ejemplo de programa Resolvamos el siguiente problema: Una ma\u00f1ana pon\u00e9s un billete en la vereda al lado del obelisco porte\u00f1o. A partir de ah\u00ed, cada d\u00eda vas y duplic\u00e1s la cantidad de billetes, apil\u00e1ndolos prolijamente. \u00bfCu\u00e1nto tiempo pasa antes de que la pila de billetes sea m\u00e1s alta que el obelisco? Ac\u00e1 va una soluci\u00f3n: # obelisco.py grosor_billete = 0.11 * 0.001 # grosor de un billete en metros altura_obelisco = 67.5 # altura en metros num_billetes = 1 dia = 1 while num_billetes * grosor_billete <= altura_obelisco: print(dia, num_billetes, num_billetes * grosor_billete) dia = dia + 1 num_billetes = num_billetes * 2 print('Cantidad de d\u00edas', dia) print('Cantidad de billetes', num_billetes) print('Altura final', num_billetes * grosor_billete) Cuando lo ejecut\u00e1s, la salida ser\u00e1 la siguiente: bash % python3 obelisco.py 1 1 0.00011 2 2 0.00022 3 4 0.00044 4 8 0.00088 5 16 0.00176 6 32 0.00352 ... 19 262144 28.83584 20 524288 57.67168 Cantidad de d\u00edas 21 Cantidad de billetes 1048576 Altura final 115.34336 A continuaci\u00f3n vamos a usar este primer programa como ejemplo para aprender algunas cosas fundamentales sobre Python. Comandos Un programa de Python es una secuencia de comandos: a = 3 + 4 b = a * 2 print(b) Cada comando se termina con una nueva l\u00ednea. Los comandos son ejecutados uno luego del otro hasta que el int\u00e9rprete llega al final del archivo. Comentarios Los comentarios son texto que no ser\u00e1 ejecutado. a = 3 + 4 # Esto es un comentario b = a * 2 print(b) Los comentarios comienzan con # y siguen hasta el final de la l\u00ednea. Variables Una variable es un nombre para un valor. Estos nombres pueden estar formados por letras (min\u00fasculas y may\u00fasculas) de la a a la z. Tambi\u00e9n pueden incluir el gui\u00f3n bajo, y se pueden usar n\u00fameros, salvo como primer caracter. altura = 442 # v\u00e1lido _altura = 442 # v\u00e1lido altura2 = 442 # v\u00e1lido 2altura = 442 # inv\u00e1lido Tipos El tipo de las variables no debe ser declarado como en otros lenguajes. El tipo es asociado con el valor del lado derecho. altura = 442 # Entero altura = 442.0 # Punto flotante altura = 'Muy, muy alto' # Cadena de caracteres Decimos que Python tiene tipado din\u00e1mico. El tipo percibido por el int\u00e9rprete puede cambiar a lo largo de la ejecuci\u00f3n dependiendo del valor asignado a la variable. Python distingue may\u00fasculas y min\u00fasculas May\u00fasculas y min\u00fasculas son diferentes para Python. Por ejemplo, todas las siguientes variables son diferentes. nombre = 'David' Nombre = 'Diego' NOMBRE = 'Rosita' Los comandos de Python siempre se escriben con min\u00fasculas. while x < 0: # OK WHILE x < 0: # ERROR Ciclos El comando while ejecuta un ciclo o loop . while num_billetes * grosor_billete <= altura_obelisco: print(dia, num_billetes, num_billetes * grosor_billete) dia = dia + 1 num_billetes = num_billetes * 2 print('Cantidad de d\u00edas', dia) Los comandos indentados debajo del while se van a a ejecutar mientras que la expresi\u00f3n luego del while sea verdadera ( True ). Indentaci\u00f3n La indentaci\u00f3n se usa para marcar grupos de comandos que van juntos. Consider\u00e1 el ejemplo anterior: while num_billetes * grosor_billete <= altura_obelisco: print(dia, num_billetes, num_billetes * grosor_billete) dia = dia + 1 num_billetes = num_billetes * 2 print('Cantidad de d\u00edas', dia) La indentaci\u00f3n agrupa los comandos siguientes como las operaciones a repetir: print(dia, num_billetes, num_billetes * grosor_billete) dia = dia + 1 num_billetes = num_billetes * 2 Como el comando print() del final no est\u00e1 indentado, no pertenece al ciclo. La l\u00ednea en blanco que dejamos entre ambos solo est\u00e1 para facilitar la lectura y no afecta la ejecuci\u00f3n. Indentando adecuadamente Algunas recomendaciones sobre c\u00f3mo indentar: Us\u00e1 espacios y no el tabulador. Us\u00e1 4 espacios por cada nivel. Us\u00e1 un editor de textos que entienda que est\u00e1s escribiendo en Python. El \u00fanico requisito del int\u00e9rprete de Python es que la indentaci\u00f3n dentro de un mismo bloque sea consistente. Por ejemplo, esto es un error: while num_billetes * grosor_billete <= altura_obelisco: print(dia, num_billetes, num_billetes * grosor_billete) dia = dia + 1 # ERROR num_billetes = num_billetes * 2 Condicionales El comando if es usado para ejecutar un condicional: if a > b: print('Gana a') else: print('Gana b') Pod\u00e9s verificar condiciones mutuamente excluyentes agregando condiciones extras con elif . if a > b: print('Gana a') elif a == b: print('Empate!') else: print('Gana b') El comando elif viene de else, if y puede traducirse como \"si no se da la condici\u00f3n del if anterior, verific\u00e1 si se da la siguiente\". Imprimir en pantalla La funci\u00f3n print imprime una l\u00ednea de texto con el valor pasado como par\u00e1metro. print('Hello world!') # Imprime 'Hello world!' Pod\u00e9s imprimir variables. El texto impreso en ese caso ser\u00e1 el valor de la variable y no su nombre. x = 100 print(x) # imprime el texto '100' Si le pas\u00e1s m\u00e1s de un valor al print los separa con espacios. nombre = 'Juana' print('Mi nombre es', nombre) # Imprime el texto 'Mi nombre es Juana' print() siempre termina la l\u00ednea impresa pasando a la siguiente. print('Hola') print('Mi nombre es', 'Juana') Esto imprime: Hola Mi nombre es Juana El salto de l\u00ednea entre ambos comandos puede ser suprimido: print('Hola', end=' ') print('Mi nombre es', 'Juana') Este c\u00f3digo va a imprimir: Hola Mi nombre es Juana Ingreso de valores por teclado Para leer un valor ingresado por el usuario, us\u00e1 la funci\u00f3n input() : nombre = input('Ingres\u00e1 tu nombre:') print('Tu nombre es', nombre) input imprime el texto que le pases como par\u00e1metro y espera una respuesta. Es \u00fatil para programas peque\u00f1os, para hacer ejercicios o para debuguear un c\u00f3digo. Casi no se lo usa en programas reales. El comando pass A veces es conveniente especificar un bloque de c\u00f3digo que no haga nada. El comando pass se usa para eso. if a > b: pass else: print('No gan\u00f3 a') Este comando no hace nada. Sirve para guardar el lugar para un comando que querramos agregar luego. Ejercicios Ejercicio 1.4: Debuguear El siguiente fragmento de c\u00f3digo est\u00e1 relacionado con el problema del obelisco. Tiene un bug, es decir, un error. # obelisco.py grosor_billete = 0.11 * 0.001 # 0.11 mm en metros altura_obelisco = 67.5 # altura en metros num_billetes = 1 dia = 1 while num_billetes * grosor_billete <= altura_obelisco: print(dia, num_billetes, num_billetes * grosor_billete) dia = dias + 1 num_billetes = num_billetes * 2 print('Cantidad de d\u00edas', dia) print('Cantidad de billetes', num_billetes) print('Altura final', num_billetes * grosor_billete) Copi\u00e1 y peg\u00e1 el c\u00f3digo que aparece arriba en un nuevo archivo llamado obelisco.py . Cuando ejecutes el c\u00f3digo vas a obtener el siguiente mensaje de error que hace que el programa se detenga: Traceback (most recent call last): File \"obelisco.py\", line 10, in <module> dia = dias + 1 NameError: name 'dias' is not defined Aprender a leer y entender los mensajes de error es una parte fundamental de programar en Python. Si tu programa crashea (se rompe, da error) la \u00faltima l\u00ednea del mensaje de error indica el motivo. Un poco m\u00e1s arriba vas a ver un fragmento de c\u00f3digo, un nombre de archivo y un n\u00famero de l\u00ednea que identifican el problema. \u00bfEn qu\u00e9 linea est\u00e1 el error? \u00bfCu\u00e1l es el error? Repar\u00e1 el error. Ejecut\u00e1 el programa exitosamente. Ejercicio 1.5: La pelota que rebota Este es el primer conjunto de ejercicios en el que vas a tener que crear un archivo de Python y correrlo. A partir de aca, vamos a asumir que est\u00e1s trabajando en el subdirectorio ejercicios_python/ . Para ayudarte a organizar los archivos de diferentes clases y a ubicar el lugar correcto ya creamos algunos subdirectorios y un par de archivos en el directorio correpondiente a esta clase. Busc\u00e1 en tu terminal el archivo ejercicios_python/Clase01/rebotes.py (cambiando de directorio como vimos reci\u00e9n). Lo vamos a usar en este ejercicio. Una pelota de goma es arrojada desde una altura de 100 metros y cada vez que toca el piso salta 3/5 de la altura desde la que cay\u00f3. Escrib\u00ed un programa rebotes.py que imprima una tabla mostrando las alturas que alcanza en cada uno de sus primeros diez rebotes. Tu programa deber\u00eda generar una tabla que se parezca a esta: 1 60.0 2 36.0 3 21.599999999999998 4 12.959999999999999 5 7.775999999999999 6 4.6655999999999995 7 2.7993599999999996 8 1.6796159999999998 9 1.0077695999999998 10 0.6046617599999998 Nota: Pod\u00e9s limpiar un toque la salida si us\u00e1s la funci\u00f3n round() de la que miraste el help hace un rato. Trat\u00e1 de usarla para redondear a cuatro d\u00edgitos. 1 60.0 2 36.0 3 21.6 4 12.96 5 7.776 6 4.6656 7 2.7994 8 1.6796 9 1.0078 10 0.6047 Ejercicio 1.6: Saludos Escrib\u00ed un programa llamado saludo.py que pregunte el nombre de le usuarie, imprima un saludo (por ejemplo, \"Hola, Juana\") y termine. Contenidos | Anterior (1 Python) | Pr\u00f3ximo (3 N\u00fameros)","title":"02 Hello world"},{"location":"01_Introduccion/02_Hello_world/#12-un-primer-programa","text":"En esta secci\u00f3n vas a crear tu primer programa en Python, ejecutarlo y debuguearlo.","title":"1.2 Un primer programa"},{"location":"01_Introduccion/02_Hello_world/#ejecutando-python","text":"Los programas en Python siempre son ejecutados en un int\u00e9rprete de Python. El int\u00e9rprete es una aplicaci\u00f3n que funciona en la consola y se ejecuta desde la terminal. python3 Python 3.6.1 (v3.6.1:69c0db5050, Mar 21 2017, 01:21:04) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Les programadores no suelen tener problemas en usar el int\u00e9rprete de esta forma, aunque no es la m\u00e1s c\u00f3moda para principiantes. M\u00e1s adelante vamos a proponerles usar entornos de desarrollo m\u00e1s sofisticados, pero por el momento qued\u00e9mosnos con la incomodidad que nos va a ense\u00f1ar cosas \u00fatiles.","title":"Ejecutando Python"},{"location":"01_Introduccion/02_Hello_world/#modo-interactivo","text":"Cuando ejecut\u00e1s Python, entr\u00e1s al modo interactivo en el que pod\u00e9s experimentar. Si escrib\u00eds un comando, se va a ejecutar inmediatamente. No hay ning\u00fan ciclo de edici\u00f3n-compilaci\u00f3n-ejecuci\u00f3n-debug en Python, como hay en otros lenguajes. >>> print('hello world') hello world >>> 37*42 1554 >>> for i in range(5): ... print(i) ... 0 1 2 3 4 >>> Esta forma de escribir c\u00f3digo (en una consola del lenguaje) que se eval\u00faa inmediatamente e imprime el resultado, se denomina bucle de Lectura-Evaluaci\u00f3n-Impresi\u00f3n (REPL por las siglas en ingl\u00e9s de \u00abRead-Eval-Print-Loop\u00bb). Asegurate de poder interactuar con el int\u00e9rprete antes de seguir. Veamos en mayor detalle c\u00f3mo funciona este REPL: >>> es el s\u00edmbolo del int\u00e9rprete para comenzar un nuevo comando. ... es el s\u00edmbolo del int\u00e9rprete para continuar con un comando comenzado antes. Dej\u00e1 una l\u00ednea en blanco para terminar lo que ya ingresaste. El s\u00edmbolo ... puede mostrarse o no dependiendo de tu entorno. En este curso lo mostraremos como l\u00edneas en blanco para facilitar el copy-paste de fragmentos de c\u00f3digo (del que ya dijimos, \u00a1no hay que abusar!). Antes vimos que el gui\u00f3n bajo _ guarda el \u00faltimo resultado. >>> 37 * 42 1554 >>> _ * 2 3108 >>> _ + 50 3158 >>> Esto solo es v\u00e1lido en el modo interactivo que estamos viendo. No uses el gui\u00f3n bajo en un programa.","title":"Modo interactivo"},{"location":"01_Introduccion/02_Hello_world/#crear-programas","text":"Los programas se guardan en archivos .py . # hello.py print('hello world') Pod\u00e9s crear estos archivos con tu editor de texto favorito. M\u00e1s adelante vamos a proponerles usar el spyder que es un entorno de desarrollo integrado (IDE por \u00abIntegrated Development Environment\u00bb, entorno de desarrollo integrado) que permite tener en la pantalla un editor y un int\u00e9rprete al mismo tiempo, entre otras cosas. Pero por ahora usemos el block de notas, el gedit o tu editor favorito para seguir estos ejemplos.","title":"Crear programas"},{"location":"01_Introduccion/02_Hello_world/#ejecutar-programas","text":"Para ejecutar un programa, correlo en la terminal con el comando python seguido del nombre del archivo a ejecutar. Por ejemplo, en una l\u00ednea de comandos Unix (por ejemplo Ubuntu): bash % python hello.py hello world bash % O en una terminal de Windows: C:\\SomeFolder>hello.py hello world C:\\SomeFolder>c:\\python36\\python hello.py hello world Obervaci\u00f3n: En Windows puede ser necesario especificar el camino (path) completo al int\u00e9rprete de Python como en c:\\python36\\python . Sin embargo, si Python est\u00e1 instalado del modo usual, podr\u00eda alcanzar con que tip\u00e9es el nombre del programa como en hello.py . Ten\u00e9 en cuenta que con estos comandos est\u00e1s corriendo el c\u00f3digo de Python desde la l\u00ednea de comandos de tu sistema operativo. El c\u00f3digo se ejecuta, Python termina y el control vuelve a la terminal, saliendo de Python. Si necesit\u00e1s ejecutarlo y seguir dentro del int\u00e9rprete de Python pod\u00e9s usar python -i hello.py . Si est\u00e1s dentro del int\u00e9rprete de Python y quer\u00e9s salir y volver a la l\u00ednea de comandos, pod\u00e9s hacerlo mediante el comando exit() .","title":"Ejecutar programas"},{"location":"01_Introduccion/02_Hello_world/#un-ejemplo-de-programa","text":"Resolvamos el siguiente problema: Una ma\u00f1ana pon\u00e9s un billete en la vereda al lado del obelisco porte\u00f1o. A partir de ah\u00ed, cada d\u00eda vas y duplic\u00e1s la cantidad de billetes, apil\u00e1ndolos prolijamente. \u00bfCu\u00e1nto tiempo pasa antes de que la pila de billetes sea m\u00e1s alta que el obelisco? Ac\u00e1 va una soluci\u00f3n: # obelisco.py grosor_billete = 0.11 * 0.001 # grosor de un billete en metros altura_obelisco = 67.5 # altura en metros num_billetes = 1 dia = 1 while num_billetes * grosor_billete <= altura_obelisco: print(dia, num_billetes, num_billetes * grosor_billete) dia = dia + 1 num_billetes = num_billetes * 2 print('Cantidad de d\u00edas', dia) print('Cantidad de billetes', num_billetes) print('Altura final', num_billetes * grosor_billete) Cuando lo ejecut\u00e1s, la salida ser\u00e1 la siguiente: bash % python3 obelisco.py 1 1 0.00011 2 2 0.00022 3 4 0.00044 4 8 0.00088 5 16 0.00176 6 32 0.00352 ... 19 262144 28.83584 20 524288 57.67168 Cantidad de d\u00edas 21 Cantidad de billetes 1048576 Altura final 115.34336 A continuaci\u00f3n vamos a usar este primer programa como ejemplo para aprender algunas cosas fundamentales sobre Python.","title":"Un ejemplo de programa"},{"location":"01_Introduccion/02_Hello_world/#comandos","text":"Un programa de Python es una secuencia de comandos: a = 3 + 4 b = a * 2 print(b) Cada comando se termina con una nueva l\u00ednea. Los comandos son ejecutados uno luego del otro hasta que el int\u00e9rprete llega al final del archivo.","title":"Comandos"},{"location":"01_Introduccion/02_Hello_world/#comentarios","text":"Los comentarios son texto que no ser\u00e1 ejecutado. a = 3 + 4 # Esto es un comentario b = a * 2 print(b) Los comentarios comienzan con # y siguen hasta el final de la l\u00ednea.","title":"Comentarios"},{"location":"01_Introduccion/02_Hello_world/#variables","text":"Una variable es un nombre para un valor. Estos nombres pueden estar formados por letras (min\u00fasculas y may\u00fasculas) de la a a la z. Tambi\u00e9n pueden incluir el gui\u00f3n bajo, y se pueden usar n\u00fameros, salvo como primer caracter. altura = 442 # v\u00e1lido _altura = 442 # v\u00e1lido altura2 = 442 # v\u00e1lido 2altura = 442 # inv\u00e1lido","title":"Variables"},{"location":"01_Introduccion/02_Hello_world/#tipos","text":"El tipo de las variables no debe ser declarado como en otros lenguajes. El tipo es asociado con el valor del lado derecho. altura = 442 # Entero altura = 442.0 # Punto flotante altura = 'Muy, muy alto' # Cadena de caracteres Decimos que Python tiene tipado din\u00e1mico. El tipo percibido por el int\u00e9rprete puede cambiar a lo largo de la ejecuci\u00f3n dependiendo del valor asignado a la variable.","title":"Tipos"},{"location":"01_Introduccion/02_Hello_world/#python-distingue-mayusculas-y-minusculas","text":"May\u00fasculas y min\u00fasculas son diferentes para Python. Por ejemplo, todas las siguientes variables son diferentes. nombre = 'David' Nombre = 'Diego' NOMBRE = 'Rosita' Los comandos de Python siempre se escriben con min\u00fasculas. while x < 0: # OK WHILE x < 0: # ERROR","title":"Python distingue may\u00fasculas y min\u00fasculas"},{"location":"01_Introduccion/02_Hello_world/#ciclos","text":"El comando while ejecuta un ciclo o loop . while num_billetes * grosor_billete <= altura_obelisco: print(dia, num_billetes, num_billetes * grosor_billete) dia = dia + 1 num_billetes = num_billetes * 2 print('Cantidad de d\u00edas', dia) Los comandos indentados debajo del while se van a a ejecutar mientras que la expresi\u00f3n luego del while sea verdadera ( True ).","title":"Ciclos"},{"location":"01_Introduccion/02_Hello_world/#indentacion","text":"La indentaci\u00f3n se usa para marcar grupos de comandos que van juntos. Consider\u00e1 el ejemplo anterior: while num_billetes * grosor_billete <= altura_obelisco: print(dia, num_billetes, num_billetes * grosor_billete) dia = dia + 1 num_billetes = num_billetes * 2 print('Cantidad de d\u00edas', dia) La indentaci\u00f3n agrupa los comandos siguientes como las operaciones a repetir: print(dia, num_billetes, num_billetes * grosor_billete) dia = dia + 1 num_billetes = num_billetes * 2 Como el comando print() del final no est\u00e1 indentado, no pertenece al ciclo. La l\u00ednea en blanco que dejamos entre ambos solo est\u00e1 para facilitar la lectura y no afecta la ejecuci\u00f3n.","title":"Indentaci\u00f3n"},{"location":"01_Introduccion/02_Hello_world/#indentando-adecuadamente","text":"Algunas recomendaciones sobre c\u00f3mo indentar: Us\u00e1 espacios y no el tabulador. Us\u00e1 4 espacios por cada nivel. Us\u00e1 un editor de textos que entienda que est\u00e1s escribiendo en Python. El \u00fanico requisito del int\u00e9rprete de Python es que la indentaci\u00f3n dentro de un mismo bloque sea consistente. Por ejemplo, esto es un error: while num_billetes * grosor_billete <= altura_obelisco: print(dia, num_billetes, num_billetes * grosor_billete) dia = dia + 1 # ERROR num_billetes = num_billetes * 2","title":"Indentando adecuadamente"},{"location":"01_Introduccion/02_Hello_world/#condicionales","text":"El comando if es usado para ejecutar un condicional: if a > b: print('Gana a') else: print('Gana b') Pod\u00e9s verificar condiciones mutuamente excluyentes agregando condiciones extras con elif . if a > b: print('Gana a') elif a == b: print('Empate!') else: print('Gana b') El comando elif viene de else, if y puede traducirse como \"si no se da la condici\u00f3n del if anterior, verific\u00e1 si se da la siguiente\".","title":"Condicionales"},{"location":"01_Introduccion/02_Hello_world/#imprimir-en-pantalla","text":"La funci\u00f3n print imprime una l\u00ednea de texto con el valor pasado como par\u00e1metro. print('Hello world!') # Imprime 'Hello world!' Pod\u00e9s imprimir variables. El texto impreso en ese caso ser\u00e1 el valor de la variable y no su nombre. x = 100 print(x) # imprime el texto '100' Si le pas\u00e1s m\u00e1s de un valor al print los separa con espacios. nombre = 'Juana' print('Mi nombre es', nombre) # Imprime el texto 'Mi nombre es Juana' print() siempre termina la l\u00ednea impresa pasando a la siguiente. print('Hola') print('Mi nombre es', 'Juana') Esto imprime: Hola Mi nombre es Juana El salto de l\u00ednea entre ambos comandos puede ser suprimido: print('Hola', end=' ') print('Mi nombre es', 'Juana') Este c\u00f3digo va a imprimir: Hola Mi nombre es Juana","title":"Imprimir en pantalla"},{"location":"01_Introduccion/02_Hello_world/#ingreso-de-valores-por-teclado","text":"Para leer un valor ingresado por el usuario, us\u00e1 la funci\u00f3n input() : nombre = input('Ingres\u00e1 tu nombre:') print('Tu nombre es', nombre) input imprime el texto que le pases como par\u00e1metro y espera una respuesta. Es \u00fatil para programas peque\u00f1os, para hacer ejercicios o para debuguear un c\u00f3digo. Casi no se lo usa en programas reales.","title":"Ingreso de valores por teclado"},{"location":"01_Introduccion/02_Hello_world/#el-comando-pass","text":"A veces es conveniente especificar un bloque de c\u00f3digo que no haga nada. El comando pass se usa para eso. if a > b: pass else: print('No gan\u00f3 a') Este comando no hace nada. Sirve para guardar el lugar para un comando que querramos agregar luego.","title":"El comando pass"},{"location":"01_Introduccion/02_Hello_world/#ejercicios","text":"","title":"Ejercicios"},{"location":"01_Introduccion/02_Hello_world/#ejercicio-14-debuguear","text":"El siguiente fragmento de c\u00f3digo est\u00e1 relacionado con el problema del obelisco. Tiene un bug, es decir, un error. # obelisco.py grosor_billete = 0.11 * 0.001 # 0.11 mm en metros altura_obelisco = 67.5 # altura en metros num_billetes = 1 dia = 1 while num_billetes * grosor_billete <= altura_obelisco: print(dia, num_billetes, num_billetes * grosor_billete) dia = dias + 1 num_billetes = num_billetes * 2 print('Cantidad de d\u00edas', dia) print('Cantidad de billetes', num_billetes) print('Altura final', num_billetes * grosor_billete) Copi\u00e1 y peg\u00e1 el c\u00f3digo que aparece arriba en un nuevo archivo llamado obelisco.py . Cuando ejecutes el c\u00f3digo vas a obtener el siguiente mensaje de error que hace que el programa se detenga: Traceback (most recent call last): File \"obelisco.py\", line 10, in <module> dia = dias + 1 NameError: name 'dias' is not defined Aprender a leer y entender los mensajes de error es una parte fundamental de programar en Python. Si tu programa crashea (se rompe, da error) la \u00faltima l\u00ednea del mensaje de error indica el motivo. Un poco m\u00e1s arriba vas a ver un fragmento de c\u00f3digo, un nombre de archivo y un n\u00famero de l\u00ednea que identifican el problema. \u00bfEn qu\u00e9 linea est\u00e1 el error? \u00bfCu\u00e1l es el error? Repar\u00e1 el error. Ejecut\u00e1 el programa exitosamente.","title":"Ejercicio 1.4: Debuguear"},{"location":"01_Introduccion/02_Hello_world/#ejercicio-15-la-pelota-que-rebota","text":"Este es el primer conjunto de ejercicios en el que vas a tener que crear un archivo de Python y correrlo. A partir de aca, vamos a asumir que est\u00e1s trabajando en el subdirectorio ejercicios_python/ . Para ayudarte a organizar los archivos de diferentes clases y a ubicar el lugar correcto ya creamos algunos subdirectorios y un par de archivos en el directorio correpondiente a esta clase. Busc\u00e1 en tu terminal el archivo ejercicios_python/Clase01/rebotes.py (cambiando de directorio como vimos reci\u00e9n). Lo vamos a usar en este ejercicio. Una pelota de goma es arrojada desde una altura de 100 metros y cada vez que toca el piso salta 3/5 de la altura desde la que cay\u00f3. Escrib\u00ed un programa rebotes.py que imprima una tabla mostrando las alturas que alcanza en cada uno de sus primeros diez rebotes. Tu programa deber\u00eda generar una tabla que se parezca a esta: 1 60.0 2 36.0 3 21.599999999999998 4 12.959999999999999 5 7.775999999999999 6 4.6655999999999995 7 2.7993599999999996 8 1.6796159999999998 9 1.0077695999999998 10 0.6046617599999998 Nota: Pod\u00e9s limpiar un toque la salida si us\u00e1s la funci\u00f3n round() de la que miraste el help hace un rato. Trat\u00e1 de usarla para redondear a cuatro d\u00edgitos. 1 60.0 2 36.0 3 21.6 4 12.96 5 7.776 6 4.6656 7 2.7994 8 1.6796 9 1.0078 10 0.6047","title":"Ejercicio 1.5: La pelota que rebota"},{"location":"01_Introduccion/02_Hello_world/#ejercicio-16-saludos","text":"Escrib\u00ed un programa llamado saludo.py que pregunte el nombre de le usuarie, imprima un saludo (por ejemplo, \"Hola, Juana\") y termine. Contenidos | Anterior (1 Python) | Pr\u00f3ximo (3 N\u00fameros)","title":"Ejercicio 1.6: Saludos"},{"location":"01_Introduccion/03_Numeros/","text":"Contenidos | Anterior (2 Un primer programa) | Pr\u00f3ximo (4 Cadenas) 1.3 N\u00fameros Esta secci\u00f3n introduce las operaciones matem\u00e1ticas elementales. Tipos de n\u00fameros Python tiene 4 tipos de n\u00fameros: Booleanos Enteros Punto flotante Complejos (con parte real y parte imaginaria) Booleanos (bool) Las variables booleanas se llaman as\u00ed en honor al l\u00f3gico ingl\u00e9s George Boole . Pueden tomar dos valores: True y False (verdadero y falso). a = True b = False Internamente, son evaluados como enteros con valores 1 , 0 . c = 4 + True # 5 d = False if d == 0: print('d is False') No escribas c\u00f3digo basado en esta convenci\u00f3n. Ser\u00eda bastante raro. Enteros (int) Representan n\u00fameros enteros (positivos y negativos) de cualquier magnitud: a = 37 b = -299392993727716627377128481812241231 Incluso se pueden especificar en diferentes bases: c = 0x7fa8 # Hexadecimal d = 0o253 # Octal e = 0b10001111 # Binario Operaciones usuales: x + y Suma x - y Resta x * y Multiplicaci\u00f3n x / y Divisi\u00f3n (da un float, no un int) x // y Divisi\u00f3n entera (da un int) x % y M\u00f3dulo (resto) x ** y Potencia abs(x) Valor absoluto La unidad m\u00ednima de almacenamiento de una computadora es un bit, que puede valer 0 o 1. Los n\u00fameros, caracteres e incluso im\u00e1genes y sonido son almacenados en la m\u00e1quina usando bits. Los n\u00fameros enteros positivos, en particular, suelen almacenarse mediante su representaci\u00f3n binaria (o en base dos). N\u00famero Representaci\u00f3n binaria 1 1 2 10 3 11 4 100 5 101 6 110 Hay algunas operaciones primitivas que se pueden hacer con los enteros a partir de su representaci\u00f3n como bits: x << n Desplazamiento de los bits a la izquierda x >> n Desplazamiento de los bits a la derecha x & y AND bit a bit. x | y OR bit a bit. x ^ y XOR bit a bit. ~x NOT bit a bit. Al desplazar a la izquierda, simplemente agregamos un cero en la \u00faltima posici\u00f3n. As\u00ed, por ejemplo si corremos el 1 dos lugares a la izquierda obtenemos un 4: >>> 1 << 2 # 1 << 2 -> 100 4 >>> 6 & 3 # 110 & 011 -> 010 2 Al desplazar los bits de un n\u00famero a la derecha un lugar, el \u00faltimo bit \"se cae\". >>> 1 >> 1 # 1 -> 0 0 >>> 6 >> 1 # 110 -> 11 3 Punto flotante (float) Us\u00e1 una notaci\u00f3n con decimales o una notaci\u00f3n cient\u00edfica para especificar un valor de tipo punto flotante: a = 37.45 b = 4e5 # 4 x 10**5 o 400,000 c = -1.345e-10 Los n\u00fameros de tipo floats son representados en la m\u00e1quina como n\u00fameros de doble precisi\u00f3n usando la representaci\u00f3n nativa del microprocesador que sigue el est\u00e1ndar IEEE 754 . Para los que los conozcan: es el mismo tipo que los double en el lenguaje C. Un float almacenan hasta 17 digitos con un exponente entre -308 to 308 Cuidado que la aritm\u00e9tica de los n\u00fameros de punto flotante no es exacta. >>> a = 2.1 + 4.2 >>> a == 6.3 False >>> a 6.300000000000001 >>> Esto no es un problema de Python , si no el resultado de la forma en que el hardware de nuestras computadoras almacena los n\u00fameros de punto flotante. Operaciones usuales: x + y Suma x - y Resta x * y Multiplicaci\u00f3n x / y Divici\u00f3n (da un float, no un int) x // y Divisi\u00f3n entera (da un float, pero con ceros luego del punto) x % y M\u00f3dulo (resto) x ** y Potencia abs(x) Valor absoluto Estas son las mismas operaciones que con los enteros. Otras operaciones usuales se encuentran en el m\u00f3dulo math . import math a = math.sqrt(x) b = math.sin(x) c = math.cos(x) d = math.tan(x) e = math.log(x) El m\u00f3dulo math tambi\u00e9n tiene constantes ( math.e , math.pi ), entre otras cosas. Comparaciones Las siguientes comparaciones (suelen llamarse operadores relacionales ya que expresan una relaci\u00f3n entre dos elementos) funcionan con n\u00fameros: x < y Menor que x <= y Menor o igual que x > y Mayor que x >= y Mayor o igual que x == y Igual a x != y No igual a Observ\u00e1 que el == se usa para comparar dos elementos mientras que el = se usa para asignar un valor a una variable. Son s\u00edmbolos distintos que cumplen funciones diferentes. Pod\u00e9s formar expresiones booleanas m\u00e1s complejas usando and , or , not Ac\u00e1 mostramos algunos ejemplos: if b >= a and b <= c: print('b est\u00e1 entre a y c') if not (b < a or b > c): print('b sigue estando entre a y c') Conversi\u00f3n de n\u00fameros El nombre de un tipo (de datos) puede ser usado para convertir valores: a = int(x) # Convertir x a int b = float(x) # Convertir x a float Probalo. >>> a = 3.14159 >>> int(a) 3 >>> b = '3.14159' # Tambi\u00e9n funciona con cadenas que representan n\u00fameros. >>> float(b) 3.14159 >>> Cuidado: el separador decimal en Python es el punto, como en ingl\u00e9s, y no la coma del castellano. Por eso el comando float(3,141592) da un ValueError . Ejercicios Recordatorio: Asumimos que est\u00e1s trabajando en el subdirectorio ejercicios_python/Clase01/ . Busc\u00e1 el archivo hipoteca.py y hac\u00e9 los ejercicios en ese archivo, usando un editor de texto. Ejecutalo desde la l\u00ednea de comandos. Ejercicio 1.7: La hipoteca de David David solicit\u00f3 un cr\u00e9dito a 30 a\u00f1os para comprar una vivienda, con una tasa fija nominal anual del 5%. Pidi\u00f3 $500000 al banco y acord\u00f3 un pago mensual fijo de $2684,11. El siguiente es un programa que calcula el monto total que pagar\u00e1 David a lo largo de los a\u00f1os: # hipoteca.py saldo = 500000.0 tasa = 0.05 pago_mensual = 2684.11 total_pagado = 0.0 while saldo > 0: saldo = saldo * (1+tasa/12) - pago_mensual total_pagado = total_pagado + pago_mensual print('Total pagado', round(total_pagado, 2)) Copi\u00e1 este c\u00f3digo y correlo. Deber\u00edas obtener 966279.6 como respuesta. Ejercicio 1.8: Adelantos Supongamos que David adelanta pagos extra de $1000/mes durante los primeros 12 meses de la hipoteca. Modific\u00e1 el programa para incorporar estos pagos extra y que imprima el monto total pagado junto con la cantidad de meses requeridos. Cuando lo corras, este nuevo programa deber\u00eda dar un pago total de 929965.62 en 342 meses. Aclaraci\u00f3n: aunque puede parecer sencillo, este ejercicio requiere que agregues una variable mes y que prestes bastante atenci\u00f3n a cu\u00e1ndo la increment\u00e1s, con qu\u00e9 valor entra al ciclo y con qu\u00e9 valor sale del ciclo. Una posiblidad es inicializar mes en 0 y otra es inicializarla en 1. En el primer caso es problable que la variable salga del ciclo contando la cantidad de pagos que se hicieron, en el segundo, \u00a1es probable que salga contando la cantidad de pagos m\u00e1s uno! Ejercicio 1.9: Calculadora de adelantos \u00bfCu\u00e1nto pagar\u00eda David si agrega $1000 por mes durante cuatro a\u00f1os, comenzando en el sexto a\u00f1o de la hipoteca (es decir, luego de 5 a\u00f1os)? Modific\u00e1 tu programa de forma que la informaci\u00f3n sobre pagos extras sea incorporada de manera vers\u00e1til. Agreg\u00e1 las siguientes variables antes del ciclo, para definir el comienzo, fin y monto de los pagos extras: pago_extra_mes_comienzo = 61 pago_extra_mes_fin = 108 pago_extra = 1000 Hac\u00e9 que el programa tenga en cuenta estas variables para calcular el total a pagar apropiadamente. Ejercicio 1.10: Tablas Modic\u00e1 tu programa para que imprima una tabla mostrando el mes, el total pagado hasta el momento y el saldo restante. La salida deber\u00eda verse aproximadamente as\u00ed: 1 2684.11 499399.22 2 5368.22 498795.94 3 8052.33 498190.15 4 10736.44 497581.83 5 13420.55 496970.98 ... 308 874705.88 3478.83 309 877389.99 809.21 310 880074.1 -1871.53 Total pagado: 880074.1 Meses: 310 Ejercicio 1.11: Bonus Ya que estamos, correg\u00ed el c\u00f3digo anterior de forma que el pago del \u00faltimo mes se ajuste a lo adeudado. Asegurate de guardar en el archivo hipoteca.py esta \u00faltima versi\u00f3n en tu directorio ejercicios_python/Clase01/ . Vamos a volver a trabajar con \u00e9l. Ejercicio 1.12: Un misterio Las funciones int() y float() pueden usarse para convertir n\u00fameros. Por ejemplo, >>> int(\"123\") 123 >>> float(\"1.23\") 1.23 >>> Con esto en mente, \u00bfpodr\u00edas explicar el siguiente comportamiento? >>> bool(\"False\") True >>> Ejercicio 1.13: El volumen de una esfera En tu directorio de trabajo de esta clase, escrib\u00ed un programa llamado esfera.py que le pida al usuario que ingrese por teclado el radio r de una esfera y calcule e imprima el volumen de la misma. Sugerencia: recordar que el vol\u00famen de una esfera es 4/3 \u03c0r^3 . Finalmente, ejecut\u00e1 el programa desde la l\u00ednea de comandos para responder \u00bfcu\u00e1l es el volumen de una esfera de radio 6? Deber\u00eda darte 904.7786842338603 . Contenidos | Anterior (2 Un primer programa) | Pr\u00f3ximo (4 Cadenas)","title":"03 Numeros"},{"location":"01_Introduccion/03_Numeros/#13-numeros","text":"Esta secci\u00f3n introduce las operaciones matem\u00e1ticas elementales.","title":"1.3 N\u00fameros"},{"location":"01_Introduccion/03_Numeros/#tipos-de-numeros","text":"Python tiene 4 tipos de n\u00fameros: Booleanos Enteros Punto flotante Complejos (con parte real y parte imaginaria)","title":"Tipos de n\u00fameros"},{"location":"01_Introduccion/03_Numeros/#booleanos-bool","text":"Las variables booleanas se llaman as\u00ed en honor al l\u00f3gico ingl\u00e9s George Boole . Pueden tomar dos valores: True y False (verdadero y falso). a = True b = False Internamente, son evaluados como enteros con valores 1 , 0 . c = 4 + True # 5 d = False if d == 0: print('d is False') No escribas c\u00f3digo basado en esta convenci\u00f3n. Ser\u00eda bastante raro.","title":"Booleanos (bool)"},{"location":"01_Introduccion/03_Numeros/#enteros-int","text":"Representan n\u00fameros enteros (positivos y negativos) de cualquier magnitud: a = 37 b = -299392993727716627377128481812241231 Incluso se pueden especificar en diferentes bases: c = 0x7fa8 # Hexadecimal d = 0o253 # Octal e = 0b10001111 # Binario Operaciones usuales: x + y Suma x - y Resta x * y Multiplicaci\u00f3n x / y Divisi\u00f3n (da un float, no un int) x // y Divisi\u00f3n entera (da un int) x % y M\u00f3dulo (resto) x ** y Potencia abs(x) Valor absoluto La unidad m\u00ednima de almacenamiento de una computadora es un bit, que puede valer 0 o 1. Los n\u00fameros, caracteres e incluso im\u00e1genes y sonido son almacenados en la m\u00e1quina usando bits. Los n\u00fameros enteros positivos, en particular, suelen almacenarse mediante su representaci\u00f3n binaria (o en base dos). N\u00famero Representaci\u00f3n binaria 1 1 2 10 3 11 4 100 5 101 6 110 Hay algunas operaciones primitivas que se pueden hacer con los enteros a partir de su representaci\u00f3n como bits: x << n Desplazamiento de los bits a la izquierda x >> n Desplazamiento de los bits a la derecha x & y AND bit a bit. x | y OR bit a bit. x ^ y XOR bit a bit. ~x NOT bit a bit. Al desplazar a la izquierda, simplemente agregamos un cero en la \u00faltima posici\u00f3n. As\u00ed, por ejemplo si corremos el 1 dos lugares a la izquierda obtenemos un 4: >>> 1 << 2 # 1 << 2 -> 100 4 >>> 6 & 3 # 110 & 011 -> 010 2 Al desplazar los bits de un n\u00famero a la derecha un lugar, el \u00faltimo bit \"se cae\". >>> 1 >> 1 # 1 -> 0 0 >>> 6 >> 1 # 110 -> 11 3","title":"Enteros (int)"},{"location":"01_Introduccion/03_Numeros/#punto-flotante-float","text":"Us\u00e1 una notaci\u00f3n con decimales o una notaci\u00f3n cient\u00edfica para especificar un valor de tipo punto flotante: a = 37.45 b = 4e5 # 4 x 10**5 o 400,000 c = -1.345e-10 Los n\u00fameros de tipo floats son representados en la m\u00e1quina como n\u00fameros de doble precisi\u00f3n usando la representaci\u00f3n nativa del microprocesador que sigue el est\u00e1ndar IEEE 754 . Para los que los conozcan: es el mismo tipo que los double en el lenguaje C. Un float almacenan hasta 17 digitos con un exponente entre -308 to 308 Cuidado que la aritm\u00e9tica de los n\u00fameros de punto flotante no es exacta. >>> a = 2.1 + 4.2 >>> a == 6.3 False >>> a 6.300000000000001 >>> Esto no es un problema de Python , si no el resultado de la forma en que el hardware de nuestras computadoras almacena los n\u00fameros de punto flotante. Operaciones usuales: x + y Suma x - y Resta x * y Multiplicaci\u00f3n x / y Divici\u00f3n (da un float, no un int) x // y Divisi\u00f3n entera (da un float, pero con ceros luego del punto) x % y M\u00f3dulo (resto) x ** y Potencia abs(x) Valor absoluto Estas son las mismas operaciones que con los enteros. Otras operaciones usuales se encuentran en el m\u00f3dulo math . import math a = math.sqrt(x) b = math.sin(x) c = math.cos(x) d = math.tan(x) e = math.log(x) El m\u00f3dulo math tambi\u00e9n tiene constantes ( math.e , math.pi ), entre otras cosas.","title":"Punto flotante (float)"},{"location":"01_Introduccion/03_Numeros/#comparaciones","text":"Las siguientes comparaciones (suelen llamarse operadores relacionales ya que expresan una relaci\u00f3n entre dos elementos) funcionan con n\u00fameros: x < y Menor que x <= y Menor o igual que x > y Mayor que x >= y Mayor o igual que x == y Igual a x != y No igual a Observ\u00e1 que el == se usa para comparar dos elementos mientras que el = se usa para asignar un valor a una variable. Son s\u00edmbolos distintos que cumplen funciones diferentes. Pod\u00e9s formar expresiones booleanas m\u00e1s complejas usando and , or , not Ac\u00e1 mostramos algunos ejemplos: if b >= a and b <= c: print('b est\u00e1 entre a y c') if not (b < a or b > c): print('b sigue estando entre a y c')","title":"Comparaciones"},{"location":"01_Introduccion/03_Numeros/#conversion-de-numeros","text":"El nombre de un tipo (de datos) puede ser usado para convertir valores: a = int(x) # Convertir x a int b = float(x) # Convertir x a float Probalo. >>> a = 3.14159 >>> int(a) 3 >>> b = '3.14159' # Tambi\u00e9n funciona con cadenas que representan n\u00fameros. >>> float(b) 3.14159 >>> Cuidado: el separador decimal en Python es el punto, como en ingl\u00e9s, y no la coma del castellano. Por eso el comando float(3,141592) da un ValueError .","title":"Conversi\u00f3n de n\u00fameros"},{"location":"01_Introduccion/03_Numeros/#ejercicios","text":"Recordatorio: Asumimos que est\u00e1s trabajando en el subdirectorio ejercicios_python/Clase01/ . Busc\u00e1 el archivo hipoteca.py y hac\u00e9 los ejercicios en ese archivo, usando un editor de texto. Ejecutalo desde la l\u00ednea de comandos.","title":"Ejercicios"},{"location":"01_Introduccion/03_Numeros/#ejercicio-17-la-hipoteca-de-david","text":"David solicit\u00f3 un cr\u00e9dito a 30 a\u00f1os para comprar una vivienda, con una tasa fija nominal anual del 5%. Pidi\u00f3 $500000 al banco y acord\u00f3 un pago mensual fijo de $2684,11. El siguiente es un programa que calcula el monto total que pagar\u00e1 David a lo largo de los a\u00f1os: # hipoteca.py saldo = 500000.0 tasa = 0.05 pago_mensual = 2684.11 total_pagado = 0.0 while saldo > 0: saldo = saldo * (1+tasa/12) - pago_mensual total_pagado = total_pagado + pago_mensual print('Total pagado', round(total_pagado, 2)) Copi\u00e1 este c\u00f3digo y correlo. Deber\u00edas obtener 966279.6 como respuesta.","title":"Ejercicio 1.7: La hipoteca de David"},{"location":"01_Introduccion/03_Numeros/#ejercicio-18-adelantos","text":"Supongamos que David adelanta pagos extra de $1000/mes durante los primeros 12 meses de la hipoteca. Modific\u00e1 el programa para incorporar estos pagos extra y que imprima el monto total pagado junto con la cantidad de meses requeridos. Cuando lo corras, este nuevo programa deber\u00eda dar un pago total de 929965.62 en 342 meses. Aclaraci\u00f3n: aunque puede parecer sencillo, este ejercicio requiere que agregues una variable mes y que prestes bastante atenci\u00f3n a cu\u00e1ndo la increment\u00e1s, con qu\u00e9 valor entra al ciclo y con qu\u00e9 valor sale del ciclo. Una posiblidad es inicializar mes en 0 y otra es inicializarla en 1. En el primer caso es problable que la variable salga del ciclo contando la cantidad de pagos que se hicieron, en el segundo, \u00a1es probable que salga contando la cantidad de pagos m\u00e1s uno!","title":"Ejercicio 1.8: Adelantos"},{"location":"01_Introduccion/03_Numeros/#ejercicio-19-calculadora-de-adelantos","text":"\u00bfCu\u00e1nto pagar\u00eda David si agrega $1000 por mes durante cuatro a\u00f1os, comenzando en el sexto a\u00f1o de la hipoteca (es decir, luego de 5 a\u00f1os)? Modific\u00e1 tu programa de forma que la informaci\u00f3n sobre pagos extras sea incorporada de manera vers\u00e1til. Agreg\u00e1 las siguientes variables antes del ciclo, para definir el comienzo, fin y monto de los pagos extras: pago_extra_mes_comienzo = 61 pago_extra_mes_fin = 108 pago_extra = 1000 Hac\u00e9 que el programa tenga en cuenta estas variables para calcular el total a pagar apropiadamente.","title":"Ejercicio 1.9: Calculadora de adelantos"},{"location":"01_Introduccion/03_Numeros/#ejercicio-110-tablas","text":"Modic\u00e1 tu programa para que imprima una tabla mostrando el mes, el total pagado hasta el momento y el saldo restante. La salida deber\u00eda verse aproximadamente as\u00ed: 1 2684.11 499399.22 2 5368.22 498795.94 3 8052.33 498190.15 4 10736.44 497581.83 5 13420.55 496970.98 ... 308 874705.88 3478.83 309 877389.99 809.21 310 880074.1 -1871.53 Total pagado: 880074.1 Meses: 310","title":"Ejercicio 1.10: Tablas"},{"location":"01_Introduccion/03_Numeros/#ejercicio-111-bonus","text":"Ya que estamos, correg\u00ed el c\u00f3digo anterior de forma que el pago del \u00faltimo mes se ajuste a lo adeudado. Asegurate de guardar en el archivo hipoteca.py esta \u00faltima versi\u00f3n en tu directorio ejercicios_python/Clase01/ . Vamos a volver a trabajar con \u00e9l.","title":"Ejercicio 1.11: Bonus"},{"location":"01_Introduccion/03_Numeros/#ejercicio-112-un-misterio","text":"Las funciones int() y float() pueden usarse para convertir n\u00fameros. Por ejemplo, >>> int(\"123\") 123 >>> float(\"1.23\") 1.23 >>> Con esto en mente, \u00bfpodr\u00edas explicar el siguiente comportamiento? >>> bool(\"False\") True >>>","title":"Ejercicio 1.12: Un misterio"},{"location":"01_Introduccion/03_Numeros/#ejercicio-113-el-volumen-de-una-esfera","text":"En tu directorio de trabajo de esta clase, escrib\u00ed un programa llamado esfera.py que le pida al usuario que ingrese por teclado el radio r de una esfera y calcule e imprima el volumen de la misma. Sugerencia: recordar que el vol\u00famen de una esfera es 4/3 \u03c0r^3 . Finalmente, ejecut\u00e1 el programa desde la l\u00ednea de comandos para responder \u00bfcu\u00e1l es el volumen de una esfera de radio 6? Deber\u00eda darte 904.7786842338603 . Contenidos | Anterior (2 Un primer programa) | Pr\u00f3ximo (4 Cadenas)","title":"Ejercicio 1.13: El volumen de una esfera"},{"location":"01_Introduccion/04_Strings/","text":"Contenidos | Anterior (3 N\u00fameros) | Pr\u00f3ximo (5 Listas) 1.4 Cadenas En esta secci\u00f3n veremos c\u00f3mo trabajar con textos. Representaci\u00f3n de textos Las cadenas de caracteres entre comillas se usan para representar texto en Python. En este caso, fragmentos del Mart\u00edn Fierro. # Comillas simples a = 'Aqu\u00ed me pongo a cantar, al comp\u00e1s de la vig\u00fcela' # Comillas dobles b = \"Los hermanos sean unidos porque \u00e9sa es la ley primera\" # Comillas triples c = ''' Yo no tengo en el amor Quien me venga con querellas; Como esas aves tan bellas Que saltan de rama en rama Yo hago en el tr\u00e9bol mi cama Y me cubren las estrellas. ''' Normalmente las cadenas de caracteres solo ocupan una linea. Las comillas triples nos permiten capturar todo el texto encerrado a lo largo de m\u00faltiples lineas. No hay diferencia entre las comillas simples (') y las dobles (\"). Pero el mismo tipo de comillas que se us\u00f3 para abrir debe usarse para cerrar . C\u00f3digo de escape Los c\u00f3digos de escape (escape codes) son expresiones que comienzan con una barra invertida, \\ y se usan para representar caracteres que no pueden ser f\u00e1cilmente tipeados directamente con el teclado. Estos son algunos c\u00f3digos de escape usuales: '\\n' Avanzar una l\u00ednea '\\r' Retorno de carro '\\t' Tabulador '\\'' Comilla literal '\\\"' Comilla doble literal '\\\\' Barra invertida literal El retorno de carro (c\u00f3digo '\\r') mueve el cursor al comienzo de la l\u00ednea pero sin avanzar una l\u00ednea. El origen de su nombre est\u00e1 relacionado con las m\u00e1quinas de escribir. Representaci\u00f3n en memoria de las cadenas Las cadenas se representan en Python asociando a cada caracter un n\u00famero entero o c\u00f3digo Unicode . Es posible definir un caracter usando su c\u00f3digo y c\u00f3digos de escape como s = '\\U0001D120' para la clave de sol. Indexaci\u00f3n de cadenas Las cadenas funcionan como los vectores multidimensionales en matem\u00e1tica, permitiendo el acceso a los caracteres individuales. El \u00edndice comienza a contar en cero. Los \u00edndices negativos se usan para especificar una posici\u00f3n respecto al final de la cadena. a = 'Hello world' b = a[0] # 'H' c = a[4] # 'o' d = a[-1] # 'd' (fin de cadena) Tambi\u00e9n se puede rebanar (slice) o seleccionar subcadenas especificando un range de \u00edndices con : . d = a[:5] # 'Hello' e = a[6:] # 'world' f = a[3:8] # 'lo wo' g = a[-5:] # 'world' El caracter que corresponde al \u00faltimo \u00edndice no se incluye. Si un extremo no se especifica, significa que es desde el comienzo o hasta el final , respectivamente. Operaciones con cadenas Concatenaci\u00f3n, longitud, pertenencia y replicaci\u00f3n. # Concatenaci\u00f3n (+) a = 'Hello' + 'World' # 'HelloWorld' b = 'Say ' + a # 'Say HelloWorld' # Longitud (len) s = 'Hello' len(s) # 5 # Test de pertenencia (in, not in) t = 'e' in s # True f = 'x' in s # False g = 'hi' not in s # True # Replicaci\u00f3n (s * n) rep = s * 5 # 'HelloHelloHelloHelloHello' M\u00e9todos de las cadenas Las cadenas en Python tienen m\u00e9todos que realizan diversas operaciones con este tipo de datos. Ejemplo: sacar (strip) los espacios en blanco sobrantes al inicio o al final de una cadena. s = ' Hello ' t = s.strip() # 'Hello' Ejemplo: Conversi\u00f3n entre may\u00fasculas y min\u00fasculas. s = 'Hello' l = s.lower() # 'hello' u = s.upper() # 'HELLO' Ejemplo: Reemplazo de texto. s = 'Hello world' t = s.replace('Hello' , 'Hallo') # 'Hallo world' M\u00e1s m\u00e9todos de cadenas: Los strings (cadenas) ofrecen una amplia variedad de m\u00e9todos para testear y manipular textos. Estos son algunos de los m\u00e9todos: s.endswith(suffix) # Verifica si termina con el sufijo s.find(t) # Primera aparici\u00f3n de t en s (o -1 si no est\u00e1) s.index(t) # Primera aparici\u00f3n de t en s (error si no est\u00e1) s.isalpha() # Verifica si los caracteres son alfab\u00e9ticos s.isdigit() # Verifica si los caracteres son num\u00e9ricos s.islower() # Verifica si los caracteres son min\u00fasculas s.isupper() # Verifica si los caracteres son may\u00fasculas s.join(slist) # Une una lista de cadenas usando s como delimitador s.lower() # Convertir a min\u00fasculas s.replace(old,new) # Reemplaza texto s.split([delim]) # Parte la cadena en subcadenas s.startswith(prefix) # Verifica si comienza con un sufijo s.strip() # Elimina espacios en blanco al inicio o al final s.upper() # Convierte a may\u00fasculas Mutabilidad de cadenas Los strings son \"inmutables\" o de s\u00f3lo lectura. Una vez creados, su valor no puede ser cambiado. >>> s = 'Hello World' >>> s[1] = 'a' # Intento cambiar la 'e' por una 'a' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'str' object does not support item assignment >>> Esto implica que las operaciones y m\u00e9todos que manipulan cadenas deben crear nuevas cadenas para almacenar su resultado. Conversi\u00f3n de cadenas Us\u00e1 str() para convertir cualquier valor a cadena. El resultado es una cadena con el mismo contenido que hubiera mostrado el comando print() sobre la expresi\u00f3n entre par\u00e9ntesis. >>> x = 42 >>> str(x) '42' >>> f-Strings Las f-Strings son cadenas en las que ciertas expresiones son formateadas >>> nombre = 'Naranja' >>> cajones = 100 >>> precio = 91.1 >>> a = f'{nombre:>10s} {cajones:10d} {precio:10.2f}' >>> a ' Naranja 100 91.10' >>> b = f'Costo = ${cajones*precio:0.2f}' >>> b 'Costo = $9110.00' >>> Nota: Esto requiere Python 3.6 o uno m\u00e1s nuevo. El significado de los c\u00f3digos lo veremos m\u00e1s adelante. Ejercicios En estos ejercicios vas a experimentar con operaciones sobre el tipo de dato string de Python. Hacelo en el int\u00e9rprete interactivo para ver inmediatamente los resultados. Recordamos: En los ejercicios donde interactu\u00e1s con el int\u00e9rprete, el s\u00edmbolo >>> es el que usa Python para indicarte que espera un nuevo comando. Algunos comandos ocupan m\u00e1s de una l\u00ednea de c\u00f3digo --para que funcionen, vas a tener que apretar 'enter' algunas veces. Acordate de no copiar el >>> de los ejemplos. Comencemos definiendo una cadena que contiene una lista de frutas as\u00ed:: >>> frutas = 'Manzana,Naranja,Mandarina,Banana,Kiwi' >>> Ejercicio 1.14: Extraer caracteres individuales y subcadenas Los strings son vectores de caracteres. Trat\u00e1 de extraer algunos carateres: >>> frutas[0] ? >>> frutas[1] ? >>> frutas[2] ? >>> frutas[-1] # \u00daltimo caracter ? >>> frutas[-2] # \u00cdndices negativos se cuentan desde el final ? >>> Como ya dijimos, en Python los strings son s\u00f3lo de lectura. Verific\u00e1 esto tratando de cambiar el primer caracter de frutas por una m min\u00fascula 'm'. >>> frutas[0] = 'm' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'str' object does not support item assignment >>> Ejercicio 1.15: Concatenaci\u00f3n de cadenas A pesar de ser s\u00f3lo de lectura, siempre pod\u00e9s reasignar una variable a una cadena nueva. Prob\u00e1 el siguiente comando que concatena la palabra \"Pera\" al final de frutas : >>> frutas = frutas + 'Pera' >>> frutas 'Manzana,Naranja,Mandarina,Banana,KiwiPera' >>> Ups! No es exactamento lo que quer\u00edamos. Reparalo para que quede 'Manzana,Naranja,Mandarina,Banana,Kiwi,Pera' . >>> frutas = ? >>> frutas 'Manzana,Naranja,Mandarina,Banana,Kiwi,Pera' >>> Agreg\u00e1 'Mel\u00f3n'` al principio de la cadena: >>> frutas = ? >>> frutas 'Mel\u00f3n,Manzana,Naranja,Mandarina,Banana,Kiwi,Pera' >>> Podr\u00eda parecer en estos ejemplos que la cadena original est\u00e1 siendo modificada, contradiciendo la regla de que las cadenas son de s\u00f3lo lectura. No es as\u00ed. Las operaciones sobre cadenas crean una nueva cadena cada vez. Cuando la variable frutas es reasignada, apunta a la cadena recientemente creada. Luego, la cadena vieja es destruida dado que ya no est\u00e1 siendo usada. Ejercicio 1.16: Testeo de pertenencia (test de subcadena) Experiment\u00e1 con el operador in para buscar subcadenas. En el int\u00e9rprete interactivo prob\u00e1 estas operaciones: >>> 'Naranja' in frutas ? >>> 'nana' in frutas True >>> 'Lima' in frutas ? >>> \u00bfPor qu\u00e9 la verificaci\u00f3n de 'nana' di\u00f3 True ? Ejercicio 1.17: Iteraci\u00f3n sobre cadenas Us\u00e1 el comando for para iterar sobre los caracteres de una cadena. >>> cadena = \"Ejemplo con for\" >>> for c in cadena: print('caracter:', c) # Mir\u00e1 el output. Modific\u00e1 el c\u00f3digo anterior de manera que dentro del ciclo el programa cuente cu\u00e1ntas letras \"o\" hay en la cadena. Sugerencia: us\u00e1 un contador como con los meses de la hipoteca. Ejercicio 1.18: Geringoso r\u00fastico Us\u00e1 una iteraci\u00f3n sobre el string cadena para agregar la s\u00edlaba 'pa', 'pe', 'pi', 'po', o 'pu' seg\u00fan corresponda luego de cada vocal. >>> cadena = 'Geringoso' >>> capadepenapa = '' >>> for c in cadena: ? >>> capadepenapa Geperipingoposopo Pod\u00e9s probar tu c\u00f3digo cambiando la cadena inicial por otra palabra, como 'apa' o 'boligoma'. Guard\u00e1 el c\u00f3digo en un archivo geringoso.py . Ejercicio 1.19: M\u00e9todos de cadenas En el int\u00e9rprete interactivo experiment\u00e1 con algunos de los m\u00e9todos de cadenas introducidos antes. >>> frutas.lower() ? >>> frutas ? >>> Record\u00e1, las cadenas son siempre de s\u00f3lo lectura. Si quer\u00e9s guardar el resultado de una operaci\u00f3n, vas a necesit\u00e1s asign\u00e1rselo a una variable: >>> lowersyms = frutas.lower() >>> Prob\u00e1 algunas m\u00e1s: >>> frutas.find('Mandarina') ? >>> frutas[13:17] ? >>> frutas = frutas.replace('Kiwi','Mel\u00f3n') >>> frutas ? >>> nombre = ' Naranja \\n' >>> nombre = nombre.strip() # Remove surrounding whitespace >>> nombre ? >>> Ejercicio 1.20: f-strings A veces quer\u00e9s crear una cadena que incorpore los valores de otras variables en ella. Para hacer eso, us\u00e1 una f-string. Por ejemplo: >>> nombre = 'Naranja' >>> cajones = 100 >>> precio = 91.1 >>> f'{cajones} cajones de {nombre} a ${precio:0.2f}' '100 cajones de Naranja a $91.10' >>> Modific\u00e1 el programa hipoteca.py del Ejercicio 1.11 de la secci\u00f3n anterior para que escriba su salida usando f-strings. Trat\u00e1 de hacer que la salida quede bien alineada. Ejercicio 1.21: Expresiones regulares Una limitaci\u00f3n de las operaciones b\u00e1sicas de cadenas es que no ofrecen ning\u00fan tipo de transformaci\u00f3n usando patrones m\u00e1s sofisticados. Para eso vas a tener que usar el m\u00f3dulo re de Python y aprender a usar expresiones regulares. El manejo de estas expresiones es un tema en s\u00ed mismo. A continuaci\u00f3n presentamos un corto ejemplo: >>> texto = 'Hoy es 6/8/2020. Ma\u00f1ana ser\u00e1 7/8/2020.' >>> # Encontrar las apariciones de una fecha en el texto >>> import re >>> re.findall(r'\\d+/\\d+/\\d+', texto) ['6/8/2020', '7/8/2020'] >>> # Reemplaz\u00e1 esas apariciones, cambiando el formato >>> re.sub(r'(\\d+)/(\\d+)/(\\d+)', r'\\3-\\2-\\1', texto) 'Hoy es 2020-8-6. Ma\u00f1ana ser\u00e1 2020-8-7.' >>> Para m\u00e1s informaci\u00f3n sobre el m\u00f3dulo re , mir\u00e1 la documentaci\u00f3n oficial en ingl\u00e9s o alg\u00fan tutorial en castellano . Es un tema que escapa al contenido del curso pero te recomendamos que mires en detalle en alg\u00fan momento. Aunque no justo ahora. Sigamos... Comentario A medida que empez\u00e1s a usar Python es usual que quieras saber qu\u00e9 otras operaciones admiten los objetos con los que est\u00e1s trabajando. Por ejemplo. \u00bfc\u00f3mo pod\u00e9s averiguar qu\u00e9 operaciones se pueden hacer con una cadena? Dependiendo de tu entorno de Python, podr\u00e1s ver una lista de m\u00e9todos disponibles apretando la tecla tab. Por ejemplo, intent\u00e1 esto: >>> s = 'hello world' >>> s.<tecla tab> >>> Si al presionar tab no pasa nada, pod\u00e9s volver al viejo uso de la funci\u00f3n dir() . Por ejemplo: >>> s = 'hello' >>> dir(s) ['__add__', '__class__', '__contains__', ..., 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] >>> dir() produce una lista con todas las operaciones que pueden aparecer luego del par\u00e1metro que le pasaste, en este caso s . Tambi\u00e9n pod\u00e9s usar el comando help() para obtener m\u00e1s informaci\u00f3n sobre una operaci\u00f3n espec\u00edfica: >>> help(s.upper) Help on built-in function upper: upper(...) S.upper() -> string Return a copy of the string S converted to uppercase. >>> Contenidos | Anterior (3 N\u00fameros) | Pr\u00f3ximo (5 Listas)","title":"04 Strings"},{"location":"01_Introduccion/04_Strings/#14-cadenas","text":"En esta secci\u00f3n veremos c\u00f3mo trabajar con textos.","title":"1.4 Cadenas"},{"location":"01_Introduccion/04_Strings/#representacion-de-textos","text":"Las cadenas de caracteres entre comillas se usan para representar texto en Python. En este caso, fragmentos del Mart\u00edn Fierro. # Comillas simples a = 'Aqu\u00ed me pongo a cantar, al comp\u00e1s de la vig\u00fcela' # Comillas dobles b = \"Los hermanos sean unidos porque \u00e9sa es la ley primera\" # Comillas triples c = ''' Yo no tengo en el amor Quien me venga con querellas; Como esas aves tan bellas Que saltan de rama en rama Yo hago en el tr\u00e9bol mi cama Y me cubren las estrellas. ''' Normalmente las cadenas de caracteres solo ocupan una linea. Las comillas triples nos permiten capturar todo el texto encerrado a lo largo de m\u00faltiples lineas. No hay diferencia entre las comillas simples (') y las dobles (\"). Pero el mismo tipo de comillas que se us\u00f3 para abrir debe usarse para cerrar .","title":"Representaci\u00f3n de textos"},{"location":"01_Introduccion/04_Strings/#codigo-de-escape","text":"Los c\u00f3digos de escape (escape codes) son expresiones que comienzan con una barra invertida, \\ y se usan para representar caracteres que no pueden ser f\u00e1cilmente tipeados directamente con el teclado. Estos son algunos c\u00f3digos de escape usuales: '\\n' Avanzar una l\u00ednea '\\r' Retorno de carro '\\t' Tabulador '\\'' Comilla literal '\\\"' Comilla doble literal '\\\\' Barra invertida literal El retorno de carro (c\u00f3digo '\\r') mueve el cursor al comienzo de la l\u00ednea pero sin avanzar una l\u00ednea. El origen de su nombre est\u00e1 relacionado con las m\u00e1quinas de escribir.","title":"C\u00f3digo de escape"},{"location":"01_Introduccion/04_Strings/#representacion-en-memoria-de-las-cadenas","text":"Las cadenas se representan en Python asociando a cada caracter un n\u00famero entero o c\u00f3digo Unicode . Es posible definir un caracter usando su c\u00f3digo y c\u00f3digos de escape como s = '\\U0001D120' para la clave de sol.","title":"Representaci\u00f3n en memoria de las cadenas"},{"location":"01_Introduccion/04_Strings/#indexacion-de-cadenas","text":"Las cadenas funcionan como los vectores multidimensionales en matem\u00e1tica, permitiendo el acceso a los caracteres individuales. El \u00edndice comienza a contar en cero. Los \u00edndices negativos se usan para especificar una posici\u00f3n respecto al final de la cadena. a = 'Hello world' b = a[0] # 'H' c = a[4] # 'o' d = a[-1] # 'd' (fin de cadena) Tambi\u00e9n se puede rebanar (slice) o seleccionar subcadenas especificando un range de \u00edndices con : . d = a[:5] # 'Hello' e = a[6:] # 'world' f = a[3:8] # 'lo wo' g = a[-5:] # 'world' El caracter que corresponde al \u00faltimo \u00edndice no se incluye. Si un extremo no se especifica, significa que es desde el comienzo o hasta el final , respectivamente.","title":"Indexaci\u00f3n de cadenas"},{"location":"01_Introduccion/04_Strings/#operaciones-con-cadenas","text":"Concatenaci\u00f3n, longitud, pertenencia y replicaci\u00f3n. # Concatenaci\u00f3n (+) a = 'Hello' + 'World' # 'HelloWorld' b = 'Say ' + a # 'Say HelloWorld' # Longitud (len) s = 'Hello' len(s) # 5 # Test de pertenencia (in, not in) t = 'e' in s # True f = 'x' in s # False g = 'hi' not in s # True # Replicaci\u00f3n (s * n) rep = s * 5 # 'HelloHelloHelloHelloHello'","title":"Operaciones con cadenas"},{"location":"01_Introduccion/04_Strings/#metodos-de-las-cadenas","text":"Las cadenas en Python tienen m\u00e9todos que realizan diversas operaciones con este tipo de datos. Ejemplo: sacar (strip) los espacios en blanco sobrantes al inicio o al final de una cadena. s = ' Hello ' t = s.strip() # 'Hello' Ejemplo: Conversi\u00f3n entre may\u00fasculas y min\u00fasculas. s = 'Hello' l = s.lower() # 'hello' u = s.upper() # 'HELLO' Ejemplo: Reemplazo de texto. s = 'Hello world' t = s.replace('Hello' , 'Hallo') # 'Hallo world' M\u00e1s m\u00e9todos de cadenas: Los strings (cadenas) ofrecen una amplia variedad de m\u00e9todos para testear y manipular textos. Estos son algunos de los m\u00e9todos: s.endswith(suffix) # Verifica si termina con el sufijo s.find(t) # Primera aparici\u00f3n de t en s (o -1 si no est\u00e1) s.index(t) # Primera aparici\u00f3n de t en s (error si no est\u00e1) s.isalpha() # Verifica si los caracteres son alfab\u00e9ticos s.isdigit() # Verifica si los caracteres son num\u00e9ricos s.islower() # Verifica si los caracteres son min\u00fasculas s.isupper() # Verifica si los caracteres son may\u00fasculas s.join(slist) # Une una lista de cadenas usando s como delimitador s.lower() # Convertir a min\u00fasculas s.replace(old,new) # Reemplaza texto s.split([delim]) # Parte la cadena en subcadenas s.startswith(prefix) # Verifica si comienza con un sufijo s.strip() # Elimina espacios en blanco al inicio o al final s.upper() # Convierte a may\u00fasculas","title":"M\u00e9todos de las cadenas"},{"location":"01_Introduccion/04_Strings/#mutabilidad-de-cadenas","text":"Los strings son \"inmutables\" o de s\u00f3lo lectura. Una vez creados, su valor no puede ser cambiado. >>> s = 'Hello World' >>> s[1] = 'a' # Intento cambiar la 'e' por una 'a' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'str' object does not support item assignment >>> Esto implica que las operaciones y m\u00e9todos que manipulan cadenas deben crear nuevas cadenas para almacenar su resultado.","title":"Mutabilidad de cadenas"},{"location":"01_Introduccion/04_Strings/#conversion-de-cadenas","text":"Us\u00e1 str() para convertir cualquier valor a cadena. El resultado es una cadena con el mismo contenido que hubiera mostrado el comando print() sobre la expresi\u00f3n entre par\u00e9ntesis. >>> x = 42 >>> str(x) '42' >>>","title":"Conversi\u00f3n de cadenas"},{"location":"01_Introduccion/04_Strings/#f-strings","text":"Las f-Strings son cadenas en las que ciertas expresiones son formateadas >>> nombre = 'Naranja' >>> cajones = 100 >>> precio = 91.1 >>> a = f'{nombre:>10s} {cajones:10d} {precio:10.2f}' >>> a ' Naranja 100 91.10' >>> b = f'Costo = ${cajones*precio:0.2f}' >>> b 'Costo = $9110.00' >>> Nota: Esto requiere Python 3.6 o uno m\u00e1s nuevo. El significado de los c\u00f3digos lo veremos m\u00e1s adelante.","title":"f-Strings"},{"location":"01_Introduccion/04_Strings/#ejercicios","text":"En estos ejercicios vas a experimentar con operaciones sobre el tipo de dato string de Python. Hacelo en el int\u00e9rprete interactivo para ver inmediatamente los resultados. Recordamos: En los ejercicios donde interactu\u00e1s con el int\u00e9rprete, el s\u00edmbolo >>> es el que usa Python para indicarte que espera un nuevo comando. Algunos comandos ocupan m\u00e1s de una l\u00ednea de c\u00f3digo --para que funcionen, vas a tener que apretar 'enter' algunas veces. Acordate de no copiar el >>> de los ejemplos. Comencemos definiendo una cadena que contiene una lista de frutas as\u00ed:: >>> frutas = 'Manzana,Naranja,Mandarina,Banana,Kiwi' >>>","title":"Ejercicios"},{"location":"01_Introduccion/04_Strings/#ejercicio-114-extraer-caracteres-individuales-y-subcadenas","text":"Los strings son vectores de caracteres. Trat\u00e1 de extraer algunos carateres: >>> frutas[0] ? >>> frutas[1] ? >>> frutas[2] ? >>> frutas[-1] # \u00daltimo caracter ? >>> frutas[-2] # \u00cdndices negativos se cuentan desde el final ? >>> Como ya dijimos, en Python los strings son s\u00f3lo de lectura. Verific\u00e1 esto tratando de cambiar el primer caracter de frutas por una m min\u00fascula 'm'. >>> frutas[0] = 'm' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'str' object does not support item assignment >>>","title":"Ejercicio 1.14: Extraer caracteres individuales y subcadenas"},{"location":"01_Introduccion/04_Strings/#ejercicio-115-concatenacion-de-cadenas","text":"A pesar de ser s\u00f3lo de lectura, siempre pod\u00e9s reasignar una variable a una cadena nueva. Prob\u00e1 el siguiente comando que concatena la palabra \"Pera\" al final de frutas : >>> frutas = frutas + 'Pera' >>> frutas 'Manzana,Naranja,Mandarina,Banana,KiwiPera' >>> Ups! No es exactamento lo que quer\u00edamos. Reparalo para que quede 'Manzana,Naranja,Mandarina,Banana,Kiwi,Pera' . >>> frutas = ? >>> frutas 'Manzana,Naranja,Mandarina,Banana,Kiwi,Pera' >>> Agreg\u00e1 'Mel\u00f3n'` al principio de la cadena: >>> frutas = ? >>> frutas 'Mel\u00f3n,Manzana,Naranja,Mandarina,Banana,Kiwi,Pera' >>> Podr\u00eda parecer en estos ejemplos que la cadena original est\u00e1 siendo modificada, contradiciendo la regla de que las cadenas son de s\u00f3lo lectura. No es as\u00ed. Las operaciones sobre cadenas crean una nueva cadena cada vez. Cuando la variable frutas es reasignada, apunta a la cadena recientemente creada. Luego, la cadena vieja es destruida dado que ya no est\u00e1 siendo usada.","title":"Ejercicio 1.15: Concatenaci\u00f3n de cadenas"},{"location":"01_Introduccion/04_Strings/#ejercicio-116-testeo-de-pertenencia-test-de-subcadena","text":"Experiment\u00e1 con el operador in para buscar subcadenas. En el int\u00e9rprete interactivo prob\u00e1 estas operaciones: >>> 'Naranja' in frutas ? >>> 'nana' in frutas True >>> 'Lima' in frutas ? >>> \u00bfPor qu\u00e9 la verificaci\u00f3n de 'nana' di\u00f3 True ?","title":"Ejercicio 1.16: Testeo de pertenencia (test de subcadena)"},{"location":"01_Introduccion/04_Strings/#ejercicio-117-iteracion-sobre-cadenas","text":"Us\u00e1 el comando for para iterar sobre los caracteres de una cadena. >>> cadena = \"Ejemplo con for\" >>> for c in cadena: print('caracter:', c) # Mir\u00e1 el output. Modific\u00e1 el c\u00f3digo anterior de manera que dentro del ciclo el programa cuente cu\u00e1ntas letras \"o\" hay en la cadena. Sugerencia: us\u00e1 un contador como con los meses de la hipoteca.","title":"Ejercicio 1.17: Iteraci\u00f3n sobre cadenas"},{"location":"01_Introduccion/04_Strings/#ejercicio-118-geringoso-rustico","text":"Us\u00e1 una iteraci\u00f3n sobre el string cadena para agregar la s\u00edlaba 'pa', 'pe', 'pi', 'po', o 'pu' seg\u00fan corresponda luego de cada vocal. >>> cadena = 'Geringoso' >>> capadepenapa = '' >>> for c in cadena: ? >>> capadepenapa Geperipingoposopo Pod\u00e9s probar tu c\u00f3digo cambiando la cadena inicial por otra palabra, como 'apa' o 'boligoma'. Guard\u00e1 el c\u00f3digo en un archivo geringoso.py .","title":"Ejercicio 1.18: Geringoso r\u00fastico"},{"location":"01_Introduccion/04_Strings/#ejercicio-119-metodos-de-cadenas","text":"En el int\u00e9rprete interactivo experiment\u00e1 con algunos de los m\u00e9todos de cadenas introducidos antes. >>> frutas.lower() ? >>> frutas ? >>> Record\u00e1, las cadenas son siempre de s\u00f3lo lectura. Si quer\u00e9s guardar el resultado de una operaci\u00f3n, vas a necesit\u00e1s asign\u00e1rselo a una variable: >>> lowersyms = frutas.lower() >>> Prob\u00e1 algunas m\u00e1s: >>> frutas.find('Mandarina') ? >>> frutas[13:17] ? >>> frutas = frutas.replace('Kiwi','Mel\u00f3n') >>> frutas ? >>> nombre = ' Naranja \\n' >>> nombre = nombre.strip() # Remove surrounding whitespace >>> nombre ? >>>","title":"Ejercicio 1.19: M\u00e9todos de cadenas"},{"location":"01_Introduccion/04_Strings/#ejercicio-120-f-strings","text":"A veces quer\u00e9s crear una cadena que incorpore los valores de otras variables en ella. Para hacer eso, us\u00e1 una f-string. Por ejemplo: >>> nombre = 'Naranja' >>> cajones = 100 >>> precio = 91.1 >>> f'{cajones} cajones de {nombre} a ${precio:0.2f}' '100 cajones de Naranja a $91.10' >>> Modific\u00e1 el programa hipoteca.py del Ejercicio 1.11 de la secci\u00f3n anterior para que escriba su salida usando f-strings. Trat\u00e1 de hacer que la salida quede bien alineada.","title":"Ejercicio 1.20: f-strings"},{"location":"01_Introduccion/04_Strings/#ejercicio-121-expresiones-regulares","text":"Una limitaci\u00f3n de las operaciones b\u00e1sicas de cadenas es que no ofrecen ning\u00fan tipo de transformaci\u00f3n usando patrones m\u00e1s sofisticados. Para eso vas a tener que usar el m\u00f3dulo re de Python y aprender a usar expresiones regulares. El manejo de estas expresiones es un tema en s\u00ed mismo. A continuaci\u00f3n presentamos un corto ejemplo: >>> texto = 'Hoy es 6/8/2020. Ma\u00f1ana ser\u00e1 7/8/2020.' >>> # Encontrar las apariciones de una fecha en el texto >>> import re >>> re.findall(r'\\d+/\\d+/\\d+', texto) ['6/8/2020', '7/8/2020'] >>> # Reemplaz\u00e1 esas apariciones, cambiando el formato >>> re.sub(r'(\\d+)/(\\d+)/(\\d+)', r'\\3-\\2-\\1', texto) 'Hoy es 2020-8-6. Ma\u00f1ana ser\u00e1 2020-8-7.' >>> Para m\u00e1s informaci\u00f3n sobre el m\u00f3dulo re , mir\u00e1 la documentaci\u00f3n oficial en ingl\u00e9s o alg\u00fan tutorial en castellano . Es un tema que escapa al contenido del curso pero te recomendamos que mires en detalle en alg\u00fan momento. Aunque no justo ahora. Sigamos...","title":"Ejercicio 1.21: Expresiones regulares"},{"location":"01_Introduccion/04_Strings/#comentario","text":"A medida que empez\u00e1s a usar Python es usual que quieras saber qu\u00e9 otras operaciones admiten los objetos con los que est\u00e1s trabajando. Por ejemplo. \u00bfc\u00f3mo pod\u00e9s averiguar qu\u00e9 operaciones se pueden hacer con una cadena? Dependiendo de tu entorno de Python, podr\u00e1s ver una lista de m\u00e9todos disponibles apretando la tecla tab. Por ejemplo, intent\u00e1 esto: >>> s = 'hello world' >>> s.<tecla tab> >>> Si al presionar tab no pasa nada, pod\u00e9s volver al viejo uso de la funci\u00f3n dir() . Por ejemplo: >>> s = 'hello' >>> dir(s) ['__add__', '__class__', '__contains__', ..., 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] >>> dir() produce una lista con todas las operaciones que pueden aparecer luego del par\u00e1metro que le pasaste, en este caso s . Tambi\u00e9n pod\u00e9s usar el comando help() para obtener m\u00e1s informaci\u00f3n sobre una operaci\u00f3n espec\u00edfica: >>> help(s.upper) Help on built-in function upper: upper(...) S.upper() -> string Return a copy of the string S converted to uppercase. >>> Contenidos | Anterior (3 N\u00fameros) | Pr\u00f3ximo (5 Listas)","title":"Comentario"},{"location":"01_Introduccion/05_Listas/","text":"Contenidos | Anterior (4 Cadenas) | Pr\u00f3ximo (6 Cierre de la clase) 1.5 Listas En esta secci\u00f3n estudiaremos listas que es el tipo de datos primitivo de Python para guardar colecciones ordenadas de valores. Creaci\u00f3n de Listas Us\u00e1 corchetes para definir una lista: nombres = [ 'Rosita', 'Manuel', 'Luciana' ] nums = [ 39, 38, 42, 65, 111] A veces las listas son creadas con otros m\u00e9todos. Por ejemplo, los elementos de una cadena pueden ser separados en una lista usando el m\u00e9todo split() : >>> line = 'Pera,100,490.10' >>> row = line.split(',') #la coma indica el elemento que separa >>> row ['Pera', '100', '490.10'] >>> Operaciones con listas Las listas pueden almacenar elementos de cualquier tipo. Pod\u00e9s agregar nuevos elementos usando append() : nombres.append('Mauro') # Lo agrega al final Us\u00e1 el s\u00edmbolo de adici\u00f3n + para concatenar listas: s = [1, 2, 3] t = ['a', 'b'] s + t # [1, 2, 3, 'a', 'b'] Las listas se indexan con n\u00fameros enteros, comenzando en 0. nombres = [ 'Rosita', 'Manuel', 'Luciana' ] nombres[0] # 'Rosita' nombres[1] # 'Manuel' nombres[2] # 'Luciana' Los \u00edndices negativos cuentan desde el final. nombres[-1] # 'Luciana' Pod\u00e9s cambiar cualquier elemento de una lista. nombres[1] = 'Juan Manuel' nombres # [ 'Rosita', 'Juan Manuel', 'Luciana' ] Y pod\u00e9s insertar elementos en una posici\u00f3n. Acordate que los \u00edndices comienzan a contar desde el 0. nombres.insert(2, 'Iratxe') # Lo inserta en la posici\u00f3n 2. nombres.insert(0, 'Iratxe') # Lo inserta como primer elemento. La funci\u00f3n len permite obtener la longitud de una lista. nombres = ['Rosita','Manuel','Luciana'] len(nombres) # 3 Test de pertenencia a la lista ( in , not in ). 'Rosita' in nombres # True 'Diego' not in nombres # True Se puede replicar una lista ( s * n ). s = [1, 2, 3] s * 3 # [1, 2, 3, 1, 2, 3, 1, 2, 3] Iteradores de listas y b\u00fasqueda Us\u00e1 el comando for para iterar sobre los elementos de una lista. for nombre in nombres: # us\u00e1 nombre # e.g. print(nombre) ... Para encontrar r\u00e1pidamente la posici\u00f3n de un elemento en una lista, us\u00e1 index() . nombres = ['Rosita','Manuel','Luciana'] nombres.index('Luciana') # 2 Si el elemento est\u00e1 presente en m\u00e1s de una posici\u00f3n, index() te va a devolver el \u00edndice de la primera aparici\u00f3n. Si el elemento no est\u00e1 en la lista se va a generar una excepci\u00f3n de tipo ValueError . Borrar elementos Pod\u00e9s borrar elementos de una lista tanto usando el valor del elemento como su posici\u00f3n: # Usando el valor nombres.remove('Luciana') # Usando la posici\u00f3n del nombres[1] Al borrar un elemento no se genera un hueco. Los siguientes elementos se mover\u00e1n para llenar el vac\u00edo. Si hubiera m\u00e1s de una aparici\u00f3n de un valor, remove() s\u00f3lo sacar\u00e1 la primera aparici\u00f3n. Ordenar una lista Las listas pueden ser ordenadas \"in-place\", es decir, sin usar nuevas variables. s = [10, 1, 7, 3] s.sort() # [1, 3, 7, 10] # Orden inverso s = [10, 1, 7, 3] s.sort(reverse=True) # [10, 7, 3, 1] # Funciona con cualquier tipo de datos que tengan orden s = ['foo', 'bar', 'spam'] s.sort() # ['bar', 'foo', 'spam'] Us\u00e1 sorted() si quer\u00e9s generar una nueva lista ordenada en lugar de ordenar la misma: t = sorted(s) # s queda igual, t guarda los valores ordenados Listas y matem\u00e1tica Cuidado: Las listas no fueron dise\u00f1adas para realizar operaciones matem\u00e1ticas. >>> nums = [1, 2, 3, 4, 5] >>> nums * 2 [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] >>> nums + [10, 11, 12, 13, 14] [1, 2, 3, 4, 5, 10, 11, 12, 13, 14] Espec\u00edficamente, las listas no representan vectores ni matrices como en MATLAB, Octave, R, etc. Sin embargo, hay paquetes de Python que hacen muy bien ese trabajo (por ejemplo numpy ). Ejercicios En este ejercicio, vamos a experimentar con el tipo de dato lista de Python. En la \u00faltima secci\u00f3n, trabajaste con cadenas que hac\u00edan referencia a cajones de frutas. >>> frutas = 'Frambuesa,Manzana,Naranja,Mandarina,Banana,Sand\u00eda,Pera' Arm\u00e1 una lista con los nombres de frutas usando el comando split() : >>> lista_frutas = frutas.split(',') Ejercicio 1.22: Extracci\u00f3n y reasignaci\u00f3n de elementos. Prob\u00e1 un par de estos comandos para extraer un elemento: >>> lista_frutas[0] 'Frambuesa' >>> lista_frutas[1] 'Manzana' >>> lista_frutas[-1] 'Pera' >>> lista_frutas[-2] 'Sand\u00eda' >>> Intent\u00e1 reasignar un valor: >>> lista_frutas[2] = 'Granada' >>> lista_frutas ['Frambuesa', 'Manzana', 'Granada', 'Mandarina', 'Banana', 'Sand\u00eda', 'Pera'] >>> Hac\u00e9 unas rebanadas (slices) de la lista: >>> lista_frutas[0:3] ['Frambuesa', 'Manzana', 'Granada'] >>> lista_frutas[-2:] ['Sand\u00eda', 'Pera'] >>> Cre\u00e1 una lista vac\u00eda y agregale un elemento. >>> compra = [] >>> compra.append('Pera') >>> compra ['Pera'] Pod\u00e9s incluso reasignar una lista a una porci\u00f3n de otra lista. Por ejemplo: >>> lista_frutas[-2:] = compra >>> lista_frutas ['Frambuesa', 'Manzana', 'Granada', 'Mandarina', 'Banana', 'Pera'] >>> Cuando hac\u00e9s esto, la lista del lado izquierdo ( lista_frutas ) va a cambiar su tama\u00f1o para que encaje la lista del lado derecho ( compra ). En el ejemplo de arriba los \u00faltimos dos elementos de la lista_frutas fueron reemplazados por un solo elemento en la lista compra . Ejercicio 1.23: Ciclos sobre listas El ciclo for funciona iterando sobre datos en una secuencia. Antes vimos que pod\u00edamos iterar sobre los caracteres de una cadena (las cadenas son secuencias). Ahora veremos que podemos iterar sobre listas tambi\u00e9n. Verific\u00e1 esto tipeando lo que sigue y viendo qu\u00e9 pasa: >>> for s in lista_frutas: print('s =', s) Ejercicio 1.24: Test de pertenencia Us\u00e1 los operadores in o not in para verificar si 'Granada' , 'Lima' , y 'Limon' pertenecen a la lista de frutas. >>> # \u00bfEst\u00e1 'Granada' IN `lista_frutas`? True >>> # \u00bfEst\u00e1 'Lima' IN `lista_frutas`? False >>> # \u00bfEst\u00e1 'Limon' NOT IN `lista_frutas`? True >>> Ejercicio 1.25: Adjuntar, insertar y borrar elementos Us\u00e1 el m\u00e9todo append() para agregar 'Mango' al final de lista_frutas . >>> # agregar 'Mango' >>> lista_frutas ['Frambuesa', 'Manzana', 'Granada', 'Mandarina', 'Banana', 'Pera', 'Mango'] >>> Us\u00e1 el m\u00e9todo insert() para agregar 'Lima' como segundo elemento de la lista. >>> # Insertar 'Lima' como segundo elemento >>> lista_frutas ['Frambuesa', 'Lima', 'Manzana', 'Granada', 'Mandarina', 'Banana', 'Pera', 'Mango'] >>> Us\u00e1 el m\u00e9todo remove() para borrar 'Mandarina' de la lista. >>> # Borrar 'Mandarina' >>> lista_frutas ['Frambuesa', 'Lima', 'Manzana', 'Granada', 'Banana', 'Pera', 'Mango'] >>> Agreg\u00e1 una segunda copia de 'Banana' al final de la lista. Observaci\u00f3n: es perfectamente v\u00e1lido tener valores duplicados en una lista. >>> # Agregar 'Banana' >>> lista_frutas ['Frambuesa', 'Lima', 'Manzana', 'Granada', 'Banana', 'Pera', 'Mango', 'Banana'] >>> Us\u00e1 el m\u00e9todo index() para determinar la posici\u00f3n de la primera aparici\u00f3n de 'Banana' en la lista. >>> # Encontrar la primera aparici\u00f3n de 'Banana' >>> lista_frutas 4 >>> lista_frutas[4] 'Banana' >>> Cont\u00e1 la cantidad de apariciones de 'Banana' en la lista: >>> lista_frutas.count('Banana') 2 >>> Borr\u00e1 la primera aparici\u00f3n de 'Banana' . >>> # Borrar la primer aparici\u00f3n de 'Banana' >>> lista_frutas ['Frambuesa', 'Lima', 'Manzana', 'Granada', 'Pera', 'Mango', 'Banana'] >>> Para que sepas, no hay un m\u00e9todo que permita encontrar o borrar todas las apariciones de un elemento en un a lista. M\u00e1s adelante veremos una forma elegante de hacerlo. Ejercicio 1.26: Sorting \u00bfQuer\u00e9s ordenar una lista? Us\u00e1 el m\u00e9todo sort() . Probalo: >>> lista_frutas.sort() >>> lista_frutas ['Banana', 'Frambuesa', 'Granada', 'Lima', 'Mango', 'Manzana', 'Pera'] >>> \u00bfY si ordenamos al rev\u00e9s? >>> lista_frutas.sort(reverse=True) >>> lista_frutas ['Pera', 'Manzana', 'Mango', 'Lima', 'Granada', 'Frambuesa', 'Banana'] >>> Observaci\u00f3n: acordate de que el m\u00e9todo sort() modifica el contenido de la misma lista in-place . Los elementos son reordenados movi\u00e9ndolos de una posici\u00f3n a otra, pero no se crea una nueva lista. Ejercicio 1.27: Juntar m\u00faltiples cadenas Si quer\u00e9s juntar las cadenas en una lista, us\u00e1 el m\u00e9todo join() de los strings como sigue (ojo: parece un poco raro al principio). >>> lista_frutas = ['Banana', 'Mango', 'Frambuesa', 'Pera', 'Granada', 'Manzana', 'Lima'] >>> a = ','.join(lista_frutas) >>> a 'Banana,Mango,Frambuesa,Pera,Granada,Manzana,Lima' >>> b = ':'.join(lista_frutas) >>> b 'Banana:Mango:Frambuesa:Pera:Granada:Manzana:Lima' >>> c = ''.join(lista_frutas) >>> c 'BananaMangoFrambuesaPeraGranadaManzanaLima' >>> Ejercicio 1.28: Listas de cualquier cosa Las listas pueden contener cualquier tipo de objeto, incluyendo otras listas (ser\u00edan 'listas anidadas'). Prob\u00e1 esto: >>> nums = [101, 102, 103] >>> items = ['spam', lista_frutas, nums] >>> items ['spam', ['Banana', 'Mango', 'Frambuesa', 'Pera', 'Granada', 'Manzana', 'Lima'], [101, 102, 103]] Fijate bien el output. items es una lista con tres elementos. El primero es un string, pero los otros dos elementos son listas. Pod\u00e9s acceder a los elementos de las listas anidadas usando m\u00faltiples operaciones de acceso por \u00edndice. >>> items[0] 'spam' >>> items[0][0] 's' >>> items[1] ['Banana', 'Mango', 'Frambuesa', 'Pera', 'Granada', 'Manzana', 'Lima'] >>> items[1][1] 'Mango' >>> items[1][1][2] 'n' >>> items[2] [101, 102, 103] >>> items[2][1] 102 >>> A pesar de que es t\u00e9cnicamente posible hacer una estructura de listas muy complicada, como regla general, es mejor mantener las cosas simples. Lo m\u00e1s usual es guardar en las listas muchos elementos del mismo tipo. Por ejemplo, una lista s\u00f3lo de n\u00fameros o una lista de cadenas. Mezclar diferentes tipos de datos en una misma lista puede volverse conceptualmente difuso, as\u00ed que mejor lo evitamos. Ejercicio 1.29: Traductor (r\u00fastico) al lenguaje inclusivo Queremos hacer un traductor que cambie las palabras masculinas de una frase por su versi\u00f3n neutra. Como primera aproximaci\u00f3n, complet\u00e1 el siguiente c\u00f3digo para reemplazar todas las letras 'o' que figuren en el \u00faltimo o ante\u00faltimo caracter de cada palabra por una 'e'. Por ejemplo 'todos somos programadores' pasar\u00eda a ser 'todes somes programadores'. Guard\u00e1 tu c\u00f3digo en el archivo inclusive.py >>> frase = 'todos somos programadores' >>> palabras = frase.split() >>> for palabra in palabras: if ? ... frase_t = ? print(frase_t) 'todes somes programadores' >>> Prob\u00e1 tu c\u00f3digo con 'Los hermanos sean unidos porque \u00e9sa es la ley primera', '\u00bfc\u00f3mo transmitir a los otros el infinito Aleph?' y 'Todos, tu tambi\u00e9n'. \u00bfQu\u00e9 falla en esta \u00faltima? (\u00a1no hace falta que lo resuelvas!) Contenidos | Anterior (4 Cadenas) | Pr\u00f3ximo (6 Cierre de la clase)","title":"05 Listas"},{"location":"01_Introduccion/05_Listas/#15-listas","text":"En esta secci\u00f3n estudiaremos listas que es el tipo de datos primitivo de Python para guardar colecciones ordenadas de valores.","title":"1.5 Listas"},{"location":"01_Introduccion/05_Listas/#creacion-de-listas","text":"Us\u00e1 corchetes para definir una lista: nombres = [ 'Rosita', 'Manuel', 'Luciana' ] nums = [ 39, 38, 42, 65, 111] A veces las listas son creadas con otros m\u00e9todos. Por ejemplo, los elementos de una cadena pueden ser separados en una lista usando el m\u00e9todo split() : >>> line = 'Pera,100,490.10' >>> row = line.split(',') #la coma indica el elemento que separa >>> row ['Pera', '100', '490.10'] >>>","title":"Creaci\u00f3n de Listas"},{"location":"01_Introduccion/05_Listas/#operaciones-con-listas","text":"Las listas pueden almacenar elementos de cualquier tipo. Pod\u00e9s agregar nuevos elementos usando append() : nombres.append('Mauro') # Lo agrega al final Us\u00e1 el s\u00edmbolo de adici\u00f3n + para concatenar listas: s = [1, 2, 3] t = ['a', 'b'] s + t # [1, 2, 3, 'a', 'b'] Las listas se indexan con n\u00fameros enteros, comenzando en 0. nombres = [ 'Rosita', 'Manuel', 'Luciana' ] nombres[0] # 'Rosita' nombres[1] # 'Manuel' nombres[2] # 'Luciana' Los \u00edndices negativos cuentan desde el final. nombres[-1] # 'Luciana' Pod\u00e9s cambiar cualquier elemento de una lista. nombres[1] = 'Juan Manuel' nombres # [ 'Rosita', 'Juan Manuel', 'Luciana' ] Y pod\u00e9s insertar elementos en una posici\u00f3n. Acordate que los \u00edndices comienzan a contar desde el 0. nombres.insert(2, 'Iratxe') # Lo inserta en la posici\u00f3n 2. nombres.insert(0, 'Iratxe') # Lo inserta como primer elemento. La funci\u00f3n len permite obtener la longitud de una lista. nombres = ['Rosita','Manuel','Luciana'] len(nombres) # 3 Test de pertenencia a la lista ( in , not in ). 'Rosita' in nombres # True 'Diego' not in nombres # True Se puede replicar una lista ( s * n ). s = [1, 2, 3] s * 3 # [1, 2, 3, 1, 2, 3, 1, 2, 3]","title":"Operaciones con listas"},{"location":"01_Introduccion/05_Listas/#iteradores-de-listas-y-busqueda","text":"Us\u00e1 el comando for para iterar sobre los elementos de una lista. for nombre in nombres: # us\u00e1 nombre # e.g. print(nombre) ... Para encontrar r\u00e1pidamente la posici\u00f3n de un elemento en una lista, us\u00e1 index() . nombres = ['Rosita','Manuel','Luciana'] nombres.index('Luciana') # 2 Si el elemento est\u00e1 presente en m\u00e1s de una posici\u00f3n, index() te va a devolver el \u00edndice de la primera aparici\u00f3n. Si el elemento no est\u00e1 en la lista se va a generar una excepci\u00f3n de tipo ValueError .","title":"Iteradores de listas y b\u00fasqueda"},{"location":"01_Introduccion/05_Listas/#borrar-elementos","text":"Pod\u00e9s borrar elementos de una lista tanto usando el valor del elemento como su posici\u00f3n: # Usando el valor nombres.remove('Luciana') # Usando la posici\u00f3n del nombres[1] Al borrar un elemento no se genera un hueco. Los siguientes elementos se mover\u00e1n para llenar el vac\u00edo. Si hubiera m\u00e1s de una aparici\u00f3n de un valor, remove() s\u00f3lo sacar\u00e1 la primera aparici\u00f3n.","title":"Borrar elementos"},{"location":"01_Introduccion/05_Listas/#ordenar-una-lista","text":"Las listas pueden ser ordenadas \"in-place\", es decir, sin usar nuevas variables. s = [10, 1, 7, 3] s.sort() # [1, 3, 7, 10] # Orden inverso s = [10, 1, 7, 3] s.sort(reverse=True) # [10, 7, 3, 1] # Funciona con cualquier tipo de datos que tengan orden s = ['foo', 'bar', 'spam'] s.sort() # ['bar', 'foo', 'spam'] Us\u00e1 sorted() si quer\u00e9s generar una nueva lista ordenada en lugar de ordenar la misma: t = sorted(s) # s queda igual, t guarda los valores ordenados","title":"Ordenar una lista"},{"location":"01_Introduccion/05_Listas/#listas-y-matematica","text":"Cuidado: Las listas no fueron dise\u00f1adas para realizar operaciones matem\u00e1ticas. >>> nums = [1, 2, 3, 4, 5] >>> nums * 2 [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] >>> nums + [10, 11, 12, 13, 14] [1, 2, 3, 4, 5, 10, 11, 12, 13, 14] Espec\u00edficamente, las listas no representan vectores ni matrices como en MATLAB, Octave, R, etc. Sin embargo, hay paquetes de Python que hacen muy bien ese trabajo (por ejemplo numpy ).","title":"Listas y matem\u00e1tica"},{"location":"01_Introduccion/05_Listas/#ejercicios","text":"En este ejercicio, vamos a experimentar con el tipo de dato lista de Python. En la \u00faltima secci\u00f3n, trabajaste con cadenas que hac\u00edan referencia a cajones de frutas. >>> frutas = 'Frambuesa,Manzana,Naranja,Mandarina,Banana,Sand\u00eda,Pera' Arm\u00e1 una lista con los nombres de frutas usando el comando split() : >>> lista_frutas = frutas.split(',')","title":"Ejercicios"},{"location":"01_Introduccion/05_Listas/#ejercicio-122-extraccion-y-reasignacion-de-elementos","text":"Prob\u00e1 un par de estos comandos para extraer un elemento: >>> lista_frutas[0] 'Frambuesa' >>> lista_frutas[1] 'Manzana' >>> lista_frutas[-1] 'Pera' >>> lista_frutas[-2] 'Sand\u00eda' >>> Intent\u00e1 reasignar un valor: >>> lista_frutas[2] = 'Granada' >>> lista_frutas ['Frambuesa', 'Manzana', 'Granada', 'Mandarina', 'Banana', 'Sand\u00eda', 'Pera'] >>> Hac\u00e9 unas rebanadas (slices) de la lista: >>> lista_frutas[0:3] ['Frambuesa', 'Manzana', 'Granada'] >>> lista_frutas[-2:] ['Sand\u00eda', 'Pera'] >>> Cre\u00e1 una lista vac\u00eda y agregale un elemento. >>> compra = [] >>> compra.append('Pera') >>> compra ['Pera'] Pod\u00e9s incluso reasignar una lista a una porci\u00f3n de otra lista. Por ejemplo: >>> lista_frutas[-2:] = compra >>> lista_frutas ['Frambuesa', 'Manzana', 'Granada', 'Mandarina', 'Banana', 'Pera'] >>> Cuando hac\u00e9s esto, la lista del lado izquierdo ( lista_frutas ) va a cambiar su tama\u00f1o para que encaje la lista del lado derecho ( compra ). En el ejemplo de arriba los \u00faltimos dos elementos de la lista_frutas fueron reemplazados por un solo elemento en la lista compra .","title":"Ejercicio 1.22: Extracci\u00f3n y reasignaci\u00f3n de elementos."},{"location":"01_Introduccion/05_Listas/#ejercicio-123-ciclos-sobre-listas","text":"El ciclo for funciona iterando sobre datos en una secuencia. Antes vimos que pod\u00edamos iterar sobre los caracteres de una cadena (las cadenas son secuencias). Ahora veremos que podemos iterar sobre listas tambi\u00e9n. Verific\u00e1 esto tipeando lo que sigue y viendo qu\u00e9 pasa: >>> for s in lista_frutas: print('s =', s)","title":"Ejercicio 1.23: Ciclos sobre listas"},{"location":"01_Introduccion/05_Listas/#ejercicio-124-test-de-pertenencia","text":"Us\u00e1 los operadores in o not in para verificar si 'Granada' , 'Lima' , y 'Limon' pertenecen a la lista de frutas. >>> # \u00bfEst\u00e1 'Granada' IN `lista_frutas`? True >>> # \u00bfEst\u00e1 'Lima' IN `lista_frutas`? False >>> # \u00bfEst\u00e1 'Limon' NOT IN `lista_frutas`? True >>>","title":"Ejercicio 1.24: Test de pertenencia"},{"location":"01_Introduccion/05_Listas/#ejercicio-125-adjuntar-insertar-y-borrar-elementos","text":"Us\u00e1 el m\u00e9todo append() para agregar 'Mango' al final de lista_frutas . >>> # agregar 'Mango' >>> lista_frutas ['Frambuesa', 'Manzana', 'Granada', 'Mandarina', 'Banana', 'Pera', 'Mango'] >>> Us\u00e1 el m\u00e9todo insert() para agregar 'Lima' como segundo elemento de la lista. >>> # Insertar 'Lima' como segundo elemento >>> lista_frutas ['Frambuesa', 'Lima', 'Manzana', 'Granada', 'Mandarina', 'Banana', 'Pera', 'Mango'] >>> Us\u00e1 el m\u00e9todo remove() para borrar 'Mandarina' de la lista. >>> # Borrar 'Mandarina' >>> lista_frutas ['Frambuesa', 'Lima', 'Manzana', 'Granada', 'Banana', 'Pera', 'Mango'] >>> Agreg\u00e1 una segunda copia de 'Banana' al final de la lista. Observaci\u00f3n: es perfectamente v\u00e1lido tener valores duplicados en una lista. >>> # Agregar 'Banana' >>> lista_frutas ['Frambuesa', 'Lima', 'Manzana', 'Granada', 'Banana', 'Pera', 'Mango', 'Banana'] >>> Us\u00e1 el m\u00e9todo index() para determinar la posici\u00f3n de la primera aparici\u00f3n de 'Banana' en la lista. >>> # Encontrar la primera aparici\u00f3n de 'Banana' >>> lista_frutas 4 >>> lista_frutas[4] 'Banana' >>> Cont\u00e1 la cantidad de apariciones de 'Banana' en la lista: >>> lista_frutas.count('Banana') 2 >>> Borr\u00e1 la primera aparici\u00f3n de 'Banana' . >>> # Borrar la primer aparici\u00f3n de 'Banana' >>> lista_frutas ['Frambuesa', 'Lima', 'Manzana', 'Granada', 'Pera', 'Mango', 'Banana'] >>> Para que sepas, no hay un m\u00e9todo que permita encontrar o borrar todas las apariciones de un elemento en un a lista. M\u00e1s adelante veremos una forma elegante de hacerlo.","title":"Ejercicio 1.25: Adjuntar, insertar y borrar elementos"},{"location":"01_Introduccion/05_Listas/#ejercicio-126-sorting","text":"\u00bfQuer\u00e9s ordenar una lista? Us\u00e1 el m\u00e9todo sort() . Probalo: >>> lista_frutas.sort() >>> lista_frutas ['Banana', 'Frambuesa', 'Granada', 'Lima', 'Mango', 'Manzana', 'Pera'] >>> \u00bfY si ordenamos al rev\u00e9s? >>> lista_frutas.sort(reverse=True) >>> lista_frutas ['Pera', 'Manzana', 'Mango', 'Lima', 'Granada', 'Frambuesa', 'Banana'] >>> Observaci\u00f3n: acordate de que el m\u00e9todo sort() modifica el contenido de la misma lista in-place . Los elementos son reordenados movi\u00e9ndolos de una posici\u00f3n a otra, pero no se crea una nueva lista.","title":"Ejercicio 1.26: Sorting"},{"location":"01_Introduccion/05_Listas/#ejercicio-127-juntar-multiples-cadenas","text":"Si quer\u00e9s juntar las cadenas en una lista, us\u00e1 el m\u00e9todo join() de los strings como sigue (ojo: parece un poco raro al principio). >>> lista_frutas = ['Banana', 'Mango', 'Frambuesa', 'Pera', 'Granada', 'Manzana', 'Lima'] >>> a = ','.join(lista_frutas) >>> a 'Banana,Mango,Frambuesa,Pera,Granada,Manzana,Lima' >>> b = ':'.join(lista_frutas) >>> b 'Banana:Mango:Frambuesa:Pera:Granada:Manzana:Lima' >>> c = ''.join(lista_frutas) >>> c 'BananaMangoFrambuesaPeraGranadaManzanaLima' >>>","title":"Ejercicio 1.27: Juntar m\u00faltiples cadenas"},{"location":"01_Introduccion/05_Listas/#ejercicio-128-listas-de-cualquier-cosa","text":"Las listas pueden contener cualquier tipo de objeto, incluyendo otras listas (ser\u00edan 'listas anidadas'). Prob\u00e1 esto: >>> nums = [101, 102, 103] >>> items = ['spam', lista_frutas, nums] >>> items ['spam', ['Banana', 'Mango', 'Frambuesa', 'Pera', 'Granada', 'Manzana', 'Lima'], [101, 102, 103]] Fijate bien el output. items es una lista con tres elementos. El primero es un string, pero los otros dos elementos son listas. Pod\u00e9s acceder a los elementos de las listas anidadas usando m\u00faltiples operaciones de acceso por \u00edndice. >>> items[0] 'spam' >>> items[0][0] 's' >>> items[1] ['Banana', 'Mango', 'Frambuesa', 'Pera', 'Granada', 'Manzana', 'Lima'] >>> items[1][1] 'Mango' >>> items[1][1][2] 'n' >>> items[2] [101, 102, 103] >>> items[2][1] 102 >>> A pesar de que es t\u00e9cnicamente posible hacer una estructura de listas muy complicada, como regla general, es mejor mantener las cosas simples. Lo m\u00e1s usual es guardar en las listas muchos elementos del mismo tipo. Por ejemplo, una lista s\u00f3lo de n\u00fameros o una lista de cadenas. Mezclar diferentes tipos de datos en una misma lista puede volverse conceptualmente difuso, as\u00ed que mejor lo evitamos.","title":"Ejercicio 1.28: Listas de cualquier cosa"},{"location":"01_Introduccion/05_Listas/#ejercicio-129-traductor-rustico-al-lenguaje-inclusivo","text":"Queremos hacer un traductor que cambie las palabras masculinas de una frase por su versi\u00f3n neutra. Como primera aproximaci\u00f3n, complet\u00e1 el siguiente c\u00f3digo para reemplazar todas las letras 'o' que figuren en el \u00faltimo o ante\u00faltimo caracter de cada palabra por una 'e'. Por ejemplo 'todos somos programadores' pasar\u00eda a ser 'todes somes programadores'. Guard\u00e1 tu c\u00f3digo en el archivo inclusive.py >>> frase = 'todos somos programadores' >>> palabras = frase.split() >>> for palabra in palabras: if ? ... frase_t = ? print(frase_t) 'todes somes programadores' >>> Prob\u00e1 tu c\u00f3digo con 'Los hermanos sean unidos porque \u00e9sa es la ley primera', '\u00bfc\u00f3mo transmitir a los otros el infinito Aleph?' y 'Todos, tu tambi\u00e9n'. \u00bfQu\u00e9 falla en esta \u00faltima? (\u00a1no hace falta que lo resuelvas!) Contenidos | Anterior (4 Cadenas) | Pr\u00f3ximo (6 Cierre de la clase)","title":"Ejercicio 1.29: Traductor (r\u00fastico) al lenguaje inclusivo"},{"location":"01_Introduccion/06_CierreClase/","text":"Contenidos | Anterior (5 Listas) 1.6 Cierre de la clase En esta clase aprendimos a correr el int\u00e9rprete de Python desde la l\u00ednea de comandos para usarlo como una calculadora. Aprendimos a editar programas con un editor de texto y a correrlos en la terminal. Vimos diferentes tipos de datos: n\u00fameros enteros, n\u00fameros de punto flotante, cadenas y listas. Al enviar tus archivos entendemos que le\u00edste y est\u00e1s de acuerdo con el c\u00f3digo de honor del curso en el que hablamos de las reglas que rigen en este curso para evitar el plagio as\u00ed como otros aspectos importantes sobre qu\u00e9 se puede compartir y qu\u00e9 no. En caso contrario no env\u00edes tus archivos y contactate con les docentes. Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: 1. Ejercicio 1.5 Pelota ( rebotes.py ) 2. Ejercicio 1.11 Bonus de Hipoteca ( hipoteca.py ) 3. Ejercicio 1.13 Volumen de la esfera ( esfera.py ) 4. Ejercicio 1.18 Geringoso ( geringoso.py ) * Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y te vamos a preguntar si quer\u00e9s participar de la revisi\u00f3n de ejercicios por pares (peer-review). En ese caso te vamos a mandar para que corrijas un par de ejercicios y vas a a recibir un par de correcciones. Por favor, us\u00e1 siempre la misma direcci\u00f3n de mail con la que te inscribiste al curso as\u00ed podemos llevar registro de tus entregas. Observaci\u00f3n: Si el enunciado de un ejercicio te pide que lo corras con un input particular, por favor pon\u00e9 la salida que obtuviste como comentario en tu c\u00f3digo. Por \u00faltimo te recordamos que es fundamental para mantenerte al tanto de las novedades del curso as\u00ed como para hacer consultas a los docentes que te sumes al grupo de Slack de la materia. Contenidos | Anterior (5 Listas)","title":"06 CierreClase"},{"location":"01_Introduccion/06_CierreClase/#16-cierre-de-la-clase","text":"En esta clase aprendimos a correr el int\u00e9rprete de Python desde la l\u00ednea de comandos para usarlo como una calculadora. Aprendimos a editar programas con un editor de texto y a correrlos en la terminal. Vimos diferentes tipos de datos: n\u00fameros enteros, n\u00fameros de punto flotante, cadenas y listas. Al enviar tus archivos entendemos que le\u00edste y est\u00e1s de acuerdo con el c\u00f3digo de honor del curso en el que hablamos de las reglas que rigen en este curso para evitar el plagio as\u00ed como otros aspectos importantes sobre qu\u00e9 se puede compartir y qu\u00e9 no. En caso contrario no env\u00edes tus archivos y contactate con les docentes. Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: 1. Ejercicio 1.5 Pelota ( rebotes.py ) 2. Ejercicio 1.11 Bonus de Hipoteca ( hipoteca.py ) 3. Ejercicio 1.13 Volumen de la esfera ( esfera.py ) 4. Ejercicio 1.18 Geringoso ( geringoso.py ) * Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y te vamos a preguntar si quer\u00e9s participar de la revisi\u00f3n de ejercicios por pares (peer-review). En ese caso te vamos a mandar para que corrijas un par de ejercicios y vas a a recibir un par de correcciones. Por favor, us\u00e1 siempre la misma direcci\u00f3n de mail con la que te inscribiste al curso as\u00ed podemos llevar registro de tus entregas. Observaci\u00f3n: Si el enunciado de un ejercicio te pide que lo corras con un input particular, por favor pon\u00e9 la salida que obtuviste como comentario en tu c\u00f3digo. Por \u00faltimo te recordamos que es fundamental para mantenerte al tanto de las novedades del curso as\u00ed como para hacer consultas a los docentes que te sumes al grupo de Slack de la materia. Contenidos | Anterior (5 Listas)","title":"1.6 Cierre de la clase"},{"location":"02_Estructuras_y_Funciones/00_Resumen/","text":"Contenidos | Anterior (1 Introducci\u00f3n a Python) | Pr\u00f3ximo (3 Trabajando con datos) 2. Estructuras y funciones Para escribir programas \u00fatiles, necesitamos aprender a trabajar con datos. En esta clase introducimos las estructuras de datos elementales de Python que nos faltan: tuplas, conjuntos y diccionarios y profundizamos un poco m\u00e1s en las listas y sus usos. Tambi\u00e9n comenzamos a ver c\u00f3mo estructurar el c\u00f3digo usando funciones y a leer archivos. Record\u00e1 que, aunque no termines todos, completar el formulario del final de cada clase y entregar los ejercicios es parte de las condiciones de aprobaci\u00f3n de la materia (todes nos podemos atrasar alguna vez, pero en general esperamos que entregues). Esto debe hacerse ANTES de las 14hs del pr\u00f3ximo mi\u00e9rcoles. 2.1 Manejo de archivos 2.2 Funciones 2.3 Tipos y estructuras de datos 2.4 Contenedores 2.5 Cierre de la clase Contenidos | Anterior (1 Introducci\u00f3n a Python) | Pr\u00f3ximo (3 Trabajando con datos)","title":"00 Resumen"},{"location":"02_Estructuras_y_Funciones/00_Resumen/#2-estructuras-y-funciones","text":"Para escribir programas \u00fatiles, necesitamos aprender a trabajar con datos. En esta clase introducimos las estructuras de datos elementales de Python que nos faltan: tuplas, conjuntos y diccionarios y profundizamos un poco m\u00e1s en las listas y sus usos. Tambi\u00e9n comenzamos a ver c\u00f3mo estructurar el c\u00f3digo usando funciones y a leer archivos. Record\u00e1 que, aunque no termines todos, completar el formulario del final de cada clase y entregar los ejercicios es parte de las condiciones de aprobaci\u00f3n de la materia (todes nos podemos atrasar alguna vez, pero en general esperamos que entregues). Esto debe hacerse ANTES de las 14hs del pr\u00f3ximo mi\u00e9rcoles. 2.1 Manejo de archivos 2.2 Funciones 2.3 Tipos y estructuras de datos 2.4 Contenedores 2.5 Cierre de la clase Contenidos | Anterior (1 Introducci\u00f3n a Python) | Pr\u00f3ximo (3 Trabajando con datos)","title":"2. Estructuras y funciones"},{"location":"02_Estructuras_y_Funciones/01_Archivos/","text":"Contenidos | Pr\u00f3ximo (2 Funciones) 2.1 Manejo de archivos La mayor\u00eda de los programas usa alguna fuente de datos. En esta secci\u00f3n discutimos el acceso a archivos. Archivos de entrada y salida Con estos comandos pod\u00e9s abrir dos archivos, una para lectura y otro para escritura: f = open('foo.txt', 'rt') # Abrir para lectura ('r' de read, 't' de text) g = open('bar.txt', 'wt') # Abrir para escritura ('w' de write, 't' de text) Observaci\u00f3n: los nombres foo, bar, foobar son gen\u00e9ricos que se usan usualmente para aludir a un nombre que se ignora, son los an\u00e1logos inform\u00e1ticos a fulano, mengano y zutano. Para leer el archivo completo, o una parte: data = f.read() # Leer 'maxbytes' bytes data = f.read([maxbytes]) Para escribir un texto en el archivo: g.write('un texto') Finalmente, hay que cerrar los archivos cuando terminamos de usarlos. f.close() g.close() Es importante cerrar adecuadamente los archivos y es bastante f\u00e1cil olvidarse (puede que el programa termine y no se termine de guardar bien). Por eso, preferimos abrir los archivos con el comando with de la siguiente forma. with open(nombre_archivo, 'rt') as file: # Us\u00e1 el archivo `file` ...comandos que usan el archivo # No hace falta cerrarlo expl\u00edcitamente ...comandos que no usan el archivo Esto cierra autom\u00e1ticamente el archivo cuando se termina de ejecutar el bloque indentado. Observaci\u00f3n: En algunos sistemas operativos es probable que le tengas que especificar el encoding agregando encoding='utf8' como par\u00e1metro al comando open . Comandos usuales para leer un archivo Para leer un archivo entero, todo de una, como cadena: with open('foo.txt', 'rt') as file: data = file.read() # `data` es una cadena con *todo* el texto en `foo.txt` Para leer l\u00ednea por l\u00ednea iterativamente: with open(nombre_archivo, 'rt') as file: for line in file: # Procesar la l\u00ednea Comandos usuales para escribir un archivo Para escribir cadenas: with open('outfile', 'wt') as out: out.write('Hello World\\n') ... Tambi\u00e9n pod\u00e9s simplemente redireccionar la salida del print (de la pantalla a un archivo). with open('outfile', 'wt') as out: print('Hello World', file=out) ... Ejercicios Estos ejercicios usan el archivo Data/camion.csv . El archivo contiene una lista de l\u00edneas con informaci\u00f3n sobre los cajones de fruta cargados en un cami\u00f3n. Suponemos que est\u00e1s trabajando en el directorio ejercicios_python/ del curso. Si no est\u00e1s segure, pod\u00e9s pedirle al Python que te diga d\u00f3nde est\u00e1 trabajando con este comando: >>> import os >>> os.getcwd() '/Users/profe/Desktop/ejercicios_python/Clase02/' # La salida va a cambiar >>> Ejercicio 2.1: Preliminares sobre lectura de archivos Primero, trat\u00e1 de leer el archivo entero de una en una larga cadena: >>> with open('../Data/camion.csv', 'rt') as f: data = f.read() >>> data 'nombre,cajones,precio\\n\"Lima\",100,32.20\\n\"Naranja\",50,91.10\\n\"Caqui\",150,83.44\\n\"Mandarina\",200,51.23\\n\"Durazno\",95,40.37\\n\"Mandarina\",50,65.10\\n\"Naranja\",100,70.44\\n' >>> print(data) nombre,cajones,precio \"Lima\",100,32.20 \"Naranja\",50,91.10 \"Caqui\",150,83.44 \"Mandarina\",200,51.23 \"Durazno\",95,40.37 \"Mandarina\",50,65.10 \"Naranja\",100,70.44 >>> En el ejemplo de arriba podr\u00e1s observar que Python tiene dos modos de salida. En el primero escribiste data en el int\u00e9rprete y Python mostr\u00f3 la representaci\u00f3n cruda de la cadena, incluyendo comillas y c\u00f3digos de escape. Cuando escribiste print(data) , en cambio, obtuviste la salida formateada de la cadena. Leer un archivo entero y cargarlo en memoria todo de una vez parece simple, pero s\u00f3lo tiene ventajas si el archivo es peque\u00f1o. Si est\u00e1s trabajando con archivos enormes es mejor procesar las l\u00edneas de tu archivo una a una. Para leer una archivo l\u00ednea por l\u00ednea, us\u00e1 un ciclo for como \u00e9ste: >>> with open('../Data/camion.csv', 'rt') as f: for line in f: print(line, end = '') nombre,cajones,precio \"Lima\",100,32.2 \"Naranja\",50,91.1 ... >>> En ese c\u00f3digo, las l\u00edneas son le\u00eddas una por una hasta el final del archivo, cuando el ciclo se termina. En ciertas ocasiones, puede pasar que quieras leer una sola l\u00ednea de texto (por ejemplo, quer\u00e9s saltearte la primera l\u00ednea del archivo que contiene los nombres de las columnas). >>> f = open('../Data/camion.csv', 'rt') >>> headers = next(f) >>> headers 'nombre,cajones,precio\\n' >>> for line in f: print(line, end = '') \"Lima\",100,32.20 \"Naranja\",50,91.10 ... >>> f.close() >>> El comando next() devuelve la siguiente l\u00ednea de texto en el archivo. Sin embargo, s\u00f3lo para que sepas, los ciclos for usan el m\u00e9todo next() para obtener sus datos. Por lo tanto, t\u00edpicamente no forz\u00e1s un llamado extra a next() salvo que expl\u00edcitamente quieras saltear o leer una l\u00ednea particular como en nuestro caso de ac\u00e1 abajo. Una vez que est\u00e9s leyendo un archivo l\u00ednea a l\u00ednea, pod\u00e9s hacer otras operaciones, como separar los datos dentro de una l\u00ednea con el m\u00e9todo split() . Por ejemplo, prob\u00e1 esto: >>> f = open('../Data/camion.csv', 'rt') >>> headers = next(f).split(',') >>> headers ['nombre', 'cajones', 'precio\\n'] >>> for line in f: row = line.split(',') print(row) ['\"Lima\"', '100', '32.20\\n'] ['\"Naranja\"', '50', '91.10\\n'] ... >>> f.close() Observaci\u00f3n: En estos ejemplos tuvimos que llamar a f.close() expl\u00edcitamente porque no estamos trabajando con el comando with . Ejercicio 2.2: Lectura de un archivo de datos Ahora que sab\u00e9s leer un archivo, escribamos un programa que haga un c\u00e1lculo simple con los datos le\u00eddos. Las columnas en camion.csv corresponden a un nombre de fruta, una cantidad de cajones cargados en el cami\u00f3n, y un precio de compra por cada caj\u00f3n de ese grupo. Escrib\u00ed un programa llamado costo_camion.py que abra el archivo, lea las l\u00edneas, y calcule el precio pagado por los cajones cargados en el cami\u00f3n. Ayuda: para interpretar un string s como un n\u00famero entero, us\u00e1 int(s) . Para leerlo como punto flotante, us\u00e1 float(s) . Tu programa deber\u00eda imprimir una salida como la siguiente: Costo total 47671.15 Acordate de guardar tu archivo en el directorio Clase02 ; vamos a volver a trabajar sobre \u00e9l. Ejercicio 2.3: Precio de la naranja El archivo Data/precios.csv contiene una serie de l\u00edneas con precios de venta de cajones en el mercado al que va el cami\u00f3n. El archivo se ve as\u00ed: \"Lima\",40.22 \"Uva\",24.85 \"Ciruela\",44.85 \"Cereza\",11.27 \"Frutilla\",53.72 ... Escrib\u00ed un c\u00f3digo que abra el archivo Data/precios.csv , busque el precio de la naranja y lo imprima en pantalla. >>> f = open('../Data/precios.csv', 'rt') ... >>> f.close() El precio de la naranja es: 106.28 Ejercicio 2.4: Archivos comprimidos \u00bfQue pasar\u00eda si quisi\u00e9ramos leer un archivo comprimido con gzip, por ejemplo? La funci\u00f3n primitiva de Python open() no hace esa tarea. Pero hay un m\u00f3dulo de la biblioteca de Python llamado gzip que lee archivos comprimidos. Probalo: >>> import gzip >>> with gzip.open('../Data/camion.csv.gz', 'rt') as f: for line in f: print(line, end = '') ... mir\u00e1 la salida ... >>> Observaci\u00f3n: La inclusi\u00f3n del modo 'rt' es cr\u00edtica ac\u00e1. Si te lo olvid\u00e1s, vas a estar leyendo cadenas de bytes en lugar de cadenas de caracteres. Comentario: \u00bfNo deber\u00edamos estar usando Pandas para esto? Es frecuente que les estudiantes que conocen un poco m\u00e1s de Python r\u00e1pidamente se\u00f1alen que hay m\u00f3dulos como Pandas que tienen, entre muchas otras funcionalidades, la posibilidad de leer archivos CSV en una sola instrucci\u00f3n. Es verdad, y funcionan muy bien. Sin embargo, este no es un curso sobre Pandas. Si bien m\u00e1s adelante veremos algo de esta biblioteca, lo que nos interesa en este momento es aprender a manejar archivos directamente. Estamos trabajando con archivos CSV porque es un formato sencillo que es muy \u00fatil conocer, pero es principalmente una excusa para mostrar c\u00f3mo Python maneja archivos de texto. En resumen, cuando tengas que trabajar con datos, definitivamente us\u00e1 Pandas. Pero para aprender a manejar archivos vamos a seguir usando las funciones b\u00e1sicas de Python. Contenidos | Pr\u00f3ximo (2 Funciones)","title":"01 Archivos"},{"location":"02_Estructuras_y_Funciones/01_Archivos/#21-manejo-de-archivos","text":"La mayor\u00eda de los programas usa alguna fuente de datos. En esta secci\u00f3n discutimos el acceso a archivos.","title":"2.1 Manejo de archivos"},{"location":"02_Estructuras_y_Funciones/01_Archivos/#archivos-de-entrada-y-salida","text":"Con estos comandos pod\u00e9s abrir dos archivos, una para lectura y otro para escritura: f = open('foo.txt', 'rt') # Abrir para lectura ('r' de read, 't' de text) g = open('bar.txt', 'wt') # Abrir para escritura ('w' de write, 't' de text) Observaci\u00f3n: los nombres foo, bar, foobar son gen\u00e9ricos que se usan usualmente para aludir a un nombre que se ignora, son los an\u00e1logos inform\u00e1ticos a fulano, mengano y zutano. Para leer el archivo completo, o una parte: data = f.read() # Leer 'maxbytes' bytes data = f.read([maxbytes]) Para escribir un texto en el archivo: g.write('un texto') Finalmente, hay que cerrar los archivos cuando terminamos de usarlos. f.close() g.close() Es importante cerrar adecuadamente los archivos y es bastante f\u00e1cil olvidarse (puede que el programa termine y no se termine de guardar bien). Por eso, preferimos abrir los archivos con el comando with de la siguiente forma. with open(nombre_archivo, 'rt') as file: # Us\u00e1 el archivo `file` ...comandos que usan el archivo # No hace falta cerrarlo expl\u00edcitamente ...comandos que no usan el archivo Esto cierra autom\u00e1ticamente el archivo cuando se termina de ejecutar el bloque indentado. Observaci\u00f3n: En algunos sistemas operativos es probable que le tengas que especificar el encoding agregando encoding='utf8' como par\u00e1metro al comando open .","title":"Archivos de entrada y salida"},{"location":"02_Estructuras_y_Funciones/01_Archivos/#comandos-usuales-para-leer-un-archivo","text":"Para leer un archivo entero, todo de una, como cadena: with open('foo.txt', 'rt') as file: data = file.read() # `data` es una cadena con *todo* el texto en `foo.txt` Para leer l\u00ednea por l\u00ednea iterativamente: with open(nombre_archivo, 'rt') as file: for line in file: # Procesar la l\u00ednea","title":"Comandos usuales para leer un archivo"},{"location":"02_Estructuras_y_Funciones/01_Archivos/#comandos-usuales-para-escribir-un-archivo","text":"Para escribir cadenas: with open('outfile', 'wt') as out: out.write('Hello World\\n') ... Tambi\u00e9n pod\u00e9s simplemente redireccionar la salida del print (de la pantalla a un archivo). with open('outfile', 'wt') as out: print('Hello World', file=out) ...","title":"Comandos usuales para escribir un archivo"},{"location":"02_Estructuras_y_Funciones/01_Archivos/#ejercicios","text":"Estos ejercicios usan el archivo Data/camion.csv . El archivo contiene una lista de l\u00edneas con informaci\u00f3n sobre los cajones de fruta cargados en un cami\u00f3n. Suponemos que est\u00e1s trabajando en el directorio ejercicios_python/ del curso. Si no est\u00e1s segure, pod\u00e9s pedirle al Python que te diga d\u00f3nde est\u00e1 trabajando con este comando: >>> import os >>> os.getcwd() '/Users/profe/Desktop/ejercicios_python/Clase02/' # La salida va a cambiar >>>","title":"Ejercicios"},{"location":"02_Estructuras_y_Funciones/01_Archivos/#ejercicio-21-preliminares-sobre-lectura-de-archivos","text":"Primero, trat\u00e1 de leer el archivo entero de una en una larga cadena: >>> with open('../Data/camion.csv', 'rt') as f: data = f.read() >>> data 'nombre,cajones,precio\\n\"Lima\",100,32.20\\n\"Naranja\",50,91.10\\n\"Caqui\",150,83.44\\n\"Mandarina\",200,51.23\\n\"Durazno\",95,40.37\\n\"Mandarina\",50,65.10\\n\"Naranja\",100,70.44\\n' >>> print(data) nombre,cajones,precio \"Lima\",100,32.20 \"Naranja\",50,91.10 \"Caqui\",150,83.44 \"Mandarina\",200,51.23 \"Durazno\",95,40.37 \"Mandarina\",50,65.10 \"Naranja\",100,70.44 >>> En el ejemplo de arriba podr\u00e1s observar que Python tiene dos modos de salida. En el primero escribiste data en el int\u00e9rprete y Python mostr\u00f3 la representaci\u00f3n cruda de la cadena, incluyendo comillas y c\u00f3digos de escape. Cuando escribiste print(data) , en cambio, obtuviste la salida formateada de la cadena. Leer un archivo entero y cargarlo en memoria todo de una vez parece simple, pero s\u00f3lo tiene ventajas si el archivo es peque\u00f1o. Si est\u00e1s trabajando con archivos enormes es mejor procesar las l\u00edneas de tu archivo una a una. Para leer una archivo l\u00ednea por l\u00ednea, us\u00e1 un ciclo for como \u00e9ste: >>> with open('../Data/camion.csv', 'rt') as f: for line in f: print(line, end = '') nombre,cajones,precio \"Lima\",100,32.2 \"Naranja\",50,91.1 ... >>> En ese c\u00f3digo, las l\u00edneas son le\u00eddas una por una hasta el final del archivo, cuando el ciclo se termina. En ciertas ocasiones, puede pasar que quieras leer una sola l\u00ednea de texto (por ejemplo, quer\u00e9s saltearte la primera l\u00ednea del archivo que contiene los nombres de las columnas). >>> f = open('../Data/camion.csv', 'rt') >>> headers = next(f) >>> headers 'nombre,cajones,precio\\n' >>> for line in f: print(line, end = '') \"Lima\",100,32.20 \"Naranja\",50,91.10 ... >>> f.close() >>> El comando next() devuelve la siguiente l\u00ednea de texto en el archivo. Sin embargo, s\u00f3lo para que sepas, los ciclos for usan el m\u00e9todo next() para obtener sus datos. Por lo tanto, t\u00edpicamente no forz\u00e1s un llamado extra a next() salvo que expl\u00edcitamente quieras saltear o leer una l\u00ednea particular como en nuestro caso de ac\u00e1 abajo. Una vez que est\u00e9s leyendo un archivo l\u00ednea a l\u00ednea, pod\u00e9s hacer otras operaciones, como separar los datos dentro de una l\u00ednea con el m\u00e9todo split() . Por ejemplo, prob\u00e1 esto: >>> f = open('../Data/camion.csv', 'rt') >>> headers = next(f).split(',') >>> headers ['nombre', 'cajones', 'precio\\n'] >>> for line in f: row = line.split(',') print(row) ['\"Lima\"', '100', '32.20\\n'] ['\"Naranja\"', '50', '91.10\\n'] ... >>> f.close() Observaci\u00f3n: En estos ejemplos tuvimos que llamar a f.close() expl\u00edcitamente porque no estamos trabajando con el comando with .","title":"Ejercicio 2.1: Preliminares sobre lectura de archivos"},{"location":"02_Estructuras_y_Funciones/01_Archivos/#ejercicio-22-lectura-de-un-archivo-de-datos","text":"Ahora que sab\u00e9s leer un archivo, escribamos un programa que haga un c\u00e1lculo simple con los datos le\u00eddos. Las columnas en camion.csv corresponden a un nombre de fruta, una cantidad de cajones cargados en el cami\u00f3n, y un precio de compra por cada caj\u00f3n de ese grupo. Escrib\u00ed un programa llamado costo_camion.py que abra el archivo, lea las l\u00edneas, y calcule el precio pagado por los cajones cargados en el cami\u00f3n. Ayuda: para interpretar un string s como un n\u00famero entero, us\u00e1 int(s) . Para leerlo como punto flotante, us\u00e1 float(s) . Tu programa deber\u00eda imprimir una salida como la siguiente: Costo total 47671.15 Acordate de guardar tu archivo en el directorio Clase02 ; vamos a volver a trabajar sobre \u00e9l.","title":"Ejercicio 2.2: Lectura de un archivo de datos"},{"location":"02_Estructuras_y_Funciones/01_Archivos/#ejercicio-23-precio-de-la-naranja","text":"El archivo Data/precios.csv contiene una serie de l\u00edneas con precios de venta de cajones en el mercado al que va el cami\u00f3n. El archivo se ve as\u00ed: \"Lima\",40.22 \"Uva\",24.85 \"Ciruela\",44.85 \"Cereza\",11.27 \"Frutilla\",53.72 ... Escrib\u00ed un c\u00f3digo que abra el archivo Data/precios.csv , busque el precio de la naranja y lo imprima en pantalla. >>> f = open('../Data/precios.csv', 'rt') ... >>> f.close() El precio de la naranja es: 106.28","title":"Ejercicio 2.3: Precio de la naranja"},{"location":"02_Estructuras_y_Funciones/01_Archivos/#ejercicio-24-archivos-comprimidos","text":"\u00bfQue pasar\u00eda si quisi\u00e9ramos leer un archivo comprimido con gzip, por ejemplo? La funci\u00f3n primitiva de Python open() no hace esa tarea. Pero hay un m\u00f3dulo de la biblioteca de Python llamado gzip que lee archivos comprimidos. Probalo: >>> import gzip >>> with gzip.open('../Data/camion.csv.gz', 'rt') as f: for line in f: print(line, end = '') ... mir\u00e1 la salida ... >>> Observaci\u00f3n: La inclusi\u00f3n del modo 'rt' es cr\u00edtica ac\u00e1. Si te lo olvid\u00e1s, vas a estar leyendo cadenas de bytes en lugar de cadenas de caracteres.","title":"Ejercicio 2.4: Archivos comprimidos"},{"location":"02_Estructuras_y_Funciones/01_Archivos/#comentario-no-deberiamos-estar-usando-pandas-para-esto","text":"Es frecuente que les estudiantes que conocen un poco m\u00e1s de Python r\u00e1pidamente se\u00f1alen que hay m\u00f3dulos como Pandas que tienen, entre muchas otras funcionalidades, la posibilidad de leer archivos CSV en una sola instrucci\u00f3n. Es verdad, y funcionan muy bien. Sin embargo, este no es un curso sobre Pandas. Si bien m\u00e1s adelante veremos algo de esta biblioteca, lo que nos interesa en este momento es aprender a manejar archivos directamente. Estamos trabajando con archivos CSV porque es un formato sencillo que es muy \u00fatil conocer, pero es principalmente una excusa para mostrar c\u00f3mo Python maneja archivos de texto. En resumen, cuando tengas que trabajar con datos, definitivamente us\u00e1 Pandas. Pero para aprender a manejar archivos vamos a seguir usando las funciones b\u00e1sicas de Python. Contenidos | Pr\u00f3ximo (2 Funciones)","title":"Comentario: \u00bfNo deber\u00edamos estar usando Pandas para esto?"},{"location":"02_Estructuras_y_Funciones/02_Funciones/","text":"Contenidos | Anterior (1 Manejo de archivos) | Pr\u00f3ximo (3 Tipos y estructuras de datos) 2.2 Funciones A medida que tus programas se vuelven m\u00e1s largos y complejos, vas a necesitar organizarte. En esta secci\u00f3n vamos a introducir brevemente funciones y m\u00f3dulos de la biblioteca as\u00ed como tambi\u00e9n la administraci\u00f3n de errores y excepciones. Funciones a medida Us\u00e1 funciones para encapsular c\u00f3digo que quieras reutilizar. El siguiente ejemplo muestra una definici\u00f3n de una funci\u00f3n: def sumcount(n): ''' Devuelve la suma de los primeros n enteros ''' total = 0 while n > 0: total += n n -= 1 return total Para llamar a una funci\u00f3n: a = sumcount(100) Una funci\u00f3n es una serie de instrucciones que realiza una tarea y devuelve un resultado. La palabra return es necesaria para explicitar el valor de retorno de la funci\u00f3n. Funciones de la biblioteca Python trae una gran biblioteca est\u00e1ndar. Los m\u00f3dulos de esta biblioteca se cargan usando import . Por ejemplo: import math x = math.sqrt(10) import urllib.request u = urllib.request.urlopen('http://www.python.org/') data = u.read() Vamos a estudiar bibliotecas y m\u00f3dulos en detalle m\u00e1s adelante. Errores y excepciones Las funciones informan los errores como excepciones. Dado que una excepci\u00f3n interrumpe la ejecuci\u00f3n de una funci\u00f3n, la misma puede generar que todo el programa se detenga si no es administrada adecuadamente. Prob\u00e1 por ejemplo lo siguiente en tu int\u00e9rprete: >>> int('N/A') Traceback (most recent call last): File \"<stdin>\", line 1, in <m\u00f3dulo> ValueError: invalid literal for int() with base 10: 'N/A' >>> Para poder entender qu\u00e9 pas\u00f3 (debuguear), el mensaje describe cu\u00e1l fue el problema, d\u00f3nde ocurri\u00f3 y un poco de la historia (traceback) de los llamados que terminaron en este error. Atrapar y administrar excepciones Las excepciones pueden ser atrapadas y administradas. Para atrapar una excepci\u00f3n, se usan los comandos try - except . Pod\u00e9s probar el siguiente fragmento de c\u00f3digo peg\u00e1ndolo en un archivo foo.py : numero_valido=False while not numero_valido: try: a = input('Ingres\u00e1 un n\u00famero entero: ') n = int(a) numero_valido = True except ValueError: print('No es v\u00e1lido. Intent\u00e1 de nuevo.') print(f'Ingresaste {n}.') Si en este ejemplo el usuario ingresa por ejemplo una letra, el comando n = int(a) genera una excepci\u00f3n de tipo ValueError : el comando numero_valido = True no se ejecuta, la excepci\u00f3n es atrapada por el except ValueError y el ciclo se repite. Probalo ingresando letras, n\u00fameros con decimales y n\u00fameros enteros. Prob\u00e1 tambi\u00e9n qu\u00e9 ocurre si quer\u00e9s salir sin ingresar nada generando una excepci\u00f3n presionando las teclas Ctrl+C . Le\u00e9 el mensaje que describe lo ocurrido: Ctrl+C genera una excepci\u00f3n de tipo KeyboardInterrupt que no es atrapada. Si no especificamos el tipo de excepci\u00f3n que queremos atrapar, vamos a terminar atrapando todas la excepciones. Prob\u00e1 lo mismo que antes pero con este c\u00f3digo. numero_valido=False while not numero_valido: try: a = input('Ingres\u00e1 un n\u00famero entero: ') n = int(a) numero_valido = True except: print('No es v\u00e1lido. Intent\u00e1 de nuevo.') print(f'Ingresaste {n}.') Deber\u00edas observar una diferencia: al presionar las teclas Ctrl+C la excepci\u00f3n KeyboardInterrupt s\u00ed es atrapada y no se termina el ciclo hasta no ingresar un n\u00famero entero. Suele ser dif\u00edcil saber exactamente qu\u00e9 tipo de errores pueden ocurrir por adelantado. Para bien o para mal, la administraci\u00f3n de excepciones suele ir creciendo a medida que un programa va generando errores inesperados (al mejor estilo: \"Uh! Me olvid\u00e9 de que pod\u00eda pasar esto. Deber\u00edamos preverlo y administrarlo adecuadamente para la pr\u00f3xima\"). Generar excepciones Para generar una excepci\u00f3n (tambi\u00e9n diremos levantar una excepci\u00f3n, porque m\u00e1s cercano al t\u00e9rmino ingl\u00e9s \"raise\"), se usa el comando raise . Por ejemplo, si tenemos el siguiente c\u00f3digo en el archivo foo.py : raise RuntimeError('\u00a1Qu\u00e9 moco!') Al correrlo va a detener la ejecuci\u00f3n y permite rastrear la excepci\u00f3n leyendo el mensaje de error que imprime. bash $ python3 foo.py Traceback (most recent call last): File \"foo.py\", line 21, in <m\u00f3dulo> raise RuntimeError(\"\u00a1Qu\u00e9 moco!\") RuntimeError: \u00a1Qu\u00e9 moco! Alternativamente, esa excepci\u00f3n puede ser atrapada por un bloque try-except , pudiendo de esta forma evitar que el programa termine. Ejercicios Ejercicio 2.5: Definir una funci\u00f3n Prob\u00e1 primero definir una funci\u00f3n simple: >>> def saludar(nombre): 'Saluda a alguien' print('Hola', nombre) >>> saludar('Guido') Hola Guido >>> saludar('Paula') Hola Paula >>> Si la primera instrucci\u00f3n de una funci\u00f3n es una cadena, sirve como documentaci\u00f3n de la funci\u00f3n. Probalo escribiendo help(saludar) para ver c\u00f3mo la muestra. Ejercicio 2.6: Transformar un script en una funci\u00f3n Transform\u00e1 el programa costo_camion.py (que escribiste en el Ejercicio 2.2 de la secci\u00f3n anterior) en una funci\u00f3n costo_camion(nombre_archivo) . Esta funci\u00f3n recibe un nombre de archivo como entrada, lee la informaci\u00f3n sobre los cajones que carg\u00f3 el cami\u00f3n y devuelve el costo de la carga de frutas como una variable de punto flotante. Para usar tu funci\u00f3n, cambi\u00e1 el programa de forma que se parezca a esto: def costo_camion(nombre_archivo): ... # Tu c\u00f3digo ... costo = costo_camion('../Data/camion.csv') print('Costo total:', costo) Cuando ejecut\u00e1s tu programa, deber\u00edas ver la misma salida impresa que antes. Una vez que lo hayas corrido, pod\u00e9s llamar interactivamente a la funci\u00f3n escribiendo esto: bash $ python3 -i costo_camion.py Esto va a ejecutar el c\u00f3digo en el programa y dejar abierto el int\u00e9rprete interactivo. >>> costo_camion('Data/camion.csv') 47671.15 >>> Es \u00fatil para testear y debuguear poder interactuar interactivamente con tu c\u00f3digo. Ejercicio 2.7: Buscar precios A partir de lo que hiciste en el Ejercicio 2.3 , escrib\u00ed una funci\u00f3n buscar_precio(fruta) que busque en archivo ../Data/precios.csv el precio de determinada fruta (o verdura) y lo imprima en pantalla. Si la fruta no figura en el listado de precios, debe imprimir un mensaje que lo indique. >>> buscar_precio('Frambuesa') El precio de un caj\u00f3n de Frambuesa es: 34.35 >>> buscar_precio('Kale') Kale no figura en el listado de precios. Guard\u00e1 este c\u00f3digo en un archivo buscar_precio.py para entregar al final de la clase. Ejercicio 2.8: Administraci\u00f3n de errores Prob\u00e1 correr la siguiente funci\u00f3n ingresando tu edad real, una edad escrita con letras (como \"ocho\") y una edad negativa (-3): def preguntar_edad(nombre): edad = int(input(f'ingres\u00e1 tu edad {nombre}: ')) if edad<0: raise ValueError('La edad no puede ser negativa.') return edad Ahora prob\u00e1 este ejemplo que atrapa la excepci\u00f3n generada con raise y contin\u00faa la ejecuci\u00f3n con la siguiente persona. for nombre in ['Pedro','Juan','Caballero']: try: edad = preguntar_edad(nombre) print(f'{nombre} tiene {edad} a\u00f1os.') except ValueError: print(f'{nombre} no ingres\u00f3 una edad v\u00e1lida.') Vamos a usar estas ideas aplicadas al procesamiento de un archivo CSV. \u00bfQu\u00e9 pasa si intent\u00e1s usar la funci\u00f3n costo_camion() con un archivo que tiene datos faltantes? >>> costo_camion('Data/missing.csv') Traceback (most recent call last): File \"<stdin>\", line 1, in <m\u00f3dulo> File \"costo_camion.py\", line 11, in costo_camion ncajones = int(fields[1]) ValueError: invalid literal for int() with base 10: '' >>> El programa termina con un error. A esta altura ten\u00e9s que tomar una decisi\u00f3n. Para que el programa funcione pod\u00e9s editar el archivo CSV de entrada de manera de corregirlo (borrando l\u00edneas o adecuando la informaci\u00f3n) o pod\u00e9s modificar el c\u00f3digo para que maneje las l\u00edneas incorrectas de alguna manera. Modific\u00e1 el programa costo_camion.py para que atrape la excepci\u00f3n con un bloque try - except , imprima un mensaje de aviso (warning) y contin\u00fae procesando el resto del archivo. Vamos a profundizar en la administraci\u00f3n de errores en las pr\u00f3ximas clases. Ejercicio 2.9: Funciones de la biblioteca Python viene con una gran biblioteca est\u00e1ndar de funciones \u00fatiles. En este caso el m\u00f3dulo csv podr\u00eda venirnos muy bien. Pod\u00e9s usarlo cada vez que tengas que leer archivos CSV. Ac\u00e1 va un ejemplo de c\u00f3mo funciona. >>> import csv >>> f = open('Data/camion.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['nombre', 'cajones', 'precio'] >>> for row in rows: print(row) ['Lima', '100', '32.2'] ['Naranja', '50', '91.1'] ['Caqui', '150', '103.44'] ['Mandarina', '200', '51.23'] ['Durazno', '95', '40.37'] ['Mandarina', '50', '65.1'] ['Naranja', '100', '70.44'] >>> f.close() >>> Una cosa buena que tiene el m\u00f3dulo csv es que maneja solo una gran variedad de detalles de bajo nivel como el problema de las comillas, o la separaci\u00f3n con comas de los datos. En la salida del \u00faltimo ejemplo pod\u00e9s ver que el lector ya sac\u00f3 las comillas dobles de los nombres de las frutas de la primera columna. Modific\u00e1 tu programa costo_camion.py para que use el m\u00f3dulo csv para leer los archivos CSV y probalo en un par de los ejemplos anteriores. Ejercicio 2.10: Ejecuci\u00f3n desde la l\u00ednea de comandos con par\u00e1metros En el programa costo_camion.py , el nombre del archivo de entrada '../Data/camion.csv' fue escrito en el c\u00f3digo. # costo_camion.py import csv def costo_camion(nombre_archivo): ... # Tu c\u00f3digo ... costo = costo_camion('../Data/camion.csv') print('Costo total:', costo) Esto est\u00e1 bien para ejercitar, pero en un programa real probablemente no har\u00edas eso ya que querr\u00edas una mayor flexibilidad. Una posibilidad es pasarle al programa el nombre del archivo que quer\u00e9s procesar como un par\u00e1metro cuando lo llam\u00e1s desde la l\u00ednea de comandos. Copi\u00e1 el contenido de costo_camion.py a un nuevo archivo llamado camion_commandline.py que incorpore la lectura de par\u00e1metros por l\u00ednea de comando seg\u00fan la sugerencia del siguiente ejemplo: # camion_commandline.py import csv import sys def costo_camion(nombre_archivo): ... # Tu c\u00f3digo ... if len(sys.argv) == 2: nombre_archivo = sys.argv[1] else: nombre_archivo = '../Data/camion.csv' costo = costo_camion(nombre_archivo) print('Costo total:', costo) sys.argv es una lista que contiene los argumentos que le pasamos al script al momento de llamarlo desde la l\u00ednea de comandos (si es que le pasamos alguno). Por ejemplo, desde una terminal de Unix (en Windows es similar), para correr nuestro programa y que procese el mismo archivo podr\u00edamos escribir: bash $ python3 camion_commandline.py ../Data/camion.csv Costo total: 47671.15 bash $ O con el archivo missing.csv : bash $ python3 camion_commandline.py ../Data/missing.csv ... Costo total: 30381.15 bash $ Si no le pasamos ning\u00fan archivo, va a mostrar el resultado para camion.csv porque lo indicamos con la l\u00ednea nombre_archivo = '../Data/camion.csv' . Guard\u00e1 tu programa en el archivo camion_commandline.py para entregar al final de la clase. Contenidos | Anterior (1 Manejo de archivos) | Pr\u00f3ximo (3 Tipos y estructuras de datos)","title":"02 Funciones"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#22-funciones","text":"A medida que tus programas se vuelven m\u00e1s largos y complejos, vas a necesitar organizarte. En esta secci\u00f3n vamos a introducir brevemente funciones y m\u00f3dulos de la biblioteca as\u00ed como tambi\u00e9n la administraci\u00f3n de errores y excepciones.","title":"2.2 Funciones"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#funciones-a-medida","text":"Us\u00e1 funciones para encapsular c\u00f3digo que quieras reutilizar. El siguiente ejemplo muestra una definici\u00f3n de una funci\u00f3n: def sumcount(n): ''' Devuelve la suma de los primeros n enteros ''' total = 0 while n > 0: total += n n -= 1 return total Para llamar a una funci\u00f3n: a = sumcount(100) Una funci\u00f3n es una serie de instrucciones que realiza una tarea y devuelve un resultado. La palabra return es necesaria para explicitar el valor de retorno de la funci\u00f3n.","title":"Funciones a medida"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#funciones-de-la-biblioteca","text":"Python trae una gran biblioteca est\u00e1ndar. Los m\u00f3dulos de esta biblioteca se cargan usando import . Por ejemplo: import math x = math.sqrt(10) import urllib.request u = urllib.request.urlopen('http://www.python.org/') data = u.read() Vamos a estudiar bibliotecas y m\u00f3dulos en detalle m\u00e1s adelante.","title":"Funciones de la biblioteca"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#errores-y-excepciones","text":"Las funciones informan los errores como excepciones. Dado que una excepci\u00f3n interrumpe la ejecuci\u00f3n de una funci\u00f3n, la misma puede generar que todo el programa se detenga si no es administrada adecuadamente. Prob\u00e1 por ejemplo lo siguiente en tu int\u00e9rprete: >>> int('N/A') Traceback (most recent call last): File \"<stdin>\", line 1, in <m\u00f3dulo> ValueError: invalid literal for int() with base 10: 'N/A' >>> Para poder entender qu\u00e9 pas\u00f3 (debuguear), el mensaje describe cu\u00e1l fue el problema, d\u00f3nde ocurri\u00f3 y un poco de la historia (traceback) de los llamados que terminaron en este error.","title":"Errores y excepciones"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#atrapar-y-administrar-excepciones","text":"Las excepciones pueden ser atrapadas y administradas. Para atrapar una excepci\u00f3n, se usan los comandos try - except . Pod\u00e9s probar el siguiente fragmento de c\u00f3digo peg\u00e1ndolo en un archivo foo.py : numero_valido=False while not numero_valido: try: a = input('Ingres\u00e1 un n\u00famero entero: ') n = int(a) numero_valido = True except ValueError: print('No es v\u00e1lido. Intent\u00e1 de nuevo.') print(f'Ingresaste {n}.') Si en este ejemplo el usuario ingresa por ejemplo una letra, el comando n = int(a) genera una excepci\u00f3n de tipo ValueError : el comando numero_valido = True no se ejecuta, la excepci\u00f3n es atrapada por el except ValueError y el ciclo se repite. Probalo ingresando letras, n\u00fameros con decimales y n\u00fameros enteros. Prob\u00e1 tambi\u00e9n qu\u00e9 ocurre si quer\u00e9s salir sin ingresar nada generando una excepci\u00f3n presionando las teclas Ctrl+C . Le\u00e9 el mensaje que describe lo ocurrido: Ctrl+C genera una excepci\u00f3n de tipo KeyboardInterrupt que no es atrapada. Si no especificamos el tipo de excepci\u00f3n que queremos atrapar, vamos a terminar atrapando todas la excepciones. Prob\u00e1 lo mismo que antes pero con este c\u00f3digo. numero_valido=False while not numero_valido: try: a = input('Ingres\u00e1 un n\u00famero entero: ') n = int(a) numero_valido = True except: print('No es v\u00e1lido. Intent\u00e1 de nuevo.') print(f'Ingresaste {n}.') Deber\u00edas observar una diferencia: al presionar las teclas Ctrl+C la excepci\u00f3n KeyboardInterrupt s\u00ed es atrapada y no se termina el ciclo hasta no ingresar un n\u00famero entero. Suele ser dif\u00edcil saber exactamente qu\u00e9 tipo de errores pueden ocurrir por adelantado. Para bien o para mal, la administraci\u00f3n de excepciones suele ir creciendo a medida que un programa va generando errores inesperados (al mejor estilo: \"Uh! Me olvid\u00e9 de que pod\u00eda pasar esto. Deber\u00edamos preverlo y administrarlo adecuadamente para la pr\u00f3xima\").","title":"Atrapar y administrar excepciones"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#generar-excepciones","text":"Para generar una excepci\u00f3n (tambi\u00e9n diremos levantar una excepci\u00f3n, porque m\u00e1s cercano al t\u00e9rmino ingl\u00e9s \"raise\"), se usa el comando raise . Por ejemplo, si tenemos el siguiente c\u00f3digo en el archivo foo.py : raise RuntimeError('\u00a1Qu\u00e9 moco!') Al correrlo va a detener la ejecuci\u00f3n y permite rastrear la excepci\u00f3n leyendo el mensaje de error que imprime. bash $ python3 foo.py Traceback (most recent call last): File \"foo.py\", line 21, in <m\u00f3dulo> raise RuntimeError(\"\u00a1Qu\u00e9 moco!\") RuntimeError: \u00a1Qu\u00e9 moco! Alternativamente, esa excepci\u00f3n puede ser atrapada por un bloque try-except , pudiendo de esta forma evitar que el programa termine.","title":"Generar excepciones"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#ejercicios","text":"","title":"Ejercicios"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#ejercicio-25-definir-una-funcion","text":"Prob\u00e1 primero definir una funci\u00f3n simple: >>> def saludar(nombre): 'Saluda a alguien' print('Hola', nombre) >>> saludar('Guido') Hola Guido >>> saludar('Paula') Hola Paula >>> Si la primera instrucci\u00f3n de una funci\u00f3n es una cadena, sirve como documentaci\u00f3n de la funci\u00f3n. Probalo escribiendo help(saludar) para ver c\u00f3mo la muestra.","title":"Ejercicio 2.5: Definir una funci\u00f3n"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#ejercicio-26-transformar-un-script-en-una-funcion","text":"Transform\u00e1 el programa costo_camion.py (que escribiste en el Ejercicio 2.2 de la secci\u00f3n anterior) en una funci\u00f3n costo_camion(nombre_archivo) . Esta funci\u00f3n recibe un nombre de archivo como entrada, lee la informaci\u00f3n sobre los cajones que carg\u00f3 el cami\u00f3n y devuelve el costo de la carga de frutas como una variable de punto flotante. Para usar tu funci\u00f3n, cambi\u00e1 el programa de forma que se parezca a esto: def costo_camion(nombre_archivo): ... # Tu c\u00f3digo ... costo = costo_camion('../Data/camion.csv') print('Costo total:', costo) Cuando ejecut\u00e1s tu programa, deber\u00edas ver la misma salida impresa que antes. Una vez que lo hayas corrido, pod\u00e9s llamar interactivamente a la funci\u00f3n escribiendo esto: bash $ python3 -i costo_camion.py Esto va a ejecutar el c\u00f3digo en el programa y dejar abierto el int\u00e9rprete interactivo. >>> costo_camion('Data/camion.csv') 47671.15 >>> Es \u00fatil para testear y debuguear poder interactuar interactivamente con tu c\u00f3digo.","title":"Ejercicio 2.6: Transformar un script en una funci\u00f3n"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#ejercicio-27-buscar-precios","text":"A partir de lo que hiciste en el Ejercicio 2.3 , escrib\u00ed una funci\u00f3n buscar_precio(fruta) que busque en archivo ../Data/precios.csv el precio de determinada fruta (o verdura) y lo imprima en pantalla. Si la fruta no figura en el listado de precios, debe imprimir un mensaje que lo indique. >>> buscar_precio('Frambuesa') El precio de un caj\u00f3n de Frambuesa es: 34.35 >>> buscar_precio('Kale') Kale no figura en el listado de precios. Guard\u00e1 este c\u00f3digo en un archivo buscar_precio.py para entregar al final de la clase.","title":"Ejercicio 2.7: Buscar precios"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#ejercicio-28-administracion-de-errores","text":"Prob\u00e1 correr la siguiente funci\u00f3n ingresando tu edad real, una edad escrita con letras (como \"ocho\") y una edad negativa (-3): def preguntar_edad(nombre): edad = int(input(f'ingres\u00e1 tu edad {nombre}: ')) if edad<0: raise ValueError('La edad no puede ser negativa.') return edad Ahora prob\u00e1 este ejemplo que atrapa la excepci\u00f3n generada con raise y contin\u00faa la ejecuci\u00f3n con la siguiente persona. for nombre in ['Pedro','Juan','Caballero']: try: edad = preguntar_edad(nombre) print(f'{nombre} tiene {edad} a\u00f1os.') except ValueError: print(f'{nombre} no ingres\u00f3 una edad v\u00e1lida.') Vamos a usar estas ideas aplicadas al procesamiento de un archivo CSV. \u00bfQu\u00e9 pasa si intent\u00e1s usar la funci\u00f3n costo_camion() con un archivo que tiene datos faltantes? >>> costo_camion('Data/missing.csv') Traceback (most recent call last): File \"<stdin>\", line 1, in <m\u00f3dulo> File \"costo_camion.py\", line 11, in costo_camion ncajones = int(fields[1]) ValueError: invalid literal for int() with base 10: '' >>> El programa termina con un error. A esta altura ten\u00e9s que tomar una decisi\u00f3n. Para que el programa funcione pod\u00e9s editar el archivo CSV de entrada de manera de corregirlo (borrando l\u00edneas o adecuando la informaci\u00f3n) o pod\u00e9s modificar el c\u00f3digo para que maneje las l\u00edneas incorrectas de alguna manera. Modific\u00e1 el programa costo_camion.py para que atrape la excepci\u00f3n con un bloque try - except , imprima un mensaje de aviso (warning) y contin\u00fae procesando el resto del archivo. Vamos a profundizar en la administraci\u00f3n de errores en las pr\u00f3ximas clases.","title":"Ejercicio 2.8: Administraci\u00f3n de errores"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#ejercicio-29-funciones-de-la-biblioteca","text":"Python viene con una gran biblioteca est\u00e1ndar de funciones \u00fatiles. En este caso el m\u00f3dulo csv podr\u00eda venirnos muy bien. Pod\u00e9s usarlo cada vez que tengas que leer archivos CSV. Ac\u00e1 va un ejemplo de c\u00f3mo funciona. >>> import csv >>> f = open('Data/camion.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['nombre', 'cajones', 'precio'] >>> for row in rows: print(row) ['Lima', '100', '32.2'] ['Naranja', '50', '91.1'] ['Caqui', '150', '103.44'] ['Mandarina', '200', '51.23'] ['Durazno', '95', '40.37'] ['Mandarina', '50', '65.1'] ['Naranja', '100', '70.44'] >>> f.close() >>> Una cosa buena que tiene el m\u00f3dulo csv es que maneja solo una gran variedad de detalles de bajo nivel como el problema de las comillas, o la separaci\u00f3n con comas de los datos. En la salida del \u00faltimo ejemplo pod\u00e9s ver que el lector ya sac\u00f3 las comillas dobles de los nombres de las frutas de la primera columna. Modific\u00e1 tu programa costo_camion.py para que use el m\u00f3dulo csv para leer los archivos CSV y probalo en un par de los ejemplos anteriores.","title":"Ejercicio 2.9: Funciones de la biblioteca"},{"location":"02_Estructuras_y_Funciones/02_Funciones/#ejercicio-210-ejecucion-desde-la-linea-de-comandos-con-parametros","text":"En el programa costo_camion.py , el nombre del archivo de entrada '../Data/camion.csv' fue escrito en el c\u00f3digo. # costo_camion.py import csv def costo_camion(nombre_archivo): ... # Tu c\u00f3digo ... costo = costo_camion('../Data/camion.csv') print('Costo total:', costo) Esto est\u00e1 bien para ejercitar, pero en un programa real probablemente no har\u00edas eso ya que querr\u00edas una mayor flexibilidad. Una posibilidad es pasarle al programa el nombre del archivo que quer\u00e9s procesar como un par\u00e1metro cuando lo llam\u00e1s desde la l\u00ednea de comandos. Copi\u00e1 el contenido de costo_camion.py a un nuevo archivo llamado camion_commandline.py que incorpore la lectura de par\u00e1metros por l\u00ednea de comando seg\u00fan la sugerencia del siguiente ejemplo: # camion_commandline.py import csv import sys def costo_camion(nombre_archivo): ... # Tu c\u00f3digo ... if len(sys.argv) == 2: nombre_archivo = sys.argv[1] else: nombre_archivo = '../Data/camion.csv' costo = costo_camion(nombre_archivo) print('Costo total:', costo) sys.argv es una lista que contiene los argumentos que le pasamos al script al momento de llamarlo desde la l\u00ednea de comandos (si es que le pasamos alguno). Por ejemplo, desde una terminal de Unix (en Windows es similar), para correr nuestro programa y que procese el mismo archivo podr\u00edamos escribir: bash $ python3 camion_commandline.py ../Data/camion.csv Costo total: 47671.15 bash $ O con el archivo missing.csv : bash $ python3 camion_commandline.py ../Data/missing.csv ... Costo total: 30381.15 bash $ Si no le pasamos ning\u00fan archivo, va a mostrar el resultado para camion.csv porque lo indicamos con la l\u00ednea nombre_archivo = '../Data/camion.csv' . Guard\u00e1 tu programa en el archivo camion_commandline.py para entregar al final de la clase. Contenidos | Anterior (1 Manejo de archivos) | Pr\u00f3ximo (3 Tipos y estructuras de datos)","title":"Ejercicio 2.10: Ejecuci\u00f3n desde la l\u00ednea de comandos con par\u00e1metros"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/","text":"Contenidos | Anterior (2 Funciones) | Pr\u00f3ximo (4 Contenedores) 2.3 Tipos y estructuras de datos Esta secci\u00f3n introduce dos estructuras de datos elementales: las tuplas y los diccionarios. Tipos de datos primitivos Python tiene pocos tipos primitivos de datos. N\u00fameros enteros N\u00fameros de punto flotante Cadenas de texto Algo ya sabemos sobre estos tipos de datos por el cap\u00edtulo anterior. Tipo None email_address = None None suele utilizarse como un comod\u00edn para reservar el lugar para un valor opcional o faltante. En los condicionales, eval\u00faa como False . if email_address: send_email(email_address, msg) Estructuras de datos Los programas reales tienen datos m\u00e1s complejos que los que podemos almacenar en los tipos primitivos. Por ejemplo, informaci\u00f3n sobre un pedido de frutas: 100 cajones de Manzanas a $490.10 cada uno Podemos ver esto como un \"objeto\" con tres partes: Nombre del s\u00edmbolo (\"Manzanas\", una cadena) N\u00famero o cantidad (100, un entero) Precio (490.10, un flotante) Tuplas Una tupla es una colecci\u00f3n con valores agrupados juntos. Ejemplo: s = ('Manzanas', 100, 490.1) Las tuplas suelen usarse para representar registros o estructuras simples . T\u00edpicamente, una tupla representa un solo objeto con m\u00faltiples partes. Una analog\u00eda posible es la siguiente: Una tupla es como una fila de una base de datos . Los contenidos de una tupla est\u00e1n ordenados (como en una lista). s = ('Manzana', 100, 490.1) nombre = s[0] # 'Manzana' cantidad = s[1] # 100 precio = s[2] # 490.1 El contenido de las tuplas no puede ser modificado. >>> s[1] = 75 TypeError: object does not support item assignment Pod\u00e9s, sin embargo, hacer una nueva tupla basada en el contenido de otra, que no es lo mismo que modificar el contenido. s = (s[0], 75, s[2]) Empaquetar tuplas Las tuplas suelen usarse para empaquetar informaci\u00f3n relacionada en una sola entidad . s = ('Manzanas', 100, 490.1) Una tupla puede ser pasada de un lugar a otro de un programa como un solo objeto. Desempaquetar tuplas Para usar una tupla en otro lado, debemos desempaquetar su contenido en diferentes variables. fruta, cajones, precio = s print('Costo:', cajones * precio) El n\u00famero de variables a la izquierda debe ser consistente con la estructura de la tupla. nombre, cajones = s # ERROR Traceback (most recent call last): ... ValueError: too many values to unpack Tuplas vs. Listas Las tuplas parecieran ser listas de solo-lectura. Sin embargo, las tuplas suelen usarse para un solo \u00edtem que consiste de m\u00faltiples partes mientras que las listas suelen usarse para una colecci\u00f3n de diferentes elementos, t\u00edpicamente del mismo tipo. record = ('Manzanas', 100, 490.1) # Una tupla representando un registro dentro de un pedido de frutas symbols = [ 'Manzanas', 'Peras', 'Mandarinas' ] # Una lista representando tres frutas diferentes. Diccionarios Un diccionario es una funci\u00f3n que manda claves en valores . Las claves sirven como \u00edndices para acceder a los valores. s = { 'fruta': 'Manzana', 'cajones': 100, 'precio': 490.1 } Operaciones usuales Para obtener el valor almacenado en un diccionario usamos las claves. >>> print(s['fruta'], s['cajones']) Manzanas 100 >>> s['precio'] 490.10 >>> Para agregar o modificar valores, simplemente asignamos usando la clave. >>> s['cajones'] = 75 >>> s['fecha'] = '6/8/2020' >>> para borrar un valor, usamos el comando del . >>> del s['fecha'] >>> \u00bfPor qu\u00e9 diccionarios? Los diccionarios son \u00fatiles cuando hay muchos valores diferentes y esos valores pueden ser modificados o manipulados. Dado que el acceso a los elementos se hace por clave , no es necesario recordar una posici\u00f3n para cierto dato, lo que muchas veces cumple un objetivo fundamental: hacer que el c\u00f3digo sea m\u00e1s legible (y con esto menos propenso a errores). s['precio'] # diccionario # vs s[2] # lista Ejercicios Anteriormente escribiste un programa que le\u00eda el archivo camion.csv usando el m\u00f3dulo csv para leer el archivo fila por fila. >>> import csv >>> f = open('../Data/camion.csv') >>> filas = csv.reader(f) >>> next(filas) ['nombre', 'cajones', 'precio'] >>> fila = next(filas) >>> fila ['Lima', '100', '32.2'] >>> A veces, adem\u00e1s de leerlo, queremos hacer otras cosas con el archivo CSV, como por ejemplo usar los datos que contiene para hacer un c\u00e1lculo. Lamentablemente una fila de datos en crudo no es suficiente para operar aritm\u00e9ticamente. Vamos a querer interpretar los elementos de la fila de datos de alguna manera particular, convirti\u00e9ndolos a otro tipo de datos que resulte m\u00e1s adecuado para trabajar. Es frecuente adem\u00e1s de convertir los elementos de las filas, transformar las filas enteras en tuplas o diccionarios. Ejercicio 2.11: Tuplas En el int\u00e9rprete interactivo, cre\u00e1 la siguiente tupla que representa la fila de antes, pero con las columnas num\u00e9ricas pasadas a formatos adecuados: >>> t = (fila[0], int(fila[1]), float(fila[2])) >>> t ('Lima', 100, 32.2) >>> A partir de esta tupla, ahora pod\u00e9s calcular el costo total multiplicando cajones por precio: >>> cost = t[1] * t[2] >>> cost 3220.0000000000005 >>> \u00bfQu\u00e9 pas\u00f3? \u00bfQu\u00e9 hace ese 5 al final? Este error no es un problema de Python, sino de la forma en la que la m\u00e1quina representa los n\u00fameros de punto flotante. As\u00ed como en base 10 no podemos escribir un tercio de manera exacta, en base 2 escribir un quinto requiere infinitos d\u00edgitos. Al usar una representaci\u00f3n finita (una cantidad acotada de d\u00edgitos) la m\u00e1quina redondea los n\u00fameros. La aritm\u00e9tica de punto flotante no es exacta. Esto pasa en todos los lenguajes de programaci\u00f3n que usan punto flotante, pero en muchos casos estos peque\u00f1os errores quedan ocultos al imprimir. Por ejemplo: >>> print(f'{cost:0.2f}') 3220.00 >>> Las tuplas son de s\u00f3lo lectura. Verificalo tratando de cambiar el n\u00famero de cajones a 75. >>> t[1] = 75 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'tuple' object does not support item assignment >>> Aunque no pod\u00e9s cambiar al tupla, s\u00ed pod\u00e9s reemplazar la tupla por una nueva. >>> t = (t[0], 75, t[2]) >>> t ('Lima', 75, 32.2) >>> Siempre que reasignes una variable como reci\u00e9n lo hiciste con t , el valor anterior de la variable se pierde. Aunque la asignaci\u00f3n de arriba pueda parecer como que est\u00e1s modificando la tupla, en realidad est\u00e1s creando una nueva tupla y tirando la vieja. Las tuplas muchas veces se usan para empaquetar y desempaquetar valores dentro de variables. Prob\u00e1 esto: >>> nombre, cajones, precio = t >>> nombre 'Lima' >>> cajones 75 >>> precio 32.2 >>> Tom\u00e1 las variables de arriba y empaquetalas en una tupla. >>> t = (nombre, 2*cajones, precio) >>> t ('Lima', 150, 32.2) >>> Ejercicio 2.12: Diccionarios como estructuras de datos Una alternativa a la tupla es un diccionario. >>> d = { 'nombre' : fila[0], 'cajones' : int(fila[1]), 'precio' : float(fila[2]) } >>> d {'nombre': 'Lima', 'cajones': 100, 'precio': 32.2 } >>> Calcul\u00e1 el costo total de este lote: >>> cost = d['cajones'] * d['precio'] >>> cost 3220.0000000000005 >>> Compar\u00e1 este ejemplo con el mismo c\u00e1lculo hecho con tuplas m\u00e1s arriba. Cambi\u00e1 el n\u00famero de cajones a 75. >>> d['cajones'] = 75 >>> d {'nombre': 'Lima', 'cajones': 75, 'precio': 32.2 } >>> A diferencia de las tuplas, los diccionarios se pueden modificar libremente. Agreg\u00e1 algunos atributos: >>> d['fecha'] = (14, 8, 2020) >>> d['cuenta'] = 12345 >>> d {'nombre': 'Lima', 'cajones': 75, 'precio':32.2, 'fecha': (14, 8, 2020), 'cuenta': 12345} >>> Ejercicio 2.13: M\u00e1s operaciones con diccionarios Si us\u00e1s el comando for para iterar sobre el diccionario, obten\u00e9s las claves: >>> for k in d: print('k =', k) k = nombre k = cajones k = precio k = fecha k = cuenta >>> Prob\u00e1 esta variante: >>> for k in d: print(k, '=', d[k]) nombre = 'Lima' cajones = 75 precio = 32.2 fecha = (14, 8, 2020) cuenta = 12345 >>> Una manera m\u00e1s elegante de trabajar con claves y valores simult\u00e1neamente es usar el m\u00e9todo items() . Esto te devuelve una lista de tuplas de la forma (clave,valor) sobre la que pod\u00e9s iterar. >>> items = d.items() >>> items dict_items([('nombre', 'Lima'), ('cajones', 75), ('precio', 32.2), ('fecha', (14, 8, 2020))]) >>> for k, v in d.items(): print(k, '=', v) nombre = Lima cajones = 75 precio = 32.2 fecha = (14, 8, 2020) >>> Si pas\u00e1s un diccionario a una lista, obten\u00e9s sus claves. >>> list(d) ['nombre', 'cajones', 'precio', 'fecha', 'cuenta'] >>> Tambi\u00e9n pod\u00e9s obtener todas las claves del diccionario usando el m\u00e9todo keys() : >>> claves = d.keys() >>> claves dict_keys(['nombre', 'cajones', 'precio', 'fecha', 'cuenta']) >>> Si ten\u00e9s tuplas como en items pod\u00e9s crear un diccionario usando la funci\u00f3n dict() . Prob\u00e1 esto: >>> nuevos_items = [('nombre', 'Manzanas'), ('cajones', 100), ('precio', 490.1), ('fecha', (13, 8, 2020))] >>> nuevos_items [('nombre', 'Manzanas'), ('cajones', 100), ('precio', 490.1), ('fecha', (13, 8, 2020))] >>> d = dict(nuevos_items) >>> d {'nombre': 'Manzanas', 'cajones': 100, 'precio': 490.1, 'fecha': (13, 8, 2020)} Ejercicio 2.14: Diccionario geringoso. Constru\u00ed una funci\u00f3n que, a partir de una lista de palabras, devuelva un diccionario geringoso. Las claves del diccionario deben ser las palabras de la lista y los valores deben ser sus traducciones al geringoso (como en el Ejercicio 1.18 ). Prob\u00e1 tu funci\u00f3n para la lista ['banana', 'manzana', 'mandarina'] . Guard\u00e1 este ejercicio en un archivo diccionario_geringoso.py para entregar al final de la clase. Contenidos | Anterior (2 Funciones) | Pr\u00f3ximo (4 Contenedores)","title":"03 TiposDatos"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#23-tipos-y-estructuras-de-datos","text":"Esta secci\u00f3n introduce dos estructuras de datos elementales: las tuplas y los diccionarios.","title":"2.3 Tipos y estructuras de datos"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#tipos-de-datos-primitivos","text":"Python tiene pocos tipos primitivos de datos. N\u00fameros enteros N\u00fameros de punto flotante Cadenas de texto Algo ya sabemos sobre estos tipos de datos por el cap\u00edtulo anterior.","title":"Tipos de datos primitivos"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#tipo-none","text":"email_address = None None suele utilizarse como un comod\u00edn para reservar el lugar para un valor opcional o faltante. En los condicionales, eval\u00faa como False . if email_address: send_email(email_address, msg)","title":"Tipo None"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#estructuras-de-datos","text":"Los programas reales tienen datos m\u00e1s complejos que los que podemos almacenar en los tipos primitivos. Por ejemplo, informaci\u00f3n sobre un pedido de frutas: 100 cajones de Manzanas a $490.10 cada uno Podemos ver esto como un \"objeto\" con tres partes: Nombre del s\u00edmbolo (\"Manzanas\", una cadena) N\u00famero o cantidad (100, un entero) Precio (490.10, un flotante)","title":"Estructuras de datos"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#tuplas","text":"Una tupla es una colecci\u00f3n con valores agrupados juntos. Ejemplo: s = ('Manzanas', 100, 490.1) Las tuplas suelen usarse para representar registros o estructuras simples . T\u00edpicamente, una tupla representa un solo objeto con m\u00faltiples partes. Una analog\u00eda posible es la siguiente: Una tupla es como una fila de una base de datos . Los contenidos de una tupla est\u00e1n ordenados (como en una lista). s = ('Manzana', 100, 490.1) nombre = s[0] # 'Manzana' cantidad = s[1] # 100 precio = s[2] # 490.1 El contenido de las tuplas no puede ser modificado. >>> s[1] = 75 TypeError: object does not support item assignment Pod\u00e9s, sin embargo, hacer una nueva tupla basada en el contenido de otra, que no es lo mismo que modificar el contenido. s = (s[0], 75, s[2])","title":"Tuplas"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#empaquetar-tuplas","text":"Las tuplas suelen usarse para empaquetar informaci\u00f3n relacionada en una sola entidad . s = ('Manzanas', 100, 490.1) Una tupla puede ser pasada de un lugar a otro de un programa como un solo objeto.","title":"Empaquetar tuplas"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#desempaquetar-tuplas","text":"Para usar una tupla en otro lado, debemos desempaquetar su contenido en diferentes variables. fruta, cajones, precio = s print('Costo:', cajones * precio) El n\u00famero de variables a la izquierda debe ser consistente con la estructura de la tupla. nombre, cajones = s # ERROR Traceback (most recent call last): ... ValueError: too many values to unpack","title":"Desempaquetar tuplas"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#tuplas-vs-listas","text":"Las tuplas parecieran ser listas de solo-lectura. Sin embargo, las tuplas suelen usarse para un solo \u00edtem que consiste de m\u00faltiples partes mientras que las listas suelen usarse para una colecci\u00f3n de diferentes elementos, t\u00edpicamente del mismo tipo. record = ('Manzanas', 100, 490.1) # Una tupla representando un registro dentro de un pedido de frutas symbols = [ 'Manzanas', 'Peras', 'Mandarinas' ] # Una lista representando tres frutas diferentes.","title":"Tuplas vs. Listas"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#diccionarios","text":"Un diccionario es una funci\u00f3n que manda claves en valores . Las claves sirven como \u00edndices para acceder a los valores. s = { 'fruta': 'Manzana', 'cajones': 100, 'precio': 490.1 }","title":"Diccionarios"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#operaciones-usuales","text":"Para obtener el valor almacenado en un diccionario usamos las claves. >>> print(s['fruta'], s['cajones']) Manzanas 100 >>> s['precio'] 490.10 >>> Para agregar o modificar valores, simplemente asignamos usando la clave. >>> s['cajones'] = 75 >>> s['fecha'] = '6/8/2020' >>> para borrar un valor, usamos el comando del . >>> del s['fecha'] >>>","title":"Operaciones usuales"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#por-que-diccionarios","text":"Los diccionarios son \u00fatiles cuando hay muchos valores diferentes y esos valores pueden ser modificados o manipulados. Dado que el acceso a los elementos se hace por clave , no es necesario recordar una posici\u00f3n para cierto dato, lo que muchas veces cumple un objetivo fundamental: hacer que el c\u00f3digo sea m\u00e1s legible (y con esto menos propenso a errores). s['precio'] # diccionario # vs s[2] # lista","title":"\u00bfPor qu\u00e9 diccionarios?"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#ejercicios","text":"Anteriormente escribiste un programa que le\u00eda el archivo camion.csv usando el m\u00f3dulo csv para leer el archivo fila por fila. >>> import csv >>> f = open('../Data/camion.csv') >>> filas = csv.reader(f) >>> next(filas) ['nombre', 'cajones', 'precio'] >>> fila = next(filas) >>> fila ['Lima', '100', '32.2'] >>> A veces, adem\u00e1s de leerlo, queremos hacer otras cosas con el archivo CSV, como por ejemplo usar los datos que contiene para hacer un c\u00e1lculo. Lamentablemente una fila de datos en crudo no es suficiente para operar aritm\u00e9ticamente. Vamos a querer interpretar los elementos de la fila de datos de alguna manera particular, convirti\u00e9ndolos a otro tipo de datos que resulte m\u00e1s adecuado para trabajar. Es frecuente adem\u00e1s de convertir los elementos de las filas, transformar las filas enteras en tuplas o diccionarios.","title":"Ejercicios"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#ejercicio-211-tuplas","text":"En el int\u00e9rprete interactivo, cre\u00e1 la siguiente tupla que representa la fila de antes, pero con las columnas num\u00e9ricas pasadas a formatos adecuados: >>> t = (fila[0], int(fila[1]), float(fila[2])) >>> t ('Lima', 100, 32.2) >>> A partir de esta tupla, ahora pod\u00e9s calcular el costo total multiplicando cajones por precio: >>> cost = t[1] * t[2] >>> cost 3220.0000000000005 >>> \u00bfQu\u00e9 pas\u00f3? \u00bfQu\u00e9 hace ese 5 al final? Este error no es un problema de Python, sino de la forma en la que la m\u00e1quina representa los n\u00fameros de punto flotante. As\u00ed como en base 10 no podemos escribir un tercio de manera exacta, en base 2 escribir un quinto requiere infinitos d\u00edgitos. Al usar una representaci\u00f3n finita (una cantidad acotada de d\u00edgitos) la m\u00e1quina redondea los n\u00fameros. La aritm\u00e9tica de punto flotante no es exacta. Esto pasa en todos los lenguajes de programaci\u00f3n que usan punto flotante, pero en muchos casos estos peque\u00f1os errores quedan ocultos al imprimir. Por ejemplo: >>> print(f'{cost:0.2f}') 3220.00 >>> Las tuplas son de s\u00f3lo lectura. Verificalo tratando de cambiar el n\u00famero de cajones a 75. >>> t[1] = 75 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: 'tuple' object does not support item assignment >>> Aunque no pod\u00e9s cambiar al tupla, s\u00ed pod\u00e9s reemplazar la tupla por una nueva. >>> t = (t[0], 75, t[2]) >>> t ('Lima', 75, 32.2) >>> Siempre que reasignes una variable como reci\u00e9n lo hiciste con t , el valor anterior de la variable se pierde. Aunque la asignaci\u00f3n de arriba pueda parecer como que est\u00e1s modificando la tupla, en realidad est\u00e1s creando una nueva tupla y tirando la vieja. Las tuplas muchas veces se usan para empaquetar y desempaquetar valores dentro de variables. Prob\u00e1 esto: >>> nombre, cajones, precio = t >>> nombre 'Lima' >>> cajones 75 >>> precio 32.2 >>> Tom\u00e1 las variables de arriba y empaquetalas en una tupla. >>> t = (nombre, 2*cajones, precio) >>> t ('Lima', 150, 32.2) >>>","title":"Ejercicio 2.11: Tuplas"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#ejercicio-212-diccionarios-como-estructuras-de-datos","text":"Una alternativa a la tupla es un diccionario. >>> d = { 'nombre' : fila[0], 'cajones' : int(fila[1]), 'precio' : float(fila[2]) } >>> d {'nombre': 'Lima', 'cajones': 100, 'precio': 32.2 } >>> Calcul\u00e1 el costo total de este lote: >>> cost = d['cajones'] * d['precio'] >>> cost 3220.0000000000005 >>> Compar\u00e1 este ejemplo con el mismo c\u00e1lculo hecho con tuplas m\u00e1s arriba. Cambi\u00e1 el n\u00famero de cajones a 75. >>> d['cajones'] = 75 >>> d {'nombre': 'Lima', 'cajones': 75, 'precio': 32.2 } >>> A diferencia de las tuplas, los diccionarios se pueden modificar libremente. Agreg\u00e1 algunos atributos: >>> d['fecha'] = (14, 8, 2020) >>> d['cuenta'] = 12345 >>> d {'nombre': 'Lima', 'cajones': 75, 'precio':32.2, 'fecha': (14, 8, 2020), 'cuenta': 12345} >>>","title":"Ejercicio 2.12: Diccionarios como estructuras de datos"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#ejercicio-213-mas-operaciones-con-diccionarios","text":"Si us\u00e1s el comando for para iterar sobre el diccionario, obten\u00e9s las claves: >>> for k in d: print('k =', k) k = nombre k = cajones k = precio k = fecha k = cuenta >>> Prob\u00e1 esta variante: >>> for k in d: print(k, '=', d[k]) nombre = 'Lima' cajones = 75 precio = 32.2 fecha = (14, 8, 2020) cuenta = 12345 >>> Una manera m\u00e1s elegante de trabajar con claves y valores simult\u00e1neamente es usar el m\u00e9todo items() . Esto te devuelve una lista de tuplas de la forma (clave,valor) sobre la que pod\u00e9s iterar. >>> items = d.items() >>> items dict_items([('nombre', 'Lima'), ('cajones', 75), ('precio', 32.2), ('fecha', (14, 8, 2020))]) >>> for k, v in d.items(): print(k, '=', v) nombre = Lima cajones = 75 precio = 32.2 fecha = (14, 8, 2020) >>> Si pas\u00e1s un diccionario a una lista, obten\u00e9s sus claves. >>> list(d) ['nombre', 'cajones', 'precio', 'fecha', 'cuenta'] >>> Tambi\u00e9n pod\u00e9s obtener todas las claves del diccionario usando el m\u00e9todo keys() : >>> claves = d.keys() >>> claves dict_keys(['nombre', 'cajones', 'precio', 'fecha', 'cuenta']) >>> Si ten\u00e9s tuplas como en items pod\u00e9s crear un diccionario usando la funci\u00f3n dict() . Prob\u00e1 esto: >>> nuevos_items = [('nombre', 'Manzanas'), ('cajones', 100), ('precio', 490.1), ('fecha', (13, 8, 2020))] >>> nuevos_items [('nombre', 'Manzanas'), ('cajones', 100), ('precio', 490.1), ('fecha', (13, 8, 2020))] >>> d = dict(nuevos_items) >>> d {'nombre': 'Manzanas', 'cajones': 100, 'precio': 490.1, 'fecha': (13, 8, 2020)}","title":"Ejercicio 2.13: M\u00e1s operaciones con diccionarios"},{"location":"02_Estructuras_y_Funciones/03_TiposDatos/#ejercicio-214-diccionario-geringoso","text":"Constru\u00ed una funci\u00f3n que, a partir de una lista de palabras, devuelva un diccionario geringoso. Las claves del diccionario deben ser las palabras de la lista y los valores deben ser sus traducciones al geringoso (como en el Ejercicio 1.18 ). Prob\u00e1 tu funci\u00f3n para la lista ['banana', 'manzana', 'mandarina'] . Guard\u00e1 este ejercicio en un archivo diccionario_geringoso.py para entregar al final de la clase. Contenidos | Anterior (2 Funciones) | Pr\u00f3ximo (4 Contenedores)","title":"Ejercicio 2.14: Diccionario geringoso."},{"location":"02_Estructuras_y_Funciones/04_Contenedores/","text":"Contenidos | Anterior (3 Tipos y estructuras de datos) | Pr\u00f3ximo (5 Cierre de la clase) 2.4 Contenedores En esta secci\u00f3n trataremos listas, diccionarios y conjuntos. Panorama Los programas suelen trabajar con muchos objetos. Un cami\u00f3n con cajones de fruta Una tabla de precios de cajones de fruta En Python hay tres opciones principales para elegir. Listas. Datos ordenados. Diccionarios. Datos desordenados. Conjuntos. Colecci\u00f3n desordenada de elementos \u00fanicos. Listas como contenedores Us\u00e1 listas cuando el orden de los datos importe. Acordate de que las listas pueden contener cualquier tipo de objeto. Por ejemplo, una lista de tuplas. camion = [ ('Pera', 100, 490.1), ('Naranja', 50, 91.3), ('Limon', 150, 83.44) ] camion[0] # ('Pera', 100, 490.1) camion[2] # ('Limon', 150, 83.44) Construcci\u00f3n de una lista C\u00f3mo armar una lista desde cero. registros = [] # Empezamos con una lista vac\u00eda # Usamos el .append() para agregar elementos registros.append(('Pera', 100, 490.10)) registros.append(('Naranja', 50, 91.3)) ... Un ejemplo de c\u00f3mo cargar registros desde un archivo. registros = [] # Empezamos con una lista vac\u00eda with open('../Data/camion.csv', 'rt') as f: next(f) # Saltear el encabezado for line in f: row = line.split(',') registros.append((row[0], int(row[1]), float(row[2]))) Diccionarios como contenedores Los diccionarios son \u00fatiles si vamos a querer buscar r\u00e1pidamente (por claves). Por ejemplo, un diccionario de precios de cajones. precios = { 'Pera': 513.25, 'Limon': 87.22, 'Naranja': 93.37, 'Mandarina': 44.12 } As\u00ed podemos buscar datos: >>> precios['Naranja'] 93.37 >>> precios['Pera'] 513.25 >>> Construcci\u00f3n de diccionarios Ejemplo de armado de un diccionario desde cero. precios = {} # Empezamos con un diccionario vac\u00edo # Agregamos elementos precios['Pera'] = 513.25 precios['Limon'] = 87.22 precios['Naranja'] = 93.37 Un ejemplo de c\u00f3mo armar un diccionario a partir del contenido de un archivo. precios = {} # Empezamos con un diccionario vac\u00edo with open('../Data/precios.csv', 'rt') as f: for line in f: row = line.split(',') precios[row[0]] = float(row[1]) Nota: Si prob\u00e1s estos comandos en el archivo Data/precios.csv , vas a ver que casi anda. Pero hay una l\u00ednea en blanco al final que genera un error. Usando lo que ya vimos, en el Ejercicio 2.17 vas a tener que modificar el c\u00f3digo para resolver el problema. B\u00fasquedas en un diccionario Pod\u00e9s verificar si una clave existe: if key in d: # YES else: # NO Claves compuestas Casi cualquier valor puede usarse como clave en un diccionario de Python. La principal restricci\u00f3n es que una clave debe ser de tipo inmutable. Por ejemplo, tuplas: feriados = { (1, 1) : 'A\u00f1o nuevo', (1, 5) : 'D\u00eda del trabajador', (13, 9) : \"D\u00eda del programador\", } Luego, podemos acceder al diccionario as\u00ed: >>> feriados[(1, 5)] 'D\u00eda del trabajador' >>> Las listas, los conjuntos y los diccionarios no pueden ser usados como claves de diccionarios, porque son mutables. Conjuntos Un conjunto es una colecci\u00f3n de elementos \u00fanicos sin orden y sin repetici\u00f3n. citricos = { 'Naranja','Limon','Mandarina' } # Alternativamente podemos escribirlo as\u00ed: citricos = set(['Naranja', 'Limon', 'Mandarina']) Los conjuntos son \u00fatiles para evaluar pertenencia. >>> citricos set(['Naranja', 'Limon', 'Mandarina']) >>> 'Naranja' in citricos True >>> 'Manzana' in citricos False >>> Los conjuntos tambi\u00e9n son \u00fatiles para eliminar duplicados. nombres = ['Naranja', 'Manzana', 'Pera', 'Naranja', 'Pera', 'Banana'] unicos = set(nombres) # unicos = {'Manzana', 'Banana', 'Naranja', 'Pera'} M\u00e1s operaciones en conjuntos: citricos.add('Banana') # Agregar un elemento citricos.remove('Limon') # Eliminar un elemento s1 | s2 # Uni\u00f3n de conjuntos s1 y s2 s1 & s2 # Intersecci\u00f3n de conjuntos s1 - s2 # Diferencia de conjuntos Ejercicios En estos ejercicios, vas a empezar a construir un programa m\u00e1s largo. Trabaj\u00e1 en el archivo ejercicios_python/informe.py . Ejercicio 2.15: Lista de tuplas El archivo Data/camion.csv contiene la lista de cajones cargados en un cami\u00f3n. En el Ejercicio 2.6 de la secci\u00f3n anterior escribiste una funci\u00f3n costo_camion(nombre_archivo) que le\u00eda el archivo y realizaba un c\u00e1lculo. La funci\u00f3n deber\u00eda verse parecida a \u00e9sta: # fragmento de costo_camion.py import csv ... def costo_camion(nombre_archivo): '''Computa el precio total del camion (cajones * precio) de un archivo''' total = 0.0 with open(nombre_archivo, 'rt') as f: rows = csv.reader(f) headers = next(rows) for row in rows: ncajones = int(row[1]) precio = float(row[2]) total += ncajones * precio return total ... Usando este c\u00f3digo como gu\u00eda, cre\u00e1 un nuevo archivo informe.py . En este archivo, defin\u00ed una funci\u00f3n leer_camion(nombre_archivo) que abre un archivo con el contenido de un cami\u00f3n, lo lee y devuelve la informaci\u00f3n como una lista de tuplas. Para hacerlo vas a tener que hacer algunas modificaciones menores al c\u00f3digo de arriba. Primero, en vez de definir total = 0 , ten\u00e9s que empezar con una variable que empieza siendo una lista vac\u00eda Por ejemplo: camion = [] Despu\u00e9s, en vez de sumar el costo, ten\u00e9s que pasar cada fila a una tupla igual a como lo hiciste en el \u00faltimo ejercicio, y agregarla a la lista. Por ejemplo: for row in rows: lote = (row[0], int(row[1]), float(row[2])) camion.append(lote) Por \u00faltimo, la funci\u00f3n debe devolver la lista camion . Experiment\u00e1 con tu funci\u00f3n interactivamente (acordate de que primero ten\u00e9s que correr el programa informe.py en el int\u00e9rprete): Ayuda: Us\u00e1 -i para ejecutar un archivo en la terminal y quedar en el int\u00e9rprete >>> camion = leer_camion('../Data/camion.csv') >>> camion [('Lima', 100, 32.2), ('Naranja', 50, 91.1), ('Limon', 150, 83.44), ('Mandarina', 200, 51.23),('Durazno', 95, 40.37), ('Mandarina', 50, 65.1), ('Naranja', 100, 70.44)] >>> >>> camion[0] ('Lima', 100, 32.2) >>> camion[1] ('Naranja', 50, 91.1) >>> camion[1][1] 50 >>> total = 0.0 >>> for s in camion: total += s[1] * s[2] >>> print(total) 47671.15 >>> Esta lista de tuplas que creaste es muy similar a un array o matriz bidimensional. Por ejemplo, pod\u00e9s acceder a una fila espec\u00edfica y columna espec\u00edfica usando una b\u00fasqueda como camion[fila][columna] donde fila y columna son n\u00fameros enteros. Tambi\u00e9n pod\u00e9s reescribir el \u00faltimo ciclo for usando un comando como \u00e9ste: >>> total = 0.0 >>> for nombre, cajones, precio in camion: total += cajones*precio >>> print(total) 47671.15 >>> Observaci\u00f3n: la instrucci\u00f3n += es una abreviaci\u00f3n. Poner a += b es equivalente a poner a = a + b Ejercicio 2.16: Lista de diccionarios Tom\u00e1 la funci\u00f3n que escribiste en el ejercicio anterior y modificala para representar cada caj\u00f3n del cami\u00f3n con un diccionario en vez de una tupla. En este diccionario us\u00e1 los campos \"nombre\", \"cajones\" y \"precio\" para representar las diferentes columnas del archivo de entrada. Experiment\u00e1 con esta funci\u00f3n nueva igual que en el ejercicio anterior. >>> camion = leer_camion('../Data/camion.csv') >>> camion [{'nombre': 'Lima', 'cajones': 100, 'precio': 32.2}, {'nombre': 'Naranja', 'cajones': 50, 'precio': 91.1}, {'nombre': 'Limon', 'cajones': 150, 'precio': 83.44}, {'nombre': 'Mandarina', 'cajones': 200, 'precio': 51.23}, {'nombre': 'Durazno', 'cajones': 95, 'precio': 40.37}, {'nombre': 'Mandarina', 'cajones': 50, 'precio': 65.1}, {'nombre': 'Naranja', 'cajones': 100, 'precio': 70.44}] >>> camion[0] {'nombre': 'Lima', 'cajones': 100, 'precio': 32.2} >>> camion[1] {'nombre': 'Naranja', 'cajones': 50, 'precio': 91.1} >>> camion[1]['cajones'] 50 >>> total = 0.0 >>> for s in camion: total += s['cajones']*s['precio'] >>> print(total) 47671.15 >>> Fijate que ac\u00e1 los distintos campos para cada entrada se acceden a trav\u00e9s de claves en vez de la posici\u00f3n en la lista. Muchas veces preferimos esto porque el c\u00f3digo resulta m\u00e1s f\u00e1cil de leer. Tanto para otres como para nosotres en el futuro. Mirar diccionarios y listas muy grandes puede ser un l\u00edo. Para limpiar el output para debuguear, prob\u00e1 la funci\u00f3n pprint (Pretty-print) que le da un formato m\u00e1s sencillo de interpretar. >>> from pprint import pprint >>> pprint(camion) [{'nombre': 'Lima', 'precio': 32.2, 'cajones': 100}, {'nombre': 'Naranja', 'precio': 91.1, 'cajones': 50}, {'nombre': 'Limon', 'precio': 83.44, 'cajones': 150}, {'nombre': 'Mandarina', 'precio': 51.23, 'cajones': 200}, {'nombre': 'Durazno', 'precio': 40.37, 'cajones': 95}, {'nombre': 'Mandarina', 'precio': 65.1, 'cajones': 50}, {'nombre': 'Naranja', 'precio': 70.44, 'cajones': 100}] >>> Ejercicio 2.17: Diccionarios como contenedores Los diccionarios son \u00fatiles si quer\u00e9s buscar elementos usando \u00edndices que no sean n\u00fameros enteros. En la terminal de Python, jug\u00e1 con un diccionario: >>> precios = {} >>> precios['Naranja'] = 92.45 >>> precios['Mandarina'] = 45.12 >>> precios ... mir\u00e1 el resultado ... >>> precios['Naranja'] 92.45 >>> precios['Manzana'] ... mir\u00e1 el resultado ... >>> 'Manzana' in precios False >>> En el Ejercicio 2.7 escribiste una funci\u00f3n que busca el precio de una determinada fruta o verdura en el archivo ../Data/precios.csv . Esto es \u00fatil para saber sobre un producto en particular, pero si necesit\u00e1s tener los precios de toda la mercader\u00eda, no resulta pr\u00e1ctico abrir y cerrar el archivo para consultar cada precio. Por eso ahora te proponemos generar un diccionario que contenga todos los precios. En este diccionario, pod\u00e9s consultar luego los precios de cada producto. Escrib\u00ed una funci\u00f3n leer_precios(nombre_archivo) que a partir de un conjunto de precios como \u00e9ste arme un diccionario donde las claves sean los nombres de frutas y verduras, y los valores sean los precios por caj\u00f3n. Para hacerlo, empez\u00e1 con un diccionario vac\u00edo y and\u00e1 agreg\u00e1ndole valores igual a como hiciste antes, pero ahora esos valores los vas leyendo del archivo. Vamos a usar esta estructura de datos para buscar r\u00e1pidamente los precios de las frutas y verduras. Un par de consejos: Us\u00e1 el m\u00f3dulo csv igual que antes. >>> import csv >>> f = open('../Data/precios.csv', 'r') >>> rows = csv.reader(f) >>> for row in rows: print(row) ['Lima', '40.22'] ['Uva', '24.85'] ... [] >>> El archivo Data/precios.csv puede tener l\u00edneas en blanco, esto te puede traer complicaciones. Observ\u00e1 que arriba figura una lista vac\u00eda (la \u00faltima), porque la \u00faltima l\u00ednea del archivo no ten\u00eda datos. Puede suceder que esto haga que tu programa termine con una excepci\u00f3n. Us\u00e1 los comandos try y except para evitar el problema. Para pensar: \u00bfSer\u00eda mejor prevenir estos problemas con el comando if en vez de try y except ? Una vez que hayas escrito tu funci\u00f3n leer_precios() , testeala interactivamente para asegurarte de que funciona bien: >>> precios = leer_precios('../Data/precios.csv') >>> precios['Naranja'] 106.28 >>> precios['Mandarina'] 80.89 >>> Ejercicio 2.18: Balances Supongamos que los precios en camion.csv son los precios pagados al productor de frutas mientras que los precios en precios.csv son los precios de venta en el lugar de descarga del cami\u00f3n. Ahora vamos calcular el balance del negocio: junt\u00e1 todo el trabajo que hiciste reci\u00e9n en tu programa informe.py (usando las funciones leer_camion() y leer_precios() ) y complet\u00e1 el programa para que con los precios del cami\u00f3n ( Ejercicio 2.16 ) y los de venta en el negocio ( Ejercicio 2.17 ) calcule lo que cost\u00f3 el cami\u00f3n, lo que se recaud\u00f3 con la venta, y la diferencia. \u00bfHubo ganancia o p\u00e9rdida? El programa debe imprimir por pantalla un balance con estos datos. Contenidos | Anterior (3 Tipos y estructuras de datos) | Pr\u00f3ximo (5 Cierre de la clase)","title":"04 Contenedores"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#24-contenedores","text":"En esta secci\u00f3n trataremos listas, diccionarios y conjuntos.","title":"2.4 Contenedores"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#panorama","text":"Los programas suelen trabajar con muchos objetos. Un cami\u00f3n con cajones de fruta Una tabla de precios de cajones de fruta En Python hay tres opciones principales para elegir. Listas. Datos ordenados. Diccionarios. Datos desordenados. Conjuntos. Colecci\u00f3n desordenada de elementos \u00fanicos.","title":"Panorama"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#listas-como-contenedores","text":"Us\u00e1 listas cuando el orden de los datos importe. Acordate de que las listas pueden contener cualquier tipo de objeto. Por ejemplo, una lista de tuplas. camion = [ ('Pera', 100, 490.1), ('Naranja', 50, 91.3), ('Limon', 150, 83.44) ] camion[0] # ('Pera', 100, 490.1) camion[2] # ('Limon', 150, 83.44)","title":"Listas como contenedores"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#construccion-de-una-lista","text":"C\u00f3mo armar una lista desde cero. registros = [] # Empezamos con una lista vac\u00eda # Usamos el .append() para agregar elementos registros.append(('Pera', 100, 490.10)) registros.append(('Naranja', 50, 91.3)) ... Un ejemplo de c\u00f3mo cargar registros desde un archivo. registros = [] # Empezamos con una lista vac\u00eda with open('../Data/camion.csv', 'rt') as f: next(f) # Saltear el encabezado for line in f: row = line.split(',') registros.append((row[0], int(row[1]), float(row[2])))","title":"Construcci\u00f3n de una lista"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#diccionarios-como-contenedores","text":"Los diccionarios son \u00fatiles si vamos a querer buscar r\u00e1pidamente (por claves). Por ejemplo, un diccionario de precios de cajones. precios = { 'Pera': 513.25, 'Limon': 87.22, 'Naranja': 93.37, 'Mandarina': 44.12 } As\u00ed podemos buscar datos: >>> precios['Naranja'] 93.37 >>> precios['Pera'] 513.25 >>>","title":"Diccionarios como contenedores"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#construccion-de-diccionarios","text":"Ejemplo de armado de un diccionario desde cero. precios = {} # Empezamos con un diccionario vac\u00edo # Agregamos elementos precios['Pera'] = 513.25 precios['Limon'] = 87.22 precios['Naranja'] = 93.37 Un ejemplo de c\u00f3mo armar un diccionario a partir del contenido de un archivo. precios = {} # Empezamos con un diccionario vac\u00edo with open('../Data/precios.csv', 'rt') as f: for line in f: row = line.split(',') precios[row[0]] = float(row[1]) Nota: Si prob\u00e1s estos comandos en el archivo Data/precios.csv , vas a ver que casi anda. Pero hay una l\u00ednea en blanco al final que genera un error. Usando lo que ya vimos, en el Ejercicio 2.17 vas a tener que modificar el c\u00f3digo para resolver el problema.","title":"Construcci\u00f3n de diccionarios"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#busquedas-en-un-diccionario","text":"Pod\u00e9s verificar si una clave existe: if key in d: # YES else: # NO","title":"B\u00fasquedas en un diccionario"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#claves-compuestas","text":"Casi cualquier valor puede usarse como clave en un diccionario de Python. La principal restricci\u00f3n es que una clave debe ser de tipo inmutable. Por ejemplo, tuplas: feriados = { (1, 1) : 'A\u00f1o nuevo', (1, 5) : 'D\u00eda del trabajador', (13, 9) : \"D\u00eda del programador\", } Luego, podemos acceder al diccionario as\u00ed: >>> feriados[(1, 5)] 'D\u00eda del trabajador' >>> Las listas, los conjuntos y los diccionarios no pueden ser usados como claves de diccionarios, porque son mutables.","title":"Claves compuestas"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#conjuntos","text":"Un conjunto es una colecci\u00f3n de elementos \u00fanicos sin orden y sin repetici\u00f3n. citricos = { 'Naranja','Limon','Mandarina' } # Alternativamente podemos escribirlo as\u00ed: citricos = set(['Naranja', 'Limon', 'Mandarina']) Los conjuntos son \u00fatiles para evaluar pertenencia. >>> citricos set(['Naranja', 'Limon', 'Mandarina']) >>> 'Naranja' in citricos True >>> 'Manzana' in citricos False >>> Los conjuntos tambi\u00e9n son \u00fatiles para eliminar duplicados. nombres = ['Naranja', 'Manzana', 'Pera', 'Naranja', 'Pera', 'Banana'] unicos = set(nombres) # unicos = {'Manzana', 'Banana', 'Naranja', 'Pera'} M\u00e1s operaciones en conjuntos: citricos.add('Banana') # Agregar un elemento citricos.remove('Limon') # Eliminar un elemento s1 | s2 # Uni\u00f3n de conjuntos s1 y s2 s1 & s2 # Intersecci\u00f3n de conjuntos s1 - s2 # Diferencia de conjuntos","title":"Conjuntos"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#ejercicios","text":"En estos ejercicios, vas a empezar a construir un programa m\u00e1s largo. Trabaj\u00e1 en el archivo ejercicios_python/informe.py .","title":"Ejercicios"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#ejercicio-215-lista-de-tuplas","text":"El archivo Data/camion.csv contiene la lista de cajones cargados en un cami\u00f3n. En el Ejercicio 2.6 de la secci\u00f3n anterior escribiste una funci\u00f3n costo_camion(nombre_archivo) que le\u00eda el archivo y realizaba un c\u00e1lculo. La funci\u00f3n deber\u00eda verse parecida a \u00e9sta: # fragmento de costo_camion.py import csv ... def costo_camion(nombre_archivo): '''Computa el precio total del camion (cajones * precio) de un archivo''' total = 0.0 with open(nombre_archivo, 'rt') as f: rows = csv.reader(f) headers = next(rows) for row in rows: ncajones = int(row[1]) precio = float(row[2]) total += ncajones * precio return total ... Usando este c\u00f3digo como gu\u00eda, cre\u00e1 un nuevo archivo informe.py . En este archivo, defin\u00ed una funci\u00f3n leer_camion(nombre_archivo) que abre un archivo con el contenido de un cami\u00f3n, lo lee y devuelve la informaci\u00f3n como una lista de tuplas. Para hacerlo vas a tener que hacer algunas modificaciones menores al c\u00f3digo de arriba. Primero, en vez de definir total = 0 , ten\u00e9s que empezar con una variable que empieza siendo una lista vac\u00eda Por ejemplo: camion = [] Despu\u00e9s, en vez de sumar el costo, ten\u00e9s que pasar cada fila a una tupla igual a como lo hiciste en el \u00faltimo ejercicio, y agregarla a la lista. Por ejemplo: for row in rows: lote = (row[0], int(row[1]), float(row[2])) camion.append(lote) Por \u00faltimo, la funci\u00f3n debe devolver la lista camion . Experiment\u00e1 con tu funci\u00f3n interactivamente (acordate de que primero ten\u00e9s que correr el programa informe.py en el int\u00e9rprete): Ayuda: Us\u00e1 -i para ejecutar un archivo en la terminal y quedar en el int\u00e9rprete >>> camion = leer_camion('../Data/camion.csv') >>> camion [('Lima', 100, 32.2), ('Naranja', 50, 91.1), ('Limon', 150, 83.44), ('Mandarina', 200, 51.23),('Durazno', 95, 40.37), ('Mandarina', 50, 65.1), ('Naranja', 100, 70.44)] >>> >>> camion[0] ('Lima', 100, 32.2) >>> camion[1] ('Naranja', 50, 91.1) >>> camion[1][1] 50 >>> total = 0.0 >>> for s in camion: total += s[1] * s[2] >>> print(total) 47671.15 >>> Esta lista de tuplas que creaste es muy similar a un array o matriz bidimensional. Por ejemplo, pod\u00e9s acceder a una fila espec\u00edfica y columna espec\u00edfica usando una b\u00fasqueda como camion[fila][columna] donde fila y columna son n\u00fameros enteros. Tambi\u00e9n pod\u00e9s reescribir el \u00faltimo ciclo for usando un comando como \u00e9ste: >>> total = 0.0 >>> for nombre, cajones, precio in camion: total += cajones*precio >>> print(total) 47671.15 >>> Observaci\u00f3n: la instrucci\u00f3n += es una abreviaci\u00f3n. Poner a += b es equivalente a poner a = a + b","title":"Ejercicio 2.15: Lista de tuplas"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#ejercicio-216-lista-de-diccionarios","text":"Tom\u00e1 la funci\u00f3n que escribiste en el ejercicio anterior y modificala para representar cada caj\u00f3n del cami\u00f3n con un diccionario en vez de una tupla. En este diccionario us\u00e1 los campos \"nombre\", \"cajones\" y \"precio\" para representar las diferentes columnas del archivo de entrada. Experiment\u00e1 con esta funci\u00f3n nueva igual que en el ejercicio anterior. >>> camion = leer_camion('../Data/camion.csv') >>> camion [{'nombre': 'Lima', 'cajones': 100, 'precio': 32.2}, {'nombre': 'Naranja', 'cajones': 50, 'precio': 91.1}, {'nombre': 'Limon', 'cajones': 150, 'precio': 83.44}, {'nombre': 'Mandarina', 'cajones': 200, 'precio': 51.23}, {'nombre': 'Durazno', 'cajones': 95, 'precio': 40.37}, {'nombre': 'Mandarina', 'cajones': 50, 'precio': 65.1}, {'nombre': 'Naranja', 'cajones': 100, 'precio': 70.44}] >>> camion[0] {'nombre': 'Lima', 'cajones': 100, 'precio': 32.2} >>> camion[1] {'nombre': 'Naranja', 'cajones': 50, 'precio': 91.1} >>> camion[1]['cajones'] 50 >>> total = 0.0 >>> for s in camion: total += s['cajones']*s['precio'] >>> print(total) 47671.15 >>> Fijate que ac\u00e1 los distintos campos para cada entrada se acceden a trav\u00e9s de claves en vez de la posici\u00f3n en la lista. Muchas veces preferimos esto porque el c\u00f3digo resulta m\u00e1s f\u00e1cil de leer. Tanto para otres como para nosotres en el futuro. Mirar diccionarios y listas muy grandes puede ser un l\u00edo. Para limpiar el output para debuguear, prob\u00e1 la funci\u00f3n pprint (Pretty-print) que le da un formato m\u00e1s sencillo de interpretar. >>> from pprint import pprint >>> pprint(camion) [{'nombre': 'Lima', 'precio': 32.2, 'cajones': 100}, {'nombre': 'Naranja', 'precio': 91.1, 'cajones': 50}, {'nombre': 'Limon', 'precio': 83.44, 'cajones': 150}, {'nombre': 'Mandarina', 'precio': 51.23, 'cajones': 200}, {'nombre': 'Durazno', 'precio': 40.37, 'cajones': 95}, {'nombre': 'Mandarina', 'precio': 65.1, 'cajones': 50}, {'nombre': 'Naranja', 'precio': 70.44, 'cajones': 100}] >>>","title":"Ejercicio 2.16: Lista de diccionarios"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#ejercicio-217-diccionarios-como-contenedores","text":"Los diccionarios son \u00fatiles si quer\u00e9s buscar elementos usando \u00edndices que no sean n\u00fameros enteros. En la terminal de Python, jug\u00e1 con un diccionario: >>> precios = {} >>> precios['Naranja'] = 92.45 >>> precios['Mandarina'] = 45.12 >>> precios ... mir\u00e1 el resultado ... >>> precios['Naranja'] 92.45 >>> precios['Manzana'] ... mir\u00e1 el resultado ... >>> 'Manzana' in precios False >>> En el Ejercicio 2.7 escribiste una funci\u00f3n que busca el precio de una determinada fruta o verdura en el archivo ../Data/precios.csv . Esto es \u00fatil para saber sobre un producto en particular, pero si necesit\u00e1s tener los precios de toda la mercader\u00eda, no resulta pr\u00e1ctico abrir y cerrar el archivo para consultar cada precio. Por eso ahora te proponemos generar un diccionario que contenga todos los precios. En este diccionario, pod\u00e9s consultar luego los precios de cada producto. Escrib\u00ed una funci\u00f3n leer_precios(nombre_archivo) que a partir de un conjunto de precios como \u00e9ste arme un diccionario donde las claves sean los nombres de frutas y verduras, y los valores sean los precios por caj\u00f3n. Para hacerlo, empez\u00e1 con un diccionario vac\u00edo y and\u00e1 agreg\u00e1ndole valores igual a como hiciste antes, pero ahora esos valores los vas leyendo del archivo. Vamos a usar esta estructura de datos para buscar r\u00e1pidamente los precios de las frutas y verduras. Un par de consejos: Us\u00e1 el m\u00f3dulo csv igual que antes. >>> import csv >>> f = open('../Data/precios.csv', 'r') >>> rows = csv.reader(f) >>> for row in rows: print(row) ['Lima', '40.22'] ['Uva', '24.85'] ... [] >>> El archivo Data/precios.csv puede tener l\u00edneas en blanco, esto te puede traer complicaciones. Observ\u00e1 que arriba figura una lista vac\u00eda (la \u00faltima), porque la \u00faltima l\u00ednea del archivo no ten\u00eda datos. Puede suceder que esto haga que tu programa termine con una excepci\u00f3n. Us\u00e1 los comandos try y except para evitar el problema. Para pensar: \u00bfSer\u00eda mejor prevenir estos problemas con el comando if en vez de try y except ? Una vez que hayas escrito tu funci\u00f3n leer_precios() , testeala interactivamente para asegurarte de que funciona bien: >>> precios = leer_precios('../Data/precios.csv') >>> precios['Naranja'] 106.28 >>> precios['Mandarina'] 80.89 >>>","title":"Ejercicio 2.17: Diccionarios como contenedores"},{"location":"02_Estructuras_y_Funciones/04_Contenedores/#ejercicio-218-balances","text":"Supongamos que los precios en camion.csv son los precios pagados al productor de frutas mientras que los precios en precios.csv son los precios de venta en el lugar de descarga del cami\u00f3n. Ahora vamos calcular el balance del negocio: junt\u00e1 todo el trabajo que hiciste reci\u00e9n en tu programa informe.py (usando las funciones leer_camion() y leer_precios() ) y complet\u00e1 el programa para que con los precios del cami\u00f3n ( Ejercicio 2.16 ) y los de venta en el negocio ( Ejercicio 2.17 ) calcule lo que cost\u00f3 el cami\u00f3n, lo que se recaud\u00f3 con la venta, y la diferencia. \u00bfHubo ganancia o p\u00e9rdida? El programa debe imprimir por pantalla un balance con estos datos. Contenidos | Anterior (3 Tipos y estructuras de datos) | Pr\u00f3ximo (5 Cierre de la clase)","title":"Ejercicio 2.18: Balances"},{"location":"02_Estructuras_y_Funciones/05_CierreClase/","text":"Contenidos | Anterior (4 Contenedores) 2.5 Cierre de la clase En esta clase comenzamos a trabajar con funciones y estructuras de datos. Te recordamos que leas el c\u00f3digo de honor del curso en el que hablamos de las reglas que rigen en este curso para evitar el plagio as\u00ed como otros aspectos importantes sobre qu\u00e9 se puede compartir y qu\u00e9 no. Al enviar tus archivos entendemos que le\u00edste y est\u00e1s de acuerdo con este texto. En caso contrario no env\u00edes tus archivos y contactate con les docentes. Para cerrar esta clase te pedimos dos cosas: Que recopiles las soluciones de los siguientes ejercicios: El archivo buscar_precios.py del Ejercicio 2.7 . El archivo costo_camion.py del Ejercicio 2.9 . El archivo camion_commandline.py del Ejercicio 2.10 . El archivo diccionario_geringoso.py del Ejercicio 2.14 . El archivo informe.py del Ejercicio 2.18 . Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y tendr\u00e1s la opci\u00f3n de participar en la revisi\u00f3n de pares. Esperamos que entregues como m\u00ednimo tres archivos de los que te pedimos. Acordate, us\u00e1 siempre la misma direcci\u00f3n de mail con la que te inscribiste al curso as\u00ed podemos llevar registro de tus entregas. Observaci\u00f3n: Si el enunciado de un ejercicio te pide que lo corras con un input particular, por favor pon\u00e9 la salida que obtuviste como comentario en tu c\u00f3digo. Por \u00faltimo te recordamos que si te quedaron dudas, quer\u00e9s discutir alg\u00fan tema de inter\u00e9s o pedirnos a los docentes que resolvamos un ejercicio particular para la pr\u00f3xima clase, pod\u00e9s hacelo en el grupo de Slack . Contenidos | Anterior (4 Contenedores)","title":"05 CierreClase"},{"location":"02_Estructuras_y_Funciones/05_CierreClase/#25-cierre-de-la-clase","text":"En esta clase comenzamos a trabajar con funciones y estructuras de datos. Te recordamos que leas el c\u00f3digo de honor del curso en el que hablamos de las reglas que rigen en este curso para evitar el plagio as\u00ed como otros aspectos importantes sobre qu\u00e9 se puede compartir y qu\u00e9 no. Al enviar tus archivos entendemos que le\u00edste y est\u00e1s de acuerdo con este texto. En caso contrario no env\u00edes tus archivos y contactate con les docentes. Para cerrar esta clase te pedimos dos cosas: Que recopiles las soluciones de los siguientes ejercicios: El archivo buscar_precios.py del Ejercicio 2.7 . El archivo costo_camion.py del Ejercicio 2.9 . El archivo camion_commandline.py del Ejercicio 2.10 . El archivo diccionario_geringoso.py del Ejercicio 2.14 . El archivo informe.py del Ejercicio 2.18 . Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y tendr\u00e1s la opci\u00f3n de participar en la revisi\u00f3n de pares. Esperamos que entregues como m\u00ednimo tres archivos de los que te pedimos. Acordate, us\u00e1 siempre la misma direcci\u00f3n de mail con la que te inscribiste al curso as\u00ed podemos llevar registro de tus entregas. Observaci\u00f3n: Si el enunciado de un ejercicio te pide que lo corras con un input particular, por favor pon\u00e9 la salida que obtuviste como comentario en tu c\u00f3digo. Por \u00faltimo te recordamos que si te quedaron dudas, quer\u00e9s discutir alg\u00fan tema de inter\u00e9s o pedirnos a los docentes que resolvamos un ejercicio particular para la pr\u00f3xima clase, pod\u00e9s hacelo en el grupo de Slack . Contenidos | Anterior (4 Contenedores)","title":"2.5 Cierre de la clase"},{"location":"03_Datos/00_Resumen/","text":"Contenidos | Anterior (2 Estructuras y funciones) | Pr\u00f3ximo (4 Algoritmos sobre listas y comprensi\u00f3n de listas) 3. Trabajando con datos En esta clase discutimos los tipos de errores que pueden aparecer en un programa (bugs) e introducimos algunas t\u00e9cnicas primitivas para buscarlos. Para escribir programas \u00fatiles, necesitamos aprender a trabajar con datos. En esta clase vas a escribir un programa que lee un archivo de datos en formato csv y realiza un c\u00e1lculo simple. Vas a aprender a estructurar tu c\u00f3digo creando funciones y estructuras de datos un poco m\u00e1s complejas como tuplas, conjuntos y diccionarios. Esta clase comenzamos a utilizar un entorno de desarrollo integrado (IDE). Vamos a trabajar con datos reales sobre los \u00e1rboles de la ciudad de Buenos Aires en espacios p\u00fablicos. Record\u00e1 que, aunque no termines todos, completar el formulario del final de cada clase y entregar los ejercicios es parte de las condiciones de aprobaci\u00f3n de la materia (todes nos podemos atrasar alguna vez, pero en general esperamos que entregues). Esto debe hacerse ANTES de la clase siguiente. 3.1 Errores 3.2 Secuencias 3.3 Contadores del m\u00f3dulo collections 3.4 Entorno de desarrollo integrado 3.5 Impresi\u00f3n con formato 3.6 Arbolado porte\u00f1o 3.7 Cierre de la clase Contenidos | Anterior (2 Estructuras y funciones) | Pr\u00f3ximo (4 Algoritmos sobre listas y comprensi\u00f3n de listas)","title":"00 Resumen"},{"location":"03_Datos/00_Resumen/#3-trabajando-con-datos","text":"En esta clase discutimos los tipos de errores que pueden aparecer en un programa (bugs) e introducimos algunas t\u00e9cnicas primitivas para buscarlos. Para escribir programas \u00fatiles, necesitamos aprender a trabajar con datos. En esta clase vas a escribir un programa que lee un archivo de datos en formato csv y realiza un c\u00e1lculo simple. Vas a aprender a estructurar tu c\u00f3digo creando funciones y estructuras de datos un poco m\u00e1s complejas como tuplas, conjuntos y diccionarios. Esta clase comenzamos a utilizar un entorno de desarrollo integrado (IDE). Vamos a trabajar con datos reales sobre los \u00e1rboles de la ciudad de Buenos Aires en espacios p\u00fablicos. Record\u00e1 que, aunque no termines todos, completar el formulario del final de cada clase y entregar los ejercicios es parte de las condiciones de aprobaci\u00f3n de la materia (todes nos podemos atrasar alguna vez, pero en general esperamos que entregues). Esto debe hacerse ANTES de la clase siguiente. 3.1 Errores 3.2 Secuencias 3.3 Contadores del m\u00f3dulo collections 3.4 Entorno de desarrollo integrado 3.5 Impresi\u00f3n con formato 3.6 Arbolado porte\u00f1o 3.7 Cierre de la clase Contenidos | Anterior (2 Estructuras y funciones) | Pr\u00f3ximo (4 Algoritmos sobre listas y comprensi\u00f3n de listas)","title":"3. Trabajando con datos"},{"location":"03_Datos/01_Bugs/","text":"Contenidos | Pr\u00f3ximo (2 Secuencias) 3.1 Errores Tres tipos de errores: Programando nos podemos encontrar con tres tipos de errores. Los errores sint\u00e1cticos son los que se dan cuando escribimos incorrectamente. Por ejemplo si queremos escribir x = (a + b) * c pero en vez de eso escribimos x = (a + b] * c , el programa no va a correr. Un segundo tipo de error lo forman los errores en tiempo de ejecuci\u00f3n , que se dan cuando el programa empieza a ejecutarse pero se produce un error durante su ejecuci\u00f3n. Por ejemplo si le pedimos al usuarie que ingrese su edad esperando un n\u00famero entero e ingresa \"veintis\u00e9is a\u00f1os\", es probable que el programa d\u00e9 un error. Si leemos un archivo CSV y una fila tiene datos faltantes, el programa puede dar un error. Este tipo de errores en Python generan excepciones que, como veremos m\u00e1s adelante, pueden administrarse adecuadamente. El tercer tipo de error es el m\u00e1s dif\u00edcil de encontrar y de entender. Son los errores sem\u00e1nticos , que se dan cuando el programa no hace lo que est\u00e1 dise\u00f1ado para hacer. Tienen que ver con el sentido de las instrucciones. En estos casos el programa se ejecuta pero da un resultado incorrecto o inesperado. En general, la mejor forma de encontrar estos errores es correr paso a paso el c\u00f3digo que genera un resultado inesperado, tratando de entender d\u00f3nde est\u00e1 la falla, usando el debugger. Veremos c\u00f3mo usar el debugger la clase que viene, por ahora trabajaremos de forma un poco m\u00e1s primitiva. Debuggear a mano Los errores (o bugs) son dif\u00edciles de rastrear y resolver. Especialmente errores que s\u00f3lo aparecen bajo cierta combinaci\u00f3n particular de condiciones que resulta en que el programa no pueda continuar o d\u00e9 un resultado inesperado. Si tu programa corre, pero no da el resultado que esper\u00e1s, o se cuelga y no entend\u00e9s porqu\u00e9, ten\u00e9s algunas herramientas concretas que te ayudan a buscar el origen del problema. A continuaci\u00f3n veremos algunas metodolog\u00edas espec\u00edficas (aunque un poco primitivas) que permiten rastrear el origen del problema. \u00bfQu\u00e9 dice un traceback? Si te da un error, lo primero que pod\u00e9s hacer es intentar entender la causa del error usando como punto de partida el \"traceback\": python3 blah.py Traceback (most recent call last): File \"blah.py\", line 13, in ? foo() File \"blah.py\", line 10, in foo bar() File \"blah.py\", line 7, in bar spam() File \"blah.py\", line 4, in spam x.append(3) AttributeError: 'int' object has no attribute 'append' La \u00faltima l\u00ednea dice algo como que \"el objeto int no tiene un atributo append \"- lo cual es obvio, pero \u00bfc\u00f3mo llegamos ah\u00ed? La \u00faltima l\u00ednea es el motivo concreto del error. Las l\u00edneas anteriores te dicen el camino que sigui\u00f3 el programa hasta llegar al error. En este caso: el error ocurri\u00f3 en x.append(3) en la l\u00ednea 4, dentro de la funci\u00f3n spam del m\u00f3dulo \"blah.py\" , que fue llamado por la funci\u00f3n bar en la l\u00ednea 7 del mismo archivo, que fue llamada por... y as\u00ed siguiendo. Sin embargo a veces esto no proporciona suficiente informaci\u00f3n (por ejemplo, no sabemos el valor de cada par\u00e1metro usado en las llamadas). Una posibilidad que a veces da resultado es copiar el traceback en Google. Si est\u00e1s usando una biblioteca de funciones que mucha gente usa (como numpy \u00f3 math ) es muy probable que alguien se haya encontrado antes con el mismo problema que vos, y alguien m\u00e1s le haya explicado qu\u00e9 lo causa, o c\u00f3mo evitarlo. Us\u00e1 el modo REPL de Python Si us\u00e1s Python desde la l\u00ednea de comandos, pod\u00e9s usarlo pas\u00e1ndole un -i como par\u00e1metro antes del script a ejecutar. Cuando el int\u00e9rprete de Python termine de ejecutar el script se va a quedar en modo interactivo (en lugar de volver al sistema operativo). Pod\u00e9s averiguar en qu\u00e9 estado qued\u00f3 el sistema. python3 -i blah.py Traceback (most recent call last): File \"blah.py\", line 13, in ? foo() File \"blah.py\", line 10, in foo bar() File \"blah.py\", line 7, in bar spam() File \"blah.py\", line 4, in spam x.append(3) AttributeError: 'int' object has no attribute 'append' >>> print( repr(x) ) Este par\u00e1metro (el -i , que ya usamos antes) preserva el estado del int\u00e9rprete al finalizar el script y te permite interrogarlo sobre el estado de las variables y obtener informaci\u00f3n que de otro modo perder\u00edas. En el ejemplo de reci\u00e9n interesa saber qu\u00e9 es x y c\u00f3mo lleg\u00f3 a ese estado. Si est\u00e1s usando un IDE esta posibilidad de interacci\u00f3n suele ocurrir naturalmente. Debuggear con print print() es una forma r\u00e1pida y sencilla de permitir que el programa se ejecute (casi) normalmente mientras te da informaci\u00f3n del estado de las variables. Si eleg\u00eds bien las variables que mostrar, es probable que digas \"\u00a1\u00a1Aj\u00e1!!\". Sugerencia: es conveniente usar repr() para imprimir las variables def spam(x): print('DEBUG:', repr(x)) ... repr() te muestra una representaci\u00f3n t\u00e9cnicamente m\u00e1s precisa del valor de una variable, y no la representaci\u00f3n bonita que solemos ver. >>> from decimal import Decimal >>> x = Decimal('3.4') # SIN `repr` >>> print(x) 3.4 # CON `repr` >>> print(repr(x)) Decimal('3.4') >>> Debuggear con l\u00e1piz y papel Muchas veces uno asume que el int\u00e9rprete est\u00e1 haciendo algo. Si agarr\u00e1s un l\u00e1piz y un papel y hac\u00e9s de int\u00e9rprete anotando el estado de cada variable y siguiendo las instrucciones del programa paso a paso, es posible que entiendas que las cosas no son como cre\u00edas. Estas alternativas son \u00fatiles pero un poco primitivas. La mejor forma de debuggear un programa en Python es usar el debugger. Ejercicios: En los siguientes ejercicios te proponemos que uses las t\u00e9cnicas que mencionamos arriba para resolver los problemas que aparecen a continuaci\u00f3n. Determin\u00e1 los errores de los siguientes c\u00f3digos y corregilos en un archivo solucion_de_errores.py comentando brevemente los errores. \u00bfQu\u00e9 tipo de errores tiene cada uno? En el archivo solucion_de_errores.py separ\u00e1 las correcciones de los distintos c\u00f3digos con una l\u00ednea que contenga solamente los s\u00edmbolos #%% seguido de una o varias l\u00edneas comentadas indicando el ejercicio y el problema que ten\u00eda. Al terminar, deber\u00eda verse as\u00ed tu archivo: #solucion_de_errores.py #Ejercicios de errores en el c\u00f3digo #%% #Ejercicio 3.1. Funci\u00f3n tiene_a() #Comentario: El error era de TAL tipo y estaba ubicado en TAL lugar. # Lo correg\u00ed cambiando esto por aquello. # A continuaci\u00f3n va el c\u00f3digo corregido ... ... #%% #Ejercicio 3.2. Funci\u00f3n tiene_a(), nuevamente #Comentario: El error era de TAL tipo y estaba ubicado en TAL lugar. ... ... #%% #Ejercicio 3.3. Funci\u00f3n tiene_uno() #Comentario: El error era de TAL tipo y estaba ubicado en TAL lugar. ... ... ... Ejercicio 3.1: Sem\u00e1ntica \u00bfAnda bien en todos los casos de prueba? def tiene_a(expresion): n = len(expresion) i = 0 while i<n: if expresion[i] == 'a': return True else: return False i += 1 tiene_a('UNSAM 2020') tiene_a('abracadabra') tiene_a('La novela 1984 de George Orwell') Ejercicio 3.2: Sintaxis \u00bfAnda bien en todos los casos de prueba? def tiene_a(expresion) n = len(expresion) i = 0 while i<n if expresion[i] = 'a' return True i += 1 return Falso tiene_a('UNSAM 2020') tiene_a('La novela 1984 de George Orwell') Ejercicio 3.3: Tipos \u00bfAnda bien en todos los casos de prueba? def tiene_uno(expresion): n = len(expresion) i = 0 tiene = False while (i<n) and not tiene: if expresion[i] == '1': tiene = True i += 1 return tiene tiene_uno('UNSAM 2020') tiene_uno('La novela 1984 de George Orwell') tiene_uno(1984) Ejercicio 3.4: Alcances La siguiente suma no da lo que deber\u00eda: def suma(a,b): c = a + b a = 2 b = 3 c = suma(a,b) print(f\"La suma da {a} + {b} = {c}\") Ejercicio 3.5: Pisando memoria El siguiente ejemplo usa el dataset de la clase anterior, pero no lo imprime como corresponde, \u00bfpod\u00e9s determinar por qu\u00e9 y explicarlo brevemente en la versi\u00f3n corregida? import csv from pprint import pprint def leer_camion(nombre_archivo): camion=[] registro={} with open(nombre_archivo,\"rt\") as f: filas = csv.reader(f) encabezado = next(filas) for fila in filas: registro[encabezado[0]] = fila[0] registro[encabezado[1]] = int(fila[1]) registro[encabezado[2]] = float(fila[2]) camion.append(registro) return camion camion = leer_camion('../Data/camion.csv') pprint(camion) Ayuda: Primero trat\u00e1 de pensarlo, pero si este \u00faltimo se te hace muy dif\u00edcil, pod\u00e9s mirar un poco de la teor\u00eda relacionada con esto un par de secciones m\u00e1s adelante ( Secci\u00f3n 4.4 ). Contenidos | Pr\u00f3ximo (2 Secuencias)","title":"01 Bugs"},{"location":"03_Datos/01_Bugs/#31-errores","text":"","title":"3.1 Errores"},{"location":"03_Datos/01_Bugs/#tres-tipos-de-errores","text":"Programando nos podemos encontrar con tres tipos de errores. Los errores sint\u00e1cticos son los que se dan cuando escribimos incorrectamente. Por ejemplo si queremos escribir x = (a + b) * c pero en vez de eso escribimos x = (a + b] * c , el programa no va a correr. Un segundo tipo de error lo forman los errores en tiempo de ejecuci\u00f3n , que se dan cuando el programa empieza a ejecutarse pero se produce un error durante su ejecuci\u00f3n. Por ejemplo si le pedimos al usuarie que ingrese su edad esperando un n\u00famero entero e ingresa \"veintis\u00e9is a\u00f1os\", es probable que el programa d\u00e9 un error. Si leemos un archivo CSV y una fila tiene datos faltantes, el programa puede dar un error. Este tipo de errores en Python generan excepciones que, como veremos m\u00e1s adelante, pueden administrarse adecuadamente. El tercer tipo de error es el m\u00e1s dif\u00edcil de encontrar y de entender. Son los errores sem\u00e1nticos , que se dan cuando el programa no hace lo que est\u00e1 dise\u00f1ado para hacer. Tienen que ver con el sentido de las instrucciones. En estos casos el programa se ejecuta pero da un resultado incorrecto o inesperado. En general, la mejor forma de encontrar estos errores es correr paso a paso el c\u00f3digo que genera un resultado inesperado, tratando de entender d\u00f3nde est\u00e1 la falla, usando el debugger. Veremos c\u00f3mo usar el debugger la clase que viene, por ahora trabajaremos de forma un poco m\u00e1s primitiva.","title":"Tres tipos de errores:"},{"location":"03_Datos/01_Bugs/#debuggear-a-mano","text":"Los errores (o bugs) son dif\u00edciles de rastrear y resolver. Especialmente errores que s\u00f3lo aparecen bajo cierta combinaci\u00f3n particular de condiciones que resulta en que el programa no pueda continuar o d\u00e9 un resultado inesperado. Si tu programa corre, pero no da el resultado que esper\u00e1s, o se cuelga y no entend\u00e9s porqu\u00e9, ten\u00e9s algunas herramientas concretas que te ayudan a buscar el origen del problema. A continuaci\u00f3n veremos algunas metodolog\u00edas espec\u00edficas (aunque un poco primitivas) que permiten rastrear el origen del problema.","title":"Debuggear a mano"},{"location":"03_Datos/01_Bugs/#que-dice-un-traceback","text":"Si te da un error, lo primero que pod\u00e9s hacer es intentar entender la causa del error usando como punto de partida el \"traceback\": python3 blah.py Traceback (most recent call last): File \"blah.py\", line 13, in ? foo() File \"blah.py\", line 10, in foo bar() File \"blah.py\", line 7, in bar spam() File \"blah.py\", line 4, in spam x.append(3) AttributeError: 'int' object has no attribute 'append' La \u00faltima l\u00ednea dice algo como que \"el objeto int no tiene un atributo append \"- lo cual es obvio, pero \u00bfc\u00f3mo llegamos ah\u00ed? La \u00faltima l\u00ednea es el motivo concreto del error. Las l\u00edneas anteriores te dicen el camino que sigui\u00f3 el programa hasta llegar al error. En este caso: el error ocurri\u00f3 en x.append(3) en la l\u00ednea 4, dentro de la funci\u00f3n spam del m\u00f3dulo \"blah.py\" , que fue llamado por la funci\u00f3n bar en la l\u00ednea 7 del mismo archivo, que fue llamada por... y as\u00ed siguiendo. Sin embargo a veces esto no proporciona suficiente informaci\u00f3n (por ejemplo, no sabemos el valor de cada par\u00e1metro usado en las llamadas). Una posibilidad que a veces da resultado es copiar el traceback en Google. Si est\u00e1s usando una biblioteca de funciones que mucha gente usa (como numpy \u00f3 math ) es muy probable que alguien se haya encontrado antes con el mismo problema que vos, y alguien m\u00e1s le haya explicado qu\u00e9 lo causa, o c\u00f3mo evitarlo.","title":"\u00bfQu\u00e9 dice un traceback?"},{"location":"03_Datos/01_Bugs/#usa-el-modo-repl-de-python","text":"Si us\u00e1s Python desde la l\u00ednea de comandos, pod\u00e9s usarlo pas\u00e1ndole un -i como par\u00e1metro antes del script a ejecutar. Cuando el int\u00e9rprete de Python termine de ejecutar el script se va a quedar en modo interactivo (en lugar de volver al sistema operativo). Pod\u00e9s averiguar en qu\u00e9 estado qued\u00f3 el sistema. python3 -i blah.py Traceback (most recent call last): File \"blah.py\", line 13, in ? foo() File \"blah.py\", line 10, in foo bar() File \"blah.py\", line 7, in bar spam() File \"blah.py\", line 4, in spam x.append(3) AttributeError: 'int' object has no attribute 'append' >>> print( repr(x) ) Este par\u00e1metro (el -i , que ya usamos antes) preserva el estado del int\u00e9rprete al finalizar el script y te permite interrogarlo sobre el estado de las variables y obtener informaci\u00f3n que de otro modo perder\u00edas. En el ejemplo de reci\u00e9n interesa saber qu\u00e9 es x y c\u00f3mo lleg\u00f3 a ese estado. Si est\u00e1s usando un IDE esta posibilidad de interacci\u00f3n suele ocurrir naturalmente.","title":"Us\u00e1 el modo REPL de Python"},{"location":"03_Datos/01_Bugs/#debuggear-con-print","text":"print() es una forma r\u00e1pida y sencilla de permitir que el programa se ejecute (casi) normalmente mientras te da informaci\u00f3n del estado de las variables. Si eleg\u00eds bien las variables que mostrar, es probable que digas \"\u00a1\u00a1Aj\u00e1!!\". Sugerencia: es conveniente usar repr() para imprimir las variables def spam(x): print('DEBUG:', repr(x)) ... repr() te muestra una representaci\u00f3n t\u00e9cnicamente m\u00e1s precisa del valor de una variable, y no la representaci\u00f3n bonita que solemos ver. >>> from decimal import Decimal >>> x = Decimal('3.4') # SIN `repr` >>> print(x) 3.4 # CON `repr` >>> print(repr(x)) Decimal('3.4') >>>","title":"Debuggear con print"},{"location":"03_Datos/01_Bugs/#debuggear-con-lapiz-y-papel","text":"Muchas veces uno asume que el int\u00e9rprete est\u00e1 haciendo algo. Si agarr\u00e1s un l\u00e1piz y un papel y hac\u00e9s de int\u00e9rprete anotando el estado de cada variable y siguiendo las instrucciones del programa paso a paso, es posible que entiendas que las cosas no son como cre\u00edas. Estas alternativas son \u00fatiles pero un poco primitivas. La mejor forma de debuggear un programa en Python es usar el debugger.","title":"Debuggear con l\u00e1piz y papel"},{"location":"03_Datos/01_Bugs/#ejercicios","text":"En los siguientes ejercicios te proponemos que uses las t\u00e9cnicas que mencionamos arriba para resolver los problemas que aparecen a continuaci\u00f3n. Determin\u00e1 los errores de los siguientes c\u00f3digos y corregilos en un archivo solucion_de_errores.py comentando brevemente los errores. \u00bfQu\u00e9 tipo de errores tiene cada uno? En el archivo solucion_de_errores.py separ\u00e1 las correcciones de los distintos c\u00f3digos con una l\u00ednea que contenga solamente los s\u00edmbolos #%% seguido de una o varias l\u00edneas comentadas indicando el ejercicio y el problema que ten\u00eda. Al terminar, deber\u00eda verse as\u00ed tu archivo: #solucion_de_errores.py #Ejercicios de errores en el c\u00f3digo #%% #Ejercicio 3.1. Funci\u00f3n tiene_a() #Comentario: El error era de TAL tipo y estaba ubicado en TAL lugar. # Lo correg\u00ed cambiando esto por aquello. # A continuaci\u00f3n va el c\u00f3digo corregido ... ... #%% #Ejercicio 3.2. Funci\u00f3n tiene_a(), nuevamente #Comentario: El error era de TAL tipo y estaba ubicado en TAL lugar. ... ... #%% #Ejercicio 3.3. Funci\u00f3n tiene_uno() #Comentario: El error era de TAL tipo y estaba ubicado en TAL lugar. ... ... ...","title":"Ejercicios:"},{"location":"03_Datos/01_Bugs/#ejercicio-31-semantica","text":"\u00bfAnda bien en todos los casos de prueba? def tiene_a(expresion): n = len(expresion) i = 0 while i<n: if expresion[i] == 'a': return True else: return False i += 1 tiene_a('UNSAM 2020') tiene_a('abracadabra') tiene_a('La novela 1984 de George Orwell')","title":"Ejercicio 3.1: Sem\u00e1ntica"},{"location":"03_Datos/01_Bugs/#ejercicio-32-sintaxis","text":"\u00bfAnda bien en todos los casos de prueba? def tiene_a(expresion) n = len(expresion) i = 0 while i<n if expresion[i] = 'a' return True i += 1 return Falso tiene_a('UNSAM 2020') tiene_a('La novela 1984 de George Orwell')","title":"Ejercicio 3.2: Sintaxis"},{"location":"03_Datos/01_Bugs/#ejercicio-33-tipos","text":"\u00bfAnda bien en todos los casos de prueba? def tiene_uno(expresion): n = len(expresion) i = 0 tiene = False while (i<n) and not tiene: if expresion[i] == '1': tiene = True i += 1 return tiene tiene_uno('UNSAM 2020') tiene_uno('La novela 1984 de George Orwell') tiene_uno(1984)","title":"Ejercicio 3.3: Tipos"},{"location":"03_Datos/01_Bugs/#ejercicio-34-alcances","text":"La siguiente suma no da lo que deber\u00eda: def suma(a,b): c = a + b a = 2 b = 3 c = suma(a,b) print(f\"La suma da {a} + {b} = {c}\")","title":"Ejercicio 3.4: Alcances"},{"location":"03_Datos/01_Bugs/#ejercicio-35-pisando-memoria","text":"El siguiente ejemplo usa el dataset de la clase anterior, pero no lo imprime como corresponde, \u00bfpod\u00e9s determinar por qu\u00e9 y explicarlo brevemente en la versi\u00f3n corregida? import csv from pprint import pprint def leer_camion(nombre_archivo): camion=[] registro={} with open(nombre_archivo,\"rt\") as f: filas = csv.reader(f) encabezado = next(filas) for fila in filas: registro[encabezado[0]] = fila[0] registro[encabezado[1]] = int(fila[1]) registro[encabezado[2]] = float(fila[2]) camion.append(registro) return camion camion = leer_camion('../Data/camion.csv') pprint(camion) Ayuda: Primero trat\u00e1 de pensarlo, pero si este \u00faltimo se te hace muy dif\u00edcil, pod\u00e9s mirar un poco de la teor\u00eda relacionada con esto un par de secciones m\u00e1s adelante ( Secci\u00f3n 4.4 ). Contenidos | Pr\u00f3ximo (2 Secuencias)","title":"Ejercicio 3.5: Pisando memoria"},{"location":"03_Datos/02_Secuencias/","text":"Contenidos | Anterior (1 Errores) | Pr\u00f3ximo (3 Contadores del m\u00f3dulo collections ) 3.2 Secuencias Tipo de secuencias Python tiene tres tipos de datos que son secuencias . String: 'Hello' . Una cadena es una secuencia de caracteres. Lista: [1, 4, 5] . Tupla: ('Pera', 100, 490.1) . Todas las secuencias tienen un orden, indexado por enteros, y tienen una longitud. a = 'Hello' # String o cadena b = [1, 4, 5] # Lista c = ('Pera', 100, 490.1) # Tupla # Orden indexado a[0] # 'H' b[-1] # 5 c[1] # 100 # Longitud de secuencias len(a) # 5 len(b) # 3 len(c) # 3 Las secuencias pueden ser replicadas: s * n . >>> a = 'Hello' >>> a * 3 'HelloHelloHello' >>> b = [1, 2, 3] >>> b * 2 [1, 2, 3, 1, 2, 3] >>> Las secuencias del mismo tipo tambi\u00e9n pueden ser concatenadas: s + t . >>> a = (1, 2, 3) >>> b = (4, 5) >>> a + b (1, 2, 3, 4, 5) >>> >>> c = [1, 5] >>> a + c Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can only concatenate tuple (not \"list\") to tuple Rebanadas (slicing) Sacar una rebanada es tomar una subsecuencia de una secuencia. La sintaxis es s[comienzo:fin] , donde comienzo y fin son los \u00edndices de la subsecuencia que quer\u00e9s. a = [0,1,2,3,4,5,6,7,8] a[2:5] # [2,3,4] a[-5:] # [4,5,6,7,8] a[:3] # [0,1,2] Los \u00edndices comienzo y fin deben ser enteros. Las rebanadas no incluyen el valor final. Es como los intervalos semi-abiertos en matem\u00e1tica. Si los \u00edndices son omitidos toman sus valores por defecto: el principio o el final de la lista. Reasigaci\u00f3n de rebanadas En listas, una rebanada puede ser reasignada o eliminada. # Reasignaci\u00f3n a = [0,1,2,3,4,5,6,7,8] a[2:4] = [10,11,12] # [0,1,10,11,12,4,5,6,7,8] Observaci\u00f3n: La rebanada reasignada no tiene que tener necesariamente la misma longitud. # Eliminaci\u00f3n a = [0,1,2,3,4,5,6,7,8] del a[2:4] # [0,1,4,5,6,7,8] Reducciones de secuencias Hay algunas operaciones usuales que reducen una secuencia a un solo valor. >>> s = [1, 2, 3, 4] >>> sum(s) 10 >>> min(s) 1 >>> max(s) 4 >>> t = ['Hello', 'World'] >>> max(t) 'World' >>> Iterar sobre una secuencia Los ciclos for iteran sobre los elementos de una secuencia. >>> s = [1, 4, 9, 16] >>> for i in s: ... print(i) ... 1 4 9 16 >>> En cada iteraci\u00f3n del ciclo obten\u00e9s un nuevo elemento para trabajar. La variable iteradora va a tomar este nuevo valor. En el siguiente ejemplo la variable iteradora es x : for x in s: # `x` es una variable iteradora ...instrucciones En cada iteraci\u00f3n, el valor previo de la variable (si hubo alguno) es sobreescrito. Luego de terminar el ciclo, la variable retiene su \u00faltimo valor. El comando break Pod\u00e9s usar el comando break para romper un ciclo antes de tiempo. for name in namelist: if name == 'Juana': break ... ... instrucciones Cuando el comando break se ejecuta, sale del ciclo y se mueve a las siguientes instrucciones . El comando break s\u00f3lo se aplica al ciclo m\u00e1s interno. Si un ciclo est\u00e1 anidado en otro ciclo, el comando no va a romper el ciclo externo. El comando continue Para saltear un elemento y moverse al siguiente, us\u00e1 el comando continue . for line in lines: if line == '\\n': # Salteo las instrucciones que procesan l\u00edneas continue # Instrucciones que procesan l\u00edneas ... \u00c9ste es \u00fatil cuando el elemento encontrado no es de inter\u00e9s o es necesario ignorarlo en el procesamiento. Ciclos sobre enteros Para iterar sobre un rango de n\u00fameros enteros, us\u00e1 range() . for i in range(100): # i = 0,1,...,99 La sintaxis es range([comienzo,] fin [,paso]) (lo que figura entre corchetes es opcional). for i in range(100): # i = 0,1,...,99 ...codigo for j in range(10,20): # j = 10,11,..., 19 ...codigo for k in range(10,50,2): # k = 10,12,...,48 # Observ\u00e1 que va de a dos. ...codigo El valor final nunca es incluido. Es como con las rebanadas. comienzo es opcional. Por defecto es 0 . paso es opcional. Por defecto es 1 . range() calcula los valores a medida que los necesita. No guarda realmente en memoria el rango completo de n\u00fameros. La funci\u00f3n enumerate() La funci\u00f3n enumerate agrega un contador extra a una iteraci\u00f3n. nombres = ['Edmundo', 'Juana', 'Rosita'] for i, nombre in enumerate(nombres): # i = 0, nombre = 'Edmundo' # i = 1, nombre = 'Juana' # i = 2, nombre = 'Rosita' La forma general es enumerate(secuencia [, start = 0]) . start es opcional. Un buen ejemplo de cu\u00e1ndo usar enumerate() es para llevar la cuenta del n\u00famero de l\u00ednea mientras est\u00e1s leyendo un archivo: with open(nombre_archivo) as f: for nlinea, line in enumerate(f, start=1): ... Al fin de cuentas, enumerate es s\u00f3lo una forma abreviada y simp\u00e1tica de escribir: i = 0 for x in s: instrucciones i += 1 Al usar enumerate tenemos que tipear menos y el programa funciona un poco m\u00e1s r\u00e1pido. Tuplas y ciclos for Pod\u00e9s iterar con m\u00faltiples variables de iteraci\u00f3n. points = [ (1, 4),(10, 40),(23, 14),(5, 6),(7, 8) ] for x, y in points: # x = 1, y = 4 # x = 10, y = 40 # x = 23, y = 14 # ... Cuando us\u00e1s m\u00faltiples variables, cada tupla es desempaquetada en un conjunto de variables de iteraci\u00f3n. El n\u00famero de variables debe coincidir con la cantidad de elementos de cada tupla. La funci\u00f3n zip() La funci\u00f3n zip toma m\u00faltiples secuencias y las combina en un iterador. columnas = ['nombre', 'cajones', 'precio'] valores = ['Pera', 100, 490.1 ] pares = zip(columnas, valores) # ('nombre','Pera'), ('cajones',100), ('precio',490.1) Para obtener el resultado deb\u00e9s iterar. Pod\u00e9s usar m\u00faltiples variables para desempaquetar las tuplas como mostramos antes. for columna, valor in pares: ... Un uso frecuente de zip es para crear pares clave/valor y construir diccionarios. d = dict(zip(columnas, valores)) Ejercicios Ejercicio 3.6: Contar Prob\u00e1 algunos ejemplos elementales de conteo: >>> for n in range(10): # Contar 0 ... 9 print(n, end=' ') 0 1 2 3 4 5 6 7 8 9 >>> for n in range(10,0,-1): # Contar 10 ... 1 print(n, end=' ') 10 9 8 7 6 5 4 3 2 1 >>> for n in range(0,10,2): # Contar 0, 2, ... 8 print(n, end=' ') 0 2 4 6 8 >>> Ejercicio 3.7: M\u00e1s operaciones con secuencias Interactivamente experiment\u00e1 con algunas operaciones de reducci\u00f3n de secuencias. >>> data = [4, 9, 1, 25, 16, 100, 49] >>> min(data) 1 >>> max(data) 100 >>> sum(data) 204 >>> Prob\u00e1 iterar sobre los datos. >>> for x in data: print(x) 4 9 ... >>> for n, x in enumerate(data): print(n, x) 0 4 1 9 2 1 ... >>> A veces los comandos for, len(), y range() son combinados para recorrer listas: >>> for n in range(len(data)): print(data[n]) 4 9 1 ... >>> Sin embargo, Python tiene mejores alternativas para esto. Te recomendamos familiarizarte con ellas y usarlas: por su simpleza producen c\u00f3digo m\u00e1s legible y reducen la posibilidad de un bug en el c\u00f3digo. Simplemente us\u00e1 un ciclo for normal si quer\u00e9s iterar sobre los elementos de la variable data . Y us\u00e1 enumerate() si necesit\u00e1s tener el \u00edndice por alg\u00fan motivo. Ejercicio 3.8: Un ejemplo pr\u00e1ctico de enumerate() Record\u00e1 que el archivo Data/missing.csv contiene datos sobre los cajones de un cami\u00f3n, pero tiene algunas filas que faltan. Usando enumerate() , modific\u00e1 tu programa costo_camion.py de forma que imprima un aviso (warning) cada vez que encuentre una fila incorrecta. >>> cost = costo_camion('../Data/missing.csv') Fila 4: No pude interpretar: ['Mandarina', '', '51.23'] Fila 7: No pude interpretar: ['Naranja', '', '70.44'] >>> Para hacer esto, vas a tener que cambiar algunas partes de tu c\u00f3digo. ... for n_fila, fila in enumerate(filas, start=1): try: ... except ValueError: print(f'Fila {n_fila}: No pude interpretar: {fila}') Ejercicio 3.9: La funci\u00f3n zip() En el archivo Data/camion.csv , la primera l\u00ednea tiene los encabezados de las columnas. En los c\u00f3digos anteriores la descartamos. >>> f = open('../Data/camion.csv') >>> filas = csv.reader(f) >>> encabezados = next(filas) >>> encabezados ['nombre', 'cajones', 'precio'] >>> Pero, \u00bfno puede ser \u00fatil conocer los encabezados? Es ac\u00e1 donde la funci\u00f3n zip() entra en acci\u00f3n. Primero trat\u00e1 de aparear los encabezados con una fila de datos: >>> fila = next(filas) >>> fila ['Lima', '100', '32.20'] >>> list(zip(encabezados, fila)) [ ('nombre', 'Lima'), ('cajones', '100'), ('precio', '32.20') ] >>> Fijate c\u00f3mo zip() apare\u00f3 los encabezados de las columnas con los valores de la columna. Usamos list() arriba para devolver el resultado en una lista de forma que lo puedas ver. Normalmente, zip() crea un iterador que debe ser consumido en un ciclo for. Este apareamiento es un paso intermedio para construir un diccionario. Prob\u00e1 lo siguiente: >>> record = dict(zip(encabezados, fila)) >>> record {'precio': '32.20', 'nombre': 'Lima', 'cajones': '100'} >>> Esta transformaci\u00f3n es un truco sumamente \u00fatil cuando ten\u00e9s que procesar muchos archivos de datos. Por ejemplo, supon\u00e9 que quer\u00e9s hacer que el programa costo_camion.py trabaje con diferentes archivos de entrada, pero que no le importe la posici\u00f3n exacta de la columna que tiene la cantidad de cajones o el precio. Es decir, que entienda que la columna tiene el precio por su encabezado y no por su posici\u00f3n dentro del archivo. Modific\u00e1 la funci\u00f3n costo_camion() en el archivo costo_camion.py para que se vea as\u00ed: # costo_camion.py def costo_camion(nombre_archivo): ... for n_fila, fila in enumerate(filas, start=1): record = dict(zip(encabezados, fila)) try: ncajones = int(record['cajones']) precio = float(record['precio']) costo_total += ncajones * precio # Esto atrapa errores en los int() y float() de arriba. except ValueError: print(f'Fila {n_fila}: No pude interpretar: {fila}') ... Ahora, prob\u00e1 tu funci\u00f3n con un archivo completamente diferente Data/fecha_camion.csv que se ve as\u00ed: nombre,fecha,hora,cajones,precio \"Lima\",\"6/11/2007\",\"9:50am\",100,32.20 \"Naranja\",\"5/13/2007\",\"4:20pm\",50,91.10 \"Caqui\",\"9/23/2006\",\"1:30pm\",150,83.44 \"Mandarina\",\"5/17/2007\",\"10:30am\",200,51.23 \"Durazno\",\"2/1/2006\",\"10:45am\",95,40.37 \"Mandarina\",\"10/31/2006\",\"12:05pm\",50,65.10 \"Naranja\",\"7/9/2006\",\"3:15pm\",100,70.44 >>> costo_camion('../Data/fecha_camion.csv') 47671.15 >>> Si lo hiciste bien, vas a descubrir que tu programa a\u00fan funciona a pesar de que le pasaste un archivo con un formato de columnas completamente diferente al de antes. \u00a1Y eso est\u00e1 muy bueno! El cambio que hicimos ac\u00e1 es sutil, pero importante. En lugar de tener hardcodeado un formato fijo, la nueva versi\u00f3n de la funci\u00f3n costo_camion() puede sacar la informaci\u00f3n de inter\u00e9s de cualquier archivo CSV. En la medida en que el archivo tenga las columnas requeridas, el c\u00f3digo va a funcionar. Modific\u00e1 el programa informe.py que escribiste antes (ver Ejercicio 2.18 ) para que use esta t\u00e9cnica para elegir las columnas a partir de sus encabezados. Prob\u00e1 correr el programa informe.py sobre el archivo Data/fecha_camion.csv y fijate si da la misma salida que antes. Ejercicio 3.10: Invertir un diccionario Un diccionario es una funci\u00f3n que mapea claves en valores. Por ejemplo, un diccionario de precios de cajones de frutas. >>> precios = { 'Pera' : 490.1, 'Lima' : 23.45, 'Naranja' : 91.1, 'Mandarina' : 34.23 } >>> Si us\u00e1s el m\u00e9todo items() , obten\u00e9s pares (clave,valor) : >>> precios.items() dict_items([('Pera', 490.1), ('Lima', 23.45), ('Naranja', 91.1), ('Mandarina', 34.23)]) >>> Sin embargo, si lo que quer\u00e9s son pares (valor, clave) , \u00bfc\u00f3mo lo hac\u00e9s? Ayuda: us\u00e1 zip() . >>> lista_precios = list(zip(precios.values(),precios.keys())) >>> lista_precios [(490.1, 'Pera'), (23.45, 'Lima'), (91.1, 'Naranja'), (34.23, 'Mandarina')] >>> \u00bfPor qu\u00e9 har\u00eda algo as\u00ed? Por un lado porque te permite realizar cierto tipo de procesamiento de datos sobre la informaci\u00f3n del diccionario. >>> min(lista_precios) (23.45, 'Lima') >>> max(lista_precios) (490.1, 'Pera') >>> sorted(lista_precios) [(23.45, 'Lima'), (34.23, 'Mandarina'), (91.1, 'Naranja'), (490.1, 'Pera')] >>> Esto tambi\u00e9n ilustra un atributo importante de las tuplas. Cuando son usadas en una comparaci\u00f3n, las tuplas son comparadas elemento-a-elemento comenzando con el primero. Es similar a la l\u00f3gica subyacente al orden lexicogr\u00e1fico o alfab\u00e9tico en las cadenas. La funci\u00f3n zip() se usa frecuentemente en este tipo de situaciones donde necesit\u00e1s aparear datos provenientes de diferentes lugares. Por ejemplo, para aparear los nombres de las columnas con los valores para hacer un diccionario de valores con nombres. Observ\u00e1 que zip() no est\u00e1 limitada a pares. Pod\u00e9s usarla con cualquier n\u00famero de listas de entrada: >>> a = [1, 2, 3, 4] >>> b = ['w', 'x', 'y', 'z'] >>> c = [0.2, 0.4, 0.6, 0.8] >>> list(zip(a, b, c)) [(1, 'w', 0.2), (2, 'x', 0.4), (3, 'y', 0.6), (4, 'z', 0.8))] >>> Tambi\u00e9n, ten\u00e9 en cuenta que zip() se detiene cuando la m\u00e1s corta de las entradas se agota. >>> a = [1, 2, 3, 4, 5, 6] >>> b = ['x', 'y', 'z'] >>> list(zip(a,b)) [(1, 'x'), (2, 'y'), (3, 'z')] >>> Contenidos | Anterior (1 Errores) | Pr\u00f3ximo (3 Contadores del m\u00f3dulo collections )","title":"02 Secuencias"},{"location":"03_Datos/02_Secuencias/#32-secuencias","text":"","title":"3.2 Secuencias"},{"location":"03_Datos/02_Secuencias/#tipo-de-secuencias","text":"Python tiene tres tipos de datos que son secuencias . String: 'Hello' . Una cadena es una secuencia de caracteres. Lista: [1, 4, 5] . Tupla: ('Pera', 100, 490.1) . Todas las secuencias tienen un orden, indexado por enteros, y tienen una longitud. a = 'Hello' # String o cadena b = [1, 4, 5] # Lista c = ('Pera', 100, 490.1) # Tupla # Orden indexado a[0] # 'H' b[-1] # 5 c[1] # 100 # Longitud de secuencias len(a) # 5 len(b) # 3 len(c) # 3 Las secuencias pueden ser replicadas: s * n . >>> a = 'Hello' >>> a * 3 'HelloHelloHello' >>> b = [1, 2, 3] >>> b * 2 [1, 2, 3, 1, 2, 3] >>> Las secuencias del mismo tipo tambi\u00e9n pueden ser concatenadas: s + t . >>> a = (1, 2, 3) >>> b = (4, 5) >>> a + b (1, 2, 3, 4, 5) >>> >>> c = [1, 5] >>> a + c Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can only concatenate tuple (not \"list\") to tuple","title":"Tipo de secuencias"},{"location":"03_Datos/02_Secuencias/#rebanadas-slicing","text":"Sacar una rebanada es tomar una subsecuencia de una secuencia. La sintaxis es s[comienzo:fin] , donde comienzo y fin son los \u00edndices de la subsecuencia que quer\u00e9s. a = [0,1,2,3,4,5,6,7,8] a[2:5] # [2,3,4] a[-5:] # [4,5,6,7,8] a[:3] # [0,1,2] Los \u00edndices comienzo y fin deben ser enteros. Las rebanadas no incluyen el valor final. Es como los intervalos semi-abiertos en matem\u00e1tica. Si los \u00edndices son omitidos toman sus valores por defecto: el principio o el final de la lista.","title":"Rebanadas (slicing)"},{"location":"03_Datos/02_Secuencias/#reasigacion-de-rebanadas","text":"En listas, una rebanada puede ser reasignada o eliminada. # Reasignaci\u00f3n a = [0,1,2,3,4,5,6,7,8] a[2:4] = [10,11,12] # [0,1,10,11,12,4,5,6,7,8] Observaci\u00f3n: La rebanada reasignada no tiene que tener necesariamente la misma longitud. # Eliminaci\u00f3n a = [0,1,2,3,4,5,6,7,8] del a[2:4] # [0,1,4,5,6,7,8]","title":"Reasigaci\u00f3n de rebanadas"},{"location":"03_Datos/02_Secuencias/#reducciones-de-secuencias","text":"Hay algunas operaciones usuales que reducen una secuencia a un solo valor. >>> s = [1, 2, 3, 4] >>> sum(s) 10 >>> min(s) 1 >>> max(s) 4 >>> t = ['Hello', 'World'] >>> max(t) 'World' >>>","title":"Reducciones de secuencias"},{"location":"03_Datos/02_Secuencias/#iterar-sobre-una-secuencia","text":"Los ciclos for iteran sobre los elementos de una secuencia. >>> s = [1, 4, 9, 16] >>> for i in s: ... print(i) ... 1 4 9 16 >>> En cada iteraci\u00f3n del ciclo obten\u00e9s un nuevo elemento para trabajar. La variable iteradora va a tomar este nuevo valor. En el siguiente ejemplo la variable iteradora es x : for x in s: # `x` es una variable iteradora ...instrucciones En cada iteraci\u00f3n, el valor previo de la variable (si hubo alguno) es sobreescrito. Luego de terminar el ciclo, la variable retiene su \u00faltimo valor.","title":"Iterar sobre una secuencia"},{"location":"03_Datos/02_Secuencias/#el-comando-break","text":"Pod\u00e9s usar el comando break para romper un ciclo antes de tiempo. for name in namelist: if name == 'Juana': break ... ... instrucciones Cuando el comando break se ejecuta, sale del ciclo y se mueve a las siguientes instrucciones . El comando break s\u00f3lo se aplica al ciclo m\u00e1s interno. Si un ciclo est\u00e1 anidado en otro ciclo, el comando no va a romper el ciclo externo.","title":"El comando break"},{"location":"03_Datos/02_Secuencias/#el-comando-continue","text":"Para saltear un elemento y moverse al siguiente, us\u00e1 el comando continue . for line in lines: if line == '\\n': # Salteo las instrucciones que procesan l\u00edneas continue # Instrucciones que procesan l\u00edneas ... \u00c9ste es \u00fatil cuando el elemento encontrado no es de inter\u00e9s o es necesario ignorarlo en el procesamiento.","title":"El comando continue"},{"location":"03_Datos/02_Secuencias/#ciclos-sobre-enteros","text":"Para iterar sobre un rango de n\u00fameros enteros, us\u00e1 range() . for i in range(100): # i = 0,1,...,99 La sintaxis es range([comienzo,] fin [,paso]) (lo que figura entre corchetes es opcional). for i in range(100): # i = 0,1,...,99 ...codigo for j in range(10,20): # j = 10,11,..., 19 ...codigo for k in range(10,50,2): # k = 10,12,...,48 # Observ\u00e1 que va de a dos. ...codigo El valor final nunca es incluido. Es como con las rebanadas. comienzo es opcional. Por defecto es 0 . paso es opcional. Por defecto es 1 . range() calcula los valores a medida que los necesita. No guarda realmente en memoria el rango completo de n\u00fameros.","title":"Ciclos sobre enteros"},{"location":"03_Datos/02_Secuencias/#la-funcion-enumerate","text":"La funci\u00f3n enumerate agrega un contador extra a una iteraci\u00f3n. nombres = ['Edmundo', 'Juana', 'Rosita'] for i, nombre in enumerate(nombres): # i = 0, nombre = 'Edmundo' # i = 1, nombre = 'Juana' # i = 2, nombre = 'Rosita' La forma general es enumerate(secuencia [, start = 0]) . start es opcional. Un buen ejemplo de cu\u00e1ndo usar enumerate() es para llevar la cuenta del n\u00famero de l\u00ednea mientras est\u00e1s leyendo un archivo: with open(nombre_archivo) as f: for nlinea, line in enumerate(f, start=1): ... Al fin de cuentas, enumerate es s\u00f3lo una forma abreviada y simp\u00e1tica de escribir: i = 0 for x in s: instrucciones i += 1 Al usar enumerate tenemos que tipear menos y el programa funciona un poco m\u00e1s r\u00e1pido.","title":"La funci\u00f3n enumerate()"},{"location":"03_Datos/02_Secuencias/#tuplas-y-ciclos-for","text":"Pod\u00e9s iterar con m\u00faltiples variables de iteraci\u00f3n. points = [ (1, 4),(10, 40),(23, 14),(5, 6),(7, 8) ] for x, y in points: # x = 1, y = 4 # x = 10, y = 40 # x = 23, y = 14 # ... Cuando us\u00e1s m\u00faltiples variables, cada tupla es desempaquetada en un conjunto de variables de iteraci\u00f3n. El n\u00famero de variables debe coincidir con la cantidad de elementos de cada tupla.","title":"Tuplas y ciclos for"},{"location":"03_Datos/02_Secuencias/#la-funcion-zip","text":"La funci\u00f3n zip toma m\u00faltiples secuencias y las combina en un iterador. columnas = ['nombre', 'cajones', 'precio'] valores = ['Pera', 100, 490.1 ] pares = zip(columnas, valores) # ('nombre','Pera'), ('cajones',100), ('precio',490.1) Para obtener el resultado deb\u00e9s iterar. Pod\u00e9s usar m\u00faltiples variables para desempaquetar las tuplas como mostramos antes. for columna, valor in pares: ... Un uso frecuente de zip es para crear pares clave/valor y construir diccionarios. d = dict(zip(columnas, valores))","title":"La funci\u00f3n zip()"},{"location":"03_Datos/02_Secuencias/#ejercicios","text":"","title":"Ejercicios"},{"location":"03_Datos/02_Secuencias/#ejercicio-36-contar","text":"Prob\u00e1 algunos ejemplos elementales de conteo: >>> for n in range(10): # Contar 0 ... 9 print(n, end=' ') 0 1 2 3 4 5 6 7 8 9 >>> for n in range(10,0,-1): # Contar 10 ... 1 print(n, end=' ') 10 9 8 7 6 5 4 3 2 1 >>> for n in range(0,10,2): # Contar 0, 2, ... 8 print(n, end=' ') 0 2 4 6 8 >>>","title":"Ejercicio 3.6: Contar"},{"location":"03_Datos/02_Secuencias/#ejercicio-37-mas-operaciones-con-secuencias","text":"Interactivamente experiment\u00e1 con algunas operaciones de reducci\u00f3n de secuencias. >>> data = [4, 9, 1, 25, 16, 100, 49] >>> min(data) 1 >>> max(data) 100 >>> sum(data) 204 >>> Prob\u00e1 iterar sobre los datos. >>> for x in data: print(x) 4 9 ... >>> for n, x in enumerate(data): print(n, x) 0 4 1 9 2 1 ... >>> A veces los comandos for, len(), y range() son combinados para recorrer listas: >>> for n in range(len(data)): print(data[n]) 4 9 1 ... >>> Sin embargo, Python tiene mejores alternativas para esto. Te recomendamos familiarizarte con ellas y usarlas: por su simpleza producen c\u00f3digo m\u00e1s legible y reducen la posibilidad de un bug en el c\u00f3digo. Simplemente us\u00e1 un ciclo for normal si quer\u00e9s iterar sobre los elementos de la variable data . Y us\u00e1 enumerate() si necesit\u00e1s tener el \u00edndice por alg\u00fan motivo.","title":"Ejercicio 3.7: M\u00e1s operaciones con secuencias"},{"location":"03_Datos/02_Secuencias/#ejercicio-38-un-ejemplo-practico-de-enumerate","text":"Record\u00e1 que el archivo Data/missing.csv contiene datos sobre los cajones de un cami\u00f3n, pero tiene algunas filas que faltan. Usando enumerate() , modific\u00e1 tu programa costo_camion.py de forma que imprima un aviso (warning) cada vez que encuentre una fila incorrecta. >>> cost = costo_camion('../Data/missing.csv') Fila 4: No pude interpretar: ['Mandarina', '', '51.23'] Fila 7: No pude interpretar: ['Naranja', '', '70.44'] >>> Para hacer esto, vas a tener que cambiar algunas partes de tu c\u00f3digo. ... for n_fila, fila in enumerate(filas, start=1): try: ... except ValueError: print(f'Fila {n_fila}: No pude interpretar: {fila}')","title":"Ejercicio 3.8: Un ejemplo pr\u00e1ctico de enumerate()"},{"location":"03_Datos/02_Secuencias/#ejercicio-39-la-funcion-zip","text":"En el archivo Data/camion.csv , la primera l\u00ednea tiene los encabezados de las columnas. En los c\u00f3digos anteriores la descartamos. >>> f = open('../Data/camion.csv') >>> filas = csv.reader(f) >>> encabezados = next(filas) >>> encabezados ['nombre', 'cajones', 'precio'] >>> Pero, \u00bfno puede ser \u00fatil conocer los encabezados? Es ac\u00e1 donde la funci\u00f3n zip() entra en acci\u00f3n. Primero trat\u00e1 de aparear los encabezados con una fila de datos: >>> fila = next(filas) >>> fila ['Lima', '100', '32.20'] >>> list(zip(encabezados, fila)) [ ('nombre', 'Lima'), ('cajones', '100'), ('precio', '32.20') ] >>> Fijate c\u00f3mo zip() apare\u00f3 los encabezados de las columnas con los valores de la columna. Usamos list() arriba para devolver el resultado en una lista de forma que lo puedas ver. Normalmente, zip() crea un iterador que debe ser consumido en un ciclo for. Este apareamiento es un paso intermedio para construir un diccionario. Prob\u00e1 lo siguiente: >>> record = dict(zip(encabezados, fila)) >>> record {'precio': '32.20', 'nombre': 'Lima', 'cajones': '100'} >>> Esta transformaci\u00f3n es un truco sumamente \u00fatil cuando ten\u00e9s que procesar muchos archivos de datos. Por ejemplo, supon\u00e9 que quer\u00e9s hacer que el programa costo_camion.py trabaje con diferentes archivos de entrada, pero que no le importe la posici\u00f3n exacta de la columna que tiene la cantidad de cajones o el precio. Es decir, que entienda que la columna tiene el precio por su encabezado y no por su posici\u00f3n dentro del archivo. Modific\u00e1 la funci\u00f3n costo_camion() en el archivo costo_camion.py para que se vea as\u00ed: # costo_camion.py def costo_camion(nombre_archivo): ... for n_fila, fila in enumerate(filas, start=1): record = dict(zip(encabezados, fila)) try: ncajones = int(record['cajones']) precio = float(record['precio']) costo_total += ncajones * precio # Esto atrapa errores en los int() y float() de arriba. except ValueError: print(f'Fila {n_fila}: No pude interpretar: {fila}') ... Ahora, prob\u00e1 tu funci\u00f3n con un archivo completamente diferente Data/fecha_camion.csv que se ve as\u00ed: nombre,fecha,hora,cajones,precio \"Lima\",\"6/11/2007\",\"9:50am\",100,32.20 \"Naranja\",\"5/13/2007\",\"4:20pm\",50,91.10 \"Caqui\",\"9/23/2006\",\"1:30pm\",150,83.44 \"Mandarina\",\"5/17/2007\",\"10:30am\",200,51.23 \"Durazno\",\"2/1/2006\",\"10:45am\",95,40.37 \"Mandarina\",\"10/31/2006\",\"12:05pm\",50,65.10 \"Naranja\",\"7/9/2006\",\"3:15pm\",100,70.44 >>> costo_camion('../Data/fecha_camion.csv') 47671.15 >>> Si lo hiciste bien, vas a descubrir que tu programa a\u00fan funciona a pesar de que le pasaste un archivo con un formato de columnas completamente diferente al de antes. \u00a1Y eso est\u00e1 muy bueno! El cambio que hicimos ac\u00e1 es sutil, pero importante. En lugar de tener hardcodeado un formato fijo, la nueva versi\u00f3n de la funci\u00f3n costo_camion() puede sacar la informaci\u00f3n de inter\u00e9s de cualquier archivo CSV. En la medida en que el archivo tenga las columnas requeridas, el c\u00f3digo va a funcionar. Modific\u00e1 el programa informe.py que escribiste antes (ver Ejercicio 2.18 ) para que use esta t\u00e9cnica para elegir las columnas a partir de sus encabezados. Prob\u00e1 correr el programa informe.py sobre el archivo Data/fecha_camion.csv y fijate si da la misma salida que antes.","title":"Ejercicio 3.9: La funci\u00f3n zip()"},{"location":"03_Datos/02_Secuencias/#ejercicio-310-invertir-un-diccionario","text":"Un diccionario es una funci\u00f3n que mapea claves en valores. Por ejemplo, un diccionario de precios de cajones de frutas. >>> precios = { 'Pera' : 490.1, 'Lima' : 23.45, 'Naranja' : 91.1, 'Mandarina' : 34.23 } >>> Si us\u00e1s el m\u00e9todo items() , obten\u00e9s pares (clave,valor) : >>> precios.items() dict_items([('Pera', 490.1), ('Lima', 23.45), ('Naranja', 91.1), ('Mandarina', 34.23)]) >>> Sin embargo, si lo que quer\u00e9s son pares (valor, clave) , \u00bfc\u00f3mo lo hac\u00e9s? Ayuda: us\u00e1 zip() . >>> lista_precios = list(zip(precios.values(),precios.keys())) >>> lista_precios [(490.1, 'Pera'), (23.45, 'Lima'), (91.1, 'Naranja'), (34.23, 'Mandarina')] >>> \u00bfPor qu\u00e9 har\u00eda algo as\u00ed? Por un lado porque te permite realizar cierto tipo de procesamiento de datos sobre la informaci\u00f3n del diccionario. >>> min(lista_precios) (23.45, 'Lima') >>> max(lista_precios) (490.1, 'Pera') >>> sorted(lista_precios) [(23.45, 'Lima'), (34.23, 'Mandarina'), (91.1, 'Naranja'), (490.1, 'Pera')] >>> Esto tambi\u00e9n ilustra un atributo importante de las tuplas. Cuando son usadas en una comparaci\u00f3n, las tuplas son comparadas elemento-a-elemento comenzando con el primero. Es similar a la l\u00f3gica subyacente al orden lexicogr\u00e1fico o alfab\u00e9tico en las cadenas. La funci\u00f3n zip() se usa frecuentemente en este tipo de situaciones donde necesit\u00e1s aparear datos provenientes de diferentes lugares. Por ejemplo, para aparear los nombres de las columnas con los valores para hacer un diccionario de valores con nombres. Observ\u00e1 que zip() no est\u00e1 limitada a pares. Pod\u00e9s usarla con cualquier n\u00famero de listas de entrada: >>> a = [1, 2, 3, 4] >>> b = ['w', 'x', 'y', 'z'] >>> c = [0.2, 0.4, 0.6, 0.8] >>> list(zip(a, b, c)) [(1, 'w', 0.2), (2, 'x', 0.4), (3, 'y', 0.6), (4, 'z', 0.8))] >>> Tambi\u00e9n, ten\u00e9 en cuenta que zip() se detiene cuando la m\u00e1s corta de las entradas se agota. >>> a = [1, 2, 3, 4, 5, 6] >>> b = ['x', 'y', 'z'] >>> list(zip(a,b)) [(1, 'x'), (2, 'y'), (3, 'z')] >>> Contenidos | Anterior (1 Errores) | Pr\u00f3ximo (3 Contadores del m\u00f3dulo collections )","title":"Ejercicio 3.10: Invertir un diccionario"},{"location":"03_Datos/03_Contadores/","text":"Contenidos | Anterior (2 Secuencias) | Pr\u00f3ximo (4 Entorno de desarrollo integrado) 3.3 Contadores del m\u00f3dulo collections El m\u00f3dulo collections ofrece objetos \u00fatiles para manejar datos. En esta secci\u00f3n introducimos brevemente los contadores, que son solo una de las clases incluidas en este m\u00f3dulo. Ejemplo: Contar cosas Digamos que quer\u00e9s hacer una tabla con el total de cajones de cada fruta. camion = [ ('Pera', 100, 490.1), ('Naranja', 50, 91.1), ('Caqui', 150, 83.44), ('Naranja', 100, 45.23), ('Pera', 75, 572.45), ('Lima', 50, 23.15) ] Hay dos entradas de Naranja y dos de Pera en esta lista. Estos cajones deben ser combinados juntos de alguna forma. Contadores Soluci\u00f3n: Us\u00e1 un Counter (contador). from collections import Counter total_cajones = Counter() for nombre, n_cajones, precio in camion: total_cajones[nombre] += n_cajones total_cajones['Naranja'] # 150 Ejercicios En este ejercicio vas a probar contadores en un par de ejemplos simples. Carg\u00e1 tu programa informe.py y ejecutalo en el interprete de forma de tener los datos del cami\u00f3n con cajones cargado en modo interactivo. Pod\u00e9s usar el interprete desde la l\u00ednea de comandos ejecutando: bash % python3 -i informe.py O pod\u00e9s cargarlo en el Spyder y correrlo. Ejercicio 3.11: Contadores Vamos a usar un contador (objeto Counter ) para contar cajones de frutas. Probalo: >>> camion = leer_camion('../Data/camion.csv') >>> from collections import Counter >>> tenencias = Counter() >>> for s in camion: tenencias[s['nombre']] += s['cajones'] >>> tenencias Counter({'Caqui': 150, 'Durazno': 95, 'Lima': 100, 'Mandarina': 250, 'Naranja': 150}) >>> Observ\u00e1 que la entradas m\u00faltiples como Mandarina y Naranja en camion se combinan en una sola entrada. Pod\u00e9s usar el contador como un diccionario para recuperar valores individuales: >>> tenencias['Naranja'] 150 >>> tenencias['Mandarina'] 250 >>> Pod\u00e9s listar las tres frutas con mayores tenencias: >>> # Las 3 frutas con m\u00e1s cajones >>> tenencias.most_common(3) [('Mandarina', 250), ('Naranja', 150), ('Caqui', 150)] >>> Carguemos los datos de otro cami\u00f3n con cajones de fruta en un nuevo contador: >>> camion2 = leer_camion('../Data/camion2.csv') >>> tenencias2 = Counter() >>> for s in camion2: tenencias2[s['nombre']] += s['cajones'] >>> tenencias2 Counter({'Durazno': 125, 'Frambuesa': 250, 'Lima': 50, 'Mandarina': 25}) >>> Y finalmente combinemos las tenencias de ambos camiones con una operaci\u00f3n simple: >>> tenencias Counter({'Caqui': 150, 'Durazno': 95, 'Lima': 100, 'Mandarina': 250, 'Naranja': 150}) >>> tenencias2 Counter({'Frambuesa': 250, 'Durazno': 125, 'Lima': 50, 'Mandarina': 25}) >>> combinada = tenencias + tenencias2 >>> combinada Counter({'Caqui': 150, 'Durazno': 220, 'Frambuesa': 250, 'Lima': 150, 'Mandarina': 275, 'Naranja': 150}) >>> Esto es solo una peque\u00f1a muestra de lo que se puede hacer con contadores. El m\u00f3dulo collections es muy poderoso pero meterse a ver sus detalles ser\u00eda una distracci\u00f3n ahora. Sigamos con nuestro curso... Contenidos | Anterior (2 Secuencias) | Pr\u00f3ximo (4 Entorno de desarrollo integrado)","title":"03 Contadores"},{"location":"03_Datos/03_Contadores/#33-contadores-del-modulo-collections","text":"El m\u00f3dulo collections ofrece objetos \u00fatiles para manejar datos. En esta secci\u00f3n introducimos brevemente los contadores, que son solo una de las clases incluidas en este m\u00f3dulo.","title":"3.3 Contadores del m\u00f3dulo collections"},{"location":"03_Datos/03_Contadores/#ejemplo-contar-cosas","text":"Digamos que quer\u00e9s hacer una tabla con el total de cajones de cada fruta. camion = [ ('Pera', 100, 490.1), ('Naranja', 50, 91.1), ('Caqui', 150, 83.44), ('Naranja', 100, 45.23), ('Pera', 75, 572.45), ('Lima', 50, 23.15) ] Hay dos entradas de Naranja y dos de Pera en esta lista. Estos cajones deben ser combinados juntos de alguna forma.","title":"Ejemplo: Contar cosas"},{"location":"03_Datos/03_Contadores/#contadores","text":"Soluci\u00f3n: Us\u00e1 un Counter (contador). from collections import Counter total_cajones = Counter() for nombre, n_cajones, precio in camion: total_cajones[nombre] += n_cajones total_cajones['Naranja'] # 150","title":"Contadores"},{"location":"03_Datos/03_Contadores/#ejercicios","text":"En este ejercicio vas a probar contadores en un par de ejemplos simples. Carg\u00e1 tu programa informe.py y ejecutalo en el interprete de forma de tener los datos del cami\u00f3n con cajones cargado en modo interactivo. Pod\u00e9s usar el interprete desde la l\u00ednea de comandos ejecutando: bash % python3 -i informe.py O pod\u00e9s cargarlo en el Spyder y correrlo.","title":"Ejercicios"},{"location":"03_Datos/03_Contadores/#ejercicio-311-contadores","text":"Vamos a usar un contador (objeto Counter ) para contar cajones de frutas. Probalo: >>> camion = leer_camion('../Data/camion.csv') >>> from collections import Counter >>> tenencias = Counter() >>> for s in camion: tenencias[s['nombre']] += s['cajones'] >>> tenencias Counter({'Caqui': 150, 'Durazno': 95, 'Lima': 100, 'Mandarina': 250, 'Naranja': 150}) >>> Observ\u00e1 que la entradas m\u00faltiples como Mandarina y Naranja en camion se combinan en una sola entrada. Pod\u00e9s usar el contador como un diccionario para recuperar valores individuales: >>> tenencias['Naranja'] 150 >>> tenencias['Mandarina'] 250 >>> Pod\u00e9s listar las tres frutas con mayores tenencias: >>> # Las 3 frutas con m\u00e1s cajones >>> tenencias.most_common(3) [('Mandarina', 250), ('Naranja', 150), ('Caqui', 150)] >>> Carguemos los datos de otro cami\u00f3n con cajones de fruta en un nuevo contador: >>> camion2 = leer_camion('../Data/camion2.csv') >>> tenencias2 = Counter() >>> for s in camion2: tenencias2[s['nombre']] += s['cajones'] >>> tenencias2 Counter({'Durazno': 125, 'Frambuesa': 250, 'Lima': 50, 'Mandarina': 25}) >>> Y finalmente combinemos las tenencias de ambos camiones con una operaci\u00f3n simple: >>> tenencias Counter({'Caqui': 150, 'Durazno': 95, 'Lima': 100, 'Mandarina': 250, 'Naranja': 150}) >>> tenencias2 Counter({'Frambuesa': 250, 'Durazno': 125, 'Lima': 50, 'Mandarina': 25}) >>> combinada = tenencias + tenencias2 >>> combinada Counter({'Caqui': 150, 'Durazno': 220, 'Frambuesa': 250, 'Lima': 150, 'Mandarina': 275, 'Naranja': 150}) >>> Esto es solo una peque\u00f1a muestra de lo que se puede hacer con contadores. El m\u00f3dulo collections es muy poderoso pero meterse a ver sus detalles ser\u00eda una distracci\u00f3n ahora. Sigamos con nuestro curso... Contenidos | Anterior (2 Secuencias) | Pr\u00f3ximo (4 Entorno de desarrollo integrado)","title":"Ejercicio 3.11: Contadores"},{"location":"03_Datos/04_IDE/","text":"Contenidos | Anterior (3 Contadores del m\u00f3dulo collections ) | Pr\u00f3ximo (5 Impresi\u00f3n con formato) 3.4 Entorno de desarrollo integrado A partir de aqu\u00ed te vamos a proponer trabajar principalmente dentro de un entorno de desarrollo integrado (IDE, por sus siglas en ingl\u00e9s). En particular, sugerimos trabajar con el Spyder que es un entorno de desarrollo de Python dise\u00f1ado para cient\u00edficos, ingenieros y analistas de datos. El Spyder puede descargarse solo o como parte de la distribuci\u00f3n de Anaconda que trae, adem\u00e1s de Python y del Spyder, una serie de bibliotecas con m\u00f3dulos muy \u00fatiles para desarrollos relacionados a la ciencia de datos. Esta es una imagen de una captura de pantalla del Spyder: En la captura se puede ver que por defecto el Spyder viene estructurado con tres ventanas. Un editor de c\u00f3digo ocupa la mitad izquierda de la ventana, mientras que la mitad derecha se divide en una terminal (o consola) interactiva de Python en la mitad inferior y un inspector de variables en la mitad superior. El Spyder nos permite correr l\u00ednea por l\u00ednea el c\u00f3digo del editor (tecla F9 ) y ver el estado de las variables en el inspector de variables, o ejecutarlo completo (tecla F5 ). Tambi\u00e9n nos permite debuguear el c\u00f3digo con facilidad (botones azules de la barra superior). Les recomendamos que le dediquen un tiempo a probar sus \u00faltimos ejercicios en este entorno. Ver\u00e1n que es muy c\u00f3modo. Pueden mirar un breve tutorial donde no s\u00f3lo les ense\u00f1an el uso de la tecla F5 , sino tambi\u00e9n una introducci\u00f3n al uso del debugger (le dice depurador) que veremos m\u00e1s adelante en este curso. Contenidos | Anterior (3 Contadores del m\u00f3dulo collections ) | Pr\u00f3ximo (5 Impresi\u00f3n con formato)","title":"04 IDE"},{"location":"03_Datos/04_IDE/#34-entorno-de-desarrollo-integrado","text":"A partir de aqu\u00ed te vamos a proponer trabajar principalmente dentro de un entorno de desarrollo integrado (IDE, por sus siglas en ingl\u00e9s). En particular, sugerimos trabajar con el Spyder que es un entorno de desarrollo de Python dise\u00f1ado para cient\u00edficos, ingenieros y analistas de datos. El Spyder puede descargarse solo o como parte de la distribuci\u00f3n de Anaconda que trae, adem\u00e1s de Python y del Spyder, una serie de bibliotecas con m\u00f3dulos muy \u00fatiles para desarrollos relacionados a la ciencia de datos. Esta es una imagen de una captura de pantalla del Spyder: En la captura se puede ver que por defecto el Spyder viene estructurado con tres ventanas. Un editor de c\u00f3digo ocupa la mitad izquierda de la ventana, mientras que la mitad derecha se divide en una terminal (o consola) interactiva de Python en la mitad inferior y un inspector de variables en la mitad superior. El Spyder nos permite correr l\u00ednea por l\u00ednea el c\u00f3digo del editor (tecla F9 ) y ver el estado de las variables en el inspector de variables, o ejecutarlo completo (tecla F5 ). Tambi\u00e9n nos permite debuguear el c\u00f3digo con facilidad (botones azules de la barra superior). Les recomendamos que le dediquen un tiempo a probar sus \u00faltimos ejercicios en este entorno. Ver\u00e1n que es muy c\u00f3modo. Pueden mirar un breve tutorial donde no s\u00f3lo les ense\u00f1an el uso de la tecla F5 , sino tambi\u00e9n una introducci\u00f3n al uso del debugger (le dice depurador) que veremos m\u00e1s adelante en este curso. Contenidos | Anterior (3 Contadores del m\u00f3dulo collections ) | Pr\u00f3ximo (5 Impresi\u00f3n con formato)","title":"3.4 Entorno de desarrollo integrado"},{"location":"03_Datos/05_Formato/","text":"Contenidos | Anterior (4 Entorno de desarrollo integrado) | Pr\u00f3ximo (6 Arbolado porte\u00f1o) 3.5 Impresi\u00f3n con formato En esta secci\u00f3n se ven detalles t\u00e9cnicos sobre c\u00f3mo hacer que la salida por pantalla sea m\u00e1s amena para el usuario. Cuando trabaj\u00e1s con datos es usual que quieras imprimir salidas estructuradas (tablas, etc.). Por ejemplo: Nombre Cajones Precio ---------- ---------- ----------- Lima 100 32.20 Naranja 50 91.10 Caqui 150 103.44 Mandarina 200 51.23 Durazno 95 40.37 Mandarina 50 65.10 Naranja 100 70.44 Formato de cadenas Una excelente manera de darle formato a una cadena en Python (a partir de la versi\u00f3n 3.6) es usando f-strings . >>> nombre = 'Naranja' >>> cajones = 100 >>> precio = 91.1 >>> f'{nombre:>10s} {cajones:>10d} {precio:>10.2f}' ' Naranja 100 91.10' >>> La parte {expresion:formato} va a ser reemplazada. Usualmente los f-strings se usan con print . print(f'{nombre:>10s} {cajones:>10d} {precio:>10.2f}') C\u00f3digos de formato Lo c\u00f3digos de formato (lo que va luego de : dentro de {} ) son similares a los que se usan en el printf() del lenguaje C. Los m\u00e1s comunes son: d Entero decimal b Entero binario x Entero hexadecimal f Flotante como [-]m.dddddd e Flotante como [-]m.dddddde+-xx g Flotante, pero con uso selectivo de la notaci\u00f3n exponencial E. s Cadenas c Caracter (a partir de un entero, su c\u00f3digo) Los modificadores permiten ajustar el ancho a imprimir o la precisi\u00f3n decimal (cantidad de d\u00edgitos luego del punto). \u00c9sta es una lista parcial: :>10d Entero alineado a la derecha en un campo de 10 caracteres :<10d Entero alineado a la izquierda en un campo de 10 caracteres :^10d Entero centrado en un campo de 10 caracteres :0.2f Flotante con dos d\u00edgitos de precisi\u00f3n Formato a diccionarios Pod\u00e9s usar el m\u00e9todo format_map() para aplicarle un formato a los valores de un diccionario: >>> s = { 'nombre': 'Naranja', 'cajones': 100, 'precio': 91.1 } >>> '{nombre:>10s} {cajones:10d} {precio:10.2f}'.format_map(s) ' Naranja 100 91.10' >>> Usa los mismos c\u00f3digos que los f-strings pero toma los valores que provee el diccionario. El m\u00e9todo format() Existe un m\u00e9todo format() que permite aplicar formato a argumentos. >>> '{nombre:>10s} {cajones:10d} {precio:10.2f}'.format(nombre='Naranja', cajones=100, precio=91.1) ' Naranja 100 91.10' >>> '{:10s} {:10d} {:10.2f}'.format('Naranja', 100, 91.1) ' Naranja 100 91.10' >>> La verdad es que format() nos resulta un poco extenso y preferimos usar f-strings . Formato estilo C Tambi\u00e9n pod\u00e9s usar el operador % . >>> 'The value is %d' % 3 'The value is 3' >>> '%5d %-5d %10d' % (3,4,5) ' 3 4 5' >>> '%0.2f' % (3.1415926,) '3.14' Esto requiere un solo \u00edtem, o una tupla a la derecha. Los c\u00f3digos est\u00e1n tambi\u00e9n inspirados en el printf() de C. Tiene la dificultad de que hay que contar posiciones y todas las variables van juntas al final. Ejercicios Ejercicio 3.12: Formato de n\u00fameros Un problema usual cuando queremos imprimir n\u00fameros es especificar el n\u00famero de d\u00edgitos decimales. Los f-strings nos permiten hacerlo. Prob\u00e1 los siguientes ejemplos: >>> value = 42863.1 >>> print(value) 42863.1 >>> print(f'{value:0.4f}') 42863.1000 >>> print(f'{value:>16.2f}') 42863.10 >>> print(f'{value:<16.2f}') 42863.10 >>> print(f'{value:*>16,.2f}') *******42,863.10 >>> La documentaci\u00f3n completa sobre los c\u00f3digos de formato usados en f-strings puede consultarse ac\u00e1 . El formato puede aplicarse tambi\u00e9n usando el operador % de cadenas. >>> print('%0.4f' % value) 42863.1000 >>> print('%16.2f' % value) 42863.10 >>> La documentaci\u00f3n sobre c\u00f3digos usados con % puede encontrarse ac\u00e1 . A pesar de que suelen usarse dentro de un print , el formato de cadenas no est\u00e1 necesariamente ligado a la impresi\u00f3n. Por ejemplo, pod\u00e9s simplemente asignarlo a una variable. >>> f = '%0.4f' % value >>> f '42863.1000' >>> Ejercicio 3.13: Recolectar datos En el Ejercicio 2.18 , escribiste un programa llamado informe.py que calculaba las ganancias o p\u00e9rdidas de un cami\u00f3n que compra a productores y vende en el mercado. Copi\u00e1 su contenido en un archivo tabla_informe.py . En este ejercicio, vas a comenzar a modificar tabla_informe.py para producir una tabla como \u00e9sta: Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 32.2 8.02 Naranja 50 91.1 15.18 Caqui 150 103.44 2.02 Mandarina 200 51.23 29.66 Durazno 95 40.37 33.11 Mandarina 50 65.1 15.79 Naranja 100 70.44 35.84 En este informe, el \"Precio\" es el precio en el mercado y el \"Cambio\" es la variaci\u00f3n respecto al precio cobrado por el productor. Para generar un informe como el de arriba, primero ten\u00e9s que recolectar todos los datos de la tabla. Escrib\u00ed una funci\u00f3n hacer_informe() que recibe una lista de cajones y un diccionario con precios como input y devuelve una lista de tuplas conteniendo la informaci\u00f3n mostrada en la tabla anterior. Agreg\u00e1 esta funci\u00f3n a tu archivo tabla_informe.py . Deber\u00eda funcionar como se muestra en el siguiente ejemplo: >>> camion = leer_camion('../Data/camion.csv') >>> precios = leer_precios('../Data/precios.csv') >>> informe = hacer_informe(camion, precios) >>> for r in informe: print(r) ('Lima', 100, 32.2, 8.019999999999996) ('Naranja', 50, 91.1, 15.180000000000007) ('Caqui', 150, 103.44, 2.019999999999996) ('Mandarina', 200, 51.23, 29.660000000000004) ('Durazno', 95, 40.37, 33.11000000000001) ('Mandarina', 50, 65.1, 15.790000000000006) ('Naranja', 100, 70.44, 35.84) ... >>> Ejercicio 3.14: Imprimir una tabla con formato Volv\u00e9 a hacer el ciclo for del ejercicio anterior pero cambiando la forma de imprimir como sigue: >>> for r in informe: print('%10s %10d %10.2f %10.2f' % r) Lima 100 32.20 8.02 Naranja 50 91.10 15.18 Caqui 150 103.44 2.02 Mandarina 200 51.23 29.66 Durazno 95 40.37 33.11 Mandarina 50 65.10 15.79 Naranja 100 70.44 35.84 ... >>> O directamente usando f-strings. Por ejemplo: >>> for nombre, cajones, precio, cambio in informe: print(f'{nombre:>10s} {cajones:>10d} {precio:>10.2f} {cambio:>10.2f}') Lima 100 32.20 8.02 Naranja 50 91.10 15.18 Caqui 150 103.44 2.02 Mandarina 200 51.23 29.66 Durazno 95 40.37 33.11 Mandarina 50 65.10 15.79 Naranja 100 70.44 35.84 ... >>> Agreg\u00e1 estos \u00faltimos comandos a tu programa tabla_informe.py . Hac\u00e9 que el programa tome la salida de la funci\u00f3n hacer_informe() e imprima una tabla bien formateada. Ejercicio 3.15: Agregar encabezados Suponete que ten\u00e9s una tupla con nombres de encabezado como \u00e9sta: headers = ('Nombre', 'Cajones', 'Precio', 'Cambio') Agreg\u00e1 el c\u00f3digo necesario a tu programa para que tome una tupla de encabezados como la de arriba y cree una cadena donde cada nombre de encabezado est\u00e9 alineado a la derecha en un campo de 10 caracteres de ancho y separados por un solo espacio. ' Nombre Cajones Precio Cambio' Escrib\u00ed el c\u00f3digo que recibe los encabezados y crea una cadena de separaci\u00f3n entre los encabezados y los datos que siguen. Esta cadena es simplemente una tira de caracteres \"-\" bajo cada nombre de campo. Por ejemplo: '---------- ---------- ---------- ----------' Cuando est\u00e9 listo, tu programa deber\u00eda producir una tabla como esta: Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 32.20 8.02 Naranja 50 91.10 15.18 Caqui 150 103.44 2.02 Mandarina 200 51.23 29.66 Durazno 95 40.37 33.11 Mandarina 50 65.10 15.79 Naranja 100 70.44 35.84 Ejercicio 3.16: Un desaf\u00edo de formato Por \u00faltimo, modific\u00e1 tu c\u00f3digo para que el precio mostrado incluya un s\u00edmbolo de pesos ($) y la salida se vea como esta tabla: Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 $32.2 8.02 Naranja 50 $91.1 15.18 Caqui 150 $103.44 2.02 Mandarina 200 $51.23 29.66 Durazno 95 $40.37 33.11 Mandarina 50 $65.1 15.79 Naranja 100 $70.44 35.84 Guard\u00e1 estos cambios en el archivo tabla_informe.py que m\u00e1s adelante los vas a necesitar. Ejercicio 3.17: Tablas de multiplicar Escrib\u00ed un programa tablamult.py que imprima de forma prolija las tablas de multiplicar del 1 al 9 usando f-strings. Si pod\u00e9s, evit\u00e1 usar la multiplicaci\u00f3n, usando s\u00f3lo sumas alcanza. 0 1 2 3 4 5 6 7 8 9 --------------------------------------------- 0: 0 0 0 0 0 0 0 0 0 0 1: 0 1 2 3 4 5 6 7 8 9 2: 0 2 4 6 8 10 12 14 16 18 3: 0 3 6 9 12 15 18 21 24 27 4: 0 4 8 12 16 20 24 28 32 36 5: 0 5 10 15 20 25 30 35 40 45 6: 0 6 12 18 24 30 36 42 48 54 7: 0 7 14 21 28 35 42 49 56 63 8: 0 8 16 24 32 40 48 56 64 72 9: 0 9 18 27 36 45 54 63 72 81 Contenidos | Anterior (4 Entorno de desarrollo integrado) | Pr\u00f3ximo (6 Arbolado porte\u00f1o)","title":"05 Formato"},{"location":"03_Datos/05_Formato/#35-impresion-con-formato","text":"En esta secci\u00f3n se ven detalles t\u00e9cnicos sobre c\u00f3mo hacer que la salida por pantalla sea m\u00e1s amena para el usuario. Cuando trabaj\u00e1s con datos es usual que quieras imprimir salidas estructuradas (tablas, etc.). Por ejemplo: Nombre Cajones Precio ---------- ---------- ----------- Lima 100 32.20 Naranja 50 91.10 Caqui 150 103.44 Mandarina 200 51.23 Durazno 95 40.37 Mandarina 50 65.10 Naranja 100 70.44","title":"3.5 Impresi\u00f3n con formato"},{"location":"03_Datos/05_Formato/#formato-de-cadenas","text":"Una excelente manera de darle formato a una cadena en Python (a partir de la versi\u00f3n 3.6) es usando f-strings . >>> nombre = 'Naranja' >>> cajones = 100 >>> precio = 91.1 >>> f'{nombre:>10s} {cajones:>10d} {precio:>10.2f}' ' Naranja 100 91.10' >>> La parte {expresion:formato} va a ser reemplazada. Usualmente los f-strings se usan con print . print(f'{nombre:>10s} {cajones:>10d} {precio:>10.2f}')","title":"Formato de cadenas"},{"location":"03_Datos/05_Formato/#codigos-de-formato","text":"Lo c\u00f3digos de formato (lo que va luego de : dentro de {} ) son similares a los que se usan en el printf() del lenguaje C. Los m\u00e1s comunes son: d Entero decimal b Entero binario x Entero hexadecimal f Flotante como [-]m.dddddd e Flotante como [-]m.dddddde+-xx g Flotante, pero con uso selectivo de la notaci\u00f3n exponencial E. s Cadenas c Caracter (a partir de un entero, su c\u00f3digo) Los modificadores permiten ajustar el ancho a imprimir o la precisi\u00f3n decimal (cantidad de d\u00edgitos luego del punto). \u00c9sta es una lista parcial: :>10d Entero alineado a la derecha en un campo de 10 caracteres :<10d Entero alineado a la izquierda en un campo de 10 caracteres :^10d Entero centrado en un campo de 10 caracteres :0.2f Flotante con dos d\u00edgitos de precisi\u00f3n","title":"C\u00f3digos de formato"},{"location":"03_Datos/05_Formato/#formato-a-diccionarios","text":"Pod\u00e9s usar el m\u00e9todo format_map() para aplicarle un formato a los valores de un diccionario: >>> s = { 'nombre': 'Naranja', 'cajones': 100, 'precio': 91.1 } >>> '{nombre:>10s} {cajones:10d} {precio:10.2f}'.format_map(s) ' Naranja 100 91.10' >>> Usa los mismos c\u00f3digos que los f-strings pero toma los valores que provee el diccionario.","title":"Formato a diccionarios"},{"location":"03_Datos/05_Formato/#el-metodo-format","text":"Existe un m\u00e9todo format() que permite aplicar formato a argumentos. >>> '{nombre:>10s} {cajones:10d} {precio:10.2f}'.format(nombre='Naranja', cajones=100, precio=91.1) ' Naranja 100 91.10' >>> '{:10s} {:10d} {:10.2f}'.format('Naranja', 100, 91.1) ' Naranja 100 91.10' >>> La verdad es que format() nos resulta un poco extenso y preferimos usar f-strings .","title":"El m\u00e9todo format()"},{"location":"03_Datos/05_Formato/#formato-estilo-c","text":"Tambi\u00e9n pod\u00e9s usar el operador % . >>> 'The value is %d' % 3 'The value is 3' >>> '%5d %-5d %10d' % (3,4,5) ' 3 4 5' >>> '%0.2f' % (3.1415926,) '3.14' Esto requiere un solo \u00edtem, o una tupla a la derecha. Los c\u00f3digos est\u00e1n tambi\u00e9n inspirados en el printf() de C. Tiene la dificultad de que hay que contar posiciones y todas las variables van juntas al final.","title":"Formato estilo C"},{"location":"03_Datos/05_Formato/#ejercicios","text":"","title":"Ejercicios"},{"location":"03_Datos/05_Formato/#ejercicio-312-formato-de-numeros","text":"Un problema usual cuando queremos imprimir n\u00fameros es especificar el n\u00famero de d\u00edgitos decimales. Los f-strings nos permiten hacerlo. Prob\u00e1 los siguientes ejemplos: >>> value = 42863.1 >>> print(value) 42863.1 >>> print(f'{value:0.4f}') 42863.1000 >>> print(f'{value:>16.2f}') 42863.10 >>> print(f'{value:<16.2f}') 42863.10 >>> print(f'{value:*>16,.2f}') *******42,863.10 >>> La documentaci\u00f3n completa sobre los c\u00f3digos de formato usados en f-strings puede consultarse ac\u00e1 . El formato puede aplicarse tambi\u00e9n usando el operador % de cadenas. >>> print('%0.4f' % value) 42863.1000 >>> print('%16.2f' % value) 42863.10 >>> La documentaci\u00f3n sobre c\u00f3digos usados con % puede encontrarse ac\u00e1 . A pesar de que suelen usarse dentro de un print , el formato de cadenas no est\u00e1 necesariamente ligado a la impresi\u00f3n. Por ejemplo, pod\u00e9s simplemente asignarlo a una variable. >>> f = '%0.4f' % value >>> f '42863.1000' >>>","title":"Ejercicio 3.12: Formato de n\u00fameros"},{"location":"03_Datos/05_Formato/#ejercicio-313-recolectar-datos","text":"En el Ejercicio 2.18 , escribiste un programa llamado informe.py que calculaba las ganancias o p\u00e9rdidas de un cami\u00f3n que compra a productores y vende en el mercado. Copi\u00e1 su contenido en un archivo tabla_informe.py . En este ejercicio, vas a comenzar a modificar tabla_informe.py para producir una tabla como \u00e9sta: Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 32.2 8.02 Naranja 50 91.1 15.18 Caqui 150 103.44 2.02 Mandarina 200 51.23 29.66 Durazno 95 40.37 33.11 Mandarina 50 65.1 15.79 Naranja 100 70.44 35.84 En este informe, el \"Precio\" es el precio en el mercado y el \"Cambio\" es la variaci\u00f3n respecto al precio cobrado por el productor. Para generar un informe como el de arriba, primero ten\u00e9s que recolectar todos los datos de la tabla. Escrib\u00ed una funci\u00f3n hacer_informe() que recibe una lista de cajones y un diccionario con precios como input y devuelve una lista de tuplas conteniendo la informaci\u00f3n mostrada en la tabla anterior. Agreg\u00e1 esta funci\u00f3n a tu archivo tabla_informe.py . Deber\u00eda funcionar como se muestra en el siguiente ejemplo: >>> camion = leer_camion('../Data/camion.csv') >>> precios = leer_precios('../Data/precios.csv') >>> informe = hacer_informe(camion, precios) >>> for r in informe: print(r) ('Lima', 100, 32.2, 8.019999999999996) ('Naranja', 50, 91.1, 15.180000000000007) ('Caqui', 150, 103.44, 2.019999999999996) ('Mandarina', 200, 51.23, 29.660000000000004) ('Durazno', 95, 40.37, 33.11000000000001) ('Mandarina', 50, 65.1, 15.790000000000006) ('Naranja', 100, 70.44, 35.84) ... >>>","title":"Ejercicio 3.13: Recolectar datos"},{"location":"03_Datos/05_Formato/#ejercicio-314-imprimir-una-tabla-con-formato","text":"Volv\u00e9 a hacer el ciclo for del ejercicio anterior pero cambiando la forma de imprimir como sigue: >>> for r in informe: print('%10s %10d %10.2f %10.2f' % r) Lima 100 32.20 8.02 Naranja 50 91.10 15.18 Caqui 150 103.44 2.02 Mandarina 200 51.23 29.66 Durazno 95 40.37 33.11 Mandarina 50 65.10 15.79 Naranja 100 70.44 35.84 ... >>> O directamente usando f-strings. Por ejemplo: >>> for nombre, cajones, precio, cambio in informe: print(f'{nombre:>10s} {cajones:>10d} {precio:>10.2f} {cambio:>10.2f}') Lima 100 32.20 8.02 Naranja 50 91.10 15.18 Caqui 150 103.44 2.02 Mandarina 200 51.23 29.66 Durazno 95 40.37 33.11 Mandarina 50 65.10 15.79 Naranja 100 70.44 35.84 ... >>> Agreg\u00e1 estos \u00faltimos comandos a tu programa tabla_informe.py . Hac\u00e9 que el programa tome la salida de la funci\u00f3n hacer_informe() e imprima una tabla bien formateada.","title":"Ejercicio 3.14: Imprimir una tabla con formato"},{"location":"03_Datos/05_Formato/#ejercicio-315-agregar-encabezados","text":"Suponete que ten\u00e9s una tupla con nombres de encabezado como \u00e9sta: headers = ('Nombre', 'Cajones', 'Precio', 'Cambio') Agreg\u00e1 el c\u00f3digo necesario a tu programa para que tome una tupla de encabezados como la de arriba y cree una cadena donde cada nombre de encabezado est\u00e9 alineado a la derecha en un campo de 10 caracteres de ancho y separados por un solo espacio. ' Nombre Cajones Precio Cambio' Escrib\u00ed el c\u00f3digo que recibe los encabezados y crea una cadena de separaci\u00f3n entre los encabezados y los datos que siguen. Esta cadena es simplemente una tira de caracteres \"-\" bajo cada nombre de campo. Por ejemplo: '---------- ---------- ---------- ----------' Cuando est\u00e9 listo, tu programa deber\u00eda producir una tabla como esta: Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 32.20 8.02 Naranja 50 91.10 15.18 Caqui 150 103.44 2.02 Mandarina 200 51.23 29.66 Durazno 95 40.37 33.11 Mandarina 50 65.10 15.79 Naranja 100 70.44 35.84","title":"Ejercicio 3.15: Agregar encabezados"},{"location":"03_Datos/05_Formato/#ejercicio-316-un-desafio-de-formato","text":"Por \u00faltimo, modific\u00e1 tu c\u00f3digo para que el precio mostrado incluya un s\u00edmbolo de pesos ($) y la salida se vea como esta tabla: Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 $32.2 8.02 Naranja 50 $91.1 15.18 Caqui 150 $103.44 2.02 Mandarina 200 $51.23 29.66 Durazno 95 $40.37 33.11 Mandarina 50 $65.1 15.79 Naranja 100 $70.44 35.84 Guard\u00e1 estos cambios en el archivo tabla_informe.py que m\u00e1s adelante los vas a necesitar.","title":"Ejercicio 3.16: Un desaf\u00edo de formato"},{"location":"03_Datos/05_Formato/#ejercicio-317-tablas-de-multiplicar","text":"Escrib\u00ed un programa tablamult.py que imprima de forma prolija las tablas de multiplicar del 1 al 9 usando f-strings. Si pod\u00e9s, evit\u00e1 usar la multiplicaci\u00f3n, usando s\u00f3lo sumas alcanza. 0 1 2 3 4 5 6 7 8 9 --------------------------------------------- 0: 0 0 0 0 0 0 0 0 0 0 1: 0 1 2 3 4 5 6 7 8 9 2: 0 2 4 6 8 10 12 14 16 18 3: 0 3 6 9 12 15 18 21 24 27 4: 0 4 8 12 16 20 24 28 32 36 5: 0 5 10 15 20 25 30 35 40 45 6: 0 6 12 18 24 30 36 42 48 54 7: 0 7 14 21 28 35 42 49 56 63 8: 0 8 16 24 32 40 48 56 64 72 9: 0 9 18 27 36 45 54 63 72 81 Contenidos | Anterior (4 Entorno de desarrollo integrado) | Pr\u00f3ximo (6 Arbolado porte\u00f1o)","title":"Ejercicio 3.17: Tablas de multiplicar"},{"location":"03_Datos/06_Arboles1/","text":"Contenidos | Anterior (5 Impresi\u00f3n con formato) | Pr\u00f3ximo (7 Cierre de la clase) 3.6 Arbolado porte\u00f1o En esta secci\u00f3n haremos algunos ejercicios que integran los conceptos aprendidos en las clases anteriores. Vamos a manejar archivos, diccionarios, listas, contadores y el comando zip , entre otras cosas. Entreg\u00e1 lo que puedas hacer. Ejercicios Vamos a repasar las herramientas que vimos en esta clase aplic\u00e1ndolas a una base de datos sobre \u00e1rboles en parques de la Ciudad de Buenos Aires. Para empezar, descarg\u00e1 el archivo CSV de \" Arbolado en espacios verdes \" en tu carpeta Data . Vamos a estudiar esta base de datos y responder algunas preguntas. Guard\u00e1 los ejercicios de esta secci\u00f3n en un archivo arboles.py . Descripci\u00f3n de la base T\u00edtulo de la columna Tipo de dato Descripci\u00f3n long N\u00famero flotante (float) Coordenadas para geolocalizaci\u00f3n lat N\u00famero flotante (float) Coordenadas para geolocalizaci\u00f3n id_arbol N\u00famero entero (integer) Identificador \u00fanico del \u00e1rbol altura_tot N\u00famero entero (integer) Altura del \u00e1rbol (m) diametro N\u00famero entero (integer) Di\u00e1metro del \u00e1rbol (cm) inclinacio N\u00famero entero (integer) Inclinaci\u00f3n del \u00e1rbol (grados) id_especie N\u00famero entero (integer) Identificador de la especie nombre_com Texto (string) Nombre com\u00fan del \u00e1rbol nombre_cie Texto (string) Nombre cient\u00edfico del \u00e1rbol tipo_folla Texto (string) Tipo de follaje del \u00e1rbol espacio_ve Texto (string) Nombre del espacio verde ubicacion Texto (string) Direcci\u00f3n del espacio verde nombre_fam Texto (string) Nombre de la familia del \u00e1rbol nombre_gen Texto (string) Nombre del g\u00e9nero del \u00e1rbol origen Texto (string) Origen del \u00e1rbol coord_x N\u00famero flotante (float) Coordenadas para localizaci\u00f3n coord_y N\u00famero flotante (float) Coordenadas para localizaci\u00f3n Ejercicio 3.18: Lectura de los \u00e1rboles de un parque Defin\u00ed una funci\u00f3n leer_parque(nombre_archivo, parque) que abra el archivo indicado y devuelva una lista de diccionarios con la informaci\u00f3n del parque especificado. La funci\u00f3n debe devolver, en una lista un diccionario con todos los datos por cada \u00e1rbol del parque elegido (record\u00e1 que cada fila del csv es un \u00e1rbol). Sugerencia: basate en la funci\u00f3n leer_camion() y us\u00e1 tambi\u00e9n el comando zip como hiciste en el Ejercicio 3.9 para combinar el encabezado del archivo con los datos de cada fila. Inicialmente no te preocupes por los tipos de datos de cada columna, pero cuando empieces a operar con una columna modific\u00e1 esta funci\u00f3n para que ese dato sea del tipo adecuado para operar. Observaci\u00f3n: La columna que indica el nombre del parque en el que se encuentra el \u00e1rbol se llama 'espacio_ve' en el archivo CSV. Prob\u00e1 con el parque \"GENERAL PAZ\" para tener un ejemplo de trabajo, deber\u00eda darte una lista con 690 \u00e1rboles. Ejercicio 3.19: Determinar las especies en un parque Escrib\u00ed una funci\u00f3n especies(lista_arboles) que tome una lista de \u00e1rboles como la generada en el ejercicio anterior y devuelva el conjunto de especies (la columna 'nombre_com' del archivo) que figuran en la lista. Sugerencia: Us\u00e1 el comando set como en la Secci\u00f3n 2.4 . Ejercicio 3.20: Contar ejemplares por especie Usando contadores como en el Ejercicio 3.11 , escrib\u00ed una funci\u00f3n contar_ejemplares(lista_arboles) que, dada una lista como la que generada con leer_parque() , devuelva un diccionario en el que las especies (record\u00e1, es la columna 'nombre_com' del archivo) sean las claves y tengan como valores asociados la cantidad de ejemplares en esa especie en la lista dada. Luego, combin\u00e1 esta funci\u00f3n con leer_parque() y con el m\u00e9todo most_common() para informar las cinco especies m\u00e1s frecuentes en cada uno de los siguientes parques: 'GENERAL PAZ' 'ANDES, LOS' 'CENTENARIO' Resultados de cantidad por especie en tres parques: General Paz Los Andes Centenario Casuarina: 97 Jacarand\u00e1: 117 Pl\u00e1tano: 137 Tipa blanca: 54 Tipa blanca: 28 Jacarand\u00e1: 45 Eucalipto: 49 Cipr\u00e9s: 21 Tipa blanca: 42 Palo borracho rosado: 44 Palo borracho rosado: 18 Palo borracho rosado: 41 Fenix: 40 Lapacho: 12 Fresno americano: 38 Ejercicio 3.21: Alturas de una especie en una lista Escrib\u00ed una funci\u00f3n obtener_alturas(lista_arboles, especie) que, dada una lista de \u00e1rboles como la anterior y una especie de \u00e1rbol (un valor de la columna 'nombre_com' del archivo), devuelva una lista con las alturas (columna 'altura_tot' ) de los ejemplares de esa especie en la lista. Observaci\u00f3n: Ac\u00e1 s\u00ed, fijate de devolver las alturas como n\u00fameros (de punto flotante) y no como cadenas de caracteres. Pod\u00e9s hacer esto modificando leer_parque . Usala para calcular la altura promedio y altura m\u00e1xima de los 'Jacarand\u00e1' en los tres parques mencionados. Resultados de alturas de Jacarand\u00e1s en tres parques: Medida General Paz Los Andes Centenario max 16.0 25.0 18.0 prom 10.2 10.54 8.96 Ejercicio 3.22: Inclinaciones por especie de una lista Escrib\u00ed una funci\u00f3n obtener_inclinaciones(lista_arboles, especie) que, dada una especie de \u00e1rbol y una lista de \u00e1rboles como la anterior, devuelva una lista con las inclinaciones (columna 'inclinacio' ) de los ejemplares de esa especie. Ejercicio 3.23: Especie con el ejemplar m\u00e1s inclinado Combinando la funci\u00f3n especies() con obtener_inclinaciones() escrib\u00ed una funci\u00f3n especimen_mas_inclinado(lista_arboles) que, dada una lista de \u00e1rboles devuelva la especie que tiene el ejemplar m\u00e1s inclinado y su inclinaci\u00f3n. Correlo para los tres parques mencionados anteriormente. Resultados. Deber\u00edas obtener, por ejemplo, que en el Parque Centenario hay un Falso Guayabo inclinado 80 grados. Ejercicio 3.24: Especie m\u00e1s inclinada en promedio Volv\u00e9 a combinar las funciones anteriores para escribir la funci\u00f3n especie_promedio_mas_inclinada(lista_arboles) que, dada una lista de \u00e1rboles devuelva la especie que en promedio tiene la mayor inclinaci\u00f3n y el promedio calculado.. Resultados. Deber\u00edas obtener, por ejemplo, que los \u00c1lamos Plateados del Parque Los Andes tiene un promedio de inclinaci\u00f3n de 25 grados. Preguntas extras: \u00bfQu\u00e9 habr\u00eda que cambiar para obtener la especie con un ejemplar m\u00e1s inclinado de toda la ciudad y no solo de un parque? \u00bfPodr\u00edas dar la latitud y longitud de ese ejemplar? \u00bfY d\u00f3nde se encuentra (lat,lon) el ejemplar m\u00e1s alto? \u00bfDe qu\u00e9 especie es? Contenidos | Anterior (5 Impresi\u00f3n con formato) | Pr\u00f3ximo (7 Cierre de la clase)","title":"06 Arboles1"},{"location":"03_Datos/06_Arboles1/#36-arbolado-porteno","text":"En esta secci\u00f3n haremos algunos ejercicios que integran los conceptos aprendidos en las clases anteriores. Vamos a manejar archivos, diccionarios, listas, contadores y el comando zip , entre otras cosas. Entreg\u00e1 lo que puedas hacer.","title":"3.6 Arbolado porte\u00f1o"},{"location":"03_Datos/06_Arboles1/#ejercicios","text":"Vamos a repasar las herramientas que vimos en esta clase aplic\u00e1ndolas a una base de datos sobre \u00e1rboles en parques de la Ciudad de Buenos Aires. Para empezar, descarg\u00e1 el archivo CSV de \" Arbolado en espacios verdes \" en tu carpeta Data . Vamos a estudiar esta base de datos y responder algunas preguntas. Guard\u00e1 los ejercicios de esta secci\u00f3n en un archivo arboles.py .","title":"Ejercicios"},{"location":"03_Datos/06_Arboles1/#descripcion-de-la-base","text":"T\u00edtulo de la columna Tipo de dato Descripci\u00f3n long N\u00famero flotante (float) Coordenadas para geolocalizaci\u00f3n lat N\u00famero flotante (float) Coordenadas para geolocalizaci\u00f3n id_arbol N\u00famero entero (integer) Identificador \u00fanico del \u00e1rbol altura_tot N\u00famero entero (integer) Altura del \u00e1rbol (m) diametro N\u00famero entero (integer) Di\u00e1metro del \u00e1rbol (cm) inclinacio N\u00famero entero (integer) Inclinaci\u00f3n del \u00e1rbol (grados) id_especie N\u00famero entero (integer) Identificador de la especie nombre_com Texto (string) Nombre com\u00fan del \u00e1rbol nombre_cie Texto (string) Nombre cient\u00edfico del \u00e1rbol tipo_folla Texto (string) Tipo de follaje del \u00e1rbol espacio_ve Texto (string) Nombre del espacio verde ubicacion Texto (string) Direcci\u00f3n del espacio verde nombre_fam Texto (string) Nombre de la familia del \u00e1rbol nombre_gen Texto (string) Nombre del g\u00e9nero del \u00e1rbol origen Texto (string) Origen del \u00e1rbol coord_x N\u00famero flotante (float) Coordenadas para localizaci\u00f3n coord_y N\u00famero flotante (float) Coordenadas para localizaci\u00f3n","title":"Descripci\u00f3n de la base"},{"location":"03_Datos/06_Arboles1/#ejercicio-318-lectura-de-los-arboles-de-un-parque","text":"Defin\u00ed una funci\u00f3n leer_parque(nombre_archivo, parque) que abra el archivo indicado y devuelva una lista de diccionarios con la informaci\u00f3n del parque especificado. La funci\u00f3n debe devolver, en una lista un diccionario con todos los datos por cada \u00e1rbol del parque elegido (record\u00e1 que cada fila del csv es un \u00e1rbol). Sugerencia: basate en la funci\u00f3n leer_camion() y us\u00e1 tambi\u00e9n el comando zip como hiciste en el Ejercicio 3.9 para combinar el encabezado del archivo con los datos de cada fila. Inicialmente no te preocupes por los tipos de datos de cada columna, pero cuando empieces a operar con una columna modific\u00e1 esta funci\u00f3n para que ese dato sea del tipo adecuado para operar. Observaci\u00f3n: La columna que indica el nombre del parque en el que se encuentra el \u00e1rbol se llama 'espacio_ve' en el archivo CSV. Prob\u00e1 con el parque \"GENERAL PAZ\" para tener un ejemplo de trabajo, deber\u00eda darte una lista con 690 \u00e1rboles.","title":"Ejercicio 3.18: Lectura de los \u00e1rboles de un parque"},{"location":"03_Datos/06_Arboles1/#ejercicio-319-determinar-las-especies-en-un-parque","text":"Escrib\u00ed una funci\u00f3n especies(lista_arboles) que tome una lista de \u00e1rboles como la generada en el ejercicio anterior y devuelva el conjunto de especies (la columna 'nombre_com' del archivo) que figuran en la lista. Sugerencia: Us\u00e1 el comando set como en la Secci\u00f3n 2.4 .","title":"Ejercicio 3.19: Determinar las especies en un parque"},{"location":"03_Datos/06_Arboles1/#ejercicio-320-contar-ejemplares-por-especie","text":"Usando contadores como en el Ejercicio 3.11 , escrib\u00ed una funci\u00f3n contar_ejemplares(lista_arboles) que, dada una lista como la que generada con leer_parque() , devuelva un diccionario en el que las especies (record\u00e1, es la columna 'nombre_com' del archivo) sean las claves y tengan como valores asociados la cantidad de ejemplares en esa especie en la lista dada. Luego, combin\u00e1 esta funci\u00f3n con leer_parque() y con el m\u00e9todo most_common() para informar las cinco especies m\u00e1s frecuentes en cada uno de los siguientes parques: 'GENERAL PAZ' 'ANDES, LOS' 'CENTENARIO' Resultados de cantidad por especie en tres parques: General Paz Los Andes Centenario Casuarina: 97 Jacarand\u00e1: 117 Pl\u00e1tano: 137 Tipa blanca: 54 Tipa blanca: 28 Jacarand\u00e1: 45 Eucalipto: 49 Cipr\u00e9s: 21 Tipa blanca: 42 Palo borracho rosado: 44 Palo borracho rosado: 18 Palo borracho rosado: 41 Fenix: 40 Lapacho: 12 Fresno americano: 38","title":"Ejercicio 3.20: Contar ejemplares por especie"},{"location":"03_Datos/06_Arboles1/#ejercicio-321-alturas-de-una-especie-en-una-lista","text":"Escrib\u00ed una funci\u00f3n obtener_alturas(lista_arboles, especie) que, dada una lista de \u00e1rboles como la anterior y una especie de \u00e1rbol (un valor de la columna 'nombre_com' del archivo), devuelva una lista con las alturas (columna 'altura_tot' ) de los ejemplares de esa especie en la lista. Observaci\u00f3n: Ac\u00e1 s\u00ed, fijate de devolver las alturas como n\u00fameros (de punto flotante) y no como cadenas de caracteres. Pod\u00e9s hacer esto modificando leer_parque . Usala para calcular la altura promedio y altura m\u00e1xima de los 'Jacarand\u00e1' en los tres parques mencionados. Resultados de alturas de Jacarand\u00e1s en tres parques: Medida General Paz Los Andes Centenario max 16.0 25.0 18.0 prom 10.2 10.54 8.96","title":"Ejercicio 3.21: Alturas de una especie en una lista"},{"location":"03_Datos/06_Arboles1/#ejercicio-322-inclinaciones-por-especie-de-una-lista","text":"Escrib\u00ed una funci\u00f3n obtener_inclinaciones(lista_arboles, especie) que, dada una especie de \u00e1rbol y una lista de \u00e1rboles como la anterior, devuelva una lista con las inclinaciones (columna 'inclinacio' ) de los ejemplares de esa especie.","title":"Ejercicio 3.22: Inclinaciones por especie de una lista"},{"location":"03_Datos/06_Arboles1/#ejercicio-323-especie-con-el-ejemplar-mas-inclinado","text":"Combinando la funci\u00f3n especies() con obtener_inclinaciones() escrib\u00ed una funci\u00f3n especimen_mas_inclinado(lista_arboles) que, dada una lista de \u00e1rboles devuelva la especie que tiene el ejemplar m\u00e1s inclinado y su inclinaci\u00f3n. Correlo para los tres parques mencionados anteriormente. Resultados. Deber\u00edas obtener, por ejemplo, que en el Parque Centenario hay un Falso Guayabo inclinado 80 grados.","title":"Ejercicio 3.23: Especie con el ejemplar m\u00e1s inclinado"},{"location":"03_Datos/06_Arboles1/#ejercicio-324-especie-mas-inclinada-en-promedio","text":"Volv\u00e9 a combinar las funciones anteriores para escribir la funci\u00f3n especie_promedio_mas_inclinada(lista_arboles) que, dada una lista de \u00e1rboles devuelva la especie que en promedio tiene la mayor inclinaci\u00f3n y el promedio calculado.. Resultados. Deber\u00edas obtener, por ejemplo, que los \u00c1lamos Plateados del Parque Los Andes tiene un promedio de inclinaci\u00f3n de 25 grados. Preguntas extras: \u00bfQu\u00e9 habr\u00eda que cambiar para obtener la especie con un ejemplar m\u00e1s inclinado de toda la ciudad y no solo de un parque? \u00bfPodr\u00edas dar la latitud y longitud de ese ejemplar? \u00bfY d\u00f3nde se encuentra (lat,lon) el ejemplar m\u00e1s alto? \u00bfDe qu\u00e9 especie es? Contenidos | Anterior (5 Impresi\u00f3n con formato) | Pr\u00f3ximo (7 Cierre de la clase)","title":"Ejercicio 3.24: Especie m\u00e1s inclinada en promedio"},{"location":"03_Datos/07_CierreClase/","text":"Contenidos | Anterior (6 Arbolado porte\u00f1o) 3.7 Cierre de la clase En esta clase aprendimos a trabajar con datos. Manejamos archivos CSV y estructuras un poco m\u00e1s complejas como tuplas, conjuntos y diccionarios y profundizamos un poco m\u00e1s en las listas. Te recordamos que leas el c\u00f3digo de honor del curso en el que hablamos de las reglas que rigen en este curso para evitar el plagio as\u00ed como otros aspectos importantes sobre qu\u00e9 se puede compartir y qu\u00e9 no. Al enviar tus archivos entendemos que le\u00edste y estas de acuerdo con este texto. En caso contrario no env\u00edes tus archivos y contactate con los docentes. Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: 1. El archivo solucion_de_errores.py del Ejercicio 3.1 y siguientes. 2. El archivo informe.py del Ejercicio 3.9 . 4. El archivo tabla_informe.py del Ejercicio 3.16 (o del Ejercicio 3.15 si no sali\u00f3 lo del signo $). 5. El archivo tablamult.py del Ejercicio 3.17 . 3. El archivo arboles.py sobre arbolado porte\u00f1o incluyendo todos los ejercicios que hayas hecho (esperamos al menos el Ejercicio 3.18 y uno m\u00e1s). Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y tendr\u00e1s la opci\u00f3n de participar en la revisi\u00f3n de pares. Esperamos en esta clase que entregues los cinco ejercicios que te pedimos. Acordate, us\u00e1 siempre la misma direcci\u00f3n de mail con la que te inscribiste al curso as\u00ed podemos llevar registro de tus entregas. Observaci\u00f3n: Si el enunciado de un ejercicio te pide que lo corras con un input particular, por favor pon\u00e9 la salida que obtuviste como comentario en tu c\u00f3digo. Por \u00faltimo te recordamos que si te quedaron dudas, quer\u00e9s discutir alg\u00fan tema de inter\u00e9s o pedirnos a los docentes que resolvamos un ejercicio particular para la pr\u00f3xima clase, pod\u00e9s hacelo en el grupo de Slack . Contenidos | Anterior (6 Arbolado porte\u00f1o)","title":"07 CierreClase"},{"location":"03_Datos/07_CierreClase/#37-cierre-de-la-clase","text":"En esta clase aprendimos a trabajar con datos. Manejamos archivos CSV y estructuras un poco m\u00e1s complejas como tuplas, conjuntos y diccionarios y profundizamos un poco m\u00e1s en las listas. Te recordamos que leas el c\u00f3digo de honor del curso en el que hablamos de las reglas que rigen en este curso para evitar el plagio as\u00ed como otros aspectos importantes sobre qu\u00e9 se puede compartir y qu\u00e9 no. Al enviar tus archivos entendemos que le\u00edste y estas de acuerdo con este texto. En caso contrario no env\u00edes tus archivos y contactate con los docentes. Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: 1. El archivo solucion_de_errores.py del Ejercicio 3.1 y siguientes. 2. El archivo informe.py del Ejercicio 3.9 . 4. El archivo tabla_informe.py del Ejercicio 3.16 (o del Ejercicio 3.15 si no sali\u00f3 lo del signo $). 5. El archivo tablamult.py del Ejercicio 3.17 . 3. El archivo arboles.py sobre arbolado porte\u00f1o incluyendo todos los ejercicios que hayas hecho (esperamos al menos el Ejercicio 3.18 y uno m\u00e1s). Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y tendr\u00e1s la opci\u00f3n de participar en la revisi\u00f3n de pares. Esperamos en esta clase que entregues los cinco ejercicios que te pedimos. Acordate, us\u00e1 siempre la misma direcci\u00f3n de mail con la que te inscribiste al curso as\u00ed podemos llevar registro de tus entregas. Observaci\u00f3n: Si el enunciado de un ejercicio te pide que lo corras con un input particular, por favor pon\u00e9 la salida que obtuviste como comentario en tu c\u00f3digo. Por \u00faltimo te recordamos que si te quedaron dudas, quer\u00e9s discutir alg\u00fan tema de inter\u00e9s o pedirnos a los docentes que resolvamos un ejercicio particular para la pr\u00f3xima clase, pod\u00e9s hacelo en el grupo de Slack . Contenidos | Anterior (6 Arbolado porte\u00f1o)","title":"3.7 Cierre de la clase"},{"location":"04_Listas_y_Listas/00_Resumen/","text":"Contenidos | Anterior (3 Trabajando con datos) | Pr\u00f3ximo (5 Aleatoridad) 4. Algoritmos sobre listas y comprensi\u00f3n de listas En esta clase introducimos el debugger y les proponemos una serie de ejercicios donde tienen que escribir algoritmos que operen sobre listas. Luego introducimos la comprensi\u00f3n de listas , un concepto muy hermoso y pythonesco. Cerramos la clase con una discusi\u00f3n sobre el concepto de objeto que subyace al lenguaje y algunos ejercicios para repasar estos conceptos usando el dataset de la clase pasada. Record\u00e1: aunque no termines todos los ejercicios, complet\u00e1 el formulario del final de la clase y sub\u00ed los que hayas podido hacer ANTES del d\u00eda mi\u00e9rcoles siguiente a las 14hs. Esto es parte de las condiciones de aprobaci\u00f3n de la materia: todes podemos tener una semana complicada, pero en general esperamos que entregues la mayor\u00eda de los ejercicios. 4.1 Debuggear programas 4.2 Listas y b\u00fasqueda lineal 4.3 Comprensi\u00f3n de listas 4.4 Objetos 4.5 Arbolado porte\u00f1o y comprensi\u00f3n de listas 4.6 Cierre de la clase Contenidos | Anterior (3 Trabajando con datos) | Pr\u00f3ximo (5 Aleatoridad)","title":"00 Resumen"},{"location":"04_Listas_y_Listas/00_Resumen/#4-algoritmos-sobre-listas-y-comprension-de-listas","text":"En esta clase introducimos el debugger y les proponemos una serie de ejercicios donde tienen que escribir algoritmos que operen sobre listas. Luego introducimos la comprensi\u00f3n de listas , un concepto muy hermoso y pythonesco. Cerramos la clase con una discusi\u00f3n sobre el concepto de objeto que subyace al lenguaje y algunos ejercicios para repasar estos conceptos usando el dataset de la clase pasada. Record\u00e1: aunque no termines todos los ejercicios, complet\u00e1 el formulario del final de la clase y sub\u00ed los que hayas podido hacer ANTES del d\u00eda mi\u00e9rcoles siguiente a las 14hs. Esto es parte de las condiciones de aprobaci\u00f3n de la materia: todes podemos tener una semana complicada, pero en general esperamos que entregues la mayor\u00eda de los ejercicios. 4.1 Debuggear programas 4.2 Listas y b\u00fasqueda lineal 4.3 Comprensi\u00f3n de listas 4.4 Objetos 4.5 Arbolado porte\u00f1o y comprensi\u00f3n de listas 4.6 Cierre de la clase Contenidos | Anterior (3 Trabajando con datos) | Pr\u00f3ximo (5 Aleatoridad)","title":"4. Algoritmos sobre listas y comprensi\u00f3n de listas"},{"location":"04_Listas_y_Listas/01_Debugger/","text":"Contenidos | Pr\u00f3ximo (2 Listas y b\u00fasqueda lineal) 4.1 Debuggear programas Python tiene un debugger poderoso que te permite probar porciones de c\u00f3digo. Esto es sencillo y est\u00e1 integrado en IDEs como Spyder. Vimos en la Secci\u00f3n 3.1 diferentes ejemplos de problemas que pueden aparecer y tuviste que arremangarte e ingeni\u00e1rtelas para resolverlos a mano. En esta secci\u00f3n vamos a introducir la herramientas pdb (Python debugger) que ofrece el lenguaje para resolver este tipo de problemas. Testear es genial, debuggear es horrible. Se dice que hay un bug (un error) cuando un programa no se comporta como el programador espera o hace algo inesperado. Es muy frecuente que los programas tengan bugs. Despu\u00e9s de escribir un fragmento de c\u00f3digo por primera vez, es conveniente correrlo algunas veces usando tests que permitan poner en evidencia esos bugs. Dise\u00f1ar un conjunto de tests adecuado no es una tarea sencilla y es frecuente que queden casos especiales que causen errores inesperados. Python es un lenguaje interpretado, con tipos de datos din\u00e1micos (una misma variable puede cambiar de tipo, de int a float , por ejemplo). No tiene un compilador que te alerte sobre inconsistencias de tipos antes de ejecutar el programa. Es bueno usar buenas pr\u00e1cticas que minimicen estos potenciales errores pero igual es posible que algunos errores se filtren. Testear consiste en ejecutar un programa o porci\u00f3n de c\u00f3digo en condiciones controladas, con entradas conocidas y salidas predichas de forma de poder verificar si lo que da el algoritmos es lo que esperabas. La ejecuci\u00f3n de un algoritmo puede pensarse como un \u00e1rbol (el \u00e1rbol de ejecuci\u00f3n del algoritmo, cada condici\u00f3n booleana da lugar a una ramificaci\u00f3n del \u00e1rbol). Seg\u00fan la entrada que le des, el programa se va a ejecutar siguiendo una rama u otra. Lo ideal es testear todas las ramas posibles de ejecuci\u00f3n y que los casos de prueba ( test cases ) incluyan todos los casos especiales (casos como listas vac\u00edas, \u00edndices apuntando al primer o al \u00faltimo elemento, claves ausentes, etc.) comprobando en cada caso que el programa se comporte seg\u00fan lo esperado. Los entornos de desarrollo integrado (como el Spyder) dan la posiblidad de combinar el uso de un int\u00e9rprete de Python con un editor de c\u00f3digo y suelen integrar tambi\u00e9n el uso del debugger. A\u00fan con herramientas como el Spyder, hacer debugging es lento y tedioso. Antes de entrar en los detalles de c\u00f3mo hacerlo, comentaremos algunos m\u00e9todos que tratan de reducir su necesidad. Profundizaremos sobre estos m\u00e9todos m\u00e1s adelante. Aseveraciones (assert) El comando assert se usa para un control interno del programa. Si la expresi\u00f3n que queremos verificar es False , se levanta una excepci\u00f3n de tipo AssertionError . La sintaxis de assert es la siguiente. assert <expresion> [, 'Mensaje'] Por ejemplo assert isinstance(10, int), 'Necesito un entero (int)' La idea no es usarlo para comprobar la validez de lo ingresado por el usuario. El prop\u00f3sito de usar assert es verificar que ciertas condiciones se cumplan. En general se lo usa mientras el programa est\u00e1 en desarrollo, y luego se los quita o desactiva cuando el programa funciona. Programaci\u00f3n por contratos Se llama programaci\u00f3n por contratos a una forma de programar en la que le programadore define, para cada parte del programa, el tipo y formato de datos con que llamarla y el tipo de datos que devolver\u00e1. Para asegurarse que los tipos de datos sean los esperados, el uso irrestricto de verificaciones puede ayudar en el dise\u00f1o de software, y detecta tempranamente un error en los datos pasados a una funci\u00f3n evitando que se propague. Por ejemplo: podr\u00edas poner verificaciones para cada par\u00e1metro de una funci\u00f3n. def add(x, y): assert isinstance(x, int), 'Necesito un entero (int)' assert isinstance(y, int), 'Necesito un entero (int)' return x + y De este modo, una funcion puede verificar que todos sus argumentos sean v\u00e1lidos. >>> add(2, 3) 5 >>> add('2', '3') Traceback (most recent call last): ... AssertionError: Necesito un entero (int) >>> El debugger de Python (pdb) Es posible usar el debugger de Python directamente en el int\u00e9rprete (sin interfaz gr\u00e1fica) para seguir el funcionamiento de un programa. No vamos a entrar en esos detalles ac\u00e1. Solo mencionamos que la funci\u00f3n breakpoint () inicia el debugger: def mi_funcion(): ... breakpoint() # Iniciar el debugger (Python 3.7+) ... Pod\u00e9s encontrar instrucciones detalladas ac\u00e1 sobre como usarlo. Nos resulta m\u00e1s c\u00f3modo usar un IDE como Spyder para hacer debugging y \u00e9se es el m\u00e9todo que describiremos aqu\u00ed. Este es el men\u00fa desplegable del debugger: Fijate los nombres de cada \u00edcono: Nombre Acci\u00f3n Debug inicia el modo debug Step da un paso en el programa Step Into entra en la funci\u00f3n referida Step Return ejecuta hasta salir de la funci\u00f3n Continue retoma la ejecuci\u00f3n normal Stop detiene el programa Vamos a volver a analizar el siguiente c\u00f3digo, similar al del Ejercicio 3.1 para que veas la utilidad del debugger: def tiene_a(expresion): n = len(expresion) i = 0 while i<n: if expresion[i] == 'a': return True else: return False i += 1 rta = tiene_a ('palabra') print(rta) Una vez que tengas el c\u00f3digo copiado en el Spyder, vamos a ejecutarlo en modo debug : Primero entramos al modo debug (Ctrl+F5): El programa queda pausado antes de comenzar. Not\u00e1 los cambios en la ventana interactiva. Si damos un paso en el programa: \u00bfqu\u00e9 va a ocurrir? Debemos tratar de responder esta pregunta antes de avanzar cada paso. Es nuestra predicci\u00f3n, contrastada con lo que realmente sucede, lo que delata el error . Queremos ver la evoluci\u00f3n de las variables en la solapa Variable Explorer (solapa del centro en el panel superior de la derecha). El programa est\u00e1 en ejecuci\u00f3n pero pausado. Sabemos que estamos en modo debug por el prompt ipdb> abajo. Damos algunos pasos (con Step , Ctrl + F10) hasta llegar a la llamada a la funci\u00f3n tiene_a() que queremos analizar. Fijate que el debugger pas\u00f3 por la l\u00ednea de definici\u00f3n de la funci\u00f3n (y ahora sabe d\u00f3nde ir a buscarla) pero nunca entr\u00f3 al cuerpo de la funci\u00f3n a\u00fan. Eso va a ocurrir reci\u00e9n al llamarla. A esta altura, no queremos simplemente dar un paso (eso ejecutar\u00eda la funci\u00f3n entera, de una) sino entrar en los detalles de esta funci\u00f3n. Para eso usamos Step Into (Ctrl + F11) de forma de entrar en la ejecuci\u00f3n de la funci\u00f3n tiene_a() . Una vez dentro, seguimos dando pasos (con Step , Ctrl + F10), siempre pensando qu\u00e9 esperamos que haga la funci\u00f3n y observando la evoluci\u00f3n de las variables en el explorador de variables. Sigamos as\u00ed hasta llegar al condicional if . Vemos en el Variable Explorer que todas las variables internas de la funci\u00f3n est\u00e1n definidas y con sus valores asignados. Como i = 0 sabemos que es la primera iteraci\u00f3n. Corroboramos que n=7 (\u201cpalabra\u201d tiene 7 letras). En este punto se eval\u00faa if palabra[i] == 'a': , y saltaremos a alguna de las dos ramas de ejecuci\u00f3n seg\u00fan la evaluaci\u00f3n resulte True o False . La expresi\u00f3n resulta False ya que la primera letra de 'palabra' es la 'p' y no una 'a'. Pero entonces la siguiente instrucci\u00f3n ser\u00e1 return False con lo que saldremos de la funci\u00f3n habiendo s\u00f3lo evaluado la primera letra de la palabra pasada como par\u00e1metro. \u00bfEsto es lo que quer\u00edamos? Acabamos de volver de la funci\u00f3n. Las variables internas a la funci\u00f3n ya no est\u00e1n visibles (salimos de su alcance o scope ). El programa sigue en ejecuci\u00f3n, en modo debug . Si seguimos dando pasos con Step (Ctrl + F10) vamos a pasar por el print() y terminar la ejecuci\u00f3n del programa, saliendo del modo debug . Si, en cambio, al llegar a la l\u00ednea del print() en lugar de Step (Ctrl + F10) avanz\u00e1ramos con un Step Into (Ctrl + F11), entrar\u00edamos en los detalles de la definici\u00f3n de esta funci\u00f3n y la cosa se pondr\u00eda un toque t\u00e9cnica. Cuando esto ocurre es \u00fatil usar el Step Return (Ctrl + Shift + F11) para salir de tanto nivel de detalle. En todo caso, lo que observamos en esta ejecuci\u00f3n de tiene_a() es que salimos de la funci\u00f3n despu\u00e9s de haber analizado s\u00f3lo la primera letra de la palabra. \u00bfEs correcto esto? \u00bfDonde est\u00e1 el error? \u00bfC\u00f3mo lo podemos resolver? Comentario. Recorrer la ejecuci\u00f3n de un programa como un simple espectador no nos muestra claramente un error en el c\u00f3digo. Es la incongruencia entre lo esperado y lo que realmente sucede lo que lo marca. Esto exige mucha atenci\u00f3n para, antes de ejecutar cada paso, preguntarse: \u00bfqu\u00e9 espero que ocurra? Luego, al avanzar un paso en la ejecuci\u00f3n, puede ocurrir que lo que esperamos que pase no sea lo que realmente pasa. Entonces estamos en un paso clave de la ejecuci\u00f3n, que nos marca que estamos frente a una de dos: \u00f3 frente a un error en el c\u00f3digo \u00f3 frente a la oportunidad de mejorar nuestra comprensi\u00f3n del mismo. Ejercicios Ejercicio 4.1: Debugger Ingres\u00e1 y corr\u00e9 el siguiente c\u00f3digo en tu IDE: def invertir_lista(lista): '''Recibe una lista L y la develve invertida.''' invertida = [] i = len(lista) while i > 0: # tomo el \u00faltimo elemento i = i-1 invertida.append (lista.pop(i)) # return invertida l = [1, 2, 3, 4, 5] m = invertir_lista(l) print(f'Entrada {l}, Salida: {m}') Deber\u00edas observar que la funci\u00f3n modifica el valor de la lista de entrada. Eso no deber\u00eda ocurrir: una funci\u00f3n nunca deber\u00eda modificar los par\u00e1metros salvo que sea lo esperado. Us\u00e1 el debugger y el explorador de variables para determinar cu\u00e1l es el primer paso clave en el que se modifica el valor de esta variable. Ejercicio 4.2: M\u00e1s debugger Siguiendo con los ejemplos del Ejercicio 3.1 , us\u00e1 el debugger para analizar el siguiente c\u00f3digo: import csv from pprint import pprint def leer_camion(nombre_archivo): camion = [] registro = {} with open(nombre_archivo,\"rt\") as f: filas = csv.reader(f) encabezado = next(filas) for fila in filas: registro[encabezado[0]] = fila[0] registro[encabezado[1]] = int(fila[1]) registro[encabezado[2]] = float(fila[2]) camion.append(registro) return camion camion = leer_camion('../Data/camion.csv') pprint(camion) Observ\u00e1 en particular lo que ocurre al leer la segunda fila de datos del archivo y guardarlos en la variable registro con los datos ya guardados en la lista camion . M\u00e1s ejercitacion con el debugger? Contenidos | Pr\u00f3ximo (2 Listas y b\u00fasqueda lineal)","title":"01 Debugger"},{"location":"04_Listas_y_Listas/01_Debugger/#41-debuggear-programas","text":"Python tiene un debugger poderoso que te permite probar porciones de c\u00f3digo. Esto es sencillo y est\u00e1 integrado en IDEs como Spyder. Vimos en la Secci\u00f3n 3.1 diferentes ejemplos de problemas que pueden aparecer y tuviste que arremangarte e ingeni\u00e1rtelas para resolverlos a mano. En esta secci\u00f3n vamos a introducir la herramientas pdb (Python debugger) que ofrece el lenguaje para resolver este tipo de problemas.","title":"4.1 Debuggear programas"},{"location":"04_Listas_y_Listas/01_Debugger/#testear-es-genial-debuggear-es-horrible","text":"Se dice que hay un bug (un error) cuando un programa no se comporta como el programador espera o hace algo inesperado. Es muy frecuente que los programas tengan bugs. Despu\u00e9s de escribir un fragmento de c\u00f3digo por primera vez, es conveniente correrlo algunas veces usando tests que permitan poner en evidencia esos bugs. Dise\u00f1ar un conjunto de tests adecuado no es una tarea sencilla y es frecuente que queden casos especiales que causen errores inesperados. Python es un lenguaje interpretado, con tipos de datos din\u00e1micos (una misma variable puede cambiar de tipo, de int a float , por ejemplo). No tiene un compilador que te alerte sobre inconsistencias de tipos antes de ejecutar el programa. Es bueno usar buenas pr\u00e1cticas que minimicen estos potenciales errores pero igual es posible que algunos errores se filtren. Testear consiste en ejecutar un programa o porci\u00f3n de c\u00f3digo en condiciones controladas, con entradas conocidas y salidas predichas de forma de poder verificar si lo que da el algoritmos es lo que esperabas. La ejecuci\u00f3n de un algoritmo puede pensarse como un \u00e1rbol (el \u00e1rbol de ejecuci\u00f3n del algoritmo, cada condici\u00f3n booleana da lugar a una ramificaci\u00f3n del \u00e1rbol). Seg\u00fan la entrada que le des, el programa se va a ejecutar siguiendo una rama u otra. Lo ideal es testear todas las ramas posibles de ejecuci\u00f3n y que los casos de prueba ( test cases ) incluyan todos los casos especiales (casos como listas vac\u00edas, \u00edndices apuntando al primer o al \u00faltimo elemento, claves ausentes, etc.) comprobando en cada caso que el programa se comporte seg\u00fan lo esperado. Los entornos de desarrollo integrado (como el Spyder) dan la posiblidad de combinar el uso de un int\u00e9rprete de Python con un editor de c\u00f3digo y suelen integrar tambi\u00e9n el uso del debugger. A\u00fan con herramientas como el Spyder, hacer debugging es lento y tedioso. Antes de entrar en los detalles de c\u00f3mo hacerlo, comentaremos algunos m\u00e9todos que tratan de reducir su necesidad. Profundizaremos sobre estos m\u00e9todos m\u00e1s adelante.","title":"Testear es genial, debuggear es horrible."},{"location":"04_Listas_y_Listas/01_Debugger/#aseveraciones-assert","text":"El comando assert se usa para un control interno del programa. Si la expresi\u00f3n que queremos verificar es False , se levanta una excepci\u00f3n de tipo AssertionError . La sintaxis de assert es la siguiente. assert <expresion> [, 'Mensaje'] Por ejemplo assert isinstance(10, int), 'Necesito un entero (int)' La idea no es usarlo para comprobar la validez de lo ingresado por el usuario. El prop\u00f3sito de usar assert es verificar que ciertas condiciones se cumplan. En general se lo usa mientras el programa est\u00e1 en desarrollo, y luego se los quita o desactiva cuando el programa funciona.","title":"Aseveraciones (assert)"},{"location":"04_Listas_y_Listas/01_Debugger/#programacion-por-contratos","text":"Se llama programaci\u00f3n por contratos a una forma de programar en la que le programadore define, para cada parte del programa, el tipo y formato de datos con que llamarla y el tipo de datos que devolver\u00e1. Para asegurarse que los tipos de datos sean los esperados, el uso irrestricto de verificaciones puede ayudar en el dise\u00f1o de software, y detecta tempranamente un error en los datos pasados a una funci\u00f3n evitando que se propague. Por ejemplo: podr\u00edas poner verificaciones para cada par\u00e1metro de una funci\u00f3n. def add(x, y): assert isinstance(x, int), 'Necesito un entero (int)' assert isinstance(y, int), 'Necesito un entero (int)' return x + y De este modo, una funcion puede verificar que todos sus argumentos sean v\u00e1lidos. >>> add(2, 3) 5 >>> add('2', '3') Traceback (most recent call last): ... AssertionError: Necesito un entero (int) >>>","title":"Programaci\u00f3n por contratos"},{"location":"04_Listas_y_Listas/01_Debugger/#el-debugger-de-python-pdb","text":"Es posible usar el debugger de Python directamente en el int\u00e9rprete (sin interfaz gr\u00e1fica) para seguir el funcionamiento de un programa. No vamos a entrar en esos detalles ac\u00e1. Solo mencionamos que la funci\u00f3n breakpoint () inicia el debugger: def mi_funcion(): ... breakpoint() # Iniciar el debugger (Python 3.7+) ... Pod\u00e9s encontrar instrucciones detalladas ac\u00e1 sobre como usarlo. Nos resulta m\u00e1s c\u00f3modo usar un IDE como Spyder para hacer debugging y \u00e9se es el m\u00e9todo que describiremos aqu\u00ed. Este es el men\u00fa desplegable del debugger: Fijate los nombres de cada \u00edcono: Nombre Acci\u00f3n Debug inicia el modo debug Step da un paso en el programa Step Into entra en la funci\u00f3n referida Step Return ejecuta hasta salir de la funci\u00f3n Continue retoma la ejecuci\u00f3n normal Stop detiene el programa Vamos a volver a analizar el siguiente c\u00f3digo, similar al del Ejercicio 3.1 para que veas la utilidad del debugger: def tiene_a(expresion): n = len(expresion) i = 0 while i<n: if expresion[i] == 'a': return True else: return False i += 1 rta = tiene_a ('palabra') print(rta) Una vez que tengas el c\u00f3digo copiado en el Spyder, vamos a ejecutarlo en modo debug : Primero entramos al modo debug (Ctrl+F5): El programa queda pausado antes de comenzar. Not\u00e1 los cambios en la ventana interactiva. Si damos un paso en el programa: \u00bfqu\u00e9 va a ocurrir? Debemos tratar de responder esta pregunta antes de avanzar cada paso. Es nuestra predicci\u00f3n, contrastada con lo que realmente sucede, lo que delata el error . Queremos ver la evoluci\u00f3n de las variables en la solapa Variable Explorer (solapa del centro en el panel superior de la derecha). El programa est\u00e1 en ejecuci\u00f3n pero pausado. Sabemos que estamos en modo debug por el prompt ipdb> abajo. Damos algunos pasos (con Step , Ctrl + F10) hasta llegar a la llamada a la funci\u00f3n tiene_a() que queremos analizar. Fijate que el debugger pas\u00f3 por la l\u00ednea de definici\u00f3n de la funci\u00f3n (y ahora sabe d\u00f3nde ir a buscarla) pero nunca entr\u00f3 al cuerpo de la funci\u00f3n a\u00fan. Eso va a ocurrir reci\u00e9n al llamarla. A esta altura, no queremos simplemente dar un paso (eso ejecutar\u00eda la funci\u00f3n entera, de una) sino entrar en los detalles de esta funci\u00f3n. Para eso usamos Step Into (Ctrl + F11) de forma de entrar en la ejecuci\u00f3n de la funci\u00f3n tiene_a() . Una vez dentro, seguimos dando pasos (con Step , Ctrl + F10), siempre pensando qu\u00e9 esperamos que haga la funci\u00f3n y observando la evoluci\u00f3n de las variables en el explorador de variables. Sigamos as\u00ed hasta llegar al condicional if . Vemos en el Variable Explorer que todas las variables internas de la funci\u00f3n est\u00e1n definidas y con sus valores asignados. Como i = 0 sabemos que es la primera iteraci\u00f3n. Corroboramos que n=7 (\u201cpalabra\u201d tiene 7 letras). En este punto se eval\u00faa if palabra[i] == 'a': , y saltaremos a alguna de las dos ramas de ejecuci\u00f3n seg\u00fan la evaluaci\u00f3n resulte True o False . La expresi\u00f3n resulta False ya que la primera letra de 'palabra' es la 'p' y no una 'a'. Pero entonces la siguiente instrucci\u00f3n ser\u00e1 return False con lo que saldremos de la funci\u00f3n habiendo s\u00f3lo evaluado la primera letra de la palabra pasada como par\u00e1metro. \u00bfEsto es lo que quer\u00edamos? Acabamos de volver de la funci\u00f3n. Las variables internas a la funci\u00f3n ya no est\u00e1n visibles (salimos de su alcance o scope ). El programa sigue en ejecuci\u00f3n, en modo debug . Si seguimos dando pasos con Step (Ctrl + F10) vamos a pasar por el print() y terminar la ejecuci\u00f3n del programa, saliendo del modo debug . Si, en cambio, al llegar a la l\u00ednea del print() en lugar de Step (Ctrl + F10) avanz\u00e1ramos con un Step Into (Ctrl + F11), entrar\u00edamos en los detalles de la definici\u00f3n de esta funci\u00f3n y la cosa se pondr\u00eda un toque t\u00e9cnica. Cuando esto ocurre es \u00fatil usar el Step Return (Ctrl + Shift + F11) para salir de tanto nivel de detalle. En todo caso, lo que observamos en esta ejecuci\u00f3n de tiene_a() es que salimos de la funci\u00f3n despu\u00e9s de haber analizado s\u00f3lo la primera letra de la palabra. \u00bfEs correcto esto? \u00bfDonde est\u00e1 el error? \u00bfC\u00f3mo lo podemos resolver? Comentario. Recorrer la ejecuci\u00f3n de un programa como un simple espectador no nos muestra claramente un error en el c\u00f3digo. Es la incongruencia entre lo esperado y lo que realmente sucede lo que lo marca. Esto exige mucha atenci\u00f3n para, antes de ejecutar cada paso, preguntarse: \u00bfqu\u00e9 espero que ocurra? Luego, al avanzar un paso en la ejecuci\u00f3n, puede ocurrir que lo que esperamos que pase no sea lo que realmente pasa. Entonces estamos en un paso clave de la ejecuci\u00f3n, que nos marca que estamos frente a una de dos: \u00f3 frente a un error en el c\u00f3digo \u00f3 frente a la oportunidad de mejorar nuestra comprensi\u00f3n del mismo.","title":"El debugger de Python (pdb)"},{"location":"04_Listas_y_Listas/01_Debugger/#ejercicios","text":"","title":"Ejercicios"},{"location":"04_Listas_y_Listas/01_Debugger/#ejercicio-41-debugger","text":"Ingres\u00e1 y corr\u00e9 el siguiente c\u00f3digo en tu IDE: def invertir_lista(lista): '''Recibe una lista L y la develve invertida.''' invertida = [] i = len(lista) while i > 0: # tomo el \u00faltimo elemento i = i-1 invertida.append (lista.pop(i)) # return invertida l = [1, 2, 3, 4, 5] m = invertir_lista(l) print(f'Entrada {l}, Salida: {m}') Deber\u00edas observar que la funci\u00f3n modifica el valor de la lista de entrada. Eso no deber\u00eda ocurrir: una funci\u00f3n nunca deber\u00eda modificar los par\u00e1metros salvo que sea lo esperado. Us\u00e1 el debugger y el explorador de variables para determinar cu\u00e1l es el primer paso clave en el que se modifica el valor de esta variable.","title":"Ejercicio 4.1: Debugger"},{"location":"04_Listas_y_Listas/01_Debugger/#ejercicio-42-mas-debugger","text":"Siguiendo con los ejemplos del Ejercicio 3.1 , us\u00e1 el debugger para analizar el siguiente c\u00f3digo: import csv from pprint import pprint def leer_camion(nombre_archivo): camion = [] registro = {} with open(nombre_archivo,\"rt\") as f: filas = csv.reader(f) encabezado = next(filas) for fila in filas: registro[encabezado[0]] = fila[0] registro[encabezado[1]] = int(fila[1]) registro[encabezado[2]] = float(fila[2]) camion.append(registro) return camion camion = leer_camion('../Data/camion.csv') pprint(camion) Observ\u00e1 en particular lo que ocurre al leer la segunda fila de datos del archivo y guardarlos en la variable registro con los datos ya guardados en la lista camion .","title":"Ejercicio 4.2: M\u00e1s debugger"},{"location":"04_Listas_y_Listas/01_Debugger/#mas-ejercitacion-con-el-debugger","text":"Contenidos | Pr\u00f3ximo (2 Listas y b\u00fasqueda lineal)","title":"M\u00e1s ejercitacion con el debugger?"},{"location":"04_Listas_y_Listas/02_IteradoresLista/","text":"Contenidos | Anterior (1 Debuggear programas) | Pr\u00f3ximo (3 Comprensi\u00f3n de listas) 4.2 Listas y b\u00fasqueda lineal En esta secci\u00f3n seguiremos usando Python, pero nos concentraremos en la parte algor\u00edtmica. Vas a escribir funciones sencillas (y no tanto) que realicen operaciones de bajo nivel sobre listas. \u00c9ste es un curso de Python y de algoritmos. Python es un lenguaje de alto nivel. Esto significa que con pocas instrucciones permite realizar operaciones muy complejas. Los lenguajes de bajo nivel est\u00e1n m\u00e1s cerca del lenguaje del procesador y programar en ellos por ejemplo, un an\u00e1lisis de datos, es mucho m\u00e1s tedioso. Sin embargo, entre las cosas que trae resueltas Python hay algunos algoritmos que nos interesa que vuelvas a escribir vos, por motivos did\u00e1cticos. En lo que sigue te vamos a pedir en algunas ocasiones que no uses toda la potencia y simpleza de Python sino que te arremangues y escribas algunas funciones desde los primeros rudimentos. Queremos mostrarte en ejemplos concretos c\u00f3mo distintas maneras de resolver un mismo problema pueden dar lugar a algoritmos con eficiencias muy diferentes. A veces una es mejor para un uso y la otra para otro uso. En concreto, vamos a profundizar en el problema de la b\u00fasqueda y en el problema del ordenamiento, que son dos problemas elementales que ilustran conceptos centrales del desarrollo de algoritmos. El uso adecuado de estos conceptos puede hacer la diferencia entre un algoritmo que termina el procesamiento en unos pocos minutos o uno que hay que dejar corriendo dos d\u00edas (y rezar para que no se corte la electricidad mientras corre). B\u00fasqueda lineal El problema de la b\u00fasqueda Presentamos ahora uno de los problemas m\u00e1s cl\u00e1sicos de la computaci\u00f3n: el problema de la b\u00fasqueda . El mismo se puede enunciar de la siguiente manera: Problema: Dada una lista lista y un elemento e devolver el \u00edndice de e en lista si e est\u00e1 en lista , y devolver -1 si e no est\u00e1 en lista . Este problema tiene una soluci\u00f3n muy sencilla en Python: se puede usar el m\u00e9todo index() de las listas. Prob\u00e1 esta soluci\u00f3n: >>> [1, 3, 5, 7].index(5) 2 >>> [1, 3, 5, 7].index(20) Traceback (most recent call last): File \"<ipython-input-177-1bcce50c5c91>\", line 1, in <module> [1, 3, 5, 7].index(20) ValueError: 20 is not in list Vemos que usar la funci\u00f3n index() resuelve nuestro problema si el valor buscado est\u00e1 en la lista, pero si el valor no est\u00e1 no s\u00f3lo no devuelve un -1, sino que se produce un error. El problema es que para poder aplicar la funci\u00f3n index() debemos estar seguros de que el valor est\u00e1 en la lista, y para averiguar eso Python nos provee del operador in : >>> 5 in [1, 3, 5, 7] True >>> 20 in [1, 3, 5, 7] False Si llamamos a la funci\u00f3n index() s\u00f3lo cuando el resultado de in es verdadero, y devolvemos -1 cuando el resultado de in es falso, estaremos resolviendo el problema planteado usando s\u00f3lo funciones provistas por Python: def busqueda_con_index(lista, e): '''Busca un elemento e en la lista. Si e est\u00e1 en lista devuelve el \u00edndice, de lo contrario devuelve -1. ''' if e in lista: pos = lista.index(e) else: pos = -1 return pos Probemos la funci\u00f3n busqueda_con_index() : >>> busqueda_con_index([1, 4, 54, 3, 0, -1], 1) 0 >>> busqueda_con_index([1, 4, 54, 3, 0, -1], -1) 5 >>> busqueda_con_index([1, 4, 54, 3, 0, -1], 3) 3 >>> busqueda_con_index([1, 4, 54, 3, 0, -1], 44) -1 >>> busqueda_con_index([], 0) -1 \u00bfCu\u00e1ntas comparaciones hace este programa? Es decir, \u00bfcu\u00e1nto esfuerzo computacional requiere este programa? \u00bfCu\u00e1ntas veces compara el valor que buscamos con los datos de la lista? No lo sabemos porque no sabemos c\u00f3mo est\u00e1n implementadas las operaciones in e index() . La pregunta queda planteada por ahora pero daremos un m\u00e9todo para averiguarlo m\u00e1s adelante. B\u00fasqueda lineal Nos interesa estudiar formas alternativas de programar la b\u00fasqueda usando operaciones m\u00e1s elementales, y no las primitivas in e index() de nuestro lenguaje de alto nivel. Aceptemos entonces que no vamos a usar ni in ni index() . En cambio, podemos iterar sobre los \u00edndices y elementos de una lista para hacer comparaciones elementales. Consideremos la siguiente soluci\u00f3n: iterar sobre los \u00edndices y elementos de una lista de manera de comparar el elemento e buscado con cada uno de los elementos de la lista y devolver la posici\u00f3n donde lo encontremos, en caso de encontrarlo. Si llegamos al final de la lista sin haber salido antes de la funci\u00f3n es porque el valor de e no est\u00e1 en la lista, y en ese caso devolvemos -1. En esta soluci\u00f3n lo ideal es usar enumerate (ver la Secci\u00f3n 3.2 ) ya que dentro de la iteraci\u00f3n necesitamos tener acceso tanto al valor del elemento (para ver si es igual al buscado) como a su \u00edndice (es el valor que tenemos que devolver). Primero hag\u00e1moslo sin usarlo y luego lo agregamos para entender su ventaja. En ambos casos necesitamos una variable i que cuente en cada momento en qu\u00e9 posici\u00f3n de la lista estamos. Si no usamos enumerate , debemos inicializar i en 0 antes de entrar en el ciclo e incrementarla en 1 en cada paso. El programa nos queda as\u00ed: def busqueda_lineal(lista, e): '''Si e est\u00e1 en la lista devuelve su posici\u00f3n, de lo contrario devuelve -1. ''' pos = -1 # comenzamos suponiendo que e no est\u00e1 i = 0 for z in lista: # recorremos los elementos de la lista if z == e: # si encontramos a e pos = i # guardamos su posici\u00f3n break # y salimos del ciclo i += 1 return pos La versi\u00f3n con enumerate es mucho m\u00e1s elegante: def busqueda_lineal(lista, e): '''Si e est\u00e1 en la lista devuelve su posici\u00f3n, de lo contrario devuelve -1. ''' pos = -1 # comenzamos suponiendo que e no est\u00e1 for i, z in enumerate(lista): # recorremos la lista if z == e: # si encontramos a e pos = i # guardamos su posici\u00f3n break # y salimos del ciclo return pos Y ahora lo probamos: >>> busqueda_lineal([1, 4, 54, 3, 0, -1], 44) -1 >>> busqueda_lineal([1, 4, 54, 3, 0, -1], 3) 3 >>> busqueda_lineal([1, 4, 54, 3, 0, -1], 0) 4 >>> busqueda_lineal([], 42) -1 \u00bfCu\u00e1ntas comparaciones hace este programa? Volvemos a preguntarnos lo mismo que en la secci\u00f3n anterior pero con el nuevo programa: \u00bfcu\u00e1nto esfuerzo computacional requiere este programa?, \u00bfcu\u00e1ntas veces compara el valor que buscamos con los datos de la lista? Ahora podemos analizar el c\u00f3digo de busqueda_lineal : El ciclo recorre uno a uno los elementos de la lista, y en el cuerpo de ese ciclo, se compara cada elemento con el valor buscado. En el caso de encontrarlo se devuelve la posici\u00f3n. Si el valor no est\u00e1 en la lista, se recorrer\u00e1 la lista entera, haciendo una comparaci\u00f3n por cada elemento. O sea que si el valor est\u00e1 en la posici\u00f3n p de la lista se hacen p comparaciones. En el peor caso , si el valor no est\u00e1, se hacen tantas comparaciones como elementos tenga la lista. En resumen: Si la lista crece, la cantidad de comparaciones para encontrar un valor arbitrario crecer\u00e1 en forma proporcional al tama\u00f1o de la lista. Es decir que: El algoritmo de b\u00fasqueda lineal tiene un comportamiento proporcional a la longitud de la lista involucrada , o que es un algoritmo lineal . Ejercicios Ejercicio 4.3: B\u00fasquedas de un elemento Cre\u00e1 el archivo busqueda_en_listas.py para guardar tu c\u00f3digo de este ejercicio y el siguiente. En este primer ejercicio ten\u00e9s que escribir una funci\u00f3n buscar_u_elemento() que reciba una lista y un elemento y devuelva la posici\u00f3n de la \u00faltima aparici\u00f3n de ese elemento en la lista (o -1 si el elemento no pertenece a la lista). Prob\u00e1 tu funci\u00f3n con algunos ejemplos: >>> buscar_u_elemento([1,2,3,2,3,4],1) 0 >>> buscar_u_elemento([1,2,3,2,3,4],2) 3 >>> buscar_u_elemento([1,2,3,2,3,4],3) 4 >>> buscar_u_elemento([1,2,3,2,3,4],5) -1 Agregale a tu programa busqueda_en_listas.py una funci\u00f3n buscar_n_elemento() que reciba una lista y un elemento y devuelva la cantidad de veces que aparece el elemento en la lista. Prob\u00e1 tambi\u00e9n esta funci\u00f3n con algunos ejemplos. Ejercicio 4.4: B\u00fasqueda de m\u00e1ximo y m\u00ednimo Agregale a tu archivo busqueda_en_listas.py una funci\u00f3n maximo() que busque el valor m\u00e1ximo de una lista de n\u00fameros positivos. Python tiene el comando max que ya hace esto, pero como pr\u00e1ctica te proponemos que completes el siguiente c\u00f3digo: def maximo(lista): '''Devuelve el m\u00e1ximo de una lista, la lista debe ser no vac\u00eda y de n\u00fameros positivos. ''' # m guarda el m\u00e1ximo de los elementos a medida que recorro la lista. m = 0 # Lo inicializo en 0 for e in lista: # Recorro la lista y voy guardando el mayor ... return m Prob\u00e1 tu funci\u00f3n con estos ejemplos: >>> maximo([1,2,7,2,3,4]) 7 >>> maximo([1,2,3,4]) 4 >>> maximo([-5,4]) 4 >>> maximo([-5,-4]) 0 \u00bfPor qu\u00e9 falla en el \u00faltimo caso? \u00bfPor qu\u00e9 anda en el caso anterior? \u00bfC\u00f3mo se puede inicializar m para que la funci\u00f3n ande tambi\u00e9n con n\u00fameros negativos? Corregilo y guarda la versi\u00f3n mejorada en el archivo busqueda_en_listas.py . Si te dan ganas, agreg\u00e1 una funci\u00f3n minimo() al archivo. Ejercitaci\u00f3n con iteradores y listas Ejercicio 4.5: Invertir una lista Escrib\u00ed una funci\u00f3n invertir_lista(lista) que dada una lista devuelva otra que tenga los mismos elementos pero en el orden inverso. Es decir, el que era el primer elemento de la lista de entrada deber\u00e1 ser el \u00faltimo de la lista de salida y an\u00e1logamente con los dem\u00e1s elementos. def invertir_lista(lista): invertida = [] for e in lista: # Recorro la lista ... #agrego el elemento e al principio de la lista invertida return invertida Guard\u00e1 la funci\u00f3n en el archivo invlista.py y probala con las siguientes listas: 1. [1, 2, 3, 4, 5] 2. ['Bogot\u00e1', 'Rosario', 'Santiago', 'San Fernando', 'San Miguel'] Ejercicio 4.6: Propagaci\u00f3n Imaginate una fila con varios f\u00f3sforos uno al lado del otro. Los f\u00f3sforos pueden estar en tres estados: nuevos, prendidos fuego o ya gastados (carbonizados). Representaremos esta situaci\u00f3n con una lista L con un elemento por f\u00f3sforo, que en cada posici\u00f3n tiene un 0 (nuevo), un 1 (encendido) o un -1 (carbonizado). El fuego se propaga inmediatamente de un f\u00f3sforo encendido a cualquier f\u00f3sforo nuevo que tenga a su lado. Los f\u00f3sforos carbonizados no se encienden nuevamente. Escrib\u00ed una funci\u00f3n llamada propagar que reciba un vector con 0's, 1's y -1's y devuelva un vector en el que los 1's se propagaron a sus vecinos con 0. Guardalo en un archivo propaga.py . Por ejemplo: >>> propagar([ 0, 0, 0,-1, 1, 0, 0, 0,-1, 0, 1, 0, 0]) [ 0, 0, 0,-1, 1, 1, 1, 1,-1, 1, 1, 1, 1] >>> propagar([ 0, 0, 0, 1, 0, 0]) [ 1, 1, 1, 1, 1, 1] Propagaci\u00f3n an\u00e1loga a la del Ejercicio 4.6 Contenidos | Anterior (1 Debuggear programas) | Pr\u00f3ximo (3 Comprensi\u00f3n de listas)","title":"02 IteradoresLista"},{"location":"04_Listas_y_Listas/02_IteradoresLista/#42-listas-y-busqueda-lineal","text":"En esta secci\u00f3n seguiremos usando Python, pero nos concentraremos en la parte algor\u00edtmica. Vas a escribir funciones sencillas (y no tanto) que realicen operaciones de bajo nivel sobre listas. \u00c9ste es un curso de Python y de algoritmos. Python es un lenguaje de alto nivel. Esto significa que con pocas instrucciones permite realizar operaciones muy complejas. Los lenguajes de bajo nivel est\u00e1n m\u00e1s cerca del lenguaje del procesador y programar en ellos por ejemplo, un an\u00e1lisis de datos, es mucho m\u00e1s tedioso. Sin embargo, entre las cosas que trae resueltas Python hay algunos algoritmos que nos interesa que vuelvas a escribir vos, por motivos did\u00e1cticos. En lo que sigue te vamos a pedir en algunas ocasiones que no uses toda la potencia y simpleza de Python sino que te arremangues y escribas algunas funciones desde los primeros rudimentos. Queremos mostrarte en ejemplos concretos c\u00f3mo distintas maneras de resolver un mismo problema pueden dar lugar a algoritmos con eficiencias muy diferentes. A veces una es mejor para un uso y la otra para otro uso. En concreto, vamos a profundizar en el problema de la b\u00fasqueda y en el problema del ordenamiento, que son dos problemas elementales que ilustran conceptos centrales del desarrollo de algoritmos. El uso adecuado de estos conceptos puede hacer la diferencia entre un algoritmo que termina el procesamiento en unos pocos minutos o uno que hay que dejar corriendo dos d\u00edas (y rezar para que no se corte la electricidad mientras corre).","title":"4.2 Listas y b\u00fasqueda lineal"},{"location":"04_Listas_y_Listas/02_IteradoresLista/#busqueda-lineal","text":"","title":"B\u00fasqueda lineal"},{"location":"04_Listas_y_Listas/02_IteradoresLista/#el-problema-de-la-busqueda","text":"Presentamos ahora uno de los problemas m\u00e1s cl\u00e1sicos de la computaci\u00f3n: el problema de la b\u00fasqueda . El mismo se puede enunciar de la siguiente manera: Problema: Dada una lista lista y un elemento e devolver el \u00edndice de e en lista si e est\u00e1 en lista , y devolver -1 si e no est\u00e1 en lista . Este problema tiene una soluci\u00f3n muy sencilla en Python: se puede usar el m\u00e9todo index() de las listas. Prob\u00e1 esta soluci\u00f3n: >>> [1, 3, 5, 7].index(5) 2 >>> [1, 3, 5, 7].index(20) Traceback (most recent call last): File \"<ipython-input-177-1bcce50c5c91>\", line 1, in <module> [1, 3, 5, 7].index(20) ValueError: 20 is not in list Vemos que usar la funci\u00f3n index() resuelve nuestro problema si el valor buscado est\u00e1 en la lista, pero si el valor no est\u00e1 no s\u00f3lo no devuelve un -1, sino que se produce un error. El problema es que para poder aplicar la funci\u00f3n index() debemos estar seguros de que el valor est\u00e1 en la lista, y para averiguar eso Python nos provee del operador in : >>> 5 in [1, 3, 5, 7] True >>> 20 in [1, 3, 5, 7] False Si llamamos a la funci\u00f3n index() s\u00f3lo cuando el resultado de in es verdadero, y devolvemos -1 cuando el resultado de in es falso, estaremos resolviendo el problema planteado usando s\u00f3lo funciones provistas por Python: def busqueda_con_index(lista, e): '''Busca un elemento e en la lista. Si e est\u00e1 en lista devuelve el \u00edndice, de lo contrario devuelve -1. ''' if e in lista: pos = lista.index(e) else: pos = -1 return pos Probemos la funci\u00f3n busqueda_con_index() : >>> busqueda_con_index([1, 4, 54, 3, 0, -1], 1) 0 >>> busqueda_con_index([1, 4, 54, 3, 0, -1], -1) 5 >>> busqueda_con_index([1, 4, 54, 3, 0, -1], 3) 3 >>> busqueda_con_index([1, 4, 54, 3, 0, -1], 44) -1 >>> busqueda_con_index([], 0) -1","title":"El problema de la b\u00fasqueda"},{"location":"04_Listas_y_Listas/02_IteradoresLista/#cuantas-comparaciones-hace-este-programa","text":"Es decir, \u00bfcu\u00e1nto esfuerzo computacional requiere este programa? \u00bfCu\u00e1ntas veces compara el valor que buscamos con los datos de la lista? No lo sabemos porque no sabemos c\u00f3mo est\u00e1n implementadas las operaciones in e index() . La pregunta queda planteada por ahora pero daremos un m\u00e9todo para averiguarlo m\u00e1s adelante.","title":"\u00bfCu\u00e1ntas comparaciones hace este programa?"},{"location":"04_Listas_y_Listas/02_IteradoresLista/#busqueda-lineal_1","text":"Nos interesa estudiar formas alternativas de programar la b\u00fasqueda usando operaciones m\u00e1s elementales, y no las primitivas in e index() de nuestro lenguaje de alto nivel. Aceptemos entonces que no vamos a usar ni in ni index() . En cambio, podemos iterar sobre los \u00edndices y elementos de una lista para hacer comparaciones elementales. Consideremos la siguiente soluci\u00f3n: iterar sobre los \u00edndices y elementos de una lista de manera de comparar el elemento e buscado con cada uno de los elementos de la lista y devolver la posici\u00f3n donde lo encontremos, en caso de encontrarlo. Si llegamos al final de la lista sin haber salido antes de la funci\u00f3n es porque el valor de e no est\u00e1 en la lista, y en ese caso devolvemos -1. En esta soluci\u00f3n lo ideal es usar enumerate (ver la Secci\u00f3n 3.2 ) ya que dentro de la iteraci\u00f3n necesitamos tener acceso tanto al valor del elemento (para ver si es igual al buscado) como a su \u00edndice (es el valor que tenemos que devolver). Primero hag\u00e1moslo sin usarlo y luego lo agregamos para entender su ventaja. En ambos casos necesitamos una variable i que cuente en cada momento en qu\u00e9 posici\u00f3n de la lista estamos. Si no usamos enumerate , debemos inicializar i en 0 antes de entrar en el ciclo e incrementarla en 1 en cada paso. El programa nos queda as\u00ed: def busqueda_lineal(lista, e): '''Si e est\u00e1 en la lista devuelve su posici\u00f3n, de lo contrario devuelve -1. ''' pos = -1 # comenzamos suponiendo que e no est\u00e1 i = 0 for z in lista: # recorremos los elementos de la lista if z == e: # si encontramos a e pos = i # guardamos su posici\u00f3n break # y salimos del ciclo i += 1 return pos La versi\u00f3n con enumerate es mucho m\u00e1s elegante: def busqueda_lineal(lista, e): '''Si e est\u00e1 en la lista devuelve su posici\u00f3n, de lo contrario devuelve -1. ''' pos = -1 # comenzamos suponiendo que e no est\u00e1 for i, z in enumerate(lista): # recorremos la lista if z == e: # si encontramos a e pos = i # guardamos su posici\u00f3n break # y salimos del ciclo return pos Y ahora lo probamos: >>> busqueda_lineal([1, 4, 54, 3, 0, -1], 44) -1 >>> busqueda_lineal([1, 4, 54, 3, 0, -1], 3) 3 >>> busqueda_lineal([1, 4, 54, 3, 0, -1], 0) 4 >>> busqueda_lineal([], 42) -1","title":"B\u00fasqueda lineal"},{"location":"04_Listas_y_Listas/02_IteradoresLista/#cuantas-comparaciones-hace-este-programa_1","text":"Volvemos a preguntarnos lo mismo que en la secci\u00f3n anterior pero con el nuevo programa: \u00bfcu\u00e1nto esfuerzo computacional requiere este programa?, \u00bfcu\u00e1ntas veces compara el valor que buscamos con los datos de la lista? Ahora podemos analizar el c\u00f3digo de busqueda_lineal : El ciclo recorre uno a uno los elementos de la lista, y en el cuerpo de ese ciclo, se compara cada elemento con el valor buscado. En el caso de encontrarlo se devuelve la posici\u00f3n. Si el valor no est\u00e1 en la lista, se recorrer\u00e1 la lista entera, haciendo una comparaci\u00f3n por cada elemento. O sea que si el valor est\u00e1 en la posici\u00f3n p de la lista se hacen p comparaciones. En el peor caso , si el valor no est\u00e1, se hacen tantas comparaciones como elementos tenga la lista. En resumen: Si la lista crece, la cantidad de comparaciones para encontrar un valor arbitrario crecer\u00e1 en forma proporcional al tama\u00f1o de la lista. Es decir que: El algoritmo de b\u00fasqueda lineal tiene un comportamiento proporcional a la longitud de la lista involucrada , o que es un algoritmo lineal .","title":"\u00bfCu\u00e1ntas comparaciones hace este programa?"},{"location":"04_Listas_y_Listas/02_IteradoresLista/#ejercicios","text":"","title":"Ejercicios"},{"location":"04_Listas_y_Listas/02_IteradoresLista/#ejercicio-43-busquedas-de-un-elemento","text":"Cre\u00e1 el archivo busqueda_en_listas.py para guardar tu c\u00f3digo de este ejercicio y el siguiente. En este primer ejercicio ten\u00e9s que escribir una funci\u00f3n buscar_u_elemento() que reciba una lista y un elemento y devuelva la posici\u00f3n de la \u00faltima aparici\u00f3n de ese elemento en la lista (o -1 si el elemento no pertenece a la lista). Prob\u00e1 tu funci\u00f3n con algunos ejemplos: >>> buscar_u_elemento([1,2,3,2,3,4],1) 0 >>> buscar_u_elemento([1,2,3,2,3,4],2) 3 >>> buscar_u_elemento([1,2,3,2,3,4],3) 4 >>> buscar_u_elemento([1,2,3,2,3,4],5) -1 Agregale a tu programa busqueda_en_listas.py una funci\u00f3n buscar_n_elemento() que reciba una lista y un elemento y devuelva la cantidad de veces que aparece el elemento en la lista. Prob\u00e1 tambi\u00e9n esta funci\u00f3n con algunos ejemplos.","title":"Ejercicio 4.3: B\u00fasquedas de un elemento"},{"location":"04_Listas_y_Listas/02_IteradoresLista/#ejercicio-44-busqueda-de-maximo-y-minimo","text":"Agregale a tu archivo busqueda_en_listas.py una funci\u00f3n maximo() que busque el valor m\u00e1ximo de una lista de n\u00fameros positivos. Python tiene el comando max que ya hace esto, pero como pr\u00e1ctica te proponemos que completes el siguiente c\u00f3digo: def maximo(lista): '''Devuelve el m\u00e1ximo de una lista, la lista debe ser no vac\u00eda y de n\u00fameros positivos. ''' # m guarda el m\u00e1ximo de los elementos a medida que recorro la lista. m = 0 # Lo inicializo en 0 for e in lista: # Recorro la lista y voy guardando el mayor ... return m Prob\u00e1 tu funci\u00f3n con estos ejemplos: >>> maximo([1,2,7,2,3,4]) 7 >>> maximo([1,2,3,4]) 4 >>> maximo([-5,4]) 4 >>> maximo([-5,-4]) 0 \u00bfPor qu\u00e9 falla en el \u00faltimo caso? \u00bfPor qu\u00e9 anda en el caso anterior? \u00bfC\u00f3mo se puede inicializar m para que la funci\u00f3n ande tambi\u00e9n con n\u00fameros negativos? Corregilo y guarda la versi\u00f3n mejorada en el archivo busqueda_en_listas.py . Si te dan ganas, agreg\u00e1 una funci\u00f3n minimo() al archivo.","title":"Ejercicio 4.4: B\u00fasqueda de m\u00e1ximo y m\u00ednimo"},{"location":"04_Listas_y_Listas/02_IteradoresLista/#ejercitacion-con-iteradores-y-listas","text":"","title":"Ejercitaci\u00f3n con iteradores y listas"},{"location":"04_Listas_y_Listas/02_IteradoresLista/#ejercicio-45-invertir-una-lista","text":"Escrib\u00ed una funci\u00f3n invertir_lista(lista) que dada una lista devuelva otra que tenga los mismos elementos pero en el orden inverso. Es decir, el que era el primer elemento de la lista de entrada deber\u00e1 ser el \u00faltimo de la lista de salida y an\u00e1logamente con los dem\u00e1s elementos. def invertir_lista(lista): invertida = [] for e in lista: # Recorro la lista ... #agrego el elemento e al principio de la lista invertida return invertida Guard\u00e1 la funci\u00f3n en el archivo invlista.py y probala con las siguientes listas: 1. [1, 2, 3, 4, 5] 2. ['Bogot\u00e1', 'Rosario', 'Santiago', 'San Fernando', 'San Miguel']","title":"Ejercicio 4.5: Invertir una lista"},{"location":"04_Listas_y_Listas/02_IteradoresLista/#ejercicio-46-propagacion","text":"Imaginate una fila con varios f\u00f3sforos uno al lado del otro. Los f\u00f3sforos pueden estar en tres estados: nuevos, prendidos fuego o ya gastados (carbonizados). Representaremos esta situaci\u00f3n con una lista L con un elemento por f\u00f3sforo, que en cada posici\u00f3n tiene un 0 (nuevo), un 1 (encendido) o un -1 (carbonizado). El fuego se propaga inmediatamente de un f\u00f3sforo encendido a cualquier f\u00f3sforo nuevo que tenga a su lado. Los f\u00f3sforos carbonizados no se encienden nuevamente. Escrib\u00ed una funci\u00f3n llamada propagar que reciba un vector con 0's, 1's y -1's y devuelva un vector en el que los 1's se propagaron a sus vecinos con 0. Guardalo en un archivo propaga.py . Por ejemplo: >>> propagar([ 0, 0, 0,-1, 1, 0, 0, 0,-1, 0, 1, 0, 0]) [ 0, 0, 0,-1, 1, 1, 1, 1,-1, 1, 1, 1, 1] >>> propagar([ 0, 0, 0, 1, 0, 0]) [ 1, 1, 1, 1, 1, 1] Propagaci\u00f3n an\u00e1loga a la del Ejercicio 4.6 Contenidos | Anterior (1 Debuggear programas) | Pr\u00f3ximo (3 Comprensi\u00f3n de listas)","title":"Ejercicio 4.6: Propagaci\u00f3n"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/","text":"Contenidos | Anterior (2 Listas y b\u00fasqueda lineal) | Pr\u00f3ximo (4 Objetos) 4.3 Comprensi\u00f3n de listas Una tarea que realizamos una y otra vez es procesar los elementos de una lista. En esta secci\u00f3n introducimos la definici\u00f3n de listas por comprensi\u00f3n que es una herramienta potente para hacer exactamente eso. Crear listas nuevas La comprensi\u00f3n de listas crea un una nueva lista aplicando una operaci\u00f3n a cada elemento de una secuencia. >>> a = [1, 2, 3, 4, 5] >>> b = [2*x for x in a] >>> b [2, 4, 6, 8, 10] >>> Otro ejemplo: >>> nombres = ['Edmundo', 'Juana'] >>> a = [nombre.lower() for nombre in nombres] >>> a ['edmundo', 'juana'] >>> La sintaxis general es : [<expresi\u00f3n> for <variable> in <secuencia>] . Filtros La comprensi\u00f3n de listas se puede usar para filtrar. >>> a = [1, -5, 4, 2, -2, 10] >>> b = [2*x for x in a if x > 0] >>> b [2, 8, 4, 20] >>> Casos de uso La comprensi\u00f3n de listas es enormemente \u00fatil. Por ejemplo, pod\u00e9s recolectar los valores de un campo espec\u00edfico de un diccionario: frutas = [s['nombre'] for s in camion] O pod\u00e9s hacer consultas ( queries ) como si las secuencias fueran bases de datos. a = [s for s in camion if s['precio'] > 100 and s['cajones'] > 50] Tambi\u00e9n pod\u00e9s combinar la comprensi\u00f3n de listas con reducciones de secuencias: costo = sum([s['cajones']*s['precio'] for s in camion]) Sintaxis general [<expresi\u00f3n> for <variable> in <secuencia> if <condici\u00f3n>] Lo que significa resultado = [] for variable in secuencia: if condici\u00f3n: resultado.append(expresi\u00f3n) Digresi\u00f3n hist\u00f3rica La comprensi\u00f3n de listas viene de la matem\u00e1tica (definici\u00f3n de conjuntos por comprensi\u00f3n). a = [x * x for x in s if x > 0] # Python a = {x^2 | x \u2208 s, x > 0} # Matem\u00e1tica La mayor\u00eda de los programadores no suelen pensar en el costado matem\u00e1tico de esta herramienta. Podemos verla simplemente como una abreviaci\u00f3n copada para definir listas. Ejercicios Corr\u00e9 tu programa informe.py de forma de tener los datos sobre cajones cargados en tu int\u00e9rprete en modo interactivo. Luego, trat\u00e1 de escribir los comandos adecuados para realizar las operaciones descriptas abajo. Estas operaciones son reducciones, transformaciones y consultas sobre la carga del cami\u00f3n. Ejercicio 4.7: Comprensi\u00f3n de listas Prob\u00e1 un par de comprensi\u00f3n de listas para familiarizarte con la sintaxis. >>> nums = [1,2,3,4] >>> cuadrados = [x * x for x in nums] >>> cuadrados [1, 4, 9, 16] >>> dobles = [2 * x for x in nums if x > 2] >>> dobles [6, 8] >>> Observ\u00e1 que est\u00e1s creando nuevas listas con los datos adecuadamente transformados o filtrados. Ejercicio 4.8: Reducci\u00f3n de secuencias Calcul\u00e1 el costo total de la carga del cami\u00f3n en un solo comando. >>> camion = leer_camion('../Data/camion.csv') >>> costo = sum([s['cajones'] * s['precio'] for s in camion]) >>> costo 47671.15 >>> Luego, leyendo la variable precios , calcul\u00e1 tambi\u00e9n el valor en el mercado de la carga del cami\u00f3n usando una sola l\u00ednea de c\u00f3digo. >>> precios = leer_precios('../Data/precios.csv') >>> valor = sum([s['cajones'] * precios[s['nombre']] for s in camion]) >>> valor 62986.1 >>> Ambos son ejemplos de aplicaci\u00f3n-reducci\u00f3n. La comprensi\u00f3n de listas est\u00e1 aplicando una operaci\u00f3n a lo largo de la lista. >>> [s['cajones'] * s['precio'] for s in camion] [3220.0000000000005, 4555.0, 15516.0, 10246.0, 3835.1499999999996, 3254.9999999999995, 7044.0] >>> La funci\u00f3n sum() luego realiza una reducci\u00f3n del resultado >>> sum(_) 47671.15 >>> Con este conocimiento algunos ya empiezan su startup de big-data. Ejercicio 4.9: Consultas de datos Prob\u00e1 los siguientes ejemplos de consultas (queries) de datos. Primero, gener\u00e1 una lista con la info de todas las frutas que tienen m\u00e1s de 100 cajones en el cami\u00f3n. >>> mas100 = [s for s in camion if s['cajones'] > 100] >>> mas100 [{'cajones': 150, 'nombre': 'Caqui', 'precio': 103.44}, {'cajones': 200, 'nombre': 'Mandarina', 'precio': 51.23}] >>> Ahora, una con la info sobre cajones de Mandarina y Naranja. >>> myn = [s for s in camion if s['nombre'] in {'Mandarina','Naranja'}] >>> myn [{'cajones': 50, 'nombre': 'Naranja', 'precio': 91.1}, {'cajones': 200, 'nombre': 'Mandarina', 'precio': 51.23}, {'cajones': 50, 'nombre': 'Mandarina', 'precio': 65.1}, {'cajones': 100, 'nombre': 'Naranja', 'precio': 70.44}] >>> O una con la info de las frutas que costaron m\u00e1s de $10000. >>> costo10k = [s for s in camion if s['cajones'] * s['precio'] > 10000] >>> costo10k [{'cajones': 150, 'nombre': 'Caqui', 'precio': 103.44}, {'cajones': 200, 'nombre': 'Mandarina', 'precio': 51.23}] >>> Esta forma de escribir resulta an\u00e1loga a las consultas a una base de datos con SQL. Ejercicio 4.10: Extracci\u00f3n de datos Usando un comprensi\u00f3n de listas, constru\u00ed una lista de tuplas (nombre, cajones) que indiquen la cantidad de cajones de cada fruta tomando los datos de camion . >>> nombre_cajones =[(s['nombre'], s['cajones']) for s in camion] >>> nombre_cajones [('Lima', 100), ('Naranja', 50), ('Caqui', 150), ('Mandarina', 200), ('Durazno', 95), ('Mandarina', 50), ('Naranja', 100)] >>> Si cambi\u00e1s los corchetes ( [ , ] ) por llaves ( { , } ), obten\u00e9s algo que se conoce como comprensi\u00f3n de conjuntos. Vas a obtener valores \u00fanicos. Por ejemplo, si quisieras un listado de las frutas en el cami\u00f3n pord\u00edas usar: >>> nombres = {s['nombre'] for s in camion} >>> nombres {'Caqui', 'Durazno', 'Lima', 'Mandarina', 'Naranja'} >>> Si especific\u00e1s pares clave:valor , pod\u00e9s construir un diccionario. Por ejemplo, si queremos un diccionario con el total de cada fruta en el cami\u00f3n podemos comenzar con >>> stock = {nombre: 0 for nombre in nombres} >>> stock {'Caqui': 0, 'Durazno': 0, 'Lima': 0, 'Mandarina': 0, 'Naranja': 0} >>> que es una comprensi\u00f3n de diccionario. Y seguir sumando los cajones: >>> for s in camion: stock[s['nombre']] += s['cajones'] >>> stock {'Caqui': 150, 'Durazno': 95, 'Lima': 100, 'Mandarina': 250, 'Naranja': 150} >>> Otro ejemplo \u00fatil podr\u00eda ser generar un diccionario de precios de venta de aquellos productos que est\u00e1n efectivamente cargados en el cami\u00f3n: >>> camion_precios = {nombre: precios[nombre] for nombre in nombres} >>> camion_precios {'Caqui': 105.46, 'Durazno': 73.48, 'Lima': 40.22, 'Mandarina': 80.89, 'Naranja': 106.28} >>> Ejercicio 4.11: Extraer datos de un archivo CSV Saber usar combinaciones de comprensi\u00f3n de listas, diccionarios y conjuntos resulta \u00fatil para procesar datos en diferentes contextos. Aunque puede volverse medio cr\u00edptico si no est\u00e1s habituade. Ac\u00e1 te mostramos un ejemplo de c\u00f3mo extraer columnas seleccionadas de un archivo CSV que tiene esas caracter\u00edsticas. No es dificil cuando lo entend\u00e9s, pero est\u00e1 muy concentrado todo. Primero, leamos el encabezado (header) del archivo CSV: >>> import csv >>> f = open('../Data/fecha_camion.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['nombre', 'fecha', 'hora', 'cajones', 'precio'] >>> Luego, definamos una lista que tenga las columnas que nos importan: >>> select = ['nombre', 'cajones', 'precio'] >>> Ubiquemos los \u00edndices de esas columnas en el CSV: >>> indices = [headers.index(ncolumna) for ncolumna in select] >>> indices [0, 3, 4] >>> Y finalmente leamos los datos y armemos un diccionario usando comprensi\u00f3n de diccionarios: >>> row = next(rows) >>> record = {ncolumna: row[index] for ncolumna, index in zip(select, indices)} # comprensi\u00f3n de diccionario >>> record {'precio': '32.20', 'nombre': 'Lima', 'cajones': '100'} >>> No es trivial este comando. El comando es sint\u00e1cticamente muy compacto, pero es conceptualmente (un poco) complejo. Cuando te sientas c\u00f3mode con esta lectura de una l\u00ednea del archivo (si no pasa, tranca, podemos seguir sin esto), le\u00e9 el resto: >>> camion = [{ ncolumna: row[index] for ncolumna, index in zip(select, indices)} for row in rows] >>> camion [{'cajones': '50', 'nombre': 'Naranja', 'precio': '91.1'}, {'cajones': '150', 'nombre': 'Caqui', 'precio': '103.44'}, {'cajones': '200', 'nombre': 'Mandarina', 'precio': '51.23'}, {'cajones': '95', 'nombre': 'Durazno', 'precio': '40.37'}, {'cajones': '50', 'nombre': 'Mandarina', 'precio': '65.1'}, {'cajones': '100', 'nombre': 'Naranja', 'precio': '70.44'}] >>> \u00a1Por las barbas de mi abuelo! Acabamos de reducir casi toda la funci\u00f3n leer_camion() a un solo comando. Comentario La comprensi\u00f3n de listas se usa frecuentemente en Python. Es una forma eficiente de transformar, filtrar o juntar datos. Tiene una sintaxis potente pero trat\u00e1 de no pasarte con su uso: manten\u00e9 cada comando tan simple como sea posible. Est\u00e1 perfecto descomponer un solo comando complejo en muchos pasos. Concretamente: compartir el \u00faltimo ejemplo con personas desprevenidas puede no ser lo ideal. Dicho esto, saber manipular datos r\u00e1pidamente es una habilidad incre\u00edblemente \u00fatil. Hay numerosas situaciones donde puede que tengas que resolver alg\u00fan tipo de problema excepcional (en el sentido de raro o \u00fanico) para importar, extraer o exportar datos. La comprensi\u00f3n de listas te puede ahorrar much\u00edsimo tiempo en esas tareas. Contenidos | Anterior (2 Listas y b\u00fasqueda lineal) | Pr\u00f3ximo (4 Objetos)","title":"03 Comprension Listas"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#43-comprension-de-listas","text":"Una tarea que realizamos una y otra vez es procesar los elementos de una lista. En esta secci\u00f3n introducimos la definici\u00f3n de listas por comprensi\u00f3n que es una herramienta potente para hacer exactamente eso.","title":"4.3 Comprensi\u00f3n de listas"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#crear-listas-nuevas","text":"La comprensi\u00f3n de listas crea un una nueva lista aplicando una operaci\u00f3n a cada elemento de una secuencia. >>> a = [1, 2, 3, 4, 5] >>> b = [2*x for x in a] >>> b [2, 4, 6, 8, 10] >>> Otro ejemplo: >>> nombres = ['Edmundo', 'Juana'] >>> a = [nombre.lower() for nombre in nombres] >>> a ['edmundo', 'juana'] >>> La sintaxis general es : [<expresi\u00f3n> for <variable> in <secuencia>] .","title":"Crear listas nuevas"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#filtros","text":"La comprensi\u00f3n de listas se puede usar para filtrar. >>> a = [1, -5, 4, 2, -2, 10] >>> b = [2*x for x in a if x > 0] >>> b [2, 8, 4, 20] >>>","title":"Filtros"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#casos-de-uso","text":"La comprensi\u00f3n de listas es enormemente \u00fatil. Por ejemplo, pod\u00e9s recolectar los valores de un campo espec\u00edfico de un diccionario: frutas = [s['nombre'] for s in camion] O pod\u00e9s hacer consultas ( queries ) como si las secuencias fueran bases de datos. a = [s for s in camion if s['precio'] > 100 and s['cajones'] > 50] Tambi\u00e9n pod\u00e9s combinar la comprensi\u00f3n de listas con reducciones de secuencias: costo = sum([s['cajones']*s['precio'] for s in camion])","title":"Casos de uso"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#sintaxis-general","text":"[<expresi\u00f3n> for <variable> in <secuencia> if <condici\u00f3n>] Lo que significa resultado = [] for variable in secuencia: if condici\u00f3n: resultado.append(expresi\u00f3n)","title":"Sintaxis general"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#digresion-historica","text":"La comprensi\u00f3n de listas viene de la matem\u00e1tica (definici\u00f3n de conjuntos por comprensi\u00f3n). a = [x * x for x in s if x > 0] # Python a = {x^2 | x \u2208 s, x > 0} # Matem\u00e1tica La mayor\u00eda de los programadores no suelen pensar en el costado matem\u00e1tico de esta herramienta. Podemos verla simplemente como una abreviaci\u00f3n copada para definir listas.","title":"Digresi\u00f3n hist\u00f3rica"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#ejercicios","text":"Corr\u00e9 tu programa informe.py de forma de tener los datos sobre cajones cargados en tu int\u00e9rprete en modo interactivo. Luego, trat\u00e1 de escribir los comandos adecuados para realizar las operaciones descriptas abajo. Estas operaciones son reducciones, transformaciones y consultas sobre la carga del cami\u00f3n.","title":"Ejercicios"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#ejercicio-47-comprension-de-listas","text":"Prob\u00e1 un par de comprensi\u00f3n de listas para familiarizarte con la sintaxis. >>> nums = [1,2,3,4] >>> cuadrados = [x * x for x in nums] >>> cuadrados [1, 4, 9, 16] >>> dobles = [2 * x for x in nums if x > 2] >>> dobles [6, 8] >>> Observ\u00e1 que est\u00e1s creando nuevas listas con los datos adecuadamente transformados o filtrados.","title":"Ejercicio 4.7: Comprensi\u00f3n de listas"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#ejercicio-48-reduccion-de-secuencias","text":"Calcul\u00e1 el costo total de la carga del cami\u00f3n en un solo comando. >>> camion = leer_camion('../Data/camion.csv') >>> costo = sum([s['cajones'] * s['precio'] for s in camion]) >>> costo 47671.15 >>> Luego, leyendo la variable precios , calcul\u00e1 tambi\u00e9n el valor en el mercado de la carga del cami\u00f3n usando una sola l\u00ednea de c\u00f3digo. >>> precios = leer_precios('../Data/precios.csv') >>> valor = sum([s['cajones'] * precios[s['nombre']] for s in camion]) >>> valor 62986.1 >>> Ambos son ejemplos de aplicaci\u00f3n-reducci\u00f3n. La comprensi\u00f3n de listas est\u00e1 aplicando una operaci\u00f3n a lo largo de la lista. >>> [s['cajones'] * s['precio'] for s in camion] [3220.0000000000005, 4555.0, 15516.0, 10246.0, 3835.1499999999996, 3254.9999999999995, 7044.0] >>> La funci\u00f3n sum() luego realiza una reducci\u00f3n del resultado >>> sum(_) 47671.15 >>> Con este conocimiento algunos ya empiezan su startup de big-data.","title":"Ejercicio 4.8: Reducci\u00f3n de secuencias"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#ejercicio-49-consultas-de-datos","text":"Prob\u00e1 los siguientes ejemplos de consultas (queries) de datos. Primero, gener\u00e1 una lista con la info de todas las frutas que tienen m\u00e1s de 100 cajones en el cami\u00f3n. >>> mas100 = [s for s in camion if s['cajones'] > 100] >>> mas100 [{'cajones': 150, 'nombre': 'Caqui', 'precio': 103.44}, {'cajones': 200, 'nombre': 'Mandarina', 'precio': 51.23}] >>> Ahora, una con la info sobre cajones de Mandarina y Naranja. >>> myn = [s for s in camion if s['nombre'] in {'Mandarina','Naranja'}] >>> myn [{'cajones': 50, 'nombre': 'Naranja', 'precio': 91.1}, {'cajones': 200, 'nombre': 'Mandarina', 'precio': 51.23}, {'cajones': 50, 'nombre': 'Mandarina', 'precio': 65.1}, {'cajones': 100, 'nombre': 'Naranja', 'precio': 70.44}] >>> O una con la info de las frutas que costaron m\u00e1s de $10000. >>> costo10k = [s for s in camion if s['cajones'] * s['precio'] > 10000] >>> costo10k [{'cajones': 150, 'nombre': 'Caqui', 'precio': 103.44}, {'cajones': 200, 'nombre': 'Mandarina', 'precio': 51.23}] >>> Esta forma de escribir resulta an\u00e1loga a las consultas a una base de datos con SQL.","title":"Ejercicio 4.9: Consultas de datos"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#ejercicio-410-extraccion-de-datos","text":"Usando un comprensi\u00f3n de listas, constru\u00ed una lista de tuplas (nombre, cajones) que indiquen la cantidad de cajones de cada fruta tomando los datos de camion . >>> nombre_cajones =[(s['nombre'], s['cajones']) for s in camion] >>> nombre_cajones [('Lima', 100), ('Naranja', 50), ('Caqui', 150), ('Mandarina', 200), ('Durazno', 95), ('Mandarina', 50), ('Naranja', 100)] >>> Si cambi\u00e1s los corchetes ( [ , ] ) por llaves ( { , } ), obten\u00e9s algo que se conoce como comprensi\u00f3n de conjuntos. Vas a obtener valores \u00fanicos. Por ejemplo, si quisieras un listado de las frutas en el cami\u00f3n pord\u00edas usar: >>> nombres = {s['nombre'] for s in camion} >>> nombres {'Caqui', 'Durazno', 'Lima', 'Mandarina', 'Naranja'} >>> Si especific\u00e1s pares clave:valor , pod\u00e9s construir un diccionario. Por ejemplo, si queremos un diccionario con el total de cada fruta en el cami\u00f3n podemos comenzar con >>> stock = {nombre: 0 for nombre in nombres} >>> stock {'Caqui': 0, 'Durazno': 0, 'Lima': 0, 'Mandarina': 0, 'Naranja': 0} >>> que es una comprensi\u00f3n de diccionario. Y seguir sumando los cajones: >>> for s in camion: stock[s['nombre']] += s['cajones'] >>> stock {'Caqui': 150, 'Durazno': 95, 'Lima': 100, 'Mandarina': 250, 'Naranja': 150} >>> Otro ejemplo \u00fatil podr\u00eda ser generar un diccionario de precios de venta de aquellos productos que est\u00e1n efectivamente cargados en el cami\u00f3n: >>> camion_precios = {nombre: precios[nombre] for nombre in nombres} >>> camion_precios {'Caqui': 105.46, 'Durazno': 73.48, 'Lima': 40.22, 'Mandarina': 80.89, 'Naranja': 106.28} >>>","title":"Ejercicio 4.10: Extracci\u00f3n de datos"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#ejercicio-411-extraer-datos-de-un-archivo-csv","text":"Saber usar combinaciones de comprensi\u00f3n de listas, diccionarios y conjuntos resulta \u00fatil para procesar datos en diferentes contextos. Aunque puede volverse medio cr\u00edptico si no est\u00e1s habituade. Ac\u00e1 te mostramos un ejemplo de c\u00f3mo extraer columnas seleccionadas de un archivo CSV que tiene esas caracter\u00edsticas. No es dificil cuando lo entend\u00e9s, pero est\u00e1 muy concentrado todo. Primero, leamos el encabezado (header) del archivo CSV: >>> import csv >>> f = open('../Data/fecha_camion.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> headers ['nombre', 'fecha', 'hora', 'cajones', 'precio'] >>> Luego, definamos una lista que tenga las columnas que nos importan: >>> select = ['nombre', 'cajones', 'precio'] >>> Ubiquemos los \u00edndices de esas columnas en el CSV: >>> indices = [headers.index(ncolumna) for ncolumna in select] >>> indices [0, 3, 4] >>> Y finalmente leamos los datos y armemos un diccionario usando comprensi\u00f3n de diccionarios: >>> row = next(rows) >>> record = {ncolumna: row[index] for ncolumna, index in zip(select, indices)} # comprensi\u00f3n de diccionario >>> record {'precio': '32.20', 'nombre': 'Lima', 'cajones': '100'} >>> No es trivial este comando. El comando es sint\u00e1cticamente muy compacto, pero es conceptualmente (un poco) complejo. Cuando te sientas c\u00f3mode con esta lectura de una l\u00ednea del archivo (si no pasa, tranca, podemos seguir sin esto), le\u00e9 el resto: >>> camion = [{ ncolumna: row[index] for ncolumna, index in zip(select, indices)} for row in rows] >>> camion [{'cajones': '50', 'nombre': 'Naranja', 'precio': '91.1'}, {'cajones': '150', 'nombre': 'Caqui', 'precio': '103.44'}, {'cajones': '200', 'nombre': 'Mandarina', 'precio': '51.23'}, {'cajones': '95', 'nombre': 'Durazno', 'precio': '40.37'}, {'cajones': '50', 'nombre': 'Mandarina', 'precio': '65.1'}, {'cajones': '100', 'nombre': 'Naranja', 'precio': '70.44'}] >>> \u00a1Por las barbas de mi abuelo! Acabamos de reducir casi toda la funci\u00f3n leer_camion() a un solo comando.","title":"Ejercicio 4.11: Extraer datos de un archivo CSV"},{"location":"04_Listas_y_Listas/03_Comprension_Listas/#comentario","text":"La comprensi\u00f3n de listas se usa frecuentemente en Python. Es una forma eficiente de transformar, filtrar o juntar datos. Tiene una sintaxis potente pero trat\u00e1 de no pasarte con su uso: manten\u00e9 cada comando tan simple como sea posible. Est\u00e1 perfecto descomponer un solo comando complejo en muchos pasos. Concretamente: compartir el \u00faltimo ejemplo con personas desprevenidas puede no ser lo ideal. Dicho esto, saber manipular datos r\u00e1pidamente es una habilidad incre\u00edblemente \u00fatil. Hay numerosas situaciones donde puede que tengas que resolver alg\u00fan tipo de problema excepcional (en el sentido de raro o \u00fanico) para importar, extraer o exportar datos. La comprensi\u00f3n de listas te puede ahorrar much\u00edsimo tiempo en esas tareas. Contenidos | Anterior (2 Listas y b\u00fasqueda lineal) | Pr\u00f3ximo (4 Objetos)","title":"Comentario"},{"location":"04_Listas_y_Listas/04_Objetos/","text":"Contenidos | Anterior (3 Comprensi\u00f3n de listas) | Pr\u00f3ximo (5 Arbolado porte\u00f1o y comprensi\u00f3n de listas) 4.4 Objetos En esta secci\u00f3n introducimos algunos conceptos sobre el modelo interno de objeto en Python y discutimos algunos temas relacionados con el manejo de memoria, copias de variable y verificaci\u00f3n de tipos. Asignaciones Muchas operaciones en Python est\u00e1n relacionadas con asignar o guardar valores. a = valor # Asignaci\u00f3n a una variable s[n] = valor # Asignaci\u00f3n a una lista s.append(valor) # Agregar a una lista d['key'] = valor # Agregar a una diccionario Ojo: las operaciones de asignaci\u00f3n nunca hacen una copia del valor asignado. Las asignaciones son simplemente copias de las referencias (o copias del puntero, si prefer\u00eds). Ejemplo de asignaci\u00f3n Consider\u00e1 este fragmento de c\u00f3digo. a = [1,2,3] b = a c = [a,b] A continuaci\u00f3n te mostramos en un gr\u00e1fico las operaciones de memoria suyacentes. En este ejemplo, hay solo un objeto lista [1,2,3] , pero hay cuatro referencias a \u00e9l. Esto significa que al modificar un valor modificamos todas las referencias. >>> a.append(999) >>> a [1,2,3,999] >>> b [1,2,3,999] >>> c [[1,2,3,999], [1,2,3,999]] >>> Observ\u00e1 c\u00f3mo un cambio en la lista original desencadena cambios en todas las dem\u00e1s variables (ouch!). Esto es porque no se hizo ninguna copia. Todos son punteros a la misma cosa. Esto es lo mismo que pasaba en el Ejercicio 3.5 . Reasignar valores La reasignaci\u00f3n de valores nunca sobreescribe la memoria ocupada por un valor anterior. a = [1,2,3] b = a a = [4,5,6] print(a) # [4, 5, 6] print(b) # [1, 2, 3] Mantiene el valor original Acordate: Las variables son nombres, no ubicaciones en la memoria. Peligros Si no te explican esto, tarde o temprano te trae problemas. Un t\u00edpico ejemplo es cuando cambi\u00e1s un dato pensando que es una copia privada y, sin querer, esto corrompe los datos en otra parte del programa. Comentario: Esta es una de las razones por las que los tipos de datos primitivos (int, float, string) son immutables (de s\u00f3lo lectura). Identidad y referencias Pod\u00e9s usar el operador is (es) para verificar si dos valores corresponden al mismo objeto. >>> a = [1,2,3] >>> b = a >>> a is b True >>> is compara la identidad del objeto (que est\u00e1 representada por un n\u00famero entero). Esta identidad tambi\u00e9n la pod\u00e9s obtener usando id() . >>> id(a) 3588944 >>> id(b) 3588944 >>> Observaci\u00f3n: Para ver si dos valores son iguales, es mejor usar el == . El comportamiento de is puede dar resultados inesperados: >>> a = [1,2,3] >>> b = a >>> c = [1,2,3] >>> a is b True >>> a is c False >>> a == c True >>> Copias superficiales Las listas y diccionarios tienen m\u00e9todos para hacer copias (no meras referencias, sino duplicados): >>> a = [2,3,[100,101],4] >>> b = list(a) # Hacer una copia >>> a is b False Ahora b es una nueva lista. >>> a.append(5) >>> a [2, 3, [100, 101], 4, 5] >>> b [2, 3, [100, 101], 4] A pesar de esto, los elementos de a y de b siguen siendo compartidos. >>> a[2].append(102) >>> b[2] [100,101,102] >>> >>> a[2] is b[2] True >>> En este ejemplo, la lista interna [100, 101, 102] es compartida por ambas variables. La copia que hicimos con el comando b = list(a) es un copia superficial (superficial en el sentido de poco profunda , en ingl\u00e9s se dice shallow copy ). Mir\u00e1 este gr\u00e1fico. La lista interna sigue siendo compartida. Copias profundas A veces vas a necesitar hacer una copia de un objeto as\u00ed como de todos los objetos que contenga. Llamamos a esto una copia pofunda ( deep copy ). Pod\u00e9s usar la funci\u00f3n deepcopy del m\u00f3dulo copy para esto: >>> a = [2,3,[100,101],4] >>> import copy >>> b = copy.deepcopy(a) >>> a[2].append(102) >>> b[2] [100,101] >>> a[2] is b[2] False >>> Nombre, valores y tipos Los nombres de variables no tienen un tipo asociado. S\u00f3lo son nombres. Pero los valores s\u00ed tienen un tipo subyacente. >>> a = 42 >>> b = 'Hello World' >>> type(a) <type 'int'> >>> type(b) <type 'str'> type() te dice el tipo del valor. Verificaci\u00f3n de tipos Pod\u00e9s verificar si un objeto es una instancia de cierto tipo. if isinstance(a, list): print('a es una lista') O incluso si su tipo est\u00e1 entre varios tipos. if isinstance(a, (list,tuple)): print('a una lista o una tupla') Cuidado: Demasiadas verificaciones de tipos pueden resultar en un c\u00f3digo excesivamente complejo. T\u00edpicamente lo us\u00e1s para evitar errores comunes cometidos por otres usuaries de tu c\u00f3digo. Todo es un objeto N\u00fameros, cadenas, listas, funciones, excepciones, clases, instancias, etc. son todos objetos. Esto significa que pueden ser nombrados, pueden ser pasados como datos, ubicados en contenedores, etc. sin restricciones. No hay objetos especiales en Python. Todos los objetos viajan en primera clase. Un ejemplo simple: >>> import math >>> items = [abs, math, ValueError ] >>> items [<built-in function abs>, <module 'math' (builtin)>, <type 'exceptions.ValueError'>] >>> items[0](-45) 45 >>> items[1].sqrt(2) 1.4142135623730951 >>> try: x = int('not a number') except items[2]: print('Failed!') Failed! >>> Ac\u00e1, items es una lista que tiene una funci\u00f3n, un m\u00f3dulo y una excepci\u00f3n. S\u00ed, \u00e9ste es un ejemplo raro. Pero es un ejemplo al fin. Pod\u00e9s usar los elementos de la lista en lugar de los nombres originales: items[0](-45) # abs items[1].sqrt(2) # math except items[2]: # ValueError Con un gran poder viene siempre una gran responsabilidad. Que puedas no significa que debas hacer este tipo de cosas. Ejercicios En estos ejercicios mostramos algo de la potencia que tiene el hecho de que todos los objetos sean de la misma jerarqu\u00eda. Ejercicio 4.12: Datos de primera clase En el archivo Data/camion.csv , le\u00edmos datos organizados en columnas que se ven as\u00ed: nombre,cajones,precio \"Lima\",100,32.20 \"Naranja\",50,91.10 ... En las clases anteriores, usamos el m\u00f3dulo csv para leer el archivo, pero tuvimos que hacer conversiones de tipo. Por ejemplo: for row in rows: nombre = row[0] cajones = int(row[1]) precio = float(row[2]) Este tipo de conversiones puede hacerse de una manera m\u00e1s inteligente usando algunas operaciones de listas. Hagamos una lista de Python con los nombres de las funciones de conversi\u00f3n que necesitamos para convertir cada columna al tipo apropiado: >>> types = [str, int, float] >>> Pod\u00e9s crear esta lista porque en Python todos los objetos son de la misma clase (de primera clase, digamos). Por lo tanto, si quer\u00e9s tener funciones en una lista, no pasa nada. Los elementos de la lista que creaste son funciones que convierten un valor x a un tipo dado ( str(x) , int(x) , float(x) ). Ahora, le\u00e9 una fila de datos del archivo anterior: >>> import csv >>> f = open('../Data/camion.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> row = next(rows) >>> row ['Lima', '100', '32.20'] >>> Como ya dijimos, con esta fila no podemos hacer operaciones porque los tipos son incorrectos. Por ejemplo: >>> row[1] * row[2] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't multiply sequence by non-int of type 'str' >>> Sin embargo, los datos pueden aparearse con los tipos especificados en types . Por ejemplo: >>> types[1] <type 'int'> >>> row[1] '100' >>> Prob\u00e1 convertir uno de los valores: >>> types[1](row[1]) # Es equivalente a int(row[1]) 100 >>> Prob\u00e1 con otro: >>> types[2](row[2]) # Equivalente a float(row[2]) 32.2 >>> Prob\u00e1 calcular usando los tipos convertidos: >>> types[1](row[1])*types[2](row[2]) 3220.0000000000005 >>> Hagamos un Zip de la lista de tipos con la de datos y veamos el resultado: >>> r = list(zip(types, row)) >>> r [(<type 'str'>, 'Lima'), (<type 'int'>, '100'), (<type 'float'>,'32.20')] >>> Se puede ver que esto aparea una funci\u00f3n de conversi\u00f3n de tipos con un valor. Por ejemplo, int est\u00e1 en un par con el valor '100' . Esta lista zipeada es \u00fatil si quer\u00e9s realizar conversiones de todos los valores. Por ejemplo: >>> converted = [] >>> for func, val in zip(types, row): converted.append(func(val)) ... >>> converted ['Lima', 100, 32.2] >>> converted[1] * converted[2] 3220.0000000000005 >>> Asegurate de entender lo que est\u00e1 pasando en el c\u00f3digo de arriba. En el ciclo la variable func va tomando los valores de las funciones de conversi\u00f3n de tipos ( str , int , float ) y la variable val va tomando los valores de los datos en la fila: 'Lima' , '100' , '32.2' . La expresi\u00f3n func(val) convierte los tipos de cada dato. El c\u00f3digo de arriba puede comprimirse en una sola instrucci\u00f3n usando comprensi\u00f3n de listas. >>> converted = [func(val) for func, val in zip(types, row)] >>> converted ['Lima', 100, 32.2] >>> Ejercicio 4.13: Diccionarios \u00bfTe acord\u00e1s que la funci\u00f3n dict() te permite hacer f\u00e1cilmente un diccionario si ten\u00e9s una secuencia de tuplas con claves y valores? Hagamos un diccionario usando el encabezado de las columnas: >>> headers ['nombre', 'cajones', 'precio'] >>> converted ['Lima', 100, 32.2] >>> dict(zip(headers, converted)) {'precio': 32.2, 'nombre': 'Lima', 'cajones': 100} >>> Si est\u00e1s en sinton\u00eda con la comprensi\u00f3n de listas pod\u00e9s escribir una sola l\u00ednea usando comprensi\u00f3n de diccionarios: >>> { name: func(val) for name, func, val in zip(headers, types, row) } {'precio': 32.2, 'name': 'Lima', 'cajones': 100} >>> Ejercicio 4.14: Fijando ideas Usando las t\u00e9cnicas de este ejercicio, vas a poder escribir instrucciones que conviertan f\u00e1cilmente campos como los de nuestro archivo en un diccionario de Python. Para ilustrar esto, supongamos que le\u00e9s un archivo de datos de la siguiente forma: >>> f = open('../Data/dowstocks.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> row = next(rows) >>> headers ['name', 'price', 'date', 'time', 'change', 'open', 'high', 'low', 'volume'] >>> row ['AA', '39.48', '6/11/2007', '9:36am', '-0.18', '39.67', '39.69', '39.45', '181800'] >>> Convirtamos estos datos usando un truco similar: >>> types = [str, float, str, str, float, float, float, float, int] >>> converted = [func(val) for func, val in zip(types, row)] >>> record = dict(zip(headers, converted)) >>> record {'volume': 181800, 'name': 'AA', 'price': 39.48, 'high': 39.69, 'low': 39.45, 'time': '9:36am', 'date': '6/11/2007', 'open': 39.67, 'change': -0.18} >>> record['name'] 'AA' >>> record['price'] 39.48 >>> Bonus: \u00bfC\u00f3mo modificar\u00edas este ejemplo para transformar la fecha ( date ) en una tupla como (6, 11, 2007) ? Es importante que entiendas lo que hicimos en este ejercicio. Volveremos sobre esto m\u00e1s adelante. Contenidos | Anterior (3 Comprensi\u00f3n de listas) | Pr\u00f3ximo (5 Arbolado porte\u00f1o y comprensi\u00f3n de listas)","title":"04 Objetos"},{"location":"04_Listas_y_Listas/04_Objetos/#44-objetos","text":"En esta secci\u00f3n introducimos algunos conceptos sobre el modelo interno de objeto en Python y discutimos algunos temas relacionados con el manejo de memoria, copias de variable y verificaci\u00f3n de tipos.","title":"4.4 Objetos"},{"location":"04_Listas_y_Listas/04_Objetos/#asignaciones","text":"Muchas operaciones en Python est\u00e1n relacionadas con asignar o guardar valores. a = valor # Asignaci\u00f3n a una variable s[n] = valor # Asignaci\u00f3n a una lista s.append(valor) # Agregar a una lista d['key'] = valor # Agregar a una diccionario Ojo: las operaciones de asignaci\u00f3n nunca hacen una copia del valor asignado. Las asignaciones son simplemente copias de las referencias (o copias del puntero, si prefer\u00eds).","title":"Asignaciones"},{"location":"04_Listas_y_Listas/04_Objetos/#ejemplo-de-asignacion","text":"Consider\u00e1 este fragmento de c\u00f3digo. a = [1,2,3] b = a c = [a,b] A continuaci\u00f3n te mostramos en un gr\u00e1fico las operaciones de memoria suyacentes. En este ejemplo, hay solo un objeto lista [1,2,3] , pero hay cuatro referencias a \u00e9l. Esto significa que al modificar un valor modificamos todas las referencias. >>> a.append(999) >>> a [1,2,3,999] >>> b [1,2,3,999] >>> c [[1,2,3,999], [1,2,3,999]] >>> Observ\u00e1 c\u00f3mo un cambio en la lista original desencadena cambios en todas las dem\u00e1s variables (ouch!). Esto es porque no se hizo ninguna copia. Todos son punteros a la misma cosa. Esto es lo mismo que pasaba en el Ejercicio 3.5 .","title":"Ejemplo de asignaci\u00f3n"},{"location":"04_Listas_y_Listas/04_Objetos/#reasignar-valores","text":"La reasignaci\u00f3n de valores nunca sobreescribe la memoria ocupada por un valor anterior. a = [1,2,3] b = a a = [4,5,6] print(a) # [4, 5, 6] print(b) # [1, 2, 3] Mantiene el valor original Acordate: Las variables son nombres, no ubicaciones en la memoria.","title":"Reasignar valores"},{"location":"04_Listas_y_Listas/04_Objetos/#peligros","text":"Si no te explican esto, tarde o temprano te trae problemas. Un t\u00edpico ejemplo es cuando cambi\u00e1s un dato pensando que es una copia privada y, sin querer, esto corrompe los datos en otra parte del programa. Comentario: Esta es una de las razones por las que los tipos de datos primitivos (int, float, string) son immutables (de s\u00f3lo lectura).","title":"Peligros"},{"location":"04_Listas_y_Listas/04_Objetos/#identidad-y-referencias","text":"Pod\u00e9s usar el operador is (es) para verificar si dos valores corresponden al mismo objeto. >>> a = [1,2,3] >>> b = a >>> a is b True >>> is compara la identidad del objeto (que est\u00e1 representada por un n\u00famero entero). Esta identidad tambi\u00e9n la pod\u00e9s obtener usando id() . >>> id(a) 3588944 >>> id(b) 3588944 >>> Observaci\u00f3n: Para ver si dos valores son iguales, es mejor usar el == . El comportamiento de is puede dar resultados inesperados: >>> a = [1,2,3] >>> b = a >>> c = [1,2,3] >>> a is b True >>> a is c False >>> a == c True >>>","title":"Identidad y referencias"},{"location":"04_Listas_y_Listas/04_Objetos/#copias-superficiales","text":"Las listas y diccionarios tienen m\u00e9todos para hacer copias (no meras referencias, sino duplicados): >>> a = [2,3,[100,101],4] >>> b = list(a) # Hacer una copia >>> a is b False Ahora b es una nueva lista. >>> a.append(5) >>> a [2, 3, [100, 101], 4, 5] >>> b [2, 3, [100, 101], 4] A pesar de esto, los elementos de a y de b siguen siendo compartidos. >>> a[2].append(102) >>> b[2] [100,101,102] >>> >>> a[2] is b[2] True >>> En este ejemplo, la lista interna [100, 101, 102] es compartida por ambas variables. La copia que hicimos con el comando b = list(a) es un copia superficial (superficial en el sentido de poco profunda , en ingl\u00e9s se dice shallow copy ). Mir\u00e1 este gr\u00e1fico. La lista interna sigue siendo compartida.","title":"Copias superficiales"},{"location":"04_Listas_y_Listas/04_Objetos/#copias-profundas","text":"A veces vas a necesitar hacer una copia de un objeto as\u00ed como de todos los objetos que contenga. Llamamos a esto una copia pofunda ( deep copy ). Pod\u00e9s usar la funci\u00f3n deepcopy del m\u00f3dulo copy para esto: >>> a = [2,3,[100,101],4] >>> import copy >>> b = copy.deepcopy(a) >>> a[2].append(102) >>> b[2] [100,101] >>> a[2] is b[2] False >>>","title":"Copias profundas"},{"location":"04_Listas_y_Listas/04_Objetos/#nombre-valores-y-tipos","text":"Los nombres de variables no tienen un tipo asociado. S\u00f3lo son nombres. Pero los valores s\u00ed tienen un tipo subyacente. >>> a = 42 >>> b = 'Hello World' >>> type(a) <type 'int'> >>> type(b) <type 'str'> type() te dice el tipo del valor.","title":"Nombre, valores y tipos"},{"location":"04_Listas_y_Listas/04_Objetos/#verificacion-de-tipos","text":"Pod\u00e9s verificar si un objeto es una instancia de cierto tipo. if isinstance(a, list): print('a es una lista') O incluso si su tipo est\u00e1 entre varios tipos. if isinstance(a, (list,tuple)): print('a una lista o una tupla') Cuidado: Demasiadas verificaciones de tipos pueden resultar en un c\u00f3digo excesivamente complejo. T\u00edpicamente lo us\u00e1s para evitar errores comunes cometidos por otres usuaries de tu c\u00f3digo.","title":"Verificaci\u00f3n de tipos"},{"location":"04_Listas_y_Listas/04_Objetos/#todo-es-un-objeto","text":"N\u00fameros, cadenas, listas, funciones, excepciones, clases, instancias, etc. son todos objetos. Esto significa que pueden ser nombrados, pueden ser pasados como datos, ubicados en contenedores, etc. sin restricciones. No hay objetos especiales en Python. Todos los objetos viajan en primera clase. Un ejemplo simple: >>> import math >>> items = [abs, math, ValueError ] >>> items [<built-in function abs>, <module 'math' (builtin)>, <type 'exceptions.ValueError'>] >>> items[0](-45) 45 >>> items[1].sqrt(2) 1.4142135623730951 >>> try: x = int('not a number') except items[2]: print('Failed!') Failed! >>> Ac\u00e1, items es una lista que tiene una funci\u00f3n, un m\u00f3dulo y una excepci\u00f3n. S\u00ed, \u00e9ste es un ejemplo raro. Pero es un ejemplo al fin. Pod\u00e9s usar los elementos de la lista en lugar de los nombres originales: items[0](-45) # abs items[1].sqrt(2) # math except items[2]: # ValueError Con un gran poder viene siempre una gran responsabilidad. Que puedas no significa que debas hacer este tipo de cosas.","title":"Todo es un objeto"},{"location":"04_Listas_y_Listas/04_Objetos/#ejercicios","text":"En estos ejercicios mostramos algo de la potencia que tiene el hecho de que todos los objetos sean de la misma jerarqu\u00eda.","title":"Ejercicios"},{"location":"04_Listas_y_Listas/04_Objetos/#ejercicio-412-datos-de-primera-clase","text":"En el archivo Data/camion.csv , le\u00edmos datos organizados en columnas que se ven as\u00ed: nombre,cajones,precio \"Lima\",100,32.20 \"Naranja\",50,91.10 ... En las clases anteriores, usamos el m\u00f3dulo csv para leer el archivo, pero tuvimos que hacer conversiones de tipo. Por ejemplo: for row in rows: nombre = row[0] cajones = int(row[1]) precio = float(row[2]) Este tipo de conversiones puede hacerse de una manera m\u00e1s inteligente usando algunas operaciones de listas. Hagamos una lista de Python con los nombres de las funciones de conversi\u00f3n que necesitamos para convertir cada columna al tipo apropiado: >>> types = [str, int, float] >>> Pod\u00e9s crear esta lista porque en Python todos los objetos son de la misma clase (de primera clase, digamos). Por lo tanto, si quer\u00e9s tener funciones en una lista, no pasa nada. Los elementos de la lista que creaste son funciones que convierten un valor x a un tipo dado ( str(x) , int(x) , float(x) ). Ahora, le\u00e9 una fila de datos del archivo anterior: >>> import csv >>> f = open('../Data/camion.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> row = next(rows) >>> row ['Lima', '100', '32.20'] >>> Como ya dijimos, con esta fila no podemos hacer operaciones porque los tipos son incorrectos. Por ejemplo: >>> row[1] * row[2] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: can't multiply sequence by non-int of type 'str' >>> Sin embargo, los datos pueden aparearse con los tipos especificados en types . Por ejemplo: >>> types[1] <type 'int'> >>> row[1] '100' >>> Prob\u00e1 convertir uno de los valores: >>> types[1](row[1]) # Es equivalente a int(row[1]) 100 >>> Prob\u00e1 con otro: >>> types[2](row[2]) # Equivalente a float(row[2]) 32.2 >>> Prob\u00e1 calcular usando los tipos convertidos: >>> types[1](row[1])*types[2](row[2]) 3220.0000000000005 >>> Hagamos un Zip de la lista de tipos con la de datos y veamos el resultado: >>> r = list(zip(types, row)) >>> r [(<type 'str'>, 'Lima'), (<type 'int'>, '100'), (<type 'float'>,'32.20')] >>> Se puede ver que esto aparea una funci\u00f3n de conversi\u00f3n de tipos con un valor. Por ejemplo, int est\u00e1 en un par con el valor '100' . Esta lista zipeada es \u00fatil si quer\u00e9s realizar conversiones de todos los valores. Por ejemplo: >>> converted = [] >>> for func, val in zip(types, row): converted.append(func(val)) ... >>> converted ['Lima', 100, 32.2] >>> converted[1] * converted[2] 3220.0000000000005 >>> Asegurate de entender lo que est\u00e1 pasando en el c\u00f3digo de arriba. En el ciclo la variable func va tomando los valores de las funciones de conversi\u00f3n de tipos ( str , int , float ) y la variable val va tomando los valores de los datos en la fila: 'Lima' , '100' , '32.2' . La expresi\u00f3n func(val) convierte los tipos de cada dato. El c\u00f3digo de arriba puede comprimirse en una sola instrucci\u00f3n usando comprensi\u00f3n de listas. >>> converted = [func(val) for func, val in zip(types, row)] >>> converted ['Lima', 100, 32.2] >>>","title":"Ejercicio 4.12: Datos de primera clase"},{"location":"04_Listas_y_Listas/04_Objetos/#ejercicio-413-diccionarios","text":"\u00bfTe acord\u00e1s que la funci\u00f3n dict() te permite hacer f\u00e1cilmente un diccionario si ten\u00e9s una secuencia de tuplas con claves y valores? Hagamos un diccionario usando el encabezado de las columnas: >>> headers ['nombre', 'cajones', 'precio'] >>> converted ['Lima', 100, 32.2] >>> dict(zip(headers, converted)) {'precio': 32.2, 'nombre': 'Lima', 'cajones': 100} >>> Si est\u00e1s en sinton\u00eda con la comprensi\u00f3n de listas pod\u00e9s escribir una sola l\u00ednea usando comprensi\u00f3n de diccionarios: >>> { name: func(val) for name, func, val in zip(headers, types, row) } {'precio': 32.2, 'name': 'Lima', 'cajones': 100} >>>","title":"Ejercicio 4.13: Diccionarios"},{"location":"04_Listas_y_Listas/04_Objetos/#ejercicio-414-fijando-ideas","text":"Usando las t\u00e9cnicas de este ejercicio, vas a poder escribir instrucciones que conviertan f\u00e1cilmente campos como los de nuestro archivo en un diccionario de Python. Para ilustrar esto, supongamos que le\u00e9s un archivo de datos de la siguiente forma: >>> f = open('../Data/dowstocks.csv') >>> rows = csv.reader(f) >>> headers = next(rows) >>> row = next(rows) >>> headers ['name', 'price', 'date', 'time', 'change', 'open', 'high', 'low', 'volume'] >>> row ['AA', '39.48', '6/11/2007', '9:36am', '-0.18', '39.67', '39.69', '39.45', '181800'] >>> Convirtamos estos datos usando un truco similar: >>> types = [str, float, str, str, float, float, float, float, int] >>> converted = [func(val) for func, val in zip(types, row)] >>> record = dict(zip(headers, converted)) >>> record {'volume': 181800, 'name': 'AA', 'price': 39.48, 'high': 39.69, 'low': 39.45, 'time': '9:36am', 'date': '6/11/2007', 'open': 39.67, 'change': -0.18} >>> record['name'] 'AA' >>> record['price'] 39.48 >>> Bonus: \u00bfC\u00f3mo modificar\u00edas este ejemplo para transformar la fecha ( date ) en una tupla como (6, 11, 2007) ? Es importante que entiendas lo que hicimos en este ejercicio. Volveremos sobre esto m\u00e1s adelante. Contenidos | Anterior (3 Comprensi\u00f3n de listas) | Pr\u00f3ximo (5 Arbolado porte\u00f1o y comprensi\u00f3n de listas)","title":"Ejercicio 4.14: Fijando ideas"},{"location":"04_Listas_y_Listas/05_Arboles2_LC/","text":"Contenidos | Anterior (4 Objetos) | Pr\u00f3ximo (6 Cierre de la clase) 4.5 Arbolado porte\u00f1o y comprensi\u00f3n de listas Seguimos aqu\u00ed con el arbolado porte\u00f1o. Vamos a plantear algunos ejercicios para hacer con la t\u00e9cnica de comprensi\u00f3n de listas introducida recientemente. Ejercicios Seguimos trabajando con el archivo CSV de \" Arbolado en espacios verdes \" que ya est\u00e1 en tu carpeta Data . Vamos a estudiar esta base de datos y responder algunas preguntas. Guard\u00e1 los ejercicios de esta secci\u00f3n en el archivo arboles.py . Ejercicio 4.15: Lectura de todos los \u00e1rboles Bas\u00e1ndote en la funci\u00f3n leer_parque(nombre_archivo, parque) del Ejercicio 3.18 , escrib\u00ed otra leer_arboles(nombre_archivo) que lea el archivo indicado y devuelva una lista de diccionarios con la informaci\u00f3n de todos los \u00e1rboles en el archivo. La funci\u00f3n debe devolver una lista conteniendo un diccionario por cada \u00e1rbol con todos los datos. Vamos a llamar arboleda a esta lista. Ejercicio 4.16: Lista de altos de Jacarand\u00e1 Usando comprensi\u00f3n de listas y la variable arboleda pod\u00e9s por ejemplo armar la lista de la altura de los \u00e1rboles. H=[float(arbol['altura_tot']) for arbol in arboleda] Us\u00e1 los filtros (record\u00e1 la Secci\u00f3n 4.3 ) para armar la lista de alturas de los Jacarand\u00e1s solamente. Ejercicio 4.17: Lista de altos y di\u00e1metros de Jacarand\u00e1 En el ejercicio anterior usaste una sola linea para seleccionar las alturas de los Jacarand\u00e1s en parques porte\u00f1os. Ahora te proponemos que armes una nueva lista que tenga pares (tuplas de longitud 2) conteniendo no solo el alto sino tambi\u00e9n el di\u00e1metro de cada Jacarand\u00e1 en la lista. Esperamos que obtengas una lista similar a esta: [(5.0, 10.0), (5.0, 10.0), ... (12.0, 25.0), ... (7.0, 97.0), (8.0, 28.0), (2.0, 30.0), (3.0, 10.0), (17.0, 40.0)] Ejercicio 4.18: Diccionario con medidas En este ejercicio vamos a considerar algunas especies de \u00e1rboles. Por ejemplo: especies = ['Eucalipto', 'Palo borracho rosado', 'Jacarand\u00e1'] Te pedimos que armes un diccionario en el que estas especies sean las claves y los valores asociados sean los datos que generaste en el ejercicio anterior. M\u00e1s a\u00fan, organiz\u00e1 tu c\u00f3digo dentro de una funci\u00f3n medidas_de_especies(especies,arboleda) que recibe una lista de nombres de especies y una lista como la del Ejercicio 4.15 y devuelve un diccionario cuyas claves son estas especies y sus valores asociados sean las medidas generadas en el ejercicio anterior. Vamos a usar esta funci\u00f3n la semana pr\u00f3xima. A modo de control, si llam\u00e1s a la funci\u00f3n con las tres especies del ejemplo como par\u00e1metro ( ['Eucalipto', 'Palo borracho rosado', 'Jacarand\u00e1'] ) y la arboleda entera, deber\u00edas recibir un diccionario con tres entradas (una por especie), cada una con una lista asociada conteniendo 4112, 3150 y 3255 pares de n\u00fameros (altos y di\u00e1metros), respectivamente. Acordate de guardar los ejercicios de esta secci\u00f3n en el archivo arboles.py . Extra: casi todes usan un for para crear este diccionario. \u00bfLo pod\u00e9s hacer usando una comprensi\u00f3n de diccionarios ? Te recordamos la sintaxis: diccionario = { clave: valor for clave in claves } Contenidos | Anterior (4 Objetos) | Pr\u00f3ximo (6 Cierre de la clase)","title":"05 Arboles2 LC"},{"location":"04_Listas_y_Listas/05_Arboles2_LC/#45-arbolado-porteno-y-comprension-de-listas","text":"Seguimos aqu\u00ed con el arbolado porte\u00f1o. Vamos a plantear algunos ejercicios para hacer con la t\u00e9cnica de comprensi\u00f3n de listas introducida recientemente.","title":"4.5 Arbolado porte\u00f1o y comprensi\u00f3n de listas"},{"location":"04_Listas_y_Listas/05_Arboles2_LC/#ejercicios","text":"Seguimos trabajando con el archivo CSV de \" Arbolado en espacios verdes \" que ya est\u00e1 en tu carpeta Data . Vamos a estudiar esta base de datos y responder algunas preguntas. Guard\u00e1 los ejercicios de esta secci\u00f3n en el archivo arboles.py .","title":"Ejercicios"},{"location":"04_Listas_y_Listas/05_Arboles2_LC/#ejercicio-415-lectura-de-todos-los-arboles","text":"Bas\u00e1ndote en la funci\u00f3n leer_parque(nombre_archivo, parque) del Ejercicio 3.18 , escrib\u00ed otra leer_arboles(nombre_archivo) que lea el archivo indicado y devuelva una lista de diccionarios con la informaci\u00f3n de todos los \u00e1rboles en el archivo. La funci\u00f3n debe devolver una lista conteniendo un diccionario por cada \u00e1rbol con todos los datos. Vamos a llamar arboleda a esta lista.","title":"Ejercicio 4.15: Lectura de todos los \u00e1rboles"},{"location":"04_Listas_y_Listas/05_Arboles2_LC/#ejercicio-416-lista-de-altos-de-jacaranda","text":"Usando comprensi\u00f3n de listas y la variable arboleda pod\u00e9s por ejemplo armar la lista de la altura de los \u00e1rboles. H=[float(arbol['altura_tot']) for arbol in arboleda] Us\u00e1 los filtros (record\u00e1 la Secci\u00f3n 4.3 ) para armar la lista de alturas de los Jacarand\u00e1s solamente.","title":"Ejercicio 4.16: Lista de altos de Jacarand\u00e1"},{"location":"04_Listas_y_Listas/05_Arboles2_LC/#ejercicio-417-lista-de-altos-y-diametros-de-jacaranda","text":"En el ejercicio anterior usaste una sola linea para seleccionar las alturas de los Jacarand\u00e1s en parques porte\u00f1os. Ahora te proponemos que armes una nueva lista que tenga pares (tuplas de longitud 2) conteniendo no solo el alto sino tambi\u00e9n el di\u00e1metro de cada Jacarand\u00e1 en la lista. Esperamos que obtengas una lista similar a esta: [(5.0, 10.0), (5.0, 10.0), ... (12.0, 25.0), ... (7.0, 97.0), (8.0, 28.0), (2.0, 30.0), (3.0, 10.0), (17.0, 40.0)]","title":"Ejercicio 4.17: Lista de altos y di\u00e1metros de Jacarand\u00e1"},{"location":"04_Listas_y_Listas/05_Arboles2_LC/#ejercicio-418-diccionario-con-medidas","text":"En este ejercicio vamos a considerar algunas especies de \u00e1rboles. Por ejemplo: especies = ['Eucalipto', 'Palo borracho rosado', 'Jacarand\u00e1'] Te pedimos que armes un diccionario en el que estas especies sean las claves y los valores asociados sean los datos que generaste en el ejercicio anterior. M\u00e1s a\u00fan, organiz\u00e1 tu c\u00f3digo dentro de una funci\u00f3n medidas_de_especies(especies,arboleda) que recibe una lista de nombres de especies y una lista como la del Ejercicio 4.15 y devuelve un diccionario cuyas claves son estas especies y sus valores asociados sean las medidas generadas en el ejercicio anterior. Vamos a usar esta funci\u00f3n la semana pr\u00f3xima. A modo de control, si llam\u00e1s a la funci\u00f3n con las tres especies del ejemplo como par\u00e1metro ( ['Eucalipto', 'Palo borracho rosado', 'Jacarand\u00e1'] ) y la arboleda entera, deber\u00edas recibir un diccionario con tres entradas (una por especie), cada una con una lista asociada conteniendo 4112, 3150 y 3255 pares de n\u00fameros (altos y di\u00e1metros), respectivamente. Acordate de guardar los ejercicios de esta secci\u00f3n en el archivo arboles.py . Extra: casi todes usan un for para crear este diccionario. \u00bfLo pod\u00e9s hacer usando una comprensi\u00f3n de diccionarios ? Te recordamos la sintaxis: diccionario = { clave: valor for clave in claves } Contenidos | Anterior (4 Objetos) | Pr\u00f3ximo (6 Cierre de la clase)","title":"Ejercicio 4.18: Diccionario con medidas"},{"location":"04_Listas_y_Listas/06_Cierre/","text":"Contenidos | Anterior (5 Arbolado porte\u00f1o y comprensi\u00f3n de listas) 4.6 Cierre de la clase En esta clase vimos algo m\u00e1s sobre el debugger, el manejo de listas y la creaci\u00f3n de listas por comprensi\u00f3n. Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: 1. El archivo busqueda_en_listas.py del Ejercicio 4.3 y el Ejercicio 4.4 . 2. El archivo invlista.py del Ejercicio 4.5 . 3. El archivo propaga.py del Ejercicio 4.6 . 4. El archivo arboles.py sobre arbolado porte\u00f1o y comprensi\u00f3n de listas incluyendo el Ejercicio 4.16 y el Ejercicio 4.17 . Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y podr\u00e1s participar de la revisi\u00f3n de pares. \u00a1Gracias! Nos vemos en la pr\u00f3xima clase. Contenidos | Anterior (5 Arbolado porte\u00f1o y comprensi\u00f3n de listas)","title":"06 Cierre"},{"location":"04_Listas_y_Listas/06_Cierre/#46-cierre-de-la-clase","text":"En esta clase vimos algo m\u00e1s sobre el debugger, el manejo de listas y la creaci\u00f3n de listas por comprensi\u00f3n. Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: 1. El archivo busqueda_en_listas.py del Ejercicio 4.3 y el Ejercicio 4.4 . 2. El archivo invlista.py del Ejercicio 4.5 . 3. El archivo propaga.py del Ejercicio 4.6 . 4. El archivo arboles.py sobre arbolado porte\u00f1o y comprensi\u00f3n de listas incluyendo el Ejercicio 4.16 y el Ejercicio 4.17 . Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y podr\u00e1s participar de la revisi\u00f3n de pares. \u00a1Gracias! Nos vemos en la pr\u00f3xima clase. Contenidos | Anterior (5 Arbolado porte\u00f1o y comprensi\u00f3n de listas)","title":"4.6 Cierre de la clase"},{"location":"05_Random_Plt_Dbg/00_Resumen/","text":"Contenidos | Anterior (4 Algoritmos sobre listas y comprensi\u00f3n de listas) | Pr\u00f3ximo (6 Complejidad y Organizaci\u00f3n de programas) 5. Aleatoridad En esta clase introducimos conceptos y t\u00e9cnicas relacionadas al azar. La aleatoriedad puede ser un gran aliado para realizar c\u00e1lculos de fen\u00f3menos estoc\u00e1sticos pero tambi\u00e9n de fen\u00f3menos deterministas. Introducimos los n\u00fameros pseudoaleatorios, as\u00ed como el m\u00f3dulo numpy y sus m\u00e9todos m\u00e1s sencillos. Presentamos una versi\u00f3n libre de un ejercicio lind\u00edsimo del curso Exactas Programa que te gu\u00eda para que resuelvas la pregunta \u00bfcu\u00e1ntos paquetes de figuritas tengo que comprar para llenar un \u00e1lbum? con un enfoque estad\u00edstico usando el m\u00e9todo de Montecarlo . Introducimos los arrays de la biblioteca numpy en una secci\u00f3n un poco t\u00e9cnica pero importante para el futuro. A lo largo de la clase iremos haciendo nuestros primeros gr\u00e1ficos en Python. Cerramos introduciendo los scatterplots que permiten visualizar dos variables en simult\u00e1neo y facilitan el an\u00e1lisis exploratorio de datos. 5.1 Random 5.2 NumPy 5.3 El album de Figuritas 5.4 Gr\u00e1ficos del Arbolado porte\u00f1o 5.5 Cierre de la clase Contenidos | Anterior (4 Algoritmos sobre listas y comprensi\u00f3n de listas) | Pr\u00f3ximo (6 Complejidad y Organizaci\u00f3n de programas)","title":"00 Resumen"},{"location":"05_Random_Plt_Dbg/00_Resumen/#5-aleatoridad","text":"En esta clase introducimos conceptos y t\u00e9cnicas relacionadas al azar. La aleatoriedad puede ser un gran aliado para realizar c\u00e1lculos de fen\u00f3menos estoc\u00e1sticos pero tambi\u00e9n de fen\u00f3menos deterministas. Introducimos los n\u00fameros pseudoaleatorios, as\u00ed como el m\u00f3dulo numpy y sus m\u00e9todos m\u00e1s sencillos. Presentamos una versi\u00f3n libre de un ejercicio lind\u00edsimo del curso Exactas Programa que te gu\u00eda para que resuelvas la pregunta \u00bfcu\u00e1ntos paquetes de figuritas tengo que comprar para llenar un \u00e1lbum? con un enfoque estad\u00edstico usando el m\u00e9todo de Montecarlo . Introducimos los arrays de la biblioteca numpy en una secci\u00f3n un poco t\u00e9cnica pero importante para el futuro. A lo largo de la clase iremos haciendo nuestros primeros gr\u00e1ficos en Python. Cerramos introduciendo los scatterplots que permiten visualizar dos variables en simult\u00e1neo y facilitan el an\u00e1lisis exploratorio de datos. 5.1 Random 5.2 NumPy 5.3 El album de Figuritas 5.4 Gr\u00e1ficos del Arbolado porte\u00f1o 5.5 Cierre de la clase Contenidos | Anterior (4 Algoritmos sobre listas y comprensi\u00f3n de listas) | Pr\u00f3ximo (6 Complejidad y Organizaci\u00f3n de programas)","title":"5. Aleatoridad"},{"location":"05_Random_Plt_Dbg/01_Random/","text":"Contenidos | Pr\u00f3ximo (2 NumPy) 5.1 Random En esta secci\u00f3n veremos algunas de las funciones del m\u00f3dulo random . Este m\u00f3dulo se usa para generar valores pseudo-aleatorios. Desde el punto de vista pr\u00e1ctico, usaremos estos valores como perfectamente aleatorios --al ser la computadora una m\u00e1quina determin\u00edstica sabemos que esto no es completamente cierto. De hecho, en lo que sigue, por simplicidad, omitiremos el prefijo pseudo y hablaremos de n\u00fameros aleatorios aunque no lo sean exactamente. Valores discretos Podemos generar n\u00fameros enteros aleatorios entre dos extremos. Por ejemplo, para simular la tirada de un dado podemos generar un n\u00famero entre 1 y 6. import random dado = random.randint(1,6) # devuelve un entero aleatorio entre 1 y 6 Si queremos simular una primera tirada del juego la generala tendremos que generar cinco valores al azar: import random tirada=[] for i in range(5): tirada.append(random.randint(1,6)) print(tirada) Ejercicios: Ejercicio 5.1: Generala servida Queremos estimar la probabilidad de obtener una generala servida (cinco dados iguales) en una tirada de dados. Podemos hacer la cuenta usando un poco de teor\u00eda de probabilidades, o podemos simular que tiramos los dados muchas veces y ver cu\u00e1ntas de esas veces obtuvimos cinco dados iguales. En este ejercicio vamos a usar el segundo camino. Escrib\u00ed una funci\u00f3n tirar() que devuelva una lista con cinco dados generados aleatoriamente. Escrib\u00ed otra funci\u00f3n llamada es_generala(tirada) que devuelve True si y s\u00f3lo si los cinco dados de la lista tirada son iguales. Luego analiz\u00e1 el siguiente c\u00f3digo. Correlo con N = 100000 varias veces y observ\u00e1 los valores que obten\u00e9s. Luego correlo algunas veces con N = 1000000 (ojo, hace un mill\u00f3n de experimentos, podr\u00eda tardar un poco): G = sum([es_generala(tirar()) for i in range(N)]) prob = G/N print(f'Tir\u00e9 {N} veces, de las cuales {G} saqu\u00e9 generala servida.') print(f'Podemos estimar la probabilidad de sacar generala servida mediante {prob:.6f}.') \u00bfPor qu\u00e9 var\u00edan m\u00e1s los resultados obtenidos con N = 100000 que con N = 1000000 ? \u00bfCada cu\u00e1ntas tiradas en promedio podr\u00edas decir que sale una generala servida? \u00bfC\u00f3mo se puede calcular la probabilidad de forma exacta? Ejercicio 5.2: Generala no necesariamente servida Si uno juega con las reglas originales (se puede volver a tirar algunos de los cinco dados hasta dos veces, llegando hasta a tres tiradas en total) siguiendo una estrategia que intente obtener generala (siempre guardar los dados que m\u00e1s se repiten y tirar nuevamente los dem\u00e1s) es m\u00e1s probable obtener una generala que si s\u00f3lo consideramos la generala servida. Escrib\u00ed un programa que estime la probabilidad de obtener una generala en las tres tiradas de una mano y guardalo en un archivo generala.py . Extra: Hay gente que, si en la primera tirada le salen todos dados diferentes, los mete al cubilete y tira los cinco nuevamente. Otras personas, eligen uno de esos dados diferentes, lo guardan, y tiran s\u00f3lo los cuatro restantes. \u00bfPod\u00e9s determinar, por medio de simulaciones, si hay una de estas estrategias que sea mejor que la otra? Semillas A veces queremos generar n\u00fameros (pseudo-)aleatorios de una manera reproducible. Puede sonar contradictorio, pero no lo es: es aqu\u00ed donde se ve claramente la naturalez pseudo aleatoria de estos n\u00fameros. Si fijamos una semilla con el comando random.seed(semilla) , donde semilla es un n\u00famero entero, la secuencia de n\u00fameros aleatorios que obtengamos ser\u00e1 reproducible utilizando la misma semilla. Prob\u00e1 por ejemplo correr dos veces el siguiente c\u00f3digo: import random random.seed(31415) tirada=[] for i in range(5): tirada.append(random.randint(1,6)) print(tirada) Elecciones con reposici\u00f3n A veces queremos elegir al azar un elemento de una lista y no solo un n\u00famero. En el caso que vimos reci\u00e9n de los dados, nuestra lista ser\u00eda [1, 2, 3, 4, 5, 6] pero podr\u00eda ser tambi\u00e9n ['uno', 'dos', 'tres', 'cuatro', 'cinco', 'seis'] . La funci\u00f3n random.choice() toma una secuencia y devuelve un elemento aleatorio. caras = ['uno', 'dos', 'tres', 'cuatro', 'cinco', 'seis'] print(random.choice(caras)) Si queremos realizar m\u00faltiples elecciones aleatorias de la lista podemos usar la funci\u00f3n random.choices() print(random.choices(caras,k=5)) Estos son experimentos con reposici\u00f3n en el sentido de que si en el primer dado sacamos un dos, al tirar el segundo dado podemos sacar otro dos, repitiendo el valor. El t\u00e9rmino reposici\u00f3n viene de pensar en una urna con bolitas. Si un dado lo pensamos como una urna con seis bolitas (etiquetadas del uno al seis), luego de sacar una bolita (tirar el dado una vez) reponemos la bolita que sacamos, de forma que en el siguiente experimento (tirar nuevamente el dado) podamos obtener el mismo valor. Ejercicio 5.3: Cocumplea\u00f1os Haciendo miles de experimentos num\u00e9ricos, estim\u00e1 la probabilidad de que en un grupo de 30 personas elegidas al azar, dos cumplan a\u00f1os el mismo d\u00eda. Escrib\u00ed un programita que permita calcular esa probabilidad asumiendo que el a\u00f1o tiene 365 d\u00edas. Modificando un poco tu programa anterior, \u00bfpod\u00e9s calcular cu\u00e1ntas personas tiene que haber en un grupo para que sea m\u00e1s probable que dos cumplan a\u00f1os el mismo d\u00eda que que todas cumplan en d\u00edas diferentes? Observaci\u00f3n : Les dejamos una nota sobre las Simulaciones de Monte Carlo , por Adri\u00e1n Paenza, que est\u00e1 relacionada con estos temas. Elecciones sin reposici\u00f3n Si queremos modelar un juego con un mazo de naipes, es natural modelarlo sin reposici\u00f3n. Cuando le damos tres cartas a un jugador la segunda carta no puede ser igual a la primera y la tercera ser\u00e1 diferente de las dos anteriores. En un mazo de naipes espa\u00f1oles, cada carta tiene un palo y un valor. El mazo tiene 40 naipes. Los palos son oro, copa, espada y basto y los valores van del 1 al 7 y de del 10 al 12. Usaremos una comprensi\u00f3n doble de listas para generar los naipes (todas las combinaciones posibles de valores y palos). valores = [1, 2, 3, 4, 5, 6, 7, 10, 11, 12] palos = ['oro', 'copa', 'espada', 'basto'] naipes = [(valor,palo) for valor in valores for palo in palos] Ahora podemos usar random.choice(naipes) para seleccionar un naipe. Sin embargo, si us\u00e1ramos random.choices(naipes, k=3) para seleccionar tres naipes para un jugador, podr\u00edamos estar repitiendo el mismo naipe m\u00e1s de una vez, lo que es incorrecto. En este caso tenemos que usar elecciones m\u00faltiples sin reposici\u00f3n . Para eso usamos la funci\u00f3n sample del m\u00f3dulo random : random.sample(naipes,k=3) . A diferencia de choices donde el par\u00e1metro k pod\u00eda tomar cualquier valor, al dar la instrucci\u00f3n random.sample(naipes,k=?) la variable k no puede ser mayor que la cantidad de naipes (es decir 40) ya que no se puede sacar sin reposici\u00f3n m\u00e1s elementos que la cantidad total. Ejercicio 5.4: Envido Teniendo en cuenta las reglas del Truco , estim\u00e1 la probabilidad de obtener 31, 32 o 33 puntos de envido en una mano. \u00bfSon iguales estas tres probabilidades? \u00bfPor qu\u00e9? Observaci\u00f3n: como corresponde, en esta materia jugamos al truco sin flor. Si no conoc\u00e9s las reglas del Truco y no te dan ganas de aprenderlo ahora, simplemente salte\u00e1 este ejercicio. Guard\u00e1 este ejercicio en un archivo envido.py para entregar. Mezclar La \u00faltima funci\u00f3n que queremos introducir es \u00fatil en muchos contextos. En los juegos de naipes, para continuar con nuestro ejemplo, es muy usual mezclar el mazo entero antes de repartir. En Python usamos la funci\u00f3n shuffle del m\u00f3dulo random . valores = [1, 2, 3, 4, 5, 6, 7, 10, 11, 12] palos = ['oro', 'copa', 'espada', 'basto'] naipes = [(valor,palo) for valor in valores for palo in palos] random.shuffle(naipes) print(naipes) Observ\u00e1 que la funci\u00f3n shuffle() modific\u00f3 la lista que le pasamos como par\u00e1metro. Una vez mezclado el mazo, podemos consultar las tres cartas que quedaron al final: naipes[-3:] o directamente sacarlas del mazo: n1 = naipes.pop() n2 = naipes.pop() n3 = naipes.pop() print(f'Repart\u00ed el {n1[0]} de {n1[1]}, el {n2[0]} de {n2[1]} y el {n3[0]} de {n3[1]}. Quedan {len(naipes)} naipes en el mazo.') Valores continuos Adem\u00e1s de generar valores (pseudo)aleatorios discretos, tambi\u00e9n es posible generar valores continuos. La funcion random.random() genera un n\u00famero de punto flotante entre 0 y 1. Ejercicio 5.5: Calcular pi Es interesante ver c\u00f3mo los algoritmos estoc\u00e1sticos (basados en elecciones aleatorias) tambi\u00e9n sirven para resolver problemas que no tienen nada de estoc\u00e1sticos. En este ejercicio vas a usar el generador random() para aproximar pi . Por definici\u00f3n pi es el \u00e1rea del c\u00edrculo de radio uno. Si generamos puntos (x,y) con: def generar_punto(): x = random.random() y = random.random() return x,y tendremos puntos dentro del cuadrado [0, 1]x[0, 1]. Algunos de estos puntos del cuadrado caer\u00e1n dentro del c\u00edrculo unitario (los que cumplan que x^2 + y^2 < 1) y otros puntos caer\u00e1n afuera. La proporci\u00f3n de puntos que caigan dentro del cuarto de c\u00edrculo guardar\u00e1 relaci\u00f3n con la proporci\u00f3n entre el \u00e1rea del cuarto de c\u00edrculo y el \u00e1rea del cuadrado. Obviamente hay una componente aleatoria, pero a medida que la cantidad de puntos crece, la proporci\u00f3n de puntos se acercar\u00e1 a la proporci\u00f3n entre las dos \u00e1reas. Si el \u00e1rea del c\u00edrculo completo es pi, el \u00e1rea de nuestro cuarto de c\u00edrculo es pi/4. Por otro lado el \u00e1rea del cuadrado unitario es 1. Por lo tanto, si generamos N puntos con una distribuci\u00f3n uniforme en el cuadrado unitario, esperamos que pi/4 de estos N puntos caigan dentro del cuarto del c\u00edrculo y el resto afuera. Es decir que, si llamamos M al n\u00famero de puntos que caen dentro del c\u00edrculo, esperamos que M ~(pi/4 * N). Despejando pi de esta estimaci\u00f3n, obtenemos que pi ~ 4*M/N. Esto nos permite estimar pi mirando cu\u00e1ntos puntos caen realmente dentro del c\u00edrculo del total de puntos. Escrib\u00ed un programa estimar_pi.py que genere cien mil puntos aleatorios con la funci\u00f3n generar_punto() , calcule la proporci\u00f3n de estos puntos que caen en el c\u00edrculo unitario (usando \u00bfx^2 + y^2 < 1?) y use este resultado para dar una aproximaci\u00f3n de pi. Ejercicio 5.6: Gaussiana Con random.random() generamos valores aleatorios entre 0 y 1 con una distribuci\u00f3n uniforme . En esa distribuci\u00f3n, todos los valores posibles tienen la misma probabilidad de ser seleccionados. Tambi\u00e9n es posible generar valores aleatorios con otras distribuciones. Una de las distribuciones m\u00e1s importantes es la distribuci\u00f3n normal o Gaussiana . La distribuci\u00f3n normal tiene dos par\u00e1metros, denominados media y desv\u00edo est\u00e1ndar y denotados usualmente con las letras griegas mu y sigma , respectivamente. La funci\u00f3n random.normalvariate(mu,sigma) genera n\u00fameros aleatorios seg\u00fan esta distribuci\u00f3n de probabilidades. Por ejemplo, usando mu = 0 y sigma = 1 podemos generar 6 valores aleatorios as\u00ed: >>> for i in range(6): print(f'{random.normalvariate(0,1):.2f}', end=', ') -0.60, 0.06, -1.33, -0.62, -0.81, 0.63, La distribuci\u00f3n normal tiene muchos usos. Uno de ellos es modelar errores experimentales, es decir la diferencia entre el valor medido de una magnitud f\u00edsica y el valor real de dicha magnitud. Hagamos alg\u00fan ejercicio sencillo antes de terminar. Supongamos que una persona se compra un term\u00f3metro que mide la temperatura con un error aleatorio normal con media 0 y desv\u00edo est\u00e1ndar de 0.2 grados (error gaussiano). Si la temperatura real de la persona es de 37.5 grados, simul\u00e1 usando normalvariate() (con mu y sigma adecuados) n = 99 valores medidos por el term\u00f3metro. Imprim\u00ed los valores obtenidos en las mediciones de temperatura simuladas y luego, como resumen, cuatro l\u00edneas indicando el valor m\u00e1ximo, el m\u00ednimo, el promedio y la mediana de estas n mediciones. Guard\u00e1 tu programa en el archivo termometro.py . Para encontrar el m\u00e1ximo y m\u00ednimo pod\u00e9s usar y agrandar tu c\u00f3digo de busqueda_en_listas.py o usar las primitivas max() y min() de Python. El promedio es la suma de los valores dividido su cantidad; pod\u00e9s programarla desde cero o usar la primitiva sum() y un cociente por n. Finalmente, la mediana de una cantidad impar de valores es el valor en la posici\u00f3n central cuando los datos est\u00e1n ordenados. Ac\u00e1 pod\u00e9s usar el m\u00e9todo sort() de listas. Y ya que estamos, \u00bfse te ocurre c\u00f3mo encontrar los cuartiles ? Contenidos | Pr\u00f3ximo (2 NumPy)","title":"01 Random"},{"location":"05_Random_Plt_Dbg/01_Random/#51-random","text":"En esta secci\u00f3n veremos algunas de las funciones del m\u00f3dulo random . Este m\u00f3dulo se usa para generar valores pseudo-aleatorios. Desde el punto de vista pr\u00e1ctico, usaremos estos valores como perfectamente aleatorios --al ser la computadora una m\u00e1quina determin\u00edstica sabemos que esto no es completamente cierto. De hecho, en lo que sigue, por simplicidad, omitiremos el prefijo pseudo y hablaremos de n\u00fameros aleatorios aunque no lo sean exactamente.","title":"5.1 Random"},{"location":"05_Random_Plt_Dbg/01_Random/#valores-discretos","text":"Podemos generar n\u00fameros enteros aleatorios entre dos extremos. Por ejemplo, para simular la tirada de un dado podemos generar un n\u00famero entre 1 y 6. import random dado = random.randint(1,6) # devuelve un entero aleatorio entre 1 y 6 Si queremos simular una primera tirada del juego la generala tendremos que generar cinco valores al azar: import random tirada=[] for i in range(5): tirada.append(random.randint(1,6)) print(tirada)","title":"Valores discretos"},{"location":"05_Random_Plt_Dbg/01_Random/#ejercicios","text":"","title":"Ejercicios:"},{"location":"05_Random_Plt_Dbg/01_Random/#ejercicio-51-generala-servida","text":"Queremos estimar la probabilidad de obtener una generala servida (cinco dados iguales) en una tirada de dados. Podemos hacer la cuenta usando un poco de teor\u00eda de probabilidades, o podemos simular que tiramos los dados muchas veces y ver cu\u00e1ntas de esas veces obtuvimos cinco dados iguales. En este ejercicio vamos a usar el segundo camino. Escrib\u00ed una funci\u00f3n tirar() que devuelva una lista con cinco dados generados aleatoriamente. Escrib\u00ed otra funci\u00f3n llamada es_generala(tirada) que devuelve True si y s\u00f3lo si los cinco dados de la lista tirada son iguales. Luego analiz\u00e1 el siguiente c\u00f3digo. Correlo con N = 100000 varias veces y observ\u00e1 los valores que obten\u00e9s. Luego correlo algunas veces con N = 1000000 (ojo, hace un mill\u00f3n de experimentos, podr\u00eda tardar un poco): G = sum([es_generala(tirar()) for i in range(N)]) prob = G/N print(f'Tir\u00e9 {N} veces, de las cuales {G} saqu\u00e9 generala servida.') print(f'Podemos estimar la probabilidad de sacar generala servida mediante {prob:.6f}.') \u00bfPor qu\u00e9 var\u00edan m\u00e1s los resultados obtenidos con N = 100000 que con N = 1000000 ? \u00bfCada cu\u00e1ntas tiradas en promedio podr\u00edas decir que sale una generala servida? \u00bfC\u00f3mo se puede calcular la probabilidad de forma exacta?","title":"Ejercicio 5.1: Generala servida"},{"location":"05_Random_Plt_Dbg/01_Random/#ejercicio-52-generala-no-necesariamente-servida","text":"Si uno juega con las reglas originales (se puede volver a tirar algunos de los cinco dados hasta dos veces, llegando hasta a tres tiradas en total) siguiendo una estrategia que intente obtener generala (siempre guardar los dados que m\u00e1s se repiten y tirar nuevamente los dem\u00e1s) es m\u00e1s probable obtener una generala que si s\u00f3lo consideramos la generala servida. Escrib\u00ed un programa que estime la probabilidad de obtener una generala en las tres tiradas de una mano y guardalo en un archivo generala.py . Extra: Hay gente que, si en la primera tirada le salen todos dados diferentes, los mete al cubilete y tira los cinco nuevamente. Otras personas, eligen uno de esos dados diferentes, lo guardan, y tiran s\u00f3lo los cuatro restantes. \u00bfPod\u00e9s determinar, por medio de simulaciones, si hay una de estas estrategias que sea mejor que la otra?","title":"Ejercicio 5.2: Generala no necesariamente servida"},{"location":"05_Random_Plt_Dbg/01_Random/#semillas","text":"A veces queremos generar n\u00fameros (pseudo-)aleatorios de una manera reproducible. Puede sonar contradictorio, pero no lo es: es aqu\u00ed donde se ve claramente la naturalez pseudo aleatoria de estos n\u00fameros. Si fijamos una semilla con el comando random.seed(semilla) , donde semilla es un n\u00famero entero, la secuencia de n\u00fameros aleatorios que obtengamos ser\u00e1 reproducible utilizando la misma semilla. Prob\u00e1 por ejemplo correr dos veces el siguiente c\u00f3digo: import random random.seed(31415) tirada=[] for i in range(5): tirada.append(random.randint(1,6)) print(tirada)","title":"Semillas"},{"location":"05_Random_Plt_Dbg/01_Random/#elecciones-con-reposicion","text":"A veces queremos elegir al azar un elemento de una lista y no solo un n\u00famero. En el caso que vimos reci\u00e9n de los dados, nuestra lista ser\u00eda [1, 2, 3, 4, 5, 6] pero podr\u00eda ser tambi\u00e9n ['uno', 'dos', 'tres', 'cuatro', 'cinco', 'seis'] . La funci\u00f3n random.choice() toma una secuencia y devuelve un elemento aleatorio. caras = ['uno', 'dos', 'tres', 'cuatro', 'cinco', 'seis'] print(random.choice(caras)) Si queremos realizar m\u00faltiples elecciones aleatorias de la lista podemos usar la funci\u00f3n random.choices() print(random.choices(caras,k=5)) Estos son experimentos con reposici\u00f3n en el sentido de que si en el primer dado sacamos un dos, al tirar el segundo dado podemos sacar otro dos, repitiendo el valor. El t\u00e9rmino reposici\u00f3n viene de pensar en una urna con bolitas. Si un dado lo pensamos como una urna con seis bolitas (etiquetadas del uno al seis), luego de sacar una bolita (tirar el dado una vez) reponemos la bolita que sacamos, de forma que en el siguiente experimento (tirar nuevamente el dado) podamos obtener el mismo valor.","title":"Elecciones con reposici\u00f3n"},{"location":"05_Random_Plt_Dbg/01_Random/#ejercicio-53-cocumpleanos","text":"Haciendo miles de experimentos num\u00e9ricos, estim\u00e1 la probabilidad de que en un grupo de 30 personas elegidas al azar, dos cumplan a\u00f1os el mismo d\u00eda. Escrib\u00ed un programita que permita calcular esa probabilidad asumiendo que el a\u00f1o tiene 365 d\u00edas. Modificando un poco tu programa anterior, \u00bfpod\u00e9s calcular cu\u00e1ntas personas tiene que haber en un grupo para que sea m\u00e1s probable que dos cumplan a\u00f1os el mismo d\u00eda que que todas cumplan en d\u00edas diferentes? Observaci\u00f3n : Les dejamos una nota sobre las Simulaciones de Monte Carlo , por Adri\u00e1n Paenza, que est\u00e1 relacionada con estos temas.","title":"Ejercicio 5.3: Cocumplea\u00f1os"},{"location":"05_Random_Plt_Dbg/01_Random/#elecciones-sin-reposicion","text":"Si queremos modelar un juego con un mazo de naipes, es natural modelarlo sin reposici\u00f3n. Cuando le damos tres cartas a un jugador la segunda carta no puede ser igual a la primera y la tercera ser\u00e1 diferente de las dos anteriores. En un mazo de naipes espa\u00f1oles, cada carta tiene un palo y un valor. El mazo tiene 40 naipes. Los palos son oro, copa, espada y basto y los valores van del 1 al 7 y de del 10 al 12. Usaremos una comprensi\u00f3n doble de listas para generar los naipes (todas las combinaciones posibles de valores y palos). valores = [1, 2, 3, 4, 5, 6, 7, 10, 11, 12] palos = ['oro', 'copa', 'espada', 'basto'] naipes = [(valor,palo) for valor in valores for palo in palos] Ahora podemos usar random.choice(naipes) para seleccionar un naipe. Sin embargo, si us\u00e1ramos random.choices(naipes, k=3) para seleccionar tres naipes para un jugador, podr\u00edamos estar repitiendo el mismo naipe m\u00e1s de una vez, lo que es incorrecto. En este caso tenemos que usar elecciones m\u00faltiples sin reposici\u00f3n . Para eso usamos la funci\u00f3n sample del m\u00f3dulo random : random.sample(naipes,k=3) . A diferencia de choices donde el par\u00e1metro k pod\u00eda tomar cualquier valor, al dar la instrucci\u00f3n random.sample(naipes,k=?) la variable k no puede ser mayor que la cantidad de naipes (es decir 40) ya que no se puede sacar sin reposici\u00f3n m\u00e1s elementos que la cantidad total.","title":"Elecciones sin reposici\u00f3n"},{"location":"05_Random_Plt_Dbg/01_Random/#ejercicio-54-envido","text":"Teniendo en cuenta las reglas del Truco , estim\u00e1 la probabilidad de obtener 31, 32 o 33 puntos de envido en una mano. \u00bfSon iguales estas tres probabilidades? \u00bfPor qu\u00e9? Observaci\u00f3n: como corresponde, en esta materia jugamos al truco sin flor. Si no conoc\u00e9s las reglas del Truco y no te dan ganas de aprenderlo ahora, simplemente salte\u00e1 este ejercicio. Guard\u00e1 este ejercicio en un archivo envido.py para entregar.","title":"Ejercicio 5.4: Envido"},{"location":"05_Random_Plt_Dbg/01_Random/#mezclar","text":"La \u00faltima funci\u00f3n que queremos introducir es \u00fatil en muchos contextos. En los juegos de naipes, para continuar con nuestro ejemplo, es muy usual mezclar el mazo entero antes de repartir. En Python usamos la funci\u00f3n shuffle del m\u00f3dulo random . valores = [1, 2, 3, 4, 5, 6, 7, 10, 11, 12] palos = ['oro', 'copa', 'espada', 'basto'] naipes = [(valor,palo) for valor in valores for palo in palos] random.shuffle(naipes) print(naipes) Observ\u00e1 que la funci\u00f3n shuffle() modific\u00f3 la lista que le pasamos como par\u00e1metro. Una vez mezclado el mazo, podemos consultar las tres cartas que quedaron al final: naipes[-3:] o directamente sacarlas del mazo: n1 = naipes.pop() n2 = naipes.pop() n3 = naipes.pop() print(f'Repart\u00ed el {n1[0]} de {n1[1]}, el {n2[0]} de {n2[1]} y el {n3[0]} de {n3[1]}. Quedan {len(naipes)} naipes en el mazo.')","title":"Mezclar"},{"location":"05_Random_Plt_Dbg/01_Random/#valores-continuos","text":"Adem\u00e1s de generar valores (pseudo)aleatorios discretos, tambi\u00e9n es posible generar valores continuos. La funcion random.random() genera un n\u00famero de punto flotante entre 0 y 1.","title":"Valores continuos"},{"location":"05_Random_Plt_Dbg/01_Random/#ejercicio-55-calcular-pi","text":"Es interesante ver c\u00f3mo los algoritmos estoc\u00e1sticos (basados en elecciones aleatorias) tambi\u00e9n sirven para resolver problemas que no tienen nada de estoc\u00e1sticos. En este ejercicio vas a usar el generador random() para aproximar pi . Por definici\u00f3n pi es el \u00e1rea del c\u00edrculo de radio uno. Si generamos puntos (x,y) con: def generar_punto(): x = random.random() y = random.random() return x,y tendremos puntos dentro del cuadrado [0, 1]x[0, 1]. Algunos de estos puntos del cuadrado caer\u00e1n dentro del c\u00edrculo unitario (los que cumplan que x^2 + y^2 < 1) y otros puntos caer\u00e1n afuera. La proporci\u00f3n de puntos que caigan dentro del cuarto de c\u00edrculo guardar\u00e1 relaci\u00f3n con la proporci\u00f3n entre el \u00e1rea del cuarto de c\u00edrculo y el \u00e1rea del cuadrado. Obviamente hay una componente aleatoria, pero a medida que la cantidad de puntos crece, la proporci\u00f3n de puntos se acercar\u00e1 a la proporci\u00f3n entre las dos \u00e1reas. Si el \u00e1rea del c\u00edrculo completo es pi, el \u00e1rea de nuestro cuarto de c\u00edrculo es pi/4. Por otro lado el \u00e1rea del cuadrado unitario es 1. Por lo tanto, si generamos N puntos con una distribuci\u00f3n uniforme en el cuadrado unitario, esperamos que pi/4 de estos N puntos caigan dentro del cuarto del c\u00edrculo y el resto afuera. Es decir que, si llamamos M al n\u00famero de puntos que caen dentro del c\u00edrculo, esperamos que M ~(pi/4 * N). Despejando pi de esta estimaci\u00f3n, obtenemos que pi ~ 4*M/N. Esto nos permite estimar pi mirando cu\u00e1ntos puntos caen realmente dentro del c\u00edrculo del total de puntos. Escrib\u00ed un programa estimar_pi.py que genere cien mil puntos aleatorios con la funci\u00f3n generar_punto() , calcule la proporci\u00f3n de estos puntos que caen en el c\u00edrculo unitario (usando \u00bfx^2 + y^2 < 1?) y use este resultado para dar una aproximaci\u00f3n de pi.","title":"Ejercicio 5.5: Calcular pi"},{"location":"05_Random_Plt_Dbg/01_Random/#ejercicio-56-gaussiana","text":"Con random.random() generamos valores aleatorios entre 0 y 1 con una distribuci\u00f3n uniforme . En esa distribuci\u00f3n, todos los valores posibles tienen la misma probabilidad de ser seleccionados. Tambi\u00e9n es posible generar valores aleatorios con otras distribuciones. Una de las distribuciones m\u00e1s importantes es la distribuci\u00f3n normal o Gaussiana . La distribuci\u00f3n normal tiene dos par\u00e1metros, denominados media y desv\u00edo est\u00e1ndar y denotados usualmente con las letras griegas mu y sigma , respectivamente. La funci\u00f3n random.normalvariate(mu,sigma) genera n\u00fameros aleatorios seg\u00fan esta distribuci\u00f3n de probabilidades. Por ejemplo, usando mu = 0 y sigma = 1 podemos generar 6 valores aleatorios as\u00ed: >>> for i in range(6): print(f'{random.normalvariate(0,1):.2f}', end=', ') -0.60, 0.06, -1.33, -0.62, -0.81, 0.63, La distribuci\u00f3n normal tiene muchos usos. Uno de ellos es modelar errores experimentales, es decir la diferencia entre el valor medido de una magnitud f\u00edsica y el valor real de dicha magnitud. Hagamos alg\u00fan ejercicio sencillo antes de terminar. Supongamos que una persona se compra un term\u00f3metro que mide la temperatura con un error aleatorio normal con media 0 y desv\u00edo est\u00e1ndar de 0.2 grados (error gaussiano). Si la temperatura real de la persona es de 37.5 grados, simul\u00e1 usando normalvariate() (con mu y sigma adecuados) n = 99 valores medidos por el term\u00f3metro. Imprim\u00ed los valores obtenidos en las mediciones de temperatura simuladas y luego, como resumen, cuatro l\u00edneas indicando el valor m\u00e1ximo, el m\u00ednimo, el promedio y la mediana de estas n mediciones. Guard\u00e1 tu programa en el archivo termometro.py . Para encontrar el m\u00e1ximo y m\u00ednimo pod\u00e9s usar y agrandar tu c\u00f3digo de busqueda_en_listas.py o usar las primitivas max() y min() de Python. El promedio es la suma de los valores dividido su cantidad; pod\u00e9s programarla desde cero o usar la primitiva sum() y un cociente por n. Finalmente, la mediana de una cantidad impar de valores es el valor en la posici\u00f3n central cuando los datos est\u00e1n ordenados. Ac\u00e1 pod\u00e9s usar el m\u00e9todo sort() de listas. Y ya que estamos, \u00bfse te ocurre c\u00f3mo encontrar los cuartiles ? Contenidos | Pr\u00f3ximo (2 NumPy)","title":"Ejercicio 5.6: Gaussiana"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/","text":"Contenidos | Anterior (1 Random) | Pr\u00f3ximo (3 El album de Figuritas) 5.2 NumPy Esta es una introducci\u00f3n a la biblioteca NumPy ( Numerical Python ) de Python. Se trata de una colecci\u00f3n de m\u00f3dulos de c\u00f3digo abierto que tiene aplicaciones en casi todos los campos de las ciencias y de la ingenier\u00eda. Es el est\u00e1ndar para trabajar con datos num\u00e9ricos en Python. Muchas otras bibliotecas y m\u00f3dulos de Python como Pandas, SciPy, Matplotlib, scikit-learn, scikit-image usan numpy. Esta biblioteca permite trabajar c\u00f3modamente con matrices multidimensionales por medio del tipo ndarray , un objeto n-dimensional homog\u00e9neo (es decir, con todas sus entradas del mismo tipo), y con m\u00e9todos para operar eficientemente sobre \u00e9l. numpy puede usarse para una amplia variedad de operaciones matem\u00e1ticas sobre matrices. Le agrega a Python estructuras de datos muy potentes sobre las que pued\u00e9s hacer c\u00e1lculos y operar matem\u00e1ticamente con eficiencia y a un alto nivel. Instalar e importar numpy Cuando quieras usar numpy en Python, primero ten\u00e9s que importarlo: import numpy as np Acortamos numpy a np para ahorrar tiempo y mantener el c\u00f3digo estandarizado. Todes escriben np . Si no lo ten\u00e9s instalado (te dar\u00e1 un error al importarlo) pod\u00e9s instalarlo escribiendo alguno de los siguientes comandos, seg\u00fan corresponda: conda install numpy pip install numpy pip3 install numpy \u00bfCu\u00e1l es la diferencia entre listas y arreglos? numpy ofrece varias formas muy eficientes de crear vectores y manipular datos num\u00e9ricos. Mientras que una lista de Python puede contener diferentes tipos de datos en su interior, los elementos de un vector numpy ser\u00e1n todos del mismo tipo. De esta forma numpy garantiza un muy alto rendimiento en las operaicones matem\u00e1ticas. Adem\u00e1s, los arreglos est\u00e1n pensados para tener un tama\u00f1o fijo, mientras que las listas est\u00e1n dise\u00f1adas para agregar y sacar elementos. Son estructuras de datos similares desde un punto de vista superficial, pero muy diferentes en cuanto a las posibilidades que brindan. Las operaciones matem\u00e1ticas sobre vectores de numpy son m\u00e1s r\u00e1pidas que sobre listas. Adem\u00e1s los vectores ocupan menos memoria que las listas an\u00e1logas. En cambio, modificar el tama\u00f1o de una lista es algo muy sencillo mientras que el de un vector es costoso. Y combinar diferentes tipos de datos es sencillo en las listas pero imposible en los vectores de numpy. Arreglos n-dimensionales Los vectores (unidimensionales) y matrices (bidimensiones) se generalizan a arreglos n-dimensionales. Esta estructura de datos es la central de la biblioteca numpy. Un arreglo ( ndarray ) tiene una grilla de valores (datos crudos) junto con informaci\u00f3n sobre c\u00f3mo ubicarlos y c\u00f3mo interpretarlos. Los elementos de esta grilla pueden ser indexados de diversas maneras y, como ya dijimos, son todos del mismo tipo. Este tipo es frecuentemente abreviado como dtype (por data type). Un arreglo puede ser indexado por tuplas de enteros no negativos, por variables booleanas, por otro arreglo o por enteros. El rango ( rank ) de un arreglo es su n\u00famero de dimensiones. Su forma ( shape ) es una tupla de enteros que dice su tama\u00f1o en cada dimensi\u00f3n. Una forma de inicializar un arreglo de numpy es mediante una lista de n\u00fameros. Esto nos da un vector (arreglo de dimensi\u00f3n uno). Usando listas anidadas, podemos definir arreglos de m\u00e1s altas dimensiones. Por ejemplo: >>> a = np.array([1, 2, 3, 4, 5, 6]) o: >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) Podemos acceder a los elementos de un arreglo usando corchetes. Acordate que los \u00edndices comienzan a contar en 0. Esto significa que si quer\u00e9s acceder al primer elemento, vas a acceder al elemento \u201c0\u201d. >>> print(a[0]) # si tiene m\u00faltiples dimensiones, esto me da una \"rebanada\" de una dimensi\u00f3n menos [1 2 3 4] >>> print(a[2]) # otra rebanada [ 9, 10, 11, 12] >>> print(a[2][3]) # accedo al cuarto elemento del tercer vector de a 12 >>> print(a[2,3]) # o, equivalentemente, accedo al elemento en la tercera fila y cuarta columna de a 12 M\u00e1s informaci\u00f3n sobre arreglos Ocasionalmente vas a ver que alguien se refiere a un arreglo como un \u201cndarray\u201d que es una forma breve de decir arreglo n-dimensional. Un arreglo n-dimensional es simplemente un arreglo con n dimensiones. Recordemos que cuando son unidimensionales los llamamos vectores y si son bidimensionales los llamamos matrices. \u00bfQu\u00e9 atributos tiene un arreglo? Un arreglo es usualmente un contenedor de tama\u00f1o fijo de elementos del mismo tipo. Su forma (shape) es una tupla de enteros no negativos que especifica el tama\u00f1o del arreglo en cada dimensi\u00f3n. Un arreglo tiene tantas dimensiones como coordenadas en la tupla. En numpy, las dimensiones se llaman axes (ejes). Esto significa que si ten\u00e9s un arreglo bidimensional que se ve as\u00ed: [[0., 0., 0.], [1., 1., 1.]] el arreglo tendr\u00e1 dos ejes. El primer eje tiene tama\u00f1o dos, el segundo tama\u00f1o tres (s\u00ed, se cuentan primero filas, luego columnas). De la misma forma que los otros objetos contenedores de Python, los elementos de un arreglo pueden ser accedidos y modificados usando \u00edndices y rebanadas. Crear un arreglo b\u00e1sico Para crear un arreglo de numpy pod\u00e9s usar la funci\u00f3n np.array() . Lo \u00fanico que necesit\u00e1s es pasarle una lista. Si quer\u00e9s, pod\u00e9s especificar el tipo de datos que quer\u00e9s que tenga. >>> import numpy as np >>> a = np.array([1, 2, 3]) Vamos a representar la creaci\u00f3n con este gr\u00e1fico: Ojo, estas visualizaciones son simplificaciones para representar lo que esta pasando y darte un entendimiento b\u00e1sico de los conceptos y mecanismos de numpy. Los arreglos y sus operaciones tienen aspectos m\u00e1s complejos que los que quedan capturados en estos dibujitos. Adem\u00e1s de crear un arreglo a partir de una secuencia de elementos, pod\u00e9s crear un arreglo lleno de 0 \u2019s: >>> np.zeros(2) array([0., 0.]) O uno lleno de 1 \u2019s: >>> np.ones(2) array([1., 1.]) \u00a1O incluso uno no inicializado! La funci\u00f3n empty crea un arreglo cuyo contenido inicial depende del estado de la memoria. Lo bueno de usar empty en lugar de zeros (o ones ) es la velocidad - al no inicilizar los valores no perdemos tiempo. \u00a1Pero asegurate de ponerle valores con sentido luego! >>> # Crea un arreglo con dos elementos >>> np.empty(2) array([ 3.14, 42. ]) # puede variar Tambi\u00e9n pod\u00e9s crear vectores a partir de un rango de valores: >>> np.arange(4) array([0, 1, 2, 3]) Tambi\u00e9n un vector que contiene elementos equiespaciados, especificando el primer n\u00famero , el l\u00edmite , y el paso . >>> np.arange(2, 9, 2) # o np.arange(2, 10, 2) array([2, 4, 6, 8]) El l\u00edmite derecho nunca est\u00e1 en la lista. Tambi\u00e9n pod\u00e9s usar np.linspace() para crear un vector de valores equiespaciados especificando el primer n\u00famero , el \u00faltimo n\u00famero , y la cantidad de elementos: >>> np.linspace(0, 10, num=5) array([ 0. , 2.5, 5. , 7.5, 10. ]) Ejercicio 5.7: arange() y linspace() Gener\u00e1 un vector que tenga los n\u00fameros impares entre el 1 y el 19 inclusive usando arange() . Repet\u00ed el ejercicio usando linspace() . \u00bfQu\u00e9 diferencia hay en el resultado? Especificar el tipo de datos Si no lo especific\u00e1s, el tipo de datos (por omisi\u00f3n) de los arreglos es el punto flotante ( np.float64 ). Sin embargo, pod\u00e9s explicitar otro tipo de datos usando la palabra clave dtype . >>> x = np.ones(2, dtype=np.int64) >>> x array([1, 1]) En estos dos casos el 64 de los tipos de datos se refiere a la cantidad de bits usados para representar el n\u00famero en el sistema binario: 64 bits. Agregar, borrar y ordenar elementos Ordenar un vector es sencillo usando np.sort() . Por ejemplo, si comenz\u00e1s con este vector: >>> arr = np.array([2, 1, 5, 3, 7, 4, 6, 8]) Pod\u00e9s ordenar sus elementos con: >>> np.sort(arr) array([1, 2, 3, 4, 5, 6, 7, 8]) Fijate que el vector arr qued\u00f3 desordenado. sort simplemente devolvi\u00f3 una copia ordenada de los datos pero no modific\u00f3 el original. Otra operaci\u00f3n usual es la concatenaci\u00f3n. Si empez\u00e1s con estos dos vectores: >>> a = np.array([1, 2, 3, 4]) >>> b = np.array([5, 6, 7, 8]) los pod\u00e9s concatenar usado np.concatenate() . >>> np.concatenate((a, b)) array([1, 2, 3, 4, 5, 6, 7, 8]) Un ejemplo un poco m\u00e1s complejo es el siguiente: >>> x = np.array([[1, 2], [3, 4]]) >>> y = np.array([[5, 6]]) Los pod\u00e9s concatenar usando: >>> np.concatenate((x, y), axis=0) array([[1, 2], [3, 4], [5, 6]]) Conocer el tama\u00f1o, dimensiones y forma de un arreglo ndarray.ndim te dice la cantidad de ejes (o dimensiones) del arreglo. ndarray.shape te va a dar una tupla de enteros que indican la cantidad de elementos en cada eje. Si ten\u00e9s una matriz con 2 filas y 3 columnas de va a dar (2, 3) . ndarray.size te dice la cantidad de elementos (cantidad de n\u00fameros) de tu arreglo. Es el producto de la tupla shape . En el ejemplo del rengl\u00f3n anterior, el size es 6. Por ejemplo, si cre\u00e1s este arreglo de tres dimensiones: >>> array_ejemplo = np.array([[[0, 1, 2, 3], ... [4, 5, 6, 7]], ... ... [[0, 1, 2, 3], ... [4, 5, 6, 7]], ... ... [[0 ,1 ,2, 3], ... [4, 5, 6, 7]]]) Vas a tener >>> array_ejemplo.ndim # cantidad de dimensiones 3 >>> array_ejemplo.shape # cantidad de elementos en cada eje (3, 2, 4) >>> array_ejemplo.size # total de elementos 3*2*4 24 Cambiar la forma de un arreglo Usando arr.reshape() le pod\u00e9s dar una nueva forma a tu arreglo sin cambiar los datos. Solo ten\u00e9 en cuenta que antes y despu\u00e9s del reshape el arreglo tiene que tener la misma cantidad de elementos. Por ejemplo, si comenz\u00e1s con un arreglo con 12 elementos, tendr\u00e1s que asegurarte que el nuevo arreglo siga teniendo 12 elementos. Por ejemplo: >>> a = np.arange(6) >>> print(a) [0 1 2 3 4 5] Pod\u00e9s usar reshape() para cambiarle la forma y que en lugar de ser un vector de 6 elementos, sea una matriz de 3 filas y dos columnas: >>> b = a.reshape(3, 2) >>> print(b) [[0 1] [2 3] [4 5]] Agregar un nuevo eje a un arreglo A veces pasa que tenemos un vector con n elementos y necesitamos pensarlo como una matriz de una fila y n columnas o de n filas y una columna. Pod\u00e9s usar np.newaxis para agregarle dimensiones a un vector existente. Usando np.newaxis una vez pod\u00e9s incrementar la dimensi\u00f3n de tu arreglo en uno. Por ejemplo pod\u00e9s pasar de un vector a una matriz o de una matriz a un arreglo tridimensional, etc. Por ejemplo, si comenz\u00e1s con este vector: >>> a = np.array([1, 2, 3, 4, 5, 6]) >>> a.shape (6,) Pod\u00e9s usar np.newaxis para agregarle una dimensi\u00f3n y convertirlo en un vector fila: >>> vec_fila = a[np.newaxis, :] >>> vec_fila.shape (1, 6) O, para convertirlo en un vector columna, pod\u00e9s unsertar un eje en la segunda dimensi\u00f3n: >>> vec_col = a[:, np.newaxis] >>> vec_col.shape (6, 1) \u00cdndices y rebanadas Pod\u00e9s indexar y rebanar arreglos de numpy como hicimos con las listas. Para obtener elementos de un arreglo, lo m\u00e1s sencillo es usar los \u00edndices para seleccionar los que queremos conservar. >>> data = np.array([1, 2, 3]) >>> data[1] 2 >>> data[0:2] array([1, 2]) >>> data[1:] array([2, 3]) >>> data[-2:] array([2, 3]) Lo pod\u00e9s visualizar as\u00ed: Otra operaci\u00f3n muy \u00fatil es seleccionar los elementos que cumplen cierta condici\u00f3n. Por ejemplo, si comenz\u00e1s con un arreglo as\u00ed: >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) Pod\u00e9s imprimir todos los valores menores que cinco. >>> print(a[a < 5]) [1 2 3 4] Tambi\u00e9n pod\u00e9s seleccionar, por ejemplo, aquellos elementos mayores o iguales que 5 y usar el resultado para indexar el arreglo. >>> five_up = (a >= 5) >>> print(a[five_up]) [ 5 6 7 8 9 10 11 12] Es interesante que five_up da un arreglo de valores booleanos. True si satisface la condici\u00f3n y False si no la satisface. Pod\u00e9s seleccionar los elementos pares: >>> pares = a[a%2==0] >>> print(pares) [ 2 4 6 8 10 12] Usando los operadores l\u00f3gicos & y | pod\u00e9s combinar dos o m\u00e1s condiciones. Ya sea para seleccionar elementos directamente: >>> c = a[(a > 2) & (a < 11)] >>> print(c) [ 3 4 5 6 7 8 9 10] o para definir una nueva variable booleana: >>> five_up = (a > 5) | (a == 5) >>> print(five_up) [[False False False False] [ True True True True] [ True True True True]] Finalmente, pod\u00e9s usar np.nonzero() para obtener las coordenadas de ciertos elementos de un arreglo. Si empezamos con este arreglo: >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) Pod\u00e9s usar np.nonzero() para imprimir los \u00edndices de los elementos que son, digamos, menores que 5: >>> b = np.nonzero(a < 5) >>> print(b) (array([0, 0, 0, 0]), array([0, 1, 2, 3])) En este ejemplo, la respuesta es una tupla de arreglos: uno por cada dimensi\u00f3n. El primer arreglo representa las filas de los elementos que satisfacen la condici\u00f3n y el segundo sus columnas. Si quer\u00e9s generar la lista de coordenadas donde se encuentran estos elementos, pod\u00e9s zipear los arreglos, convertir el resultado en una lista e imprimirla: >>> lista_de_coordenadas = list(zip(b[0], b[1])) Surge naturalmente la pregunta: \u00bfporqu\u00e9 tengo que convertir el objeto zip a una lista? Veremos en la segunda mitad de la materia m\u00e1s detalles sobre generadores en Python para entender exactamente lo que est\u00e1 pasando aqu\u00ed. Simplemente digamos que al zipear b[0] y b[1] no se genera la lista realmente, sino potencialmente. S\u00f3lo al solicitar sus elementos (iterando sobre ello o con list ) se generan realmente las coordenadas. >>> for coord in lista_de_coordenadas: ... print(coord) (0, 0) (0, 1) (0, 2) (0, 3) Pod\u00e9s usar np.nonzero() para imprimir o seleccionar los elementos del arreglo que son menores que 5: >>> print(a[b]) [1 2 3 4] Si la condici\u00f3n que pon\u00e9s no la satisface ning\u00fan elemento del arreglo entonces el arreglo de \u00edndices que obten\u00e9s con np.nonzero() ser\u00e1 vac\u00edo. Por ejemplo: >>> no_hay = np.nonzero(a == 42) >>> print(no_hay) (array([], dtype=int64), array([], dtype=int64)) Crear arreglos usando datos existentes Es sencillo crear un nuevo arreglo usando una secci\u00f3n de otro arreglo. Suponete que ten\u00e9s este: >>> a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) Pod\u00e9s crear otro arreglo a partir de una secci\u00f3n de a , simplemente especificando qu\u00e9 parte quer\u00e9s. >>> arr1 = a[3:8] >>> arr1 array([4, 5, 6, 7, 8]) Es importante saber que este m\u00e9todo genera una vista del arreglo original y no una verdadera copia. Si modific\u00e1s un elemento de la vista, \u00a1tambi\u00e9n se modificar\u00e1 en el original! >>> arr1[0] = 44 >>> print(a) [ 1 2 3 44 5 6 7 8 9 10] El concepto de vista es importante para entender lo que est\u00e1 pasando. Las operaciones m\u00e1s frecuentes devuelven vistas y no copias. Esto ahorra memoria y es m\u00e1s veloz, pero si no lo sab\u00e9s puede traerte problemas. Veamos este ejemplo: >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) Ahora creamos b1 a partir de una rebanada de a y modificamos su primer elemento. \u00a1Esto va a modificar el elemento correspondiente de a tambi\u00e9n! >>> b1 = a[0, :] >>> b1 array([1, 2, 3, 4]) >>> b1[0] = 99 >>> b1 array([99, 2, 3, 4]) >>> a array([[99, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12]]) Pod\u00e9s usar el m\u00e9todo copy para copiar los datos. Por ejemplo: >>> b2 = a[1, :].copy() >>> b2 array([5, 6, 7, 8]) >>> b2[0] = 95 >>> b2 array([95, 6, 7, 8]) >>> a # \u00a1no se modifica el 5! array([[99, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12]]) Operaciones b\u00e1sicas sobre arreglos Una vez que sab\u00e9s crear arreglos pod\u00e9s empezar a trabajar con ellos. Imaginemos que ten\u00e9s dos arreglos, uno llamados \u201cdata\u201d y otro llamado \u201cones\u201d. Pod\u00e9s sumarlos con el signo m\u00e1s. >>> data = np.array([1, 2]) >>> ones = np.ones(2, dtype=int) >>> data + ones array([2, 3]) Obviamente, pod\u00e9s hacer otras operaciones. >>> data - ones array([0, 1]) >>> data * data array([1, 4]) >>> data / data array([1., 1.]) Estas operaciones b\u00e1sicas son simples con numpy. Si quer\u00e9s calcular la suma de los elementos del arreglo, pod\u00e9s usar sum() . Esto funciona para vectores, matrices y arreglos de dimensi\u00f3n m\u00e1s alta tambi\u00e9n. >>> a = np.array([1, 2, 3, 4]) >>> a.sum() 10 Para sumar los valores por fila o por columna en una matriz, simplemente ten\u00e9s que especificar el eje sobre el que se har\u00e1 la suma. Si ten\u00e9s la matriz: >>> b = np.array([[1, 1], [2, 2]]) pod\u00e9s sumar los datos de cada columna con: >>> b.sum(axis=0) array([3, 3]) y los datos de cada fila usando: >>> b.sum(axis=1) array([2, 4]) Broadcasting Hay veces en que necesit\u00e1s realizar una operaci\u00f3n entre un arreglo y un n\u00famero (en matem\u00e1tica le decimos, un escalar ). Por ejemplo ten\u00e9s un vector con distancias en millas (lo llamamos \"data\") y lo necesit\u00e1s convertir a distancias en kil\u00f3metros. Pod\u00e9s hacer esta operaci\u00f3n as\u00ed: >>> data = np.array([1.0, 2.0]) >>> data * 1.6 array([1.6, 3.2]) numpy entiende que la multiplicaci\u00f3n debe ocurrir en cada celda del vector. Este concepto se llama broadcasting . El mecanismo de broadcasting le permite a numpy realizar operaciones en arreglos de diferente tama\u00f1o, pero los tama\u00f1os deben ser compatibles. Por ejemplo si ambos arreglos tienen el mismo tama\u00f1o o si uno tiene tama\u00f1o 1 (escalar). Si los tama\u00f1os no son compatibles, te va a dar un ValueError . Operaciones un poco m\u00e1s complejas numpy tambi\u00e9n te permite realizar operaciones que resumen los datos. Adem\u00e1s de min , max , y sum , pod\u00e9s usar mean para obtener el promedio, prod para calcular el producto, std para obtener el desv\u00edo est\u00e1ndar de los datos, y m\u00e1s. >>> data.max() 2.0 >>> data.min() 1.0 >>> data.sum() 3.0 Supongamos que tenemos un arreglo, llamado \u201ca\u201d >>> a = np.array([[0.45053314, 0.17296777, 0.34376245, 0.5510652], ... [0.54627315, 0.05093587, 0.40067661, 0.55645993], ... [0.12697628, 0.82485143, 0.26590556, 0.56917101]]) Es usual procesar los datos por fila o por columna. Si no lo aclar\u00e1s, numpy procesa los datos de todo el arreglo. Para encontrar la suma o el m\u00ednimo del arreglo, us\u00e1: >>> a.sum() 4.8595784 O: >>> a.min() 0.05093587 Pod\u00e9s especificar qu\u00e9 eje quer\u00e9s considerar. Por ejemplo, para calcular el m\u00ednimo de cada columna especific\u00e1s axis=0 . >>> a.min(axis=0) array([0.12697628, 0.05093587, 0.26590556, 0.5510652 ]) Son cuatro valores, porque la matriz tiene cuatro columnas. Crear matrices Pod\u00e9s usar listas de listas para crear arreglos bidimensionales (matrices). >>> data = np.array([[1, 2], [3, 4]]) >>> data array([[1, 2], [3, 4]]) Las t\u00e9cnicas de indexaci\u00f3n y rebanadas son muy \u00fatiles para manipular matrices: >>> data = np.array([[1, 2], [3, 4], [5, 6]]) >>> data[0, 1] 2 >>> data[1:3] array([[3, 4], [5, 6]]) >>> data[0:2, 0] array([1, 3]) Pod\u00e9s procesar los datos de matrices como lo hicimos con vectores: >>> data.max() 6 >>> data.min() 1 >>> data.sum() 21 Pod\u00e9s procesar todos, o hacerlo por fila o por columna usando el par\u00e1metro axis : >>> data = np.array([[1, 2], [5, 3], [4, 6]]) >>> data.max(axis=0) array([5, 6]) >>> data.max(axis=1) array([2, 5, 6]) Una vez que ten\u00e9s tus matrices creadas, pod\u00e9s hacer artim\u00e9tica con pares de matrices del mismo tama\u00f1o. >>> data = np.array([[1, 2], [3, 4]]) >>> ones = np.array([[1, 1], [1, 1]]) >>> data + ones array([[2, 3], [4, 5]]) Tambi\u00e9n se pueden sumar matrices de tama\u00f1os diferentes, pero s\u00f3lo si una de ellas tiene una sola fila o una sola columna. En este caso, numpy va a usar las reglas de broadcast para la operaci\u00f3n. >>> data = np.array([[1, 2], [3, 4], [5, 6]]) >>> ones_row = np.array([[1, 1]]) >>> data + ones_row array([[2, 3], [4, 5], [6, 7]]) Ten\u00e9 en cuenta que cuando numpy imprime arreglos n-dimensionales, el \u00faltimo eje se itera m\u00e1s r\u00e1pido y el primero m\u00e1s lento. Por ejemplo: >>> np.ones((4, 3, 2)) array([[[1., 1.], [1., 1.], [1., 1.]], [[1., 1.], [1., 1.], [1., 1.]], [[1., 1.], [1., 1.], [1., 1.]], [[1., 1.], [1., 1.], [1., 1.]]]) Es frecuente que querramos inicializar los valores de una matriz. numpy ofrece las funciones ones() y zeros() , as\u00ed como tambi\u00e9n la clase random.Generator que genera n\u00famero aleatorios. S\u00f3lo hay que pasarle la cantidad de elementos que queremos generar: >>> np.ones(3) array([1., 1., 1.]) >>> np.zeros(3) array([0., 0., 0.]) >>> np.random.random(3) array([0.63696169, 0.26978671, 0.04097352]) # puede variar Tambi\u00e9n pod\u00e9s usar ones() , zeros() , y random() para crear matrices, si le pas\u00e1s una tupla describiendo la forma de la matriz: >>> np.ones((3, 2)) array([[1., 1.], [1., 1.], [1., 1.]]) >>> np.zeros((3, 2)) array([[0., 0.], [0., 0.], [0., 0.]]) >>> np.random.random((3, 2)) array([[0.01652764, 0.81327024], [0.91275558, 0.60663578], [0.72949656, 0.54362499]]) # puede variar Esta idea se generaliza a dimensiones m\u00e1s altas. F\u00f3rmulas matem\u00e1ticas La facilidad para implementar f\u00f3rmulas matem\u00e1ticas sobre un arreglo es una de las caracter\u00edsticas de numpy que lo hacen tan ampliamente usado en la comunidad cient\u00edfica de Python. Por ejemplo, \u00e9sta es la f\u00f3rmula del error cuadr\u00e1tico medio: Implementar esta f\u00f3rmula es simple y directo con numpy: Lo genial de esta abstracci\u00f3n es que predictions y labels puede tener uno o mil valores. S\u00f3lo tienen que tener el mismo tama\u00f1o para que todo funcione. Lo pod\u00e9s visulalizar as\u00ed: En este ejemplo, tanto las predicciones como las etiquetas tienen tres valores. Es decir n vale tres. Luego de hacer la resta los valores se elevan al cuadrado. Luego numpy suma los valores, divide por tres, y el resultado es el error de esa predicci\u00f3n y puede usarse como un puntaje que mide la calidad del modelo que predice. Guardar y cargar objetos de numpy Si segu\u00eds usando Python despu\u00e9s de este curso, es muy probable que en cierto punto quieras guardar tus matrices (o arreglos n-dimensionales) para cargarlas en otro momento sin tener que volver a correr el c\u00f3digo que las genera. Hay un par de formas de guardar objetos de numpy. Los objetos ndarray pueden guardarse y leerse de disco con las funciones loadtxt y savetxt usando archivos de texto (tienen la ventaja de que los pod\u00e9s ver con un editor de textos como el sublime o geany ), y con las funciones load y save que guardan archivos binarios con extensi\u00f3n .npy . Los archivos .npy guardan los datos, la forma, el tipo del arreglo y otra informaci\u00f3n necesaria que permiten reconstruirlos correctamente, incluso en otra m\u00e1quina con otra arquitectura. Es sencillo guardar un arreglo con np.save() . Solo asegurate de especificar el arreglo que quer\u00e9s guardar y el nombre del archivo. Por ejemplo, si cre\u00e1s este vector: >>> a = np.array([1, 2, 3, 4, 5, 6]) Lo pod\u00e9s guardar en \u201cfilename.npy\u201d con: >>> np.save('filename', a) Y lo pod\u00e9s cargar con np.load() para reconstruir tu vector. >>> b = np.load('filename.npy') Para verificarlo, us\u00e1: >>> print(b) [1 2 3 4 5 6] En formato de texto plano, lo pod\u00e9s guardar como .csv o .txt con np.savetxt . Por ejemplo, si ten\u00e9s este vector: >>> csv_arr = np.array([1, 2, 3, 4, 5, 6, 7, 8]) lo pod\u00e9s guardar en un archivo .csv con nombre \u201cnew_file.csv\u201d as\u00ed: >>> np.savetxt('new_file.csv', csv_arr) Y lo pod\u00e9s cargar f\u00e1cilmente usando loadtxt() : >>> np.loadtxt('new_file.csv') array([1., 2., 3., 4., 5., 6., 7., 8.]) Las funciones savetxt() y loadtxt() aceptan par\u00e1metros adicionales para especificar el encabezado y los delimitadores. Si bien los archivos de texto son sencillos para compartir, los archivos .npy (y .npz) son m\u00e1s peque\u00f1os y se leen m\u00e1s r\u00e1pidamente. Ejercicio 5.8: Guardar temperaturas Ampli\u00e1 el c\u00f3digo de termometro.py que escribiste en el Ejercicio 5.6 para que guarde el vector con las temperaturas simuladas en el directorio Data de tu carpeta de ejercicios, en un archivo llamado Temperaturas.npy . Hac\u00e9 que corra 999 veces en lugar de solo 99. Ejercicio 5.9: Empezando a plotear En un rato vamos a empezar a hacer gr\u00e1ficos con Python. Aqu\u00ed solo un bot\u00f3n de muestra. Escrib\u00ed un archivo plotear_temperaturas.py que lea el archivo de datos Temperaturas.npy con 999 mediciones simuladas que creaste reci\u00e9n y, usando el siguiente ejemplo, hac\u00e9 un histograma de las temperaturas simuladas: import matplotlib.pyplot as plt plt.hist(temperaturas,bins=25) plt.show() #el show no hace falta en algunos entornos. A veces lo omitiremos. Ajust\u00e1 la cantidad de bins para que el gr\u00e1fico se vea lo mejor posible. Contenidos | Anterior (1 Random) | Pr\u00f3ximo (3 El album de Figuritas)","title":"02 NumPy Arrays"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#52-numpy","text":"Esta es una introducci\u00f3n a la biblioteca NumPy ( Numerical Python ) de Python. Se trata de una colecci\u00f3n de m\u00f3dulos de c\u00f3digo abierto que tiene aplicaciones en casi todos los campos de las ciencias y de la ingenier\u00eda. Es el est\u00e1ndar para trabajar con datos num\u00e9ricos en Python. Muchas otras bibliotecas y m\u00f3dulos de Python como Pandas, SciPy, Matplotlib, scikit-learn, scikit-image usan numpy. Esta biblioteca permite trabajar c\u00f3modamente con matrices multidimensionales por medio del tipo ndarray , un objeto n-dimensional homog\u00e9neo (es decir, con todas sus entradas del mismo tipo), y con m\u00e9todos para operar eficientemente sobre \u00e9l. numpy puede usarse para una amplia variedad de operaciones matem\u00e1ticas sobre matrices. Le agrega a Python estructuras de datos muy potentes sobre las que pued\u00e9s hacer c\u00e1lculos y operar matem\u00e1ticamente con eficiencia y a un alto nivel.","title":"5.2 NumPy"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#instalar-e-importar-numpy","text":"Cuando quieras usar numpy en Python, primero ten\u00e9s que importarlo: import numpy as np Acortamos numpy a np para ahorrar tiempo y mantener el c\u00f3digo estandarizado. Todes escriben np . Si no lo ten\u00e9s instalado (te dar\u00e1 un error al importarlo) pod\u00e9s instalarlo escribiendo alguno de los siguientes comandos, seg\u00fan corresponda: conda install numpy pip install numpy pip3 install numpy","title":"Instalar e importar numpy"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#cual-es-la-diferencia-entre-listas-y-arreglos","text":"numpy ofrece varias formas muy eficientes de crear vectores y manipular datos num\u00e9ricos. Mientras que una lista de Python puede contener diferentes tipos de datos en su interior, los elementos de un vector numpy ser\u00e1n todos del mismo tipo. De esta forma numpy garantiza un muy alto rendimiento en las operaicones matem\u00e1ticas. Adem\u00e1s, los arreglos est\u00e1n pensados para tener un tama\u00f1o fijo, mientras que las listas est\u00e1n dise\u00f1adas para agregar y sacar elementos. Son estructuras de datos similares desde un punto de vista superficial, pero muy diferentes en cuanto a las posibilidades que brindan. Las operaciones matem\u00e1ticas sobre vectores de numpy son m\u00e1s r\u00e1pidas que sobre listas. Adem\u00e1s los vectores ocupan menos memoria que las listas an\u00e1logas. En cambio, modificar el tama\u00f1o de una lista es algo muy sencillo mientras que el de un vector es costoso. Y combinar diferentes tipos de datos es sencillo en las listas pero imposible en los vectores de numpy.","title":"\u00bfCu\u00e1l es la diferencia entre listas y arreglos?"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#arreglos-n-dimensionales","text":"Los vectores (unidimensionales) y matrices (bidimensiones) se generalizan a arreglos n-dimensionales. Esta estructura de datos es la central de la biblioteca numpy. Un arreglo ( ndarray ) tiene una grilla de valores (datos crudos) junto con informaci\u00f3n sobre c\u00f3mo ubicarlos y c\u00f3mo interpretarlos. Los elementos de esta grilla pueden ser indexados de diversas maneras y, como ya dijimos, son todos del mismo tipo. Este tipo es frecuentemente abreviado como dtype (por data type). Un arreglo puede ser indexado por tuplas de enteros no negativos, por variables booleanas, por otro arreglo o por enteros. El rango ( rank ) de un arreglo es su n\u00famero de dimensiones. Su forma ( shape ) es una tupla de enteros que dice su tama\u00f1o en cada dimensi\u00f3n. Una forma de inicializar un arreglo de numpy es mediante una lista de n\u00fameros. Esto nos da un vector (arreglo de dimensi\u00f3n uno). Usando listas anidadas, podemos definir arreglos de m\u00e1s altas dimensiones. Por ejemplo: >>> a = np.array([1, 2, 3, 4, 5, 6]) o: >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) Podemos acceder a los elementos de un arreglo usando corchetes. Acordate que los \u00edndices comienzan a contar en 0. Esto significa que si quer\u00e9s acceder al primer elemento, vas a acceder al elemento \u201c0\u201d. >>> print(a[0]) # si tiene m\u00faltiples dimensiones, esto me da una \"rebanada\" de una dimensi\u00f3n menos [1 2 3 4] >>> print(a[2]) # otra rebanada [ 9, 10, 11, 12] >>> print(a[2][3]) # accedo al cuarto elemento del tercer vector de a 12 >>> print(a[2,3]) # o, equivalentemente, accedo al elemento en la tercera fila y cuarta columna de a 12","title":"Arreglos n-dimensionales"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#mas-informacion-sobre-arreglos","text":"Ocasionalmente vas a ver que alguien se refiere a un arreglo como un \u201cndarray\u201d que es una forma breve de decir arreglo n-dimensional. Un arreglo n-dimensional es simplemente un arreglo con n dimensiones. Recordemos que cuando son unidimensionales los llamamos vectores y si son bidimensionales los llamamos matrices. \u00bfQu\u00e9 atributos tiene un arreglo? Un arreglo es usualmente un contenedor de tama\u00f1o fijo de elementos del mismo tipo. Su forma (shape) es una tupla de enteros no negativos que especifica el tama\u00f1o del arreglo en cada dimensi\u00f3n. Un arreglo tiene tantas dimensiones como coordenadas en la tupla. En numpy, las dimensiones se llaman axes (ejes). Esto significa que si ten\u00e9s un arreglo bidimensional que se ve as\u00ed: [[0., 0., 0.], [1., 1., 1.]] el arreglo tendr\u00e1 dos ejes. El primer eje tiene tama\u00f1o dos, el segundo tama\u00f1o tres (s\u00ed, se cuentan primero filas, luego columnas). De la misma forma que los otros objetos contenedores de Python, los elementos de un arreglo pueden ser accedidos y modificados usando \u00edndices y rebanadas.","title":"M\u00e1s informaci\u00f3n sobre arreglos"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#crear-un-arreglo-basico","text":"Para crear un arreglo de numpy pod\u00e9s usar la funci\u00f3n np.array() . Lo \u00fanico que necesit\u00e1s es pasarle una lista. Si quer\u00e9s, pod\u00e9s especificar el tipo de datos que quer\u00e9s que tenga. >>> import numpy as np >>> a = np.array([1, 2, 3]) Vamos a representar la creaci\u00f3n con este gr\u00e1fico: Ojo, estas visualizaciones son simplificaciones para representar lo que esta pasando y darte un entendimiento b\u00e1sico de los conceptos y mecanismos de numpy. Los arreglos y sus operaciones tienen aspectos m\u00e1s complejos que los que quedan capturados en estos dibujitos. Adem\u00e1s de crear un arreglo a partir de una secuencia de elementos, pod\u00e9s crear un arreglo lleno de 0 \u2019s: >>> np.zeros(2) array([0., 0.]) O uno lleno de 1 \u2019s: >>> np.ones(2) array([1., 1.]) \u00a1O incluso uno no inicializado! La funci\u00f3n empty crea un arreglo cuyo contenido inicial depende del estado de la memoria. Lo bueno de usar empty en lugar de zeros (o ones ) es la velocidad - al no inicilizar los valores no perdemos tiempo. \u00a1Pero asegurate de ponerle valores con sentido luego! >>> # Crea un arreglo con dos elementos >>> np.empty(2) array([ 3.14, 42. ]) # puede variar Tambi\u00e9n pod\u00e9s crear vectores a partir de un rango de valores: >>> np.arange(4) array([0, 1, 2, 3]) Tambi\u00e9n un vector que contiene elementos equiespaciados, especificando el primer n\u00famero , el l\u00edmite , y el paso . >>> np.arange(2, 9, 2) # o np.arange(2, 10, 2) array([2, 4, 6, 8]) El l\u00edmite derecho nunca est\u00e1 en la lista. Tambi\u00e9n pod\u00e9s usar np.linspace() para crear un vector de valores equiespaciados especificando el primer n\u00famero , el \u00faltimo n\u00famero , y la cantidad de elementos: >>> np.linspace(0, 10, num=5) array([ 0. , 2.5, 5. , 7.5, 10. ])","title":"Crear un arreglo b\u00e1sico"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#ejercicio-57-arange-y-linspace","text":"Gener\u00e1 un vector que tenga los n\u00fameros impares entre el 1 y el 19 inclusive usando arange() . Repet\u00ed el ejercicio usando linspace() . \u00bfQu\u00e9 diferencia hay en el resultado? Especificar el tipo de datos Si no lo especific\u00e1s, el tipo de datos (por omisi\u00f3n) de los arreglos es el punto flotante ( np.float64 ). Sin embargo, pod\u00e9s explicitar otro tipo de datos usando la palabra clave dtype . >>> x = np.ones(2, dtype=np.int64) >>> x array([1, 1]) En estos dos casos el 64 de los tipos de datos se refiere a la cantidad de bits usados para representar el n\u00famero en el sistema binario: 64 bits.","title":"Ejercicio 5.7: arange() y linspace()"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#agregar-borrar-y-ordenar-elementos","text":"Ordenar un vector es sencillo usando np.sort() . Por ejemplo, si comenz\u00e1s con este vector: >>> arr = np.array([2, 1, 5, 3, 7, 4, 6, 8]) Pod\u00e9s ordenar sus elementos con: >>> np.sort(arr) array([1, 2, 3, 4, 5, 6, 7, 8]) Fijate que el vector arr qued\u00f3 desordenado. sort simplemente devolvi\u00f3 una copia ordenada de los datos pero no modific\u00f3 el original. Otra operaci\u00f3n usual es la concatenaci\u00f3n. Si empez\u00e1s con estos dos vectores: >>> a = np.array([1, 2, 3, 4]) >>> b = np.array([5, 6, 7, 8]) los pod\u00e9s concatenar usado np.concatenate() . >>> np.concatenate((a, b)) array([1, 2, 3, 4, 5, 6, 7, 8]) Un ejemplo un poco m\u00e1s complejo es el siguiente: >>> x = np.array([[1, 2], [3, 4]]) >>> y = np.array([[5, 6]]) Los pod\u00e9s concatenar usando: >>> np.concatenate((x, y), axis=0) array([[1, 2], [3, 4], [5, 6]])","title":"Agregar, borrar y ordenar elementos"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#conocer-el-tamano-dimensiones-y-forma-de-un-arreglo","text":"ndarray.ndim te dice la cantidad de ejes (o dimensiones) del arreglo. ndarray.shape te va a dar una tupla de enteros que indican la cantidad de elementos en cada eje. Si ten\u00e9s una matriz con 2 filas y 3 columnas de va a dar (2, 3) . ndarray.size te dice la cantidad de elementos (cantidad de n\u00fameros) de tu arreglo. Es el producto de la tupla shape . En el ejemplo del rengl\u00f3n anterior, el size es 6. Por ejemplo, si cre\u00e1s este arreglo de tres dimensiones: >>> array_ejemplo = np.array([[[0, 1, 2, 3], ... [4, 5, 6, 7]], ... ... [[0, 1, 2, 3], ... [4, 5, 6, 7]], ... ... [[0 ,1 ,2, 3], ... [4, 5, 6, 7]]]) Vas a tener >>> array_ejemplo.ndim # cantidad de dimensiones 3 >>> array_ejemplo.shape # cantidad de elementos en cada eje (3, 2, 4) >>> array_ejemplo.size # total de elementos 3*2*4 24","title":"Conocer el tama\u00f1o, dimensiones y forma de un arreglo"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#cambiar-la-forma-de-un-arreglo","text":"Usando arr.reshape() le pod\u00e9s dar una nueva forma a tu arreglo sin cambiar los datos. Solo ten\u00e9 en cuenta que antes y despu\u00e9s del reshape el arreglo tiene que tener la misma cantidad de elementos. Por ejemplo, si comenz\u00e1s con un arreglo con 12 elementos, tendr\u00e1s que asegurarte que el nuevo arreglo siga teniendo 12 elementos. Por ejemplo: >>> a = np.arange(6) >>> print(a) [0 1 2 3 4 5] Pod\u00e9s usar reshape() para cambiarle la forma y que en lugar de ser un vector de 6 elementos, sea una matriz de 3 filas y dos columnas: >>> b = a.reshape(3, 2) >>> print(b) [[0 1] [2 3] [4 5]]","title":"Cambiar la forma de un arreglo"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#agregar-un-nuevo-eje-a-un-arreglo","text":"A veces pasa que tenemos un vector con n elementos y necesitamos pensarlo como una matriz de una fila y n columnas o de n filas y una columna. Pod\u00e9s usar np.newaxis para agregarle dimensiones a un vector existente. Usando np.newaxis una vez pod\u00e9s incrementar la dimensi\u00f3n de tu arreglo en uno. Por ejemplo pod\u00e9s pasar de un vector a una matriz o de una matriz a un arreglo tridimensional, etc. Por ejemplo, si comenz\u00e1s con este vector: >>> a = np.array([1, 2, 3, 4, 5, 6]) >>> a.shape (6,) Pod\u00e9s usar np.newaxis para agregarle una dimensi\u00f3n y convertirlo en un vector fila: >>> vec_fila = a[np.newaxis, :] >>> vec_fila.shape (1, 6) O, para convertirlo en un vector columna, pod\u00e9s unsertar un eje en la segunda dimensi\u00f3n: >>> vec_col = a[:, np.newaxis] >>> vec_col.shape (6, 1)","title":"Agregar un nuevo eje a un arreglo"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#indices-y-rebanadas","text":"Pod\u00e9s indexar y rebanar arreglos de numpy como hicimos con las listas. Para obtener elementos de un arreglo, lo m\u00e1s sencillo es usar los \u00edndices para seleccionar los que queremos conservar. >>> data = np.array([1, 2, 3]) >>> data[1] 2 >>> data[0:2] array([1, 2]) >>> data[1:] array([2, 3]) >>> data[-2:] array([2, 3]) Lo pod\u00e9s visualizar as\u00ed: Otra operaci\u00f3n muy \u00fatil es seleccionar los elementos que cumplen cierta condici\u00f3n. Por ejemplo, si comenz\u00e1s con un arreglo as\u00ed: >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) Pod\u00e9s imprimir todos los valores menores que cinco. >>> print(a[a < 5]) [1 2 3 4] Tambi\u00e9n pod\u00e9s seleccionar, por ejemplo, aquellos elementos mayores o iguales que 5 y usar el resultado para indexar el arreglo. >>> five_up = (a >= 5) >>> print(a[five_up]) [ 5 6 7 8 9 10 11 12] Es interesante que five_up da un arreglo de valores booleanos. True si satisface la condici\u00f3n y False si no la satisface. Pod\u00e9s seleccionar los elementos pares: >>> pares = a[a%2==0] >>> print(pares) [ 2 4 6 8 10 12] Usando los operadores l\u00f3gicos & y | pod\u00e9s combinar dos o m\u00e1s condiciones. Ya sea para seleccionar elementos directamente: >>> c = a[(a > 2) & (a < 11)] >>> print(c) [ 3 4 5 6 7 8 9 10] o para definir una nueva variable booleana: >>> five_up = (a > 5) | (a == 5) >>> print(five_up) [[False False False False] [ True True True True] [ True True True True]] Finalmente, pod\u00e9s usar np.nonzero() para obtener las coordenadas de ciertos elementos de un arreglo. Si empezamos con este arreglo: >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) Pod\u00e9s usar np.nonzero() para imprimir los \u00edndices de los elementos que son, digamos, menores que 5: >>> b = np.nonzero(a < 5) >>> print(b) (array([0, 0, 0, 0]), array([0, 1, 2, 3])) En este ejemplo, la respuesta es una tupla de arreglos: uno por cada dimensi\u00f3n. El primer arreglo representa las filas de los elementos que satisfacen la condici\u00f3n y el segundo sus columnas. Si quer\u00e9s generar la lista de coordenadas donde se encuentran estos elementos, pod\u00e9s zipear los arreglos, convertir el resultado en una lista e imprimirla: >>> lista_de_coordenadas = list(zip(b[0], b[1])) Surge naturalmente la pregunta: \u00bfporqu\u00e9 tengo que convertir el objeto zip a una lista? Veremos en la segunda mitad de la materia m\u00e1s detalles sobre generadores en Python para entender exactamente lo que est\u00e1 pasando aqu\u00ed. Simplemente digamos que al zipear b[0] y b[1] no se genera la lista realmente, sino potencialmente. S\u00f3lo al solicitar sus elementos (iterando sobre ello o con list ) se generan realmente las coordenadas. >>> for coord in lista_de_coordenadas: ... print(coord) (0, 0) (0, 1) (0, 2) (0, 3) Pod\u00e9s usar np.nonzero() para imprimir o seleccionar los elementos del arreglo que son menores que 5: >>> print(a[b]) [1 2 3 4] Si la condici\u00f3n que pon\u00e9s no la satisface ning\u00fan elemento del arreglo entonces el arreglo de \u00edndices que obten\u00e9s con np.nonzero() ser\u00e1 vac\u00edo. Por ejemplo: >>> no_hay = np.nonzero(a == 42) >>> print(no_hay) (array([], dtype=int64), array([], dtype=int64))","title":"\u00cdndices y rebanadas"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#crear-arreglos-usando-datos-existentes","text":"Es sencillo crear un nuevo arreglo usando una secci\u00f3n de otro arreglo. Suponete que ten\u00e9s este: >>> a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) Pod\u00e9s crear otro arreglo a partir de una secci\u00f3n de a , simplemente especificando qu\u00e9 parte quer\u00e9s. >>> arr1 = a[3:8] >>> arr1 array([4, 5, 6, 7, 8]) Es importante saber que este m\u00e9todo genera una vista del arreglo original y no una verdadera copia. Si modific\u00e1s un elemento de la vista, \u00a1tambi\u00e9n se modificar\u00e1 en el original! >>> arr1[0] = 44 >>> print(a) [ 1 2 3 44 5 6 7 8 9 10] El concepto de vista es importante para entender lo que est\u00e1 pasando. Las operaciones m\u00e1s frecuentes devuelven vistas y no copias. Esto ahorra memoria y es m\u00e1s veloz, pero si no lo sab\u00e9s puede traerte problemas. Veamos este ejemplo: >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) Ahora creamos b1 a partir de una rebanada de a y modificamos su primer elemento. \u00a1Esto va a modificar el elemento correspondiente de a tambi\u00e9n! >>> b1 = a[0, :] >>> b1 array([1, 2, 3, 4]) >>> b1[0] = 99 >>> b1 array([99, 2, 3, 4]) >>> a array([[99, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12]]) Pod\u00e9s usar el m\u00e9todo copy para copiar los datos. Por ejemplo: >>> b2 = a[1, :].copy() >>> b2 array([5, 6, 7, 8]) >>> b2[0] = 95 >>> b2 array([95, 6, 7, 8]) >>> a # \u00a1no se modifica el 5! array([[99, 2, 3, 4], [ 5, 6, 7, 8], [ 9, 10, 11, 12]])","title":"Crear arreglos usando datos existentes"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#operaciones-basicas-sobre-arreglos","text":"Una vez que sab\u00e9s crear arreglos pod\u00e9s empezar a trabajar con ellos. Imaginemos que ten\u00e9s dos arreglos, uno llamados \u201cdata\u201d y otro llamado \u201cones\u201d. Pod\u00e9s sumarlos con el signo m\u00e1s. >>> data = np.array([1, 2]) >>> ones = np.ones(2, dtype=int) >>> data + ones array([2, 3]) Obviamente, pod\u00e9s hacer otras operaciones. >>> data - ones array([0, 1]) >>> data * data array([1, 4]) >>> data / data array([1., 1.]) Estas operaciones b\u00e1sicas son simples con numpy. Si quer\u00e9s calcular la suma de los elementos del arreglo, pod\u00e9s usar sum() . Esto funciona para vectores, matrices y arreglos de dimensi\u00f3n m\u00e1s alta tambi\u00e9n. >>> a = np.array([1, 2, 3, 4]) >>> a.sum() 10 Para sumar los valores por fila o por columna en una matriz, simplemente ten\u00e9s que especificar el eje sobre el que se har\u00e1 la suma. Si ten\u00e9s la matriz: >>> b = np.array([[1, 1], [2, 2]]) pod\u00e9s sumar los datos de cada columna con: >>> b.sum(axis=0) array([3, 3]) y los datos de cada fila usando: >>> b.sum(axis=1) array([2, 4])","title":"Operaciones b\u00e1sicas sobre arreglos"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#broadcasting","text":"Hay veces en que necesit\u00e1s realizar una operaci\u00f3n entre un arreglo y un n\u00famero (en matem\u00e1tica le decimos, un escalar ). Por ejemplo ten\u00e9s un vector con distancias en millas (lo llamamos \"data\") y lo necesit\u00e1s convertir a distancias en kil\u00f3metros. Pod\u00e9s hacer esta operaci\u00f3n as\u00ed: >>> data = np.array([1.0, 2.0]) >>> data * 1.6 array([1.6, 3.2]) numpy entiende que la multiplicaci\u00f3n debe ocurrir en cada celda del vector. Este concepto se llama broadcasting . El mecanismo de broadcasting le permite a numpy realizar operaciones en arreglos de diferente tama\u00f1o, pero los tama\u00f1os deben ser compatibles. Por ejemplo si ambos arreglos tienen el mismo tama\u00f1o o si uno tiene tama\u00f1o 1 (escalar). Si los tama\u00f1os no son compatibles, te va a dar un ValueError .","title":"Broadcasting"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#operaciones-un-poco-mas-complejas","text":"numpy tambi\u00e9n te permite realizar operaciones que resumen los datos. Adem\u00e1s de min , max , y sum , pod\u00e9s usar mean para obtener el promedio, prod para calcular el producto, std para obtener el desv\u00edo est\u00e1ndar de los datos, y m\u00e1s. >>> data.max() 2.0 >>> data.min() 1.0 >>> data.sum() 3.0 Supongamos que tenemos un arreglo, llamado \u201ca\u201d >>> a = np.array([[0.45053314, 0.17296777, 0.34376245, 0.5510652], ... [0.54627315, 0.05093587, 0.40067661, 0.55645993], ... [0.12697628, 0.82485143, 0.26590556, 0.56917101]]) Es usual procesar los datos por fila o por columna. Si no lo aclar\u00e1s, numpy procesa los datos de todo el arreglo. Para encontrar la suma o el m\u00ednimo del arreglo, us\u00e1: >>> a.sum() 4.8595784 O: >>> a.min() 0.05093587 Pod\u00e9s especificar qu\u00e9 eje quer\u00e9s considerar. Por ejemplo, para calcular el m\u00ednimo de cada columna especific\u00e1s axis=0 . >>> a.min(axis=0) array([0.12697628, 0.05093587, 0.26590556, 0.5510652 ]) Son cuatro valores, porque la matriz tiene cuatro columnas.","title":"Operaciones un poco m\u00e1s complejas"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#crear-matrices","text":"Pod\u00e9s usar listas de listas para crear arreglos bidimensionales (matrices). >>> data = np.array([[1, 2], [3, 4]]) >>> data array([[1, 2], [3, 4]]) Las t\u00e9cnicas de indexaci\u00f3n y rebanadas son muy \u00fatiles para manipular matrices: >>> data = np.array([[1, 2], [3, 4], [5, 6]]) >>> data[0, 1] 2 >>> data[1:3] array([[3, 4], [5, 6]]) >>> data[0:2, 0] array([1, 3]) Pod\u00e9s procesar los datos de matrices como lo hicimos con vectores: >>> data.max() 6 >>> data.min() 1 >>> data.sum() 21 Pod\u00e9s procesar todos, o hacerlo por fila o por columna usando el par\u00e1metro axis : >>> data = np.array([[1, 2], [5, 3], [4, 6]]) >>> data.max(axis=0) array([5, 6]) >>> data.max(axis=1) array([2, 5, 6]) Una vez que ten\u00e9s tus matrices creadas, pod\u00e9s hacer artim\u00e9tica con pares de matrices del mismo tama\u00f1o. >>> data = np.array([[1, 2], [3, 4]]) >>> ones = np.array([[1, 1], [1, 1]]) >>> data + ones array([[2, 3], [4, 5]]) Tambi\u00e9n se pueden sumar matrices de tama\u00f1os diferentes, pero s\u00f3lo si una de ellas tiene una sola fila o una sola columna. En este caso, numpy va a usar las reglas de broadcast para la operaci\u00f3n. >>> data = np.array([[1, 2], [3, 4], [5, 6]]) >>> ones_row = np.array([[1, 1]]) >>> data + ones_row array([[2, 3], [4, 5], [6, 7]]) Ten\u00e9 en cuenta que cuando numpy imprime arreglos n-dimensionales, el \u00faltimo eje se itera m\u00e1s r\u00e1pido y el primero m\u00e1s lento. Por ejemplo: >>> np.ones((4, 3, 2)) array([[[1., 1.], [1., 1.], [1., 1.]], [[1., 1.], [1., 1.], [1., 1.]], [[1., 1.], [1., 1.], [1., 1.]], [[1., 1.], [1., 1.], [1., 1.]]]) Es frecuente que querramos inicializar los valores de una matriz. numpy ofrece las funciones ones() y zeros() , as\u00ed como tambi\u00e9n la clase random.Generator que genera n\u00famero aleatorios. S\u00f3lo hay que pasarle la cantidad de elementos que queremos generar: >>> np.ones(3) array([1., 1., 1.]) >>> np.zeros(3) array([0., 0., 0.]) >>> np.random.random(3) array([0.63696169, 0.26978671, 0.04097352]) # puede variar Tambi\u00e9n pod\u00e9s usar ones() , zeros() , y random() para crear matrices, si le pas\u00e1s una tupla describiendo la forma de la matriz: >>> np.ones((3, 2)) array([[1., 1.], [1., 1.], [1., 1.]]) >>> np.zeros((3, 2)) array([[0., 0.], [0., 0.], [0., 0.]]) >>> np.random.random((3, 2)) array([[0.01652764, 0.81327024], [0.91275558, 0.60663578], [0.72949656, 0.54362499]]) # puede variar Esta idea se generaliza a dimensiones m\u00e1s altas.","title":"Crear matrices"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#formulas-matematicas","text":"La facilidad para implementar f\u00f3rmulas matem\u00e1ticas sobre un arreglo es una de las caracter\u00edsticas de numpy que lo hacen tan ampliamente usado en la comunidad cient\u00edfica de Python. Por ejemplo, \u00e9sta es la f\u00f3rmula del error cuadr\u00e1tico medio: Implementar esta f\u00f3rmula es simple y directo con numpy: Lo genial de esta abstracci\u00f3n es que predictions y labels puede tener uno o mil valores. S\u00f3lo tienen que tener el mismo tama\u00f1o para que todo funcione. Lo pod\u00e9s visulalizar as\u00ed: En este ejemplo, tanto las predicciones como las etiquetas tienen tres valores. Es decir n vale tres. Luego de hacer la resta los valores se elevan al cuadrado. Luego numpy suma los valores, divide por tres, y el resultado es el error de esa predicci\u00f3n y puede usarse como un puntaje que mide la calidad del modelo que predice.","title":"F\u00f3rmulas matem\u00e1ticas"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#guardar-y-cargar-objetos-de-numpy","text":"Si segu\u00eds usando Python despu\u00e9s de este curso, es muy probable que en cierto punto quieras guardar tus matrices (o arreglos n-dimensionales) para cargarlas en otro momento sin tener que volver a correr el c\u00f3digo que las genera. Hay un par de formas de guardar objetos de numpy. Los objetos ndarray pueden guardarse y leerse de disco con las funciones loadtxt y savetxt usando archivos de texto (tienen la ventaja de que los pod\u00e9s ver con un editor de textos como el sublime o geany ), y con las funciones load y save que guardan archivos binarios con extensi\u00f3n .npy . Los archivos .npy guardan los datos, la forma, el tipo del arreglo y otra informaci\u00f3n necesaria que permiten reconstruirlos correctamente, incluso en otra m\u00e1quina con otra arquitectura. Es sencillo guardar un arreglo con np.save() . Solo asegurate de especificar el arreglo que quer\u00e9s guardar y el nombre del archivo. Por ejemplo, si cre\u00e1s este vector: >>> a = np.array([1, 2, 3, 4, 5, 6]) Lo pod\u00e9s guardar en \u201cfilename.npy\u201d con: >>> np.save('filename', a) Y lo pod\u00e9s cargar con np.load() para reconstruir tu vector. >>> b = np.load('filename.npy') Para verificarlo, us\u00e1: >>> print(b) [1 2 3 4 5 6] En formato de texto plano, lo pod\u00e9s guardar como .csv o .txt con np.savetxt . Por ejemplo, si ten\u00e9s este vector: >>> csv_arr = np.array([1, 2, 3, 4, 5, 6, 7, 8]) lo pod\u00e9s guardar en un archivo .csv con nombre \u201cnew_file.csv\u201d as\u00ed: >>> np.savetxt('new_file.csv', csv_arr) Y lo pod\u00e9s cargar f\u00e1cilmente usando loadtxt() : >>> np.loadtxt('new_file.csv') array([1., 2., 3., 4., 5., 6., 7., 8.]) Las funciones savetxt() y loadtxt() aceptan par\u00e1metros adicionales para especificar el encabezado y los delimitadores. Si bien los archivos de texto son sencillos para compartir, los archivos .npy (y .npz) son m\u00e1s peque\u00f1os y se leen m\u00e1s r\u00e1pidamente.","title":"Guardar y cargar objetos de numpy"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#ejercicio-58-guardar-temperaturas","text":"Ampli\u00e1 el c\u00f3digo de termometro.py que escribiste en el Ejercicio 5.6 para que guarde el vector con las temperaturas simuladas en el directorio Data de tu carpeta de ejercicios, en un archivo llamado Temperaturas.npy . Hac\u00e9 que corra 999 veces en lugar de solo 99.","title":"Ejercicio 5.8: Guardar temperaturas"},{"location":"05_Random_Plt_Dbg/02_NumPy_Arrays/#ejercicio-59-empezando-a-plotear","text":"En un rato vamos a empezar a hacer gr\u00e1ficos con Python. Aqu\u00ed solo un bot\u00f3n de muestra. Escrib\u00ed un archivo plotear_temperaturas.py que lea el archivo de datos Temperaturas.npy con 999 mediciones simuladas que creaste reci\u00e9n y, usando el siguiente ejemplo, hac\u00e9 un histograma de las temperaturas simuladas: import matplotlib.pyplot as plt plt.hist(temperaturas,bins=25) plt.show() #el show no hace falta en algunos entornos. A veces lo omitiremos. Ajust\u00e1 la cantidad de bins para que el gr\u00e1fico se vea lo mejor posible. Contenidos | Anterior (1 Random) | Pr\u00f3ximo (3 El album de Figuritas)","title":"Ejercicio 5.9: Empezando a plotear"},{"location":"05_Random_Plt_Dbg/03_Figuritas/","text":"Contenidos | Anterior (2 NumPy) | Pr\u00f3ximo (4 Gr\u00e1ficos del Arbolado porte\u00f1o) 5.3 El album de Figuritas Las figuritas del mundial Esta es una adaptaci\u00f3n de una actividad que dise\u00f1aron nuestres colegas de Exactas-Programa y amablemente nos dejaron usar aqu\u00ed. El objetivo de esta actividad es hacer un programa en Python que responda la pregunta: \u00bfCu\u00e1ntas figuritas hay que comprar para completar el \u00e1lbum del Mundial? Guard\u00e1 todo lo que hagas en un archivo figuritas.py , te lo vamos a pedir al finalizar la clase. Esta pregunta es noticia cada cuatro a\u00f1os: - Mundial de Brasil 2014 - Mundial de Rusia 2018 - Incluso hay un paper que sali\u00f3 referido en el diario Datos: \u00c1lbum con 670 figuritas. Cada figurita se imprime en cantidades iguales y se distribuye aleatoriamente. Cada paquete trae cinco figuritas. Vamos a utilizar este disparador para presentar conceptos clave. Herramientas \u00fatiles de Python Para que est\u00e9n disponibles m\u00e1s funciones de Python, ten\u00e9s que usar el comando import . En particular, en esta actividad vamos a usar dos m\u00f3dulos: - El m\u00f3dulo random lo vamos a importar con el comando import random y lo vamos a usar para generar figuritas (pseudo) aleatoriamente. - El m\u00f3dulo numpy lo vamos a importar con el comando import numpy as np y lo vamos a usar para operar num\u00e9ricamente. El modelo del \u00e1lbum de figuritas Vamos a representar un \u00e1lbum de n figuritas utilizando un vector de NumPy con posiciones numeradas de 0 a n-1. Cada posici\u00f3n representa el estado de una figurita con dos valores: 0 para indicar que a\u00fan no la conseguimos y 1 para indicar que s\u00ed (o, si prefer\u00eds, pod\u00e9s usar un n\u00famero positivo para representar cu\u00e1ntas de esas figus ten\u00e9s, contando repes). Por ejemplo, si tuvi\u00e9ramos un \u00e1lbum de seis figuritas vac\u00edo lo vamos a representar como [0 0 0 0 0 0] . Cuando consigamos la figurita 3 tendremos que indicarlo poniendo un 1 en el tercer lugar de la lista, es decir album[2]=1 y el \u00e1lbum nos va a quedar [0 0 1 0 0 0] , y si queremos representar que nos toc\u00f3 dos veces la figurita 3, asignamos album[2] += 1 y el \u00e1lbum queda [0 0 2 0 0 0] . Primera simplificaci\u00f3n Supon\u00e9 por ahora que las figuritas se compran individualmente (de a una, no en un paquete con cinco). En este caso, la din\u00e1mica del llenado es la siguiente: Iniciamos con un \u00e1lbum vac\u00edo y sin haber comprado ninguna figurita. Compramos figuritas (de a una) hasta llenar el \u00e1lbum; es decir, se repite la acci\u00f3n ( el paso ) de comprar y pegar figuritas mientras (while) el \u00e1lbum est\u00e1 incompleto. Al terminar nos interesa saber cu\u00e1ntas figuritas tuvimos que comprar para llenar el \u00e1lbum. Ejercicios con figus sueltas Vamos ahora a implementar computacionalmente este modelo. Queremos definir las funciones: Ejercicio 5.10: Crear Implement\u00e1 la funci\u00f3n crear_album(figus_total) que devuelve un \u00e1lbum (vector) vac\u00edo con figus_total espacios para pegar figuritas. Ejercicio 5.11: Incompleto \u00bfCu\u00e1l ser\u00eda el comando de Python que nos dice si hay al menos un cero en el vector que representa el \u00e1lbum? \u00bfQu\u00e9 significa que haya al menos un cero en nuestro vector? Implement\u00e1 la funci\u00f3n album_incompleto(A) que recibe un vector y devuelve True si el \u00e1lbum A no est\u00e1 completo y False si est\u00e1 completo. Esta funci\u00f3n y la anterior son realmente sencillas --cada una puede escribirse en una sola l\u00ednea. En otro contexto quizas podr\u00edas usar directamente esa l\u00ednea y evitarte definir la funci\u00f3n. Sin embargo, en esta etapa nos parece interesante que organices tu c\u00f3digo definiendo estas funciones, por m\u00e1s que tengan l\u00ednea de c\u00f3digo cada una. Ejercicio 5.12: Comprar Alguna de las funciones que introdujimos en la Secci\u00f3n 5.1 sirve para devolver un n\u00famero entero aleatorio dentro de un rango (\u00bfcu\u00e1l era?). Implement\u00e1 una funci\u00f3n comprar_figu(figus_total) que reciba el n\u00famero total de figuritas que tiene el \u00e1lbum (dado por el par\u00e1metro figus_total ) y devuelva un n\u00famero entero aleatorio que representa la figurita que nos toc\u00f3. Ejercicio 5.13: Cantidad de compras Implement\u00e1 la funci\u00f3n cuantas_figus(figus_total) que, dado el tama\u00f1o del \u00e1lbum ( figus_total ), genere un \u00e1lbum nuevo, simule su llenado y devuelva la cantidad de figuritas que se debieron comprar para completarlo. Ejercicio 5.14: Ejecut\u00e1 n_repeticiones = 1000 veces la funci\u00f3n anterior utilizando figus_total = 6 y guard\u00e1 en una lista los resultados obtenidos en cada repetici\u00f3n. Con los resultados obtenidos estim\u00e1 cu\u00e1ntas figuritas hay que comprar, en promedio, para completar el \u00e1lbum de seis figuritas. Ayuda: El comando np.mean(l) devuelve el promedio de la lista l . \u00bfPod\u00e9s crear esta lista usando una comprensi\u00f3n de listas? Ejercicio 5.15: Calcul\u00e1 n_repeticiones=100 veces la funci\u00f3n cuantas_figus(figus_total=670) y guard\u00e1 los resultados obtenidos en cada repetici\u00f3n en una lista. Con los resultados obtenidos estim\u00e1 cu\u00e1ntas figuritas hay que comprar, en promedio, para completar el \u00e1lbum (de 670 figuritas). Guard\u00e1 todo lo que hiciste hasta aqu\u00ed sobre figuritas en un archivo figuritas.py . Lo que sigue profundiza un poco m\u00e1s en el asunto. Ahora con paquetes Estos ejercicios te recomendamos que los pienses y discutas con un compa\u00f1ere o alguna de tus otras personalidades (si es que ten\u00e9s): \u00bfC\u00f3mo impacta en lo realizado tener paquetes con figuritas en lugar de figus sueltas? \u00bfC\u00f3mo puede representarse un paquete? Ejercicios con paquetes Ejercicio 5.16: Simul\u00e1 la generaci\u00f3n de un paquete con cinco figuritas, sabiendo que el \u00e1lbum es de 670. Ten\u00e9 en cuenta que, como en la vida real, puede haber figuritas repetidas en un paquete. Ejercicio 5.17: Implement\u00e1 una funci\u00f3n comprar_paquete(figus_total, figus_paquete) que, dado el tama\u00f1o del \u00e1lbum ( figus_total ) y la cantidad de figuritas por paquete ( figus_paquete ), genere un paquete (lista) de figuritas al azar. Ejercicio 5.18: Implement\u00e1 una funci\u00f3n cuantos_paquetes(figus_total, figus_paquete) que dado el tama\u00f1o del \u00e1lbum y la cantidad de figus por paquete, genere un \u00e1lbum nuevo, simule su llenado y devuelva cu\u00e1ntos paquetes se debieron comprar para completarlo. Ejercicio 5.19: Calcul\u00e1 n_repeticiones = 100 veces la funci\u00f3n cuantos_paquetes , utilizando figus_total = 670 , figus_paquete = 5 . Guarda los resultados obtenidos en una lista y calcul\u00e1 su promedio. Si te da la compu, hacelo con 1000 repeticiones. Graficar el llenado del \u00e1lbum El siguiente c\u00f3digo usa las funciones que hiciste antes para graficar la curva de llenado de un \u00e1lbum a medida que compr\u00e1s paquetes de figuritas. Es un primer ejemplo de gr\u00e1fico de l\u00edneas. En las pr\u00f3ximas clases estudiaremos los detalles sobre gr\u00e1ficos de una manera sistem\u00e1tica. Por ahora solo un bot\u00f3n de muestra. def calcular_historia_figus_pegadas(figus_total, figus_paquete): album = crear_album(figus_total) historia_figus_pegadas = [0] while album_incompleto(album): paquete = comprar_paquete(figus_total, figus_paquete) while paquete: album[paquete.pop()] = 1 figus_pegadas = (album>0).sum() historia_figus_pegadas.append(figus_pegadas) return historia_figus_pegadas figus_total = 670 figus_paquete = 5 plt.plot(calcular_historia_figus_pegadas(figus_total, figus_paquete)) plt.xlabel(\"Cantidad de paquetes comprados.\") plt.ylabel(\"Cantidad de figuritas pegadas.\") plt.title(\"La curva de llenado se desacelera al final\") plt.show() Ejercicios un toque m\u00e1s estad\u00edsticos: Los siguientes ejercicios suponen algunos conceptos un poco m\u00e1s avanzados de estad\u00edstica. Son optativos pero interesantes. Ejercicio 5.20: Utilizando lo implementado en el \u00edtem anterior, estim\u00e1 la probabilidad de completar el \u00e1lbum con 850 paquetes o menos. Sugerencia: No leas esto antes de hacer el ejercicio. Hacelo primero y luego miralo. En este ejercicio resulta m\u00e1s compacto usar n_paquetes_hasta_llenar=np.array(lista) para convertir a vector la lista conteniendo cu\u00e1ntos paquetes compraste en cada experimento hasta llenar el \u00e1lbum. Trabajar con vectores tiene ventajas. Por ejemplo prob\u00e1 la siguiente instrucci\u00f3n: (n_paquetes_hasta_llenar <= 850).sum() Ejercicio 5.21: Plotear el histograma Us\u00e1 un c\u00f3digo similar al del Ejercicio 5.9 para hacer un histograma de la cantidad de paquetes que se compraron en cada experimento, ajustando la cantidad de bins para que el gr\u00e1fico se vea lo mejor posible. Ejercicio 5.22: Utilizando lo implementado, estim\u00e1 cu\u00e1ntos paquetes habr\u00eda que comprar para tener una chance del 90% de completar el \u00e1lbum. Ejercicio 5.23: Repet\u00ed suponiendo que no hay figuritas repetidas en un paquete. \u00bfCu\u00e1nto cambian las probabilidades? Ejercicio 5.24: Cooperar vs competir Por \u00faltimo, supon\u00e9 que cinco amigues se juntan y deciden compartir la compra de figuritas y el llenado de sus cinco \u00e1lbumes solidariamente. Calcul\u00e1 cu\u00e1ntos paquetes deber\u00edan comprar si deben completar todos. Hac\u00e9 100 repeticiones y compar\u00e1 el resultado con la compra individual que calculaste antes. Acordate de guardar todo lo que hiciste sobre figuritas en un archivo figuritas.py . Contenidos | Anterior (2 NumPy) | Pr\u00f3ximo (4 Gr\u00e1ficos del Arbolado porte\u00f1o)","title":"03 Figuritas"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#53-el-album-de-figuritas","text":"","title":"5.3 El album de Figuritas"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#las-figuritas-del-mundial","text":"Esta es una adaptaci\u00f3n de una actividad que dise\u00f1aron nuestres colegas de Exactas-Programa y amablemente nos dejaron usar aqu\u00ed. El objetivo de esta actividad es hacer un programa en Python que responda la pregunta: \u00bfCu\u00e1ntas figuritas hay que comprar para completar el \u00e1lbum del Mundial? Guard\u00e1 todo lo que hagas en un archivo figuritas.py , te lo vamos a pedir al finalizar la clase. Esta pregunta es noticia cada cuatro a\u00f1os: - Mundial de Brasil 2014 - Mundial de Rusia 2018 - Incluso hay un paper que sali\u00f3 referido en el diario","title":"Las figuritas del mundial"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#datos","text":"\u00c1lbum con 670 figuritas. Cada figurita se imprime en cantidades iguales y se distribuye aleatoriamente. Cada paquete trae cinco figuritas. Vamos a utilizar este disparador para presentar conceptos clave.","title":"Datos:"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#herramientas-utiles-de-python","text":"Para que est\u00e9n disponibles m\u00e1s funciones de Python, ten\u00e9s que usar el comando import . En particular, en esta actividad vamos a usar dos m\u00f3dulos: - El m\u00f3dulo random lo vamos a importar con el comando import random y lo vamos a usar para generar figuritas (pseudo) aleatoriamente. - El m\u00f3dulo numpy lo vamos a importar con el comando import numpy as np y lo vamos a usar para operar num\u00e9ricamente.","title":"Herramientas \u00fatiles de Python"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#el-modelo-del-album-de-figuritas","text":"Vamos a representar un \u00e1lbum de n figuritas utilizando un vector de NumPy con posiciones numeradas de 0 a n-1. Cada posici\u00f3n representa el estado de una figurita con dos valores: 0 para indicar que a\u00fan no la conseguimos y 1 para indicar que s\u00ed (o, si prefer\u00eds, pod\u00e9s usar un n\u00famero positivo para representar cu\u00e1ntas de esas figus ten\u00e9s, contando repes). Por ejemplo, si tuvi\u00e9ramos un \u00e1lbum de seis figuritas vac\u00edo lo vamos a representar como [0 0 0 0 0 0] . Cuando consigamos la figurita 3 tendremos que indicarlo poniendo un 1 en el tercer lugar de la lista, es decir album[2]=1 y el \u00e1lbum nos va a quedar [0 0 1 0 0 0] , y si queremos representar que nos toc\u00f3 dos veces la figurita 3, asignamos album[2] += 1 y el \u00e1lbum queda [0 0 2 0 0 0] .","title":"El modelo del \u00e1lbum de figuritas"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#primera-simplificacion","text":"Supon\u00e9 por ahora que las figuritas se compran individualmente (de a una, no en un paquete con cinco). En este caso, la din\u00e1mica del llenado es la siguiente: Iniciamos con un \u00e1lbum vac\u00edo y sin haber comprado ninguna figurita. Compramos figuritas (de a una) hasta llenar el \u00e1lbum; es decir, se repite la acci\u00f3n ( el paso ) de comprar y pegar figuritas mientras (while) el \u00e1lbum est\u00e1 incompleto. Al terminar nos interesa saber cu\u00e1ntas figuritas tuvimos que comprar para llenar el \u00e1lbum.","title":"Primera simplificaci\u00f3n"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicios-con-figus-sueltas","text":"Vamos ahora a implementar computacionalmente este modelo. Queremos definir las funciones:","title":"Ejercicios con figus sueltas"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-510-crear","text":"Implement\u00e1 la funci\u00f3n crear_album(figus_total) que devuelve un \u00e1lbum (vector) vac\u00edo con figus_total espacios para pegar figuritas.","title":"Ejercicio 5.10: Crear"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-511-incompleto","text":"\u00bfCu\u00e1l ser\u00eda el comando de Python que nos dice si hay al menos un cero en el vector que representa el \u00e1lbum? \u00bfQu\u00e9 significa que haya al menos un cero en nuestro vector? Implement\u00e1 la funci\u00f3n album_incompleto(A) que recibe un vector y devuelve True si el \u00e1lbum A no est\u00e1 completo y False si est\u00e1 completo. Esta funci\u00f3n y la anterior son realmente sencillas --cada una puede escribirse en una sola l\u00ednea. En otro contexto quizas podr\u00edas usar directamente esa l\u00ednea y evitarte definir la funci\u00f3n. Sin embargo, en esta etapa nos parece interesante que organices tu c\u00f3digo definiendo estas funciones, por m\u00e1s que tengan l\u00ednea de c\u00f3digo cada una.","title":"Ejercicio 5.11: Incompleto"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-512-comprar","text":"Alguna de las funciones que introdujimos en la Secci\u00f3n 5.1 sirve para devolver un n\u00famero entero aleatorio dentro de un rango (\u00bfcu\u00e1l era?). Implement\u00e1 una funci\u00f3n comprar_figu(figus_total) que reciba el n\u00famero total de figuritas que tiene el \u00e1lbum (dado por el par\u00e1metro figus_total ) y devuelva un n\u00famero entero aleatorio que representa la figurita que nos toc\u00f3.","title":"Ejercicio 5.12: Comprar"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-513-cantidad-de-compras","text":"Implement\u00e1 la funci\u00f3n cuantas_figus(figus_total) que, dado el tama\u00f1o del \u00e1lbum ( figus_total ), genere un \u00e1lbum nuevo, simule su llenado y devuelva la cantidad de figuritas que se debieron comprar para completarlo.","title":"Ejercicio 5.13: Cantidad de compras"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-514","text":"Ejecut\u00e1 n_repeticiones = 1000 veces la funci\u00f3n anterior utilizando figus_total = 6 y guard\u00e1 en una lista los resultados obtenidos en cada repetici\u00f3n. Con los resultados obtenidos estim\u00e1 cu\u00e1ntas figuritas hay que comprar, en promedio, para completar el \u00e1lbum de seis figuritas. Ayuda: El comando np.mean(l) devuelve el promedio de la lista l . \u00bfPod\u00e9s crear esta lista usando una comprensi\u00f3n de listas?","title":"Ejercicio 5.14:"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-515","text":"Calcul\u00e1 n_repeticiones=100 veces la funci\u00f3n cuantas_figus(figus_total=670) y guard\u00e1 los resultados obtenidos en cada repetici\u00f3n en una lista. Con los resultados obtenidos estim\u00e1 cu\u00e1ntas figuritas hay que comprar, en promedio, para completar el \u00e1lbum (de 670 figuritas). Guard\u00e1 todo lo que hiciste hasta aqu\u00ed sobre figuritas en un archivo figuritas.py . Lo que sigue profundiza un poco m\u00e1s en el asunto.","title":"Ejercicio 5.15:"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ahora-con-paquetes","text":"Estos ejercicios te recomendamos que los pienses y discutas con un compa\u00f1ere o alguna de tus otras personalidades (si es que ten\u00e9s): \u00bfC\u00f3mo impacta en lo realizado tener paquetes con figuritas en lugar de figus sueltas? \u00bfC\u00f3mo puede representarse un paquete?","title":"Ahora con paquetes"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicios-con-paquetes","text":"","title":"Ejercicios con paquetes"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-516","text":"Simul\u00e1 la generaci\u00f3n de un paquete con cinco figuritas, sabiendo que el \u00e1lbum es de 670. Ten\u00e9 en cuenta que, como en la vida real, puede haber figuritas repetidas en un paquete.","title":"Ejercicio 5.16:"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-517","text":"Implement\u00e1 una funci\u00f3n comprar_paquete(figus_total, figus_paquete) que, dado el tama\u00f1o del \u00e1lbum ( figus_total ) y la cantidad de figuritas por paquete ( figus_paquete ), genere un paquete (lista) de figuritas al azar.","title":"Ejercicio 5.17:"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-518","text":"Implement\u00e1 una funci\u00f3n cuantos_paquetes(figus_total, figus_paquete) que dado el tama\u00f1o del \u00e1lbum y la cantidad de figus por paquete, genere un \u00e1lbum nuevo, simule su llenado y devuelva cu\u00e1ntos paquetes se debieron comprar para completarlo.","title":"Ejercicio 5.18:"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-519","text":"Calcul\u00e1 n_repeticiones = 100 veces la funci\u00f3n cuantos_paquetes , utilizando figus_total = 670 , figus_paquete = 5 . Guarda los resultados obtenidos en una lista y calcul\u00e1 su promedio. Si te da la compu, hacelo con 1000 repeticiones.","title":"Ejercicio 5.19:"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#graficar-el-llenado-del-album","text":"El siguiente c\u00f3digo usa las funciones que hiciste antes para graficar la curva de llenado de un \u00e1lbum a medida que compr\u00e1s paquetes de figuritas. Es un primer ejemplo de gr\u00e1fico de l\u00edneas. En las pr\u00f3ximas clases estudiaremos los detalles sobre gr\u00e1ficos de una manera sistem\u00e1tica. Por ahora solo un bot\u00f3n de muestra. def calcular_historia_figus_pegadas(figus_total, figus_paquete): album = crear_album(figus_total) historia_figus_pegadas = [0] while album_incompleto(album): paquete = comprar_paquete(figus_total, figus_paquete) while paquete: album[paquete.pop()] = 1 figus_pegadas = (album>0).sum() historia_figus_pegadas.append(figus_pegadas) return historia_figus_pegadas figus_total = 670 figus_paquete = 5 plt.plot(calcular_historia_figus_pegadas(figus_total, figus_paquete)) plt.xlabel(\"Cantidad de paquetes comprados.\") plt.ylabel(\"Cantidad de figuritas pegadas.\") plt.title(\"La curva de llenado se desacelera al final\") plt.show()","title":"Graficar el llenado del \u00e1lbum"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicios-un-toque-mas-estadisticos","text":"Los siguientes ejercicios suponen algunos conceptos un poco m\u00e1s avanzados de estad\u00edstica. Son optativos pero interesantes.","title":"Ejercicios un toque m\u00e1s estad\u00edsticos:"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-520","text":"Utilizando lo implementado en el \u00edtem anterior, estim\u00e1 la probabilidad de completar el \u00e1lbum con 850 paquetes o menos. Sugerencia: No leas esto antes de hacer el ejercicio. Hacelo primero y luego miralo. En este ejercicio resulta m\u00e1s compacto usar n_paquetes_hasta_llenar=np.array(lista) para convertir a vector la lista conteniendo cu\u00e1ntos paquetes compraste en cada experimento hasta llenar el \u00e1lbum. Trabajar con vectores tiene ventajas. Por ejemplo prob\u00e1 la siguiente instrucci\u00f3n: (n_paquetes_hasta_llenar <= 850).sum()","title":"Ejercicio 5.20:"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-521-plotear-el-histograma","text":"Us\u00e1 un c\u00f3digo similar al del Ejercicio 5.9 para hacer un histograma de la cantidad de paquetes que se compraron en cada experimento, ajustando la cantidad de bins para que el gr\u00e1fico se vea lo mejor posible.","title":"Ejercicio 5.21: Plotear el histograma"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-522","text":"Utilizando lo implementado, estim\u00e1 cu\u00e1ntos paquetes habr\u00eda que comprar para tener una chance del 90% de completar el \u00e1lbum.","title":"Ejercicio 5.22:"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-523","text":"Repet\u00ed suponiendo que no hay figuritas repetidas en un paquete. \u00bfCu\u00e1nto cambian las probabilidades?","title":"Ejercicio 5.23:"},{"location":"05_Random_Plt_Dbg/03_Figuritas/#ejercicio-524-cooperar-vs-competir","text":"Por \u00faltimo, supon\u00e9 que cinco amigues se juntan y deciden compartir la compra de figuritas y el llenado de sus cinco \u00e1lbumes solidariamente. Calcul\u00e1 cu\u00e1ntos paquetes deber\u00edan comprar si deben completar todos. Hac\u00e9 100 repeticiones y compar\u00e1 el resultado con la compra individual que calculaste antes. Acordate de guardar todo lo que hiciste sobre figuritas en un archivo figuritas.py . Contenidos | Anterior (2 NumPy) | Pr\u00f3ximo (4 Gr\u00e1ficos del Arbolado porte\u00f1o)","title":"Ejercicio 5.24: Cooperar vs competir"},{"location":"05_Random_Plt_Dbg/04_Arboles3_plt/","text":"Contenidos | Anterior (3 El album de Figuritas) | Pr\u00f3ximo (5 Cierre de la clase) 5.4 Gr\u00e1ficos del Arbolado porte\u00f1o Ploteando datos reales En esta secci\u00f3n retomamos el dataset del arbolado porte\u00f1o (arbolado-en-espacios-verdes.csv) para hacer algunos gr\u00e1ficos que nos permitan visualizar los datos. Te damos una gu\u00eda muy elemental sobre c\u00f3mo hacer esto y un par de punteros a la documentaci\u00f3n oficial. Ya esperamos que empieces a poder buscar por tu cuenta la info que falte. Seguiremos trabajando en el archivo arboles.py . Nos basaremos en el trabajo hecho con comprensi\u00f3n de listas la clase pasada. Los siguientes tres ejercicios hacelos dentro de tres funciones diferentes, guardalas y entreg\u00e1 el archivo arboles.py con estos agregados. Ejercicio 5.25: Histograma de altos de Jacarand\u00e1s Usando tu trabajo en el Ejercicio 4.16 , gener\u00e1 un histograma con las alturas de los Jacarand\u00e1s en el dataset. Tu c\u00f3digo deber\u00eda verse similar a este: import os import matplotlib.pyplot as plt os.path.join('..', 'Data', 'arbolado-en-espacios-verdes.csv') arboleda = leer_arboles(nombre_archivo) altos = [comprensi\u00f3n de listas] plt.hist(altos,bins=...) Observaci\u00f3n: Spyder tiene opciones para mostrar las figuras dentro de la misma ventana o en una ventana nueva (Tools -> Preferences -> IPython console -> Graphics -> Backend). Te recomendamos generarlas en una ventana nueva. Luego, con plt.clf() pod\u00e9s borrar la figura actual y con plt.figure() gener\u00e1s una nueva figura por si quer\u00e9s dejar varias abiertas a la vez. Ejercicio 5.26: Scatterplot (di\u00e1metro vs alto) de Jacarand\u00e1s En este ejercicio introducimos un nuevo tipo de gr\u00e1fico: el gr\u00e1fico de dispersi\u00f3n o scatterplot . El mismo usa coordenadas cartesianas para mostrar los valores de dos variables para un conjunto de datos. En este caso vamos a graficar un punto en el plano (x,y) por cada \u00e1rbol en el dataset (o para cada arbol de cierta especie). El punto correspondiente a un \u00e1rbol con di\u00e1metro d y altura h ser\u00e1 ubicado en la posici\u00f3n x=d y y=h . Este tipo de gr\u00e1fico permite visualizar relaciones o tendencias entre las variables y es muy \u00fatil en el an\u00e1lisis exploratorio de datos. Usando como base tu trabajo del Ejercicio 4.17 , vas a generar un scatterplot para visualizar la relaci\u00f3n entre di\u00e1metro y alto de los Jacarand\u00e1s del dataset. Si ya ten\u00e9s una lista o un vector d con di\u00e1metros y otra h con altos, es sencillo hacer un primer scatterplot: import matplotlib.pyplot as plt plt.scatter(d,h) Algunas recomendaciones: 1. Convert\u00ed la lista generada en un ndarray de numpy , de esa forma pod\u00e9s usar rebanadas para obtener un vector d con di\u00e1mteros y otro h con alturas inmediatamente. 2. Mir\u00e1 alg\u00fan ejemplo como este y trat\u00e1 de entender c\u00f3mo se usan los par\u00e1metros opcionales s (de size, tama\u00f1o) y c (de color) y alpha (de transparencia) de la funci\u00f3n matplotlib.pyplot.scatter . 3. Usando el par\u00e1metro alpha hac\u00e9 que el gr\u00e1fico permita visualizar d\u00f3nde hay mayor densidad de datos. \u00bfVes alguna relaci\u00f3n entre el di\u00e1metro y el alto de los Jacarnd\u00e1s? \u00bfTe parece que es una relaci\u00f3n lineal o de otro tipo? Agregale nombres a los ejes y a la figura usando los siguientes comandos: plt.xlabel(\"diametro (cm)\") plt.ylabel(\"alto (m)\") plt.title(\"Relaci\u00f3n di\u00e1metro-alto para Jacarand\u00e1s\") Ejercicio 5.27: Scatterplot para diferentes especies Ahora vamos a usar la funci\u00f3n medidas_de_especies() definida en el Ejercicio 4.18 . Comenzando con \u00e9ste c\u00f3digo, hac\u00e9 tres gr\u00e1ficos como en el ejercicio anterior, uno por cada especie. import os import matplotlib.pyplot as plt os.path.join('..', 'Data', 'arbolado-en-espacios-verdes.csv') arboleda = leer_arboles(nombre_archivo) especies = ['Eucalipto', 'Palo borracho rosado', 'Jacarand\u00e1'] medidas = medidas_de_especies(especies, arboleda) \u00bfSe mantienen las relaciones que viste en el ejercicio anterior para las tres especies? \u00bfHay diferencias entre las especies? Para un mismo alto, \u00bfcu\u00e1l tiene mayor di\u00e1metro (tipicamente)? Para poder comparar diferentes especies resulta conveniente fijar los l\u00edmites en los ejes x e y en las diferentes figuras usando las funciones xlim() e ylim() . A continuaci\u00f3n un ejemplo: plt.xlim(0,30) plt.ylim(0,100) Acordate siempre de ponerle t\u00edtulo a las figuras y nombres y unidades a los ejes. Guard\u00e1 los \u00faltimos tres ejercicios dentro de tres funciones diferentes en tu archivo arboles.py . Te pediremos que lo entregues en la pr\u00f3xima p\u00e1gina. Extra: \u00bfpod\u00e9s hacer un solo gr\u00e1fico que muestre dos de estas tres especies en diferentes colores y resulte claro? \u00bfY las tres especies? Contenidos | Anterior (3 El album de Figuritas) | Pr\u00f3ximo (5 Cierre de la clase)","title":"04 Arboles3 plt"},{"location":"05_Random_Plt_Dbg/04_Arboles3_plt/#54-graficos-del-arbolado-porteno","text":"","title":"5.4 Gr\u00e1ficos del Arbolado porte\u00f1o"},{"location":"05_Random_Plt_Dbg/04_Arboles3_plt/#ploteando-datos-reales","text":"En esta secci\u00f3n retomamos el dataset del arbolado porte\u00f1o (arbolado-en-espacios-verdes.csv) para hacer algunos gr\u00e1ficos que nos permitan visualizar los datos. Te damos una gu\u00eda muy elemental sobre c\u00f3mo hacer esto y un par de punteros a la documentaci\u00f3n oficial. Ya esperamos que empieces a poder buscar por tu cuenta la info que falte. Seguiremos trabajando en el archivo arboles.py . Nos basaremos en el trabajo hecho con comprensi\u00f3n de listas la clase pasada. Los siguientes tres ejercicios hacelos dentro de tres funciones diferentes, guardalas y entreg\u00e1 el archivo arboles.py con estos agregados.","title":"Ploteando datos reales"},{"location":"05_Random_Plt_Dbg/04_Arboles3_plt/#ejercicio-525-histograma-de-altos-de-jacarandas","text":"Usando tu trabajo en el Ejercicio 4.16 , gener\u00e1 un histograma con las alturas de los Jacarand\u00e1s en el dataset. Tu c\u00f3digo deber\u00eda verse similar a este: import os import matplotlib.pyplot as plt os.path.join('..', 'Data', 'arbolado-en-espacios-verdes.csv') arboleda = leer_arboles(nombre_archivo) altos = [comprensi\u00f3n de listas] plt.hist(altos,bins=...) Observaci\u00f3n: Spyder tiene opciones para mostrar las figuras dentro de la misma ventana o en una ventana nueva (Tools -> Preferences -> IPython console -> Graphics -> Backend). Te recomendamos generarlas en una ventana nueva. Luego, con plt.clf() pod\u00e9s borrar la figura actual y con plt.figure() gener\u00e1s una nueva figura por si quer\u00e9s dejar varias abiertas a la vez.","title":"Ejercicio 5.25: Histograma de altos de Jacarand\u00e1s"},{"location":"05_Random_Plt_Dbg/04_Arboles3_plt/#ejercicio-526-scatterplot-diametro-vs-alto-de-jacarandas","text":"En este ejercicio introducimos un nuevo tipo de gr\u00e1fico: el gr\u00e1fico de dispersi\u00f3n o scatterplot . El mismo usa coordenadas cartesianas para mostrar los valores de dos variables para un conjunto de datos. En este caso vamos a graficar un punto en el plano (x,y) por cada \u00e1rbol en el dataset (o para cada arbol de cierta especie). El punto correspondiente a un \u00e1rbol con di\u00e1metro d y altura h ser\u00e1 ubicado en la posici\u00f3n x=d y y=h . Este tipo de gr\u00e1fico permite visualizar relaciones o tendencias entre las variables y es muy \u00fatil en el an\u00e1lisis exploratorio de datos. Usando como base tu trabajo del Ejercicio 4.17 , vas a generar un scatterplot para visualizar la relaci\u00f3n entre di\u00e1metro y alto de los Jacarand\u00e1s del dataset. Si ya ten\u00e9s una lista o un vector d con di\u00e1metros y otra h con altos, es sencillo hacer un primer scatterplot: import matplotlib.pyplot as plt plt.scatter(d,h) Algunas recomendaciones: 1. Convert\u00ed la lista generada en un ndarray de numpy , de esa forma pod\u00e9s usar rebanadas para obtener un vector d con di\u00e1mteros y otro h con alturas inmediatamente. 2. Mir\u00e1 alg\u00fan ejemplo como este y trat\u00e1 de entender c\u00f3mo se usan los par\u00e1metros opcionales s (de size, tama\u00f1o) y c (de color) y alpha (de transparencia) de la funci\u00f3n matplotlib.pyplot.scatter . 3. Usando el par\u00e1metro alpha hac\u00e9 que el gr\u00e1fico permita visualizar d\u00f3nde hay mayor densidad de datos. \u00bfVes alguna relaci\u00f3n entre el di\u00e1metro y el alto de los Jacarnd\u00e1s? \u00bfTe parece que es una relaci\u00f3n lineal o de otro tipo? Agregale nombres a los ejes y a la figura usando los siguientes comandos: plt.xlabel(\"diametro (cm)\") plt.ylabel(\"alto (m)\") plt.title(\"Relaci\u00f3n di\u00e1metro-alto para Jacarand\u00e1s\")","title":"Ejercicio 5.26: Scatterplot (di\u00e1metro vs alto) de Jacarand\u00e1s"},{"location":"05_Random_Plt_Dbg/04_Arboles3_plt/#ejercicio-527-scatterplot-para-diferentes-especies","text":"Ahora vamos a usar la funci\u00f3n medidas_de_especies() definida en el Ejercicio 4.18 . Comenzando con \u00e9ste c\u00f3digo, hac\u00e9 tres gr\u00e1ficos como en el ejercicio anterior, uno por cada especie. import os import matplotlib.pyplot as plt os.path.join('..', 'Data', 'arbolado-en-espacios-verdes.csv') arboleda = leer_arboles(nombre_archivo) especies = ['Eucalipto', 'Palo borracho rosado', 'Jacarand\u00e1'] medidas = medidas_de_especies(especies, arboleda) \u00bfSe mantienen las relaciones que viste en el ejercicio anterior para las tres especies? \u00bfHay diferencias entre las especies? Para un mismo alto, \u00bfcu\u00e1l tiene mayor di\u00e1metro (tipicamente)? Para poder comparar diferentes especies resulta conveniente fijar los l\u00edmites en los ejes x e y en las diferentes figuras usando las funciones xlim() e ylim() . A continuaci\u00f3n un ejemplo: plt.xlim(0,30) plt.ylim(0,100) Acordate siempre de ponerle t\u00edtulo a las figuras y nombres y unidades a los ejes. Guard\u00e1 los \u00faltimos tres ejercicios dentro de tres funciones diferentes en tu archivo arboles.py . Te pediremos que lo entregues en la pr\u00f3xima p\u00e1gina. Extra: \u00bfpod\u00e9s hacer un solo gr\u00e1fico que muestre dos de estas tres especies en diferentes colores y resulte claro? \u00bfY las tres especies? Contenidos | Anterior (3 El album de Figuritas) | Pr\u00f3ximo (5 Cierre de la clase)","title":"Ejercicio 5.27: Scatterplot para diferentes especies"},{"location":"05_Random_Plt_Dbg/05_Cierre/","text":"Contenidos | Anterior (4 Gr\u00e1ficos del Arbolado porte\u00f1o) 5.5 Cierre de la clase En esta clase trabajamos con la generaci\u00f3n de n\u00fameros (pseudo)aleatorios, el uso de la biblioteca NumPy y algunos ejemplos de aplicaci\u00f3n de estos conceptos. Tambi\u00e9n aprendimos a hacer algunos gr\u00e1ficos elementales en Python. Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: El archivo generala.py del Ejercicio 5.2 . El archivo termometro.py del Ejercicio 5.6 y el Ejercicio 5.8 . El archivo plotear_temperaturas.py del Ejercicio 5.9 . El archivo figuritas.py abarcando lo hecho con figuritas (al menos) hasta el Ejercicio 5.15 . El archivo arboles.py incluyendo al menos el Ejercicio 5.26 . Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y podr\u00e1s participar de la revisi\u00f3n de pares. \u00a1Gracias! Nos vemos en la pr\u00f3xima clase. Contenidos | Anterior (4 Gr\u00e1ficos del Arbolado porte\u00f1o)","title":"05 Cierre"},{"location":"05_Random_Plt_Dbg/05_Cierre/#55-cierre-de-la-clase","text":"En esta clase trabajamos con la generaci\u00f3n de n\u00fameros (pseudo)aleatorios, el uso de la biblioteca NumPy y algunos ejemplos de aplicaci\u00f3n de estos conceptos. Tambi\u00e9n aprendimos a hacer algunos gr\u00e1ficos elementales en Python. Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: El archivo generala.py del Ejercicio 5.2 . El archivo termometro.py del Ejercicio 5.6 y el Ejercicio 5.8 . El archivo plotear_temperaturas.py del Ejercicio 5.9 . El archivo figuritas.py abarcando lo hecho con figuritas (al menos) hasta el Ejercicio 5.15 . El archivo arboles.py incluyendo al menos el Ejercicio 5.26 . Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y podr\u00e1s participar de la revisi\u00f3n de pares. \u00a1Gracias! Nos vemos en la pr\u00f3xima clase. Contenidos | Anterior (4 Gr\u00e1ficos del Arbolado porte\u00f1o)","title":"5.5 Cierre de la clase"},{"location":"06_Organizacion_y_Complejidad/00_Resumen/","text":"Contenidos | Anterior (5 Aleatoridad) | Pr\u00f3ximo (7 Dise\u00f1o, especificaci\u00f3n, documentaci\u00f3n y estilo.) 6. Complejidad y Organizaci\u00f3n de programas Hasta aqu\u00ed aprendimos algunas cosas b\u00e1sicas de Python y escribimos nuestros primeros programa. A medida que escribas programas m\u00e1s grandes, vas a necesitar organizarlos un poco mejor. En esta clase trataremos con mayor detalle c\u00f3mo escribir funciones y m\u00f3dulos propios. En la segunda mitad retomamos nuestra discusi\u00f3n sobre algoritmos de b\u00fasqueda e introducimos la b\u00fasqueda binaria, un algoritmo mucho m\u00e1s eficiente para buscar un elemento en un vector. Discutimos algunos conceptos de la teor\u00eda de la complejidad y finalmente haremos unos gr\u00e1ficos para comparar visualmente la cantidad de operaciones que realizan dos m\u00e9todos de b\u00fasqueda. 6.1 Repaso de temas pasados 6.2 Scripting 6.3 Funciones 6.4 M\u00f3dulos 6.5 B\u00fasqueda binaria 6.6 Complejidad de algoritmos 6.7 Gr\u00e1ficos de complejidad 6.8 Cierre de la clase Contenidos | Anterior (5 Aleatoridad) | Pr\u00f3ximo (7 Dise\u00f1o, especificaci\u00f3n, documentaci\u00f3n y estilo.)","title":"00 Resumen"},{"location":"06_Organizacion_y_Complejidad/00_Resumen/#6-complejidad-y-organizacion-de-programas","text":"Hasta aqu\u00ed aprendimos algunas cosas b\u00e1sicas de Python y escribimos nuestros primeros programa. A medida que escribas programas m\u00e1s grandes, vas a necesitar organizarlos un poco mejor. En esta clase trataremos con mayor detalle c\u00f3mo escribir funciones y m\u00f3dulos propios. En la segunda mitad retomamos nuestra discusi\u00f3n sobre algoritmos de b\u00fasqueda e introducimos la b\u00fasqueda binaria, un algoritmo mucho m\u00e1s eficiente para buscar un elemento en un vector. Discutimos algunos conceptos de la teor\u00eda de la complejidad y finalmente haremos unos gr\u00e1ficos para comparar visualmente la cantidad de operaciones que realizan dos m\u00e9todos de b\u00fasqueda. 6.1 Repaso de temas pasados 6.2 Scripting 6.3 Funciones 6.4 M\u00f3dulos 6.5 B\u00fasqueda binaria 6.6 Complejidad de algoritmos 6.7 Gr\u00e1ficos de complejidad 6.8 Cierre de la clase Contenidos | Anterior (5 Aleatoridad) | Pr\u00f3ximo (7 Dise\u00f1o, especificaci\u00f3n, documentaci\u00f3n y estilo.)","title":"6. Complejidad y Organizaci\u00f3n de programas"},{"location":"06_Organizacion_y_Complejidad/01_Repaso/","text":"Contenidos | Pr\u00f3ximo (2 Scripting) 6.1 Repaso de temas pasados A continuaci\u00f3n dejamos unos links a unos videos sobre un par de ejercicios de la clase 5: Ejercicio Ejercicio 5.2 sobre la probabilidad de obtener una generala no servida resuelto por Matias y por Rafael . Ejercicio Ejercicio 5.15 del \u00e1lbum de Figuritas An\u00e1lisis de alternativas para propagar Los siguientes tres ejercicios proponen diferentes soluciones al Ejercicio 4.6 de propagaci\u00f3n del fuego. Vamos a analizar sus diferencias y comenzar a pensar en su eficiencia. Algunas soluciones tienen errores que deber\u00e1s corregir oportunamente. \u00a1Us\u00e1 el debugger de Python! Observaci\u00f3n: Cuando te pidamos que cuentes cu\u00e1ntas operaciones hace una funci\u00f3n, no nos va a importar el detalle de las constantes. Por ejemplo: si una funci\u00f3n para una entrada de largo n hace n+2 operaciones y otra hace 3 n+5 nos va a importar que ambas hacen una cantidad lineal de operaciones en el tama\u00f1o de la entrada, pero no las constantes 2, 3 y 5 que figuran en cada caso. Diremos que la cantidad de operaciones es O(n) (se lee 'o de n'). En cambio, s\u00ed vamos a hacer una diferencia si una funci\u00f3n hace n y otra hace n^2 operaciones (una va a tener complejidad O(n) y la otra O(n^2) ). Volveremos sobre estos temas m\u00e1s adelante. Ejercicio 6.1: Propagar por vecinos El siguiente c\u00f3digo propaga el fuego de c\u00e1da f\u00f3sforo encendido a sus vecinos inmediatos (si son f\u00f3sforos nuevos) a lo largo de toda la lista. Y repite esta operaci\u00f3n mientras sea necesario. \u00bfTe anim\u00e1s a estimar cu\u00e1ntas operaciones puede tener que hacer, en el peor caso? def propagar_al_vecino(l): modif = False n = len(l) for i,e in enumerate(l): if e==1 and i<n-1 and l[i+1]==0: l[i+1] = 1 modif = True if e==1 and i>0 and l[i-1]==0: l[i-1] = 1 modif = True return modif def propagar(l): m = l.copy() veces=0 while propagar_al_vecino(l): veces += 1 print(f\"Repet\u00ed {veces} veces la funci\u00f3n propagar_al_vecino.\") print(f\"Con input {m}\") print(f\"Y obtuve {l}\") return m #%% propagar([0,0,0,0,1]) propagar([0,0,1,0,0]) propagar([1,0,0,0,0]) Preguntas: 1. \u00bfPor qu\u00e9 los tests l[i+1]==0 y l[i-1]==0 de la funci\u00f3n propagar_al_vecino no causan un IndexError en los bordes de la lista? 2. \u00bfPor qu\u00e9 propagar([0,0,0,0,1]) y propagar([1,0,0,0,0]) , siendo entradas perfectamente sim\u00e9tricas, no generan la misma cantidad de repeticiones de llamadas a la funci\u00f3n propagar_al_vecino ? 3. Sobre la complejidad. Si te sale, calcul\u00e1: * \u00bfCu\u00e1ntas veces como m\u00e1ximo se puede repetir el ciclo while en una lista de largo n? * \u00bfCu\u00e1ntas operaciones hace \"propagar_al_vecino\" en una lista de largo n? * Entonces, \u00bfcu\u00e1ntas operaciones hace como m\u00e1ximo esta versi\u00f3n de propagar en una lista de largo n? \u00bfEs un algoritmo de complejidad lineal o cuadr\u00e1tica? Ejercicio 6.2: Propagar por como el auto fant\u00e1stico El siguiente c\u00f3digo propaga el fuego inspirado en las luces del auto fant\u00e1stico . def propagar_a_derecha(l): n = len(l) for i,e in enumerate(l): if e==1 and i<n-1: if l[i+1]==0: l[i+1] = 1 return l #% def propagar_a_izquierda(l): return propagar_a_derecha(l[::-1])[::-1] #% def propagar(l): ld=propagar_a_derecha(l) lp=propagar_a_izquierda(ld) return lp #%% l = [0,0,0,-1,1,0,0,0,-1,0,1,0,0] print(\"Estado original: \",l) print(\"Porpagando...\") lp=propagar(l) print(\"Estado original: \",l) print(\"Estado propagado: \",lp) Preguntas: 1. \u00bfPor qu\u00e9 se modific\u00f3 la lista original? 2. \u00bfPor qu\u00e9 no qued\u00f3 igual al estado propagado ? 3. Correg\u00ed el c\u00f3digo para que no cambie la lista de entrada. 4. \u00bfCu\u00e1ntas operaciones hace como m\u00e1ximo propagar_a_derecha en una lista de largo n? 5. Sabiendo que invertir una lista ( [::-1] ) requiere una cantidad lineal de operaciones en la longitud de la lista \u00bfCu\u00e1ntas operaciones hace como m\u00e1ximo propagar en una lista de largo n? Ejercicio 6.3: Propagar con cadenas Esta versi\u00f3n usa m\u00e9todos de cadenas para resolver el problema separando los f\u00f3sforos en grupos sin f\u00f3sforos quemados y analizando cada grupo. Sin embargo algo falla... def trad2s(l): '''traduce una lista con 1,0 y -1 a una cadena con 'f', 'o' y 'x' ''' d={1:'f', 0 :'o', -1:'x'} s=''.join([d[c] for c in l]) return s def trad2l(ps): '''traduce cadena con 'f', 'o' y 'x' a una lista con 1,0 y -1''' inv_d={'f':1, 'o':0, 'x':-1} l = [inv_d[c] for c in ps] return l def propagar(l, debug = True): s = trad2s(l) if debug: print(s)#, end = ' -> ') W=s.split('x') PW=[w if ('f' not in w) else 'f'*len(w) for w in W] ps=''.join(PW) if debug: print(ps) return trad2l(ps) #%% l = [0,0,0,-1,1,0,0,0,-1,0,1,0,0] lp = propagar(l) print(\"Estado original: \",l) print(\"Estado propagado: \",lp) Preguntas: 1. \u00bfPorqu\u00e9 se acorta la lista? 2. \u00bfPod\u00e9s corregir el error agregando un solo caracter al c\u00f3digo? 3. \u00bfTe parece que este algoritmo es cuadr\u00e1tico como el Ejercicio 6.1 o lineal como el Ejercicio 6.2 ? Contenidos | Pr\u00f3ximo (2 Scripting)","title":"01 Repaso"},{"location":"06_Organizacion_y_Complejidad/01_Repaso/#61-repaso-de-temas-pasados","text":"A continuaci\u00f3n dejamos unos links a unos videos sobre un par de ejercicios de la clase 5: Ejercicio Ejercicio 5.2 sobre la probabilidad de obtener una generala no servida resuelto por Matias y por Rafael . Ejercicio Ejercicio 5.15 del \u00e1lbum de Figuritas","title":"6.1 Repaso de temas pasados"},{"location":"06_Organizacion_y_Complejidad/01_Repaso/#analisis-de-alternativas-para-propagar","text":"Los siguientes tres ejercicios proponen diferentes soluciones al Ejercicio 4.6 de propagaci\u00f3n del fuego. Vamos a analizar sus diferencias y comenzar a pensar en su eficiencia. Algunas soluciones tienen errores que deber\u00e1s corregir oportunamente. \u00a1Us\u00e1 el debugger de Python! Observaci\u00f3n: Cuando te pidamos que cuentes cu\u00e1ntas operaciones hace una funci\u00f3n, no nos va a importar el detalle de las constantes. Por ejemplo: si una funci\u00f3n para una entrada de largo n hace n+2 operaciones y otra hace 3 n+5 nos va a importar que ambas hacen una cantidad lineal de operaciones en el tama\u00f1o de la entrada, pero no las constantes 2, 3 y 5 que figuran en cada caso. Diremos que la cantidad de operaciones es O(n) (se lee 'o de n'). En cambio, s\u00ed vamos a hacer una diferencia si una funci\u00f3n hace n y otra hace n^2 operaciones (una va a tener complejidad O(n) y la otra O(n^2) ). Volveremos sobre estos temas m\u00e1s adelante.","title":"An\u00e1lisis de alternativas para propagar"},{"location":"06_Organizacion_y_Complejidad/01_Repaso/#ejercicio-61-propagar-por-vecinos","text":"El siguiente c\u00f3digo propaga el fuego de c\u00e1da f\u00f3sforo encendido a sus vecinos inmediatos (si son f\u00f3sforos nuevos) a lo largo de toda la lista. Y repite esta operaci\u00f3n mientras sea necesario. \u00bfTe anim\u00e1s a estimar cu\u00e1ntas operaciones puede tener que hacer, en el peor caso? def propagar_al_vecino(l): modif = False n = len(l) for i,e in enumerate(l): if e==1 and i<n-1 and l[i+1]==0: l[i+1] = 1 modif = True if e==1 and i>0 and l[i-1]==0: l[i-1] = 1 modif = True return modif def propagar(l): m = l.copy() veces=0 while propagar_al_vecino(l): veces += 1 print(f\"Repet\u00ed {veces} veces la funci\u00f3n propagar_al_vecino.\") print(f\"Con input {m}\") print(f\"Y obtuve {l}\") return m #%% propagar([0,0,0,0,1]) propagar([0,0,1,0,0]) propagar([1,0,0,0,0]) Preguntas: 1. \u00bfPor qu\u00e9 los tests l[i+1]==0 y l[i-1]==0 de la funci\u00f3n propagar_al_vecino no causan un IndexError en los bordes de la lista? 2. \u00bfPor qu\u00e9 propagar([0,0,0,0,1]) y propagar([1,0,0,0,0]) , siendo entradas perfectamente sim\u00e9tricas, no generan la misma cantidad de repeticiones de llamadas a la funci\u00f3n propagar_al_vecino ? 3. Sobre la complejidad. Si te sale, calcul\u00e1: * \u00bfCu\u00e1ntas veces como m\u00e1ximo se puede repetir el ciclo while en una lista de largo n? * \u00bfCu\u00e1ntas operaciones hace \"propagar_al_vecino\" en una lista de largo n? * Entonces, \u00bfcu\u00e1ntas operaciones hace como m\u00e1ximo esta versi\u00f3n de propagar en una lista de largo n? \u00bfEs un algoritmo de complejidad lineal o cuadr\u00e1tica?","title":"Ejercicio 6.1: Propagar por vecinos"},{"location":"06_Organizacion_y_Complejidad/01_Repaso/#ejercicio-62-propagar-por-como-el-auto-fantastico","text":"El siguiente c\u00f3digo propaga el fuego inspirado en las luces del auto fant\u00e1stico . def propagar_a_derecha(l): n = len(l) for i,e in enumerate(l): if e==1 and i<n-1: if l[i+1]==0: l[i+1] = 1 return l #% def propagar_a_izquierda(l): return propagar_a_derecha(l[::-1])[::-1] #% def propagar(l): ld=propagar_a_derecha(l) lp=propagar_a_izquierda(ld) return lp #%% l = [0,0,0,-1,1,0,0,0,-1,0,1,0,0] print(\"Estado original: \",l) print(\"Porpagando...\") lp=propagar(l) print(\"Estado original: \",l) print(\"Estado propagado: \",lp) Preguntas: 1. \u00bfPor qu\u00e9 se modific\u00f3 la lista original? 2. \u00bfPor qu\u00e9 no qued\u00f3 igual al estado propagado ? 3. Correg\u00ed el c\u00f3digo para que no cambie la lista de entrada. 4. \u00bfCu\u00e1ntas operaciones hace como m\u00e1ximo propagar_a_derecha en una lista de largo n? 5. Sabiendo que invertir una lista ( [::-1] ) requiere una cantidad lineal de operaciones en la longitud de la lista \u00bfCu\u00e1ntas operaciones hace como m\u00e1ximo propagar en una lista de largo n?","title":"Ejercicio 6.2: Propagar por como el auto fant\u00e1stico"},{"location":"06_Organizacion_y_Complejidad/01_Repaso/#ejercicio-63-propagar-con-cadenas","text":"Esta versi\u00f3n usa m\u00e9todos de cadenas para resolver el problema separando los f\u00f3sforos en grupos sin f\u00f3sforos quemados y analizando cada grupo. Sin embargo algo falla... def trad2s(l): '''traduce una lista con 1,0 y -1 a una cadena con 'f', 'o' y 'x' ''' d={1:'f', 0 :'o', -1:'x'} s=''.join([d[c] for c in l]) return s def trad2l(ps): '''traduce cadena con 'f', 'o' y 'x' a una lista con 1,0 y -1''' inv_d={'f':1, 'o':0, 'x':-1} l = [inv_d[c] for c in ps] return l def propagar(l, debug = True): s = trad2s(l) if debug: print(s)#, end = ' -> ') W=s.split('x') PW=[w if ('f' not in w) else 'f'*len(w) for w in W] ps=''.join(PW) if debug: print(ps) return trad2l(ps) #%% l = [0,0,0,-1,1,0,0,0,-1,0,1,0,0] lp = propagar(l) print(\"Estado original: \",l) print(\"Estado propagado: \",lp) Preguntas: 1. \u00bfPorqu\u00e9 se acorta la lista? 2. \u00bfPod\u00e9s corregir el error agregando un solo caracter al c\u00f3digo? 3. \u00bfTe parece que este algoritmo es cuadr\u00e1tico como el Ejercicio 6.1 o lineal como el Ejercicio 6.2 ? Contenidos | Pr\u00f3ximo (2 Scripting)","title":"Ejercicio 6.3: Propagar con cadenas"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/","text":"Contenidos | Anterior (1 Repaso de temas pasados) | Pr\u00f3ximo (3 Funciones) 6.2 Scripting En esta secci\u00f3n profundizaremos en el proceso de crear scripts en Python. Esta y las pr\u00f3ximas secciones tienen un video asociado que pod\u00e9s ver antes de leer este texto. \u00bfQu\u00e9 es un script? Un script es un programa que ejecuta una serie de comandos y termina. Programa en el sentido cl\u00e1sico de la palabra: una secuencia de eventos. Su traducci\u00f3n literal es gui\u00f3n , como el gui\u00f3n de una pel\u00edcula, con introducci\u00f3n, nudo y desenlace. # programa.py comando1 comando2 comando3 ... Hasta aqu\u00ed mayormente hemos escrito scripts. Un problema Cuando hayas escrito un script \u00fatil, \u00e9ste va a comenzar a crecer en funciones y opciones. Vas a querer aplicarlo a otros problemas. Con el tiempo puede convertirse en un programa esencial, pero si no lo cuid\u00e1s puede convertirse en un l\u00edo enorme, en un gran embrollo. Veamos como lo organizamos. Definir nombres Los nombres deben estar definidos antes de usarse. def cuadrado (x): return x*x a = 42 b = a + 2 # Requiere que 'a' haya sido definido antes. z = cuadrado (b) # Requiere que 'cuadrado' y 'b' est\u00e9n definidos. El orden importa. Casi siempre definimos las variables y las funciones al comienzo. Definir funciones Es muy \u00fatil agrupar todo el c\u00f3digo relevante a una misma tarea en el mismo lugar. Para eso sirven las funciones. def leer_precios(nombre_archivo): precios = {} with open(nombre_archivo) as f: f_csv = csv.reader(f) for linea in f_csv: precios[linea[0]] = float(linea[1]) return precios Una funci\u00f3n simplifica las operaciones repetitivas. preciosviejos = leer_precios('preciosviejos.csv') preciosnuevos = leer_precios('preciosnuevos.csv') \u00bfQu\u00e9 es una funci\u00f3n? Una funci\u00f3n es una secuencia de comandos, con un nombre. def nombrefunc(args): comando comando ... return resultado Cualquier comando de Python puede usarse dentro de una funci\u00f3n. def foo(): import math print(math.sqrt(2)) help(math) No existen comandos especiales en Python (lo cual es muy f\u00e1cil de recordar). D\u00f3nde definir funciones En Python podemos definir funciones en cualquier orden. def foo(x): bar(x) def bar(x): comandos # OR def bar(x): comandos def foo(x): bar(x) El \u00fanico requisito es que la funci\u00f3n est\u00e9 definida al momento de ser usada (o llamada) durante la ejecuci\u00f3n de un programa. foo(3) # foo tiene que haber sido definida antes El estilo que preferimos es definir funciones desde abajo hacia arriba (\" bottom-up \") El estilo Bottom-Up Este estilo trata a las funciones como ladrillos. Los ladrillos simples \u00f3 m\u00e1s peque\u00f1os se definen primero, y luego se usan para armar funciones m\u00e1s complejas. # miprograma.py def foo(x): ... def bar(x): ... foo(x) # Definida antes ... def spam(x): ... bar(x) # Definida antes ... spam(42) # El c\u00f3digo que *usa* la funci\u00f3n est\u00e1 al final Las funciones complejas se basan en funciones m\u00e1s simples, definidas antes; aunque esto es s\u00f3lo una cuesti\u00f3n de estilo. Lo \u00fanico que realmente importa en \u00e9se programa es que la llamada a spam(42) est\u00e9 despu\u00e9s que la declaraci\u00f3n de las funciones que \u00e9ste invoca. El orden de las definiciones puede variar, siempre que sea anterior a su uso real. Dise\u00f1o de funciones Lo ideal es que una funci\u00f3n sea una caja negra . Una funci\u00f3n deber\u00eda operar \u00fanicamente sobre los par\u00e1metros provistos, evitar variables globales y efectos secundarios no esperados. Hay dos conceptos clave: Dise\u00f1o Modular y Predecibilidad . Doc-strings Es buena costumbre incluir documentaci\u00f3n en forma de doc-strings. Un doc-string \u00f3 \"texto de documentaci\u00f3n\" es texto ubicado en la l\u00ednea inmediata despu\u00e9s del nombre de la funci\u00f3n. El doc-string provee informaci\u00f3n a quien lee la funci\u00f3n, pero tambi\u00e9n se integra con la funci\u00f3n help() , IDEs y otras herramientas de programaci\u00f3n y documentaci\u00f3n. def leer_precios(nombre_archivo): ''' Lee precios de un archivo de datos CSV con dos columnas. La primera columna debe contener un nombre y la segunda un precio. ''' precios = {} with open(nombre_archivo) as f: f_csv = csv.reader(f) for row in f_csv: precios[linea[0]] = float(linea[1]) return precios Un doc-string debe ser conciso e indicar qu\u00e9 hace la funci\u00f3n. Si es necesario, pod\u00e9s incluir un ejemplo corto de uso y una descripci\u00f3n de los argumentos. Veremos tambi\u00e9n la clase que viene que es posible incluir en el doc-string una descripci\u00f3n de lo que se espera que cumplan los par\u00e1metros y lo que garantizamos que cumpla la salida (como un contrato). Notas sobre el tipo de datos Tambi\u00e9n pod\u00e9s agregar, en la definici\u00f3n de funciones, notas sobre el tipo de datos de los par\u00e1metros y de la funci\u00f3n. def leer_precios(nombre_archivo: str) -> dict: ''' Lee precios de un archivo de datos CSV con dos columnas. La primera columna debe contener un nombre y la segunda un precio. Devuelve un diccionario {nombre:precio, ...} ''' precios = {} with open(nombre_archivo) as f: f_csv = csv.reader(f) for linea in f_csv: precios[linea[0]] = float(linea[1]) return precios Estas notas no modifican al programa y son puramente informativas. A\u00fan as\u00ed pueden ser usadas por IDEs, comprobadores de c\u00f3digo, y otras herramientas. Aunque -> dict indica al programador que la funci\u00f3n devuelve un diccionario, es \u00fatil anotar en el doc-string la estructura del diccionario devuelto. Ejercicios En el Ejercicio 3.16 (o el Ejercicio 3.15 ) escribiste un programa llamado tabla_informe.py que imprime un informe con el balance de compra y venta de frutas en un cami\u00f3n. El programa tiene algunas funciones, como: # tabla_informe.py import csv def leer_camion(nombre_archivo): ''' Lee un archivo de lotes en un cami\u00f3n y lo devuelve como lista de diccionarios con claves nombre, cajones, precio. ''' camion = [] with open(nombre_archivo) as f: rows = csv.reader(f) headers = next(rows) for row in rows: record = dict(zip(headers, row)) cajon = { 'nombre' : record['nombre'], 'cajones' : int(record['cajones']), 'precio' : float(record['precio']) } camion.append(cajon) return camion ... Sin embargo hab\u00eda tambi\u00e9n partes del programa que ejecutaban una serie de c\u00e1lculos en forma de script. Este c\u00f3digo estaba casi al final del programa. Por ejemplo: ... # Output the informe headers = ('Nombre', 'Cajones', 'Precio', 'Cambio') print('%10s %10s %10s %10s' % headers) print(('-' * 10 + ' ') * len(headers)) for row in informe: print('%10s %10d %10.2f %10.2f' % row) ... En el siguiente ejercicio vamos a volver a ese programa y organizarlo mejor usando funciones. Ejercicio 6.4: Estructurar un programa como una colecci\u00f3n de funciones Volv\u00e9 a tu programa tabla_informe.py y modificalo de modo que todas las operaciones principales, incluyendo c\u00e1lculos e impresi\u00f3n, sean llevados a cabo por una colecci\u00f3n de funciones. Guarda la nueva versi\u00f3n en un archivo informe_funciones.py . M\u00e1s espec\u00edficamente: Cre\u00e1 una funci\u00f3n imprimir_informe(informe) que imprima el informe. Cambi\u00e1 la \u00faltima parte del programa de modo que consista s\u00f3lo en una serie de llamados a funciones, sin ning\u00fan c\u00f3mputo. Ejercicio 6.5: Crear una funci\u00f3n de alto nivel para la ejecuci\u00f3n del programa. Junt\u00e1 la \u00faltima parte de tu programa en una \u00fanica funci\u00f3n informe_camion(nombre_archivo_camion, nombre_archivo_precios) . Deber\u00edas obtener una funci\u00f3n que al llamarla como sigue, imprima el informe: informe_camion('../Data/camion.csv', '../Data/precios.csv') En su versi\u00f3n final tu programa ser\u00e1 una serie de definiciones de funciones seguidos por un \u00fanico llamado a la funcion informe_camion() (la cual ejecuta todos los pasos que constituyen tu programa). Cuando tu programa es una \u00fanica funci\u00f3n, es muy simple ejecutarlo con diferentes entradas. Por ejemplo, despu\u00e9s de ejecutar tu programa prob\u00e1 estos comandos en modo interactivo: >>> informe_camion('../Data/camion2.csv', '../Data/precios.csv') ... mir\u00e1 el resultado ... >>> files = ['../Data/camion.csv', '../Data/camion2.csv'] >>> for name in files: print(f'{name:-^43s}') informe_camion(name, '../Data/precios.csv') print() ... mir\u00e1 el resultado ... >>> Comentario En Python es muy f\u00e1cil escribir c\u00f3digo en forma de un script relativamente poco estructurado, en el que ten\u00e9s un archivo que contiene una secuencia de comandos. A la larga, casi siempre es mejor convertir estos scripts en funciones para organizar el c\u00f3digo. En alg\u00fan momento, si ese script crece, vas a desear haber sido un poco m\u00e1s organizado desde el comienzo. Trat\u00e1 de organizar tu c\u00f3digo en funciones simples. Es un buen principio es que cada funci\u00f3n haga una sola cosa sencilla y concreta, que tenga una sola responsabilidad. Contenidos | Anterior (1 Repaso de temas pasados) | Pr\u00f3ximo (3 Funciones)","title":"02 Scripts"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#62-scripting","text":"En esta secci\u00f3n profundizaremos en el proceso de crear scripts en Python. Esta y las pr\u00f3ximas secciones tienen un video asociado que pod\u00e9s ver antes de leer este texto.","title":"6.2 Scripting"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#que-es-un-script","text":"Un script es un programa que ejecuta una serie de comandos y termina. Programa en el sentido cl\u00e1sico de la palabra: una secuencia de eventos. Su traducci\u00f3n literal es gui\u00f3n , como el gui\u00f3n de una pel\u00edcula, con introducci\u00f3n, nudo y desenlace. # programa.py comando1 comando2 comando3 ... Hasta aqu\u00ed mayormente hemos escrito scripts.","title":"\u00bfQu\u00e9 es un script?"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#un-problema","text":"Cuando hayas escrito un script \u00fatil, \u00e9ste va a comenzar a crecer en funciones y opciones. Vas a querer aplicarlo a otros problemas. Con el tiempo puede convertirse en un programa esencial, pero si no lo cuid\u00e1s puede convertirse en un l\u00edo enorme, en un gran embrollo. Veamos como lo organizamos.","title":"Un problema"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#definir-nombres","text":"Los nombres deben estar definidos antes de usarse. def cuadrado (x): return x*x a = 42 b = a + 2 # Requiere que 'a' haya sido definido antes. z = cuadrado (b) # Requiere que 'cuadrado' y 'b' est\u00e9n definidos. El orden importa. Casi siempre definimos las variables y las funciones al comienzo.","title":"Definir nombres"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#definir-funciones","text":"Es muy \u00fatil agrupar todo el c\u00f3digo relevante a una misma tarea en el mismo lugar. Para eso sirven las funciones. def leer_precios(nombre_archivo): precios = {} with open(nombre_archivo) as f: f_csv = csv.reader(f) for linea in f_csv: precios[linea[0]] = float(linea[1]) return precios Una funci\u00f3n simplifica las operaciones repetitivas. preciosviejos = leer_precios('preciosviejos.csv') preciosnuevos = leer_precios('preciosnuevos.csv')","title":"Definir funciones"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#que-es-una-funcion","text":"Una funci\u00f3n es una secuencia de comandos, con un nombre. def nombrefunc(args): comando comando ... return resultado Cualquier comando de Python puede usarse dentro de una funci\u00f3n. def foo(): import math print(math.sqrt(2)) help(math) No existen comandos especiales en Python (lo cual es muy f\u00e1cil de recordar).","title":"\u00bfQu\u00e9 es una funci\u00f3n?"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#donde-definir-funciones","text":"En Python podemos definir funciones en cualquier orden. def foo(x): bar(x) def bar(x): comandos # OR def bar(x): comandos def foo(x): bar(x) El \u00fanico requisito es que la funci\u00f3n est\u00e9 definida al momento de ser usada (o llamada) durante la ejecuci\u00f3n de un programa. foo(3) # foo tiene que haber sido definida antes El estilo que preferimos es definir funciones desde abajo hacia arriba (\" bottom-up \")","title":"D\u00f3nde definir funciones"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#el-estilo-bottom-up","text":"Este estilo trata a las funciones como ladrillos. Los ladrillos simples \u00f3 m\u00e1s peque\u00f1os se definen primero, y luego se usan para armar funciones m\u00e1s complejas. # miprograma.py def foo(x): ... def bar(x): ... foo(x) # Definida antes ... def spam(x): ... bar(x) # Definida antes ... spam(42) # El c\u00f3digo que *usa* la funci\u00f3n est\u00e1 al final Las funciones complejas se basan en funciones m\u00e1s simples, definidas antes; aunque esto es s\u00f3lo una cuesti\u00f3n de estilo. Lo \u00fanico que realmente importa en \u00e9se programa es que la llamada a spam(42) est\u00e9 despu\u00e9s que la declaraci\u00f3n de las funciones que \u00e9ste invoca. El orden de las definiciones puede variar, siempre que sea anterior a su uso real.","title":"El estilo Bottom-Up"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#diseno-de-funciones","text":"Lo ideal es que una funci\u00f3n sea una caja negra . Una funci\u00f3n deber\u00eda operar \u00fanicamente sobre los par\u00e1metros provistos, evitar variables globales y efectos secundarios no esperados. Hay dos conceptos clave: Dise\u00f1o Modular y Predecibilidad .","title":"Dise\u00f1o de funciones"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#doc-strings","text":"Es buena costumbre incluir documentaci\u00f3n en forma de doc-strings. Un doc-string \u00f3 \"texto de documentaci\u00f3n\" es texto ubicado en la l\u00ednea inmediata despu\u00e9s del nombre de la funci\u00f3n. El doc-string provee informaci\u00f3n a quien lee la funci\u00f3n, pero tambi\u00e9n se integra con la funci\u00f3n help() , IDEs y otras herramientas de programaci\u00f3n y documentaci\u00f3n. def leer_precios(nombre_archivo): ''' Lee precios de un archivo de datos CSV con dos columnas. La primera columna debe contener un nombre y la segunda un precio. ''' precios = {} with open(nombre_archivo) as f: f_csv = csv.reader(f) for row in f_csv: precios[linea[0]] = float(linea[1]) return precios Un doc-string debe ser conciso e indicar qu\u00e9 hace la funci\u00f3n. Si es necesario, pod\u00e9s incluir un ejemplo corto de uso y una descripci\u00f3n de los argumentos. Veremos tambi\u00e9n la clase que viene que es posible incluir en el doc-string una descripci\u00f3n de lo que se espera que cumplan los par\u00e1metros y lo que garantizamos que cumpla la salida (como un contrato).","title":"Doc-strings"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#notas-sobre-el-tipo-de-datos","text":"Tambi\u00e9n pod\u00e9s agregar, en la definici\u00f3n de funciones, notas sobre el tipo de datos de los par\u00e1metros y de la funci\u00f3n. def leer_precios(nombre_archivo: str) -> dict: ''' Lee precios de un archivo de datos CSV con dos columnas. La primera columna debe contener un nombre y la segunda un precio. Devuelve un diccionario {nombre:precio, ...} ''' precios = {} with open(nombre_archivo) as f: f_csv = csv.reader(f) for linea in f_csv: precios[linea[0]] = float(linea[1]) return precios Estas notas no modifican al programa y son puramente informativas. A\u00fan as\u00ed pueden ser usadas por IDEs, comprobadores de c\u00f3digo, y otras herramientas. Aunque -> dict indica al programador que la funci\u00f3n devuelve un diccionario, es \u00fatil anotar en el doc-string la estructura del diccionario devuelto.","title":"Notas sobre el tipo de datos"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#ejercicios","text":"En el Ejercicio 3.16 (o el Ejercicio 3.15 ) escribiste un programa llamado tabla_informe.py que imprime un informe con el balance de compra y venta de frutas en un cami\u00f3n. El programa tiene algunas funciones, como: # tabla_informe.py import csv def leer_camion(nombre_archivo): ''' Lee un archivo de lotes en un cami\u00f3n y lo devuelve como lista de diccionarios con claves nombre, cajones, precio. ''' camion = [] with open(nombre_archivo) as f: rows = csv.reader(f) headers = next(rows) for row in rows: record = dict(zip(headers, row)) cajon = { 'nombre' : record['nombre'], 'cajones' : int(record['cajones']), 'precio' : float(record['precio']) } camion.append(cajon) return camion ... Sin embargo hab\u00eda tambi\u00e9n partes del programa que ejecutaban una serie de c\u00e1lculos en forma de script. Este c\u00f3digo estaba casi al final del programa. Por ejemplo: ... # Output the informe headers = ('Nombre', 'Cajones', 'Precio', 'Cambio') print('%10s %10s %10s %10s' % headers) print(('-' * 10 + ' ') * len(headers)) for row in informe: print('%10s %10d %10.2f %10.2f' % row) ... En el siguiente ejercicio vamos a volver a ese programa y organizarlo mejor usando funciones.","title":"Ejercicios"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#ejercicio-64-estructurar-un-programa-como-una-coleccion-de-funciones","text":"Volv\u00e9 a tu programa tabla_informe.py y modificalo de modo que todas las operaciones principales, incluyendo c\u00e1lculos e impresi\u00f3n, sean llevados a cabo por una colecci\u00f3n de funciones. Guarda la nueva versi\u00f3n en un archivo informe_funciones.py . M\u00e1s espec\u00edficamente: Cre\u00e1 una funci\u00f3n imprimir_informe(informe) que imprima el informe. Cambi\u00e1 la \u00faltima parte del programa de modo que consista s\u00f3lo en una serie de llamados a funciones, sin ning\u00fan c\u00f3mputo.","title":"Ejercicio 6.4: Estructurar un programa como una colecci\u00f3n de funciones"},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#ejercicio-65-crear-una-funcion-de-alto-nivel-para-la-ejecucion-del-programa","text":"Junt\u00e1 la \u00faltima parte de tu programa en una \u00fanica funci\u00f3n informe_camion(nombre_archivo_camion, nombre_archivo_precios) . Deber\u00edas obtener una funci\u00f3n que al llamarla como sigue, imprima el informe: informe_camion('../Data/camion.csv', '../Data/precios.csv') En su versi\u00f3n final tu programa ser\u00e1 una serie de definiciones de funciones seguidos por un \u00fanico llamado a la funcion informe_camion() (la cual ejecuta todos los pasos que constituyen tu programa). Cuando tu programa es una \u00fanica funci\u00f3n, es muy simple ejecutarlo con diferentes entradas. Por ejemplo, despu\u00e9s de ejecutar tu programa prob\u00e1 estos comandos en modo interactivo: >>> informe_camion('../Data/camion2.csv', '../Data/precios.csv') ... mir\u00e1 el resultado ... >>> files = ['../Data/camion.csv', '../Data/camion2.csv'] >>> for name in files: print(f'{name:-^43s}') informe_camion(name, '../Data/precios.csv') print() ... mir\u00e1 el resultado ... >>>","title":"Ejercicio 6.5: Crear una funci\u00f3n de alto nivel para la ejecuci\u00f3n del programa."},{"location":"06_Organizacion_y_Complejidad/02_Scripts/#comentario","text":"En Python es muy f\u00e1cil escribir c\u00f3digo en forma de un script relativamente poco estructurado, en el que ten\u00e9s un archivo que contiene una secuencia de comandos. A la larga, casi siempre es mejor convertir estos scripts en funciones para organizar el c\u00f3digo. En alg\u00fan momento, si ese script crece, vas a desear haber sido un poco m\u00e1s organizado desde el comienzo. Trat\u00e1 de organizar tu c\u00f3digo en funciones simples. Es un buen principio es que cada funci\u00f3n haga una sola cosa sencilla y concreta, que tenga una sola responsabilidad. Contenidos | Anterior (1 Repaso de temas pasados) | Pr\u00f3ximo (3 Funciones)","title":"Comentario"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/","text":"Contenidos | Anterior (2 Scripting) | Pr\u00f3ximo (4 M\u00f3dulos) 6.3 Funciones Aunque ya hablamos sobre funciones, dimos pocos detalles sobre su funcionamiento a un nivel algo m\u00e1s profundo. En esta secci\u00f3n esperamos completar algunos conceptos como convenciones de uso, alcance ( scope ) y otros temas. Llamando a una funci\u00f3n Imagin\u00e1 la siguiente funci\u00f3n: def leer_precios(nombre_archivo, debug): ... Pod\u00e9s llamar a la funci\u00f3n pasando los argumentos por orden: precios = leer_precios('precios.csv', True) O pod\u00e9s llamarla usando palabras clave ( keywords ): precios = leer_precios(nombre_archivo = 'precios.csv', debug = True) Argumentos por omisi\u00f3n Si prefer\u00eds que un argumento sea opcional (que tenga un valor por omisi\u00f3n o by default ), en ese caso asignale un valor en la definici\u00f3n de la funci\u00f3n. \u00c9se ser\u00e1 el valor del argumento si llam\u00e1s a la funci\u00f3n sin especificar un valor para ese argumento. def leer_precios(nombre_archivo, debug = False): ... En la declaraci\u00f3n de la funci\u00f3n pod\u00e9s asignar un valor a un argumento. Entonces, ese argumento ser\u00e1 opcional al invocar a esa funcion y si lo omit\u00eds al invocar a la funci\u00f3n va a tomar su valor asignado. A ese valor lo llamamos valor por omisi\u00f3n. d = leer_precios('precios.csv') e = leer_precios('precios.dat', True) Nota: Todos los argumentos con valores por omisi\u00f3n deben aparecer al final de la lista de argumentos (primero se declaran todos los argumentos no-opcionales) Si un argumento es opcional, dale un nombre. Comparemos estos dos estilos de invocar funciones: cortar_datos(data, False, True) # ????? cortar_datos(data, ignore_errores = True) cortar_datos(data, debug = True) cortar_datos(data, debug = True, ignore_errores = True) En la mayor\u00eda de los casos los argumentos con nombre hacen al c\u00f3digo m\u00e1s claro, m\u00e1s f\u00e1cil de entender, especialmente si estos argumentos son booleanos, que determinan opciones si-no. Buenas pr\u00e1cticas de dise\u00f1o Compar\u00e1 estas dos formas de declarar una misma funci\u00f3n. Para comprender c\u00f3mo usar la primera, tendr\u00edamos que explorar dentro de la funci\u00f3n y saber que significan sus par\u00e1metros. Us\u00e1 siempre nombres cortos para los argumentos, pero con significado. def leer_precios(f, d = False): ... def leer_precios(nombre_archivo, debug = False): ... Quien use la funci\u00f3n podr\u00eda elegir llamarla con argumentos nombrados. d = leer_precios('precios.csv', debug = True) Hay herramientas que crean autom\u00e1ticamente documentaci\u00f3n sobre el uso de las funciones y sus argumentos. Si los nombres tienen significado, la documentaci\u00f3n resulta m\u00e1s clara. Devolver un resultado El comando return termina la funci\u00f3n y devuelve un valor. def cuadrado(x): return x * x Si no se define un resultado, o si falta el comando return, la funci\u00f3n devuelve la constante None . def bar(x): instrucciones return a = bar(4) # a = None # O TAMBIEN... def foo(x): instrucciones # No hay `return` b = foo(4) # b = None Devolver m\u00faltiples resultados Las funciones s\u00f3lo pueden devolver una cosa. Si necesit\u00e1s devolver m\u00e1s de un valor, pod\u00e9s armar una tupla con ellos y devolver la tupla. def dividir(a,b): c = a // b # Cociente r = a % b # Resto return c, r # Devolver una tupla con c y r Ejemplo: x, y = dividir(37,5) # x = 7, y = 2 x = dividir(37, 5) # x = (7, 2) Alcance de variables En un programa se declaran variables y se les asignan valores. Esto ocurre dentro y fuera de funciones. x = valor # Variable Global def foo(): y = valor # Variable Local Las variables declaradas fuera de funciones son \"globales\". Las variables declaradas dentro de funciones son \"locales\". A esto se llama el alcance ( scope ) de una variable. Variables locales Las variables locales, declaradas dentro de funciones, son privadas. def leer_camion(nombre_archivo): camion = [] for linea in open(nombre_archivo): campos = line.split(',') s = (campos[0], int(campos[1]), float(campos[2])) camion.append(s) return camion En este ejemplo, nombre_archivo , camion , linea , campos y s son variables locales. >>> cajones = leer_camion('camion.csv') >>> campos Traceback (most recent call last): File \"<stdin>\", line 1, in ? NameError: name 'campos' is not defined >>> El error significa: Error de Nombre: el nombre 'campos' no est\u00e1 definido. No hay conflicto entre variables locales y variables declaradas en otras partes (funciones o globales). Variables globales Desde cualquier funci\u00f3n se puede acceder a las variables globales declaradas en ese mismo archivo. nombre = 'Dave' def saludo(): print('Hola', nombre) # Usa la variable global `nombre` Las funciones, sin embargo, no alteran normalmente el valor de una variable global. nombre = 'Dave' def spam(): nombre = 'Guido' spam() print(nombre) # imprime 'Dave' Aqu\u00ed hay dos variables diferentes: nombre global, que vale 'Dave' , y nombre local, declarada dentro de la funci\u00f3n spam() que vale 'Guido' . Cambiar una no cambia la otra: al cambiar el valor de nombre local, nombre global no cambia. Acordate: Las asignaciones de valores a variables y las declaraciones de variables dentro de funciones son locales. Modificar el valor de una variable global Si necesit\u00e1s modificar el valor de una variable global desde dentro de una funci\u00f3n, la variable tiene que estar declarada como global dentro de la misma funci\u00f3n. nombre = 'Dave' def spam(): global nombre nombre = 'Guido' # Cambia el valor de la variable global Si declaramos global nombre dentro de la funci\u00f3n, entonces nombre fuera de la funci\u00f3n spam() y dentro de la funci\u00f3n spam() refieren a la misma variable, y al modificar una de ellas modific\u00e1s la otra. La declaraci\u00f3n de globalidad de la variable (con la palabra reservada global ) tiene que aparecer antes del uso de la variable dentro de una funci\u00f3n, y la declaraci\u00f3n de la variable global fuera de la funci\u00f3n debe ocurrir en el mismo archivo que \u00e9sta. Dicho esto, hay que decir tambi\u00e9n que usar variables globales se considera una mala pr\u00e1ctica. Trat\u00e1 de evitar completamente el uso de global . Si ten\u00e9s una funci\u00f3n que depende del estado de una variable global, tu programa es menos modular: no pod\u00e9s reutilizar la funci\u00f3n en otro contexto sin agregar una variable global. Si necesit\u00e1s que una funci\u00f3n modifique el estado de algo fuera de esa funci\u00f3n, es mejor entonces usar una clase en lugar de una funci\u00f3n. Hablaremos de \u00e9sto m\u00e1s adelante, en la segunda mitad de la materia. Pasaje de argumentos Cuando llam\u00e1s a una funci\u00f3n, los argumentos son los nombres que refieren a los valores que le pas\u00e1s. Estos valores no son copias de los originales (ver Secci\u00f3n 4.4 ). Si le pas\u00e1s tipos mutables, como listas o diccionarios, la funci\u00f3n s\u00ed los puede modificar. def foo(items): items.append(42) # Cambia el valor de items a = [1, 2, 3] foo(a) print(a) # [1, 2, 3, 42] Fundamental: Las funciones no reciben una copia de los argumentos, sino los argumentos mismos. Reasignar versus modificar Existe una sutil pero importante diferencia entre modificar el valor de una variable y reasignar una variable. Es importante que entiendas esta diferencia. def foo(items): items.append(42) # Modifica el valor de 'items' a = [1, 2, 3] foo(a) print(a) # [1, 2, 3, 42] # Versus def bar(items): items = [4,5,6] # Cambia la variable local 'items' y # hace que apunte a otro objeto completamente diferente. b = [1, 2, 3] bar(b) print(b) # imprime [1, 2, 3] Record\u00e1: reasignar una variable nunca sobreescribe la memoria que ocupaba. S\u00f3lo se asocia el nombre de la variable a un nuevo valor. Ejercicios Este conjunto de ejercicios te llevan a implementar un programa medianamente complejo. Es no trivial. Hay varios pasos involucrados e implica articular muchos conceptos al mismo tiempo. La soluci\u00f3n que vas a desarrollar involucra s\u00f3lo unas 25 l\u00edneas de c\u00f3digo, pero tomate tu tiempo para asegurarte de que entend\u00e9s cada concepto y cada parte del c\u00f3digo por separado. La parte central del programa informe_funciones.py resuelve la lectura de archivos de tipo CSV. Por ejemplo, la funci\u00f3n leer_camion() lee un archivo que contiene los datos de un cami\u00f3n organizados como filas, y la funci\u00f3n leer_precios() lee un archivo que contiene precios. En ambas funciones hay una variedad de acciones detallistas y minuciosas, por ejemplo, ambos abren un archivo y lo envuelven con el m\u00f3dulo csv y ambos convierten cada uno de los campos a un tipo de datos diferente. Si tu tarea fuera de verdad leer datos de archivos, entonces querr\u00edas limpiar este c\u00f3digo un poco, hacerlo m\u00e1s prolijo, y aplicable a un uso m\u00e1s general. \u00c9sa es nuestra intenci\u00f3n ahora: Comenz\u00e1 este ejercicio creando un nuevo archivo fileparse.py en la carpeta ejercicios_python/Clase06 . Ah\u00ed vamos a trabajar. Nota: En ingl\u00e9s to parse significa analizar gramaticalmente (por ejemplo una frase), separ\u00e1ndola en sus partes constitutivas. Es un t\u00e9rmino muy usado en ciencias de la computaci\u00f3n que no tiene una traducci\u00f3n compacta al castellano. Mucha gente usa el anglicismo parsear para referirse a esta actividad. Ejercicio 6.6: Parsear un archivo CSV Vamos a empezar por el problema simple de leer un archivo CSV para guardar los datos que contiene en una lista de diccionarios. En el archivo fileparse.py defin\u00ed la siguiente funci\u00f3n: # fileparse.py import csv def parse_csv(nombre_archivo): ''' Parsea un archivo CSV en una lista de registros ''' with open(nombre_archivo) as f: rows = csv.reader(f) # Lee los encabezados headers = next(rows) registros = [] for row in rows: if not row: # Saltea filas sin datos continue registro = dict(zip(headers, row)) registros.append(registro) return registros Esta funci\u00f3n lee un archivo CSV y arma una lista de diccionarios a partir del contenido del archivo CSV. La funci\u00f3n a\u00edsla al programador de los m\u00faltiples peque\u00f1os pasos necesarios para abrir un archivo, \"envolverlo\" con el m\u00f3dulo csv , ignorar l\u00edneas vac\u00edas, y dem\u00e1s minucias. ( un \"wrapper\" (envoltorio) en programaci\u00f3n es una estructura que expone la interfase de un objeto, pero a\u00edsla al usuario de los detalles de funcionamiento de ese objeto. ) Prob\u00e9moslo en tu IDE o con python3 -i fileparse.py . >>> camion = parse_csv('../Data/camion.csv') >>> camion [{'nombre': 'Lima', 'cajones': '100', 'precio': '32.2'}, {'nombre': 'Naranja', 'cajones': '50', 'precio': '91.1'}, {'nombre': 'Caqui', 'cajones': '150', 'precio': '103.44'}, {'nombre': 'Mandarina', 'cajones': '200', 'precio': '51.23'}, {'nombre': 'Durazno', 'cajones': '95', 'precio': '40.37'}, {'nombre': 'Mandarina', 'cajones': '50', 'precio': '65.1'}, {'nombre': 'Naranja', 'cajones': '100', 'precio': '70.44'}] >>> La funci\u00f3n hace lo que quer\u00edamos, pero no podemos usar los resultados para hacer c\u00e1lculos porque todos los datos recuperados son de tipo cadena ( string ). Ya vamos a solucionar esto. Por ahora sigamos extendiendo sus funciones. Ejercicio 6.7: Selector de Columnas La mayor\u00eda de los casos, uno no est\u00e1 interesado en todos los datos que contiene el archivo CSV, sino s\u00f3lo en algunas columnas. Modifiquemos la funci\u00f3n parse_csv de modo que permita al usuario elegir (opcionalmente) algunas columnas del siguiente modo: >>> # Lee todos los datos >>> camion = parse_csv('../Data/camion.csv') >>> camion [{'nombre': 'Lima', 'cajones': '100', 'precio': '32.2'}, {'nombre': 'Naranja', 'cajones': '50', 'precio': '91.1'}, {'nombre': 'Caqui', 'cajones': '150', 'precio': '103.44'}, {'nombre': 'Mandarina', 'cajones': '200', 'precio': '51.23'}, {'nombre': 'Durazno', 'cajones': '95', 'precio': '40.37'}, {'nombre': 'Mandarina', 'cajones': '50', 'precio': '65.1'}, {'nombre': 'Naranja', 'cajones': '100', 'precio': '70.44'}] >>> # Lee solo algunos datos >>> cajones_retenidos = parse_csv('../Data/camion.csv', select=['nombre','cajones']) >>> cajones_retenidos [{'nombre': 'Lima', 'cajones': '100'}, {'nombre': 'Naranja', 'cajones': '50'}, {'nombre': 'Caqui', 'cajones': '150'}, {'nombre': 'Mandarina', 'cajones': '200'}, {'nombre': 'Durazno', 'cajones': '95'}, {'nombre': 'Mandarina', 'cajones': '50'}, {'nombre': 'Naranja', 'cajones': '100'}] >>> Vimos un ejemplo de un selector de columnas en el Ejercicio 4.11 . De todos modos, \u00e9sta es otra forma de resolverlo: # fileparse.py import csv def parse_csv(nombre_archivo, select = None): ''' Parsea un archivo CSV en una lista de registros. Se puede seleccionar s\u00f3lo un subconjunto de las columnas, determinando el par\u00e1metro select, que debe ser una lista de nombres de las columnas a considerar. ''' with open(nombre_archivo) as f: filas = csv.reader(f) # Lee los encabezados del archivo encabezados = next(filas) # Si se indic\u00f3 un selector de columnas, # buscar los \u00edndices de las columnas especificadas. # Y en ese caso achicar el conjunto de encabezados para diccionarios if select: indices = [encabezados.index(nombre_columna) for nombre_columna in select] encabezados = select else: indices = [] registros = [] for fila in filas: if not fila: # Saltear filas vac\u00edas continue # Filtrar la fila si se especificaron columnas if indices: fila = [fila[index] for index in indices] # Armar el diccionario registro = dict(zip(encabezados, fila)) registros.append(registro) return registros Esta parte es un toque t\u00e9cnica y merece una mirada de m\u00e1s cerca. El paso m\u00e1s delicado es traducir los nombres de las columnas seleccionadas a \u00edndices. Por ejemplo, supongamos que los encabezados en el archivo de entrada fueran los siguientes: >>> encabezados = ['nombre', 'dia', 'hora', 'cajones', 'precio'] >>> Y que las columnas seleccionadas fueran: >>> select = ['nombre', 'cajones'] >>> Para hacer la selecci\u00f3n correctamente, ten\u00e9s que conventir los nombres de las columnas listadas en select a \u00edndices (posiciones) de columnas en el archivo. Esto es exactamente lo que hace este paso: >>> indices = [encabezados.index(nombre_columna) for nombre_columna in select ] >>> indices [0, 3] >>> En otras palabras, \"nombre\" es la columna 0 y \"cajones\" es la columna 3. Al leer una l\u00ednea de datos del archivo, us\u00e1s los \u00edndices para filtrarla y rescatar s\u00f3lo las columnas que te interesan: >>> linea = ['Lima', '6/11/2007', '9:50am', '100', '32.20' ] >>> linea = [ linea[indice] for indice in indices ] >>> linea ['Lima', '100'] >>> Ejercicio 6.8: Conversi\u00f3n de tipo Modific\u00e1 la funci\u00f3n parse_csv() de modo que permita, opcionalmente, convertir el tipo de los datos recuperados antes de devolverlos. >>> camion = parse_csv('../Data/camion.csv', types=[str, int, float]) >>> camion [{'nombre': 'Lima', 'cajones': 100, 'precio': 32.2}, {'nombre': 'Naranja', 'cajones': 50, 'precio': 91.1}, {'nombre': 'Caqui', 'cajones': 150, 'precio': 103.44}, {'nombre': 'Mandarina', 'cajones': 200, 'precio': 51.23}, {'nombre': 'Durazno', 'cajones': 95, 'precio': 40.37}, {'nombre': 'Mandarina', 'cajones': 50, 'precio': 65.1}, {'nombre': 'Naranja', 'cajones': 100, 'precio': 70.44}] >>> cajones_lote = parse_csv('../Data/camion.csv', select=['nombre', 'cajones'], types=[str, int]) >>> cajones_lote [{'nombre': 'Lima', 'cajones': 100}, {'nombre': 'Naranja', 'cajones': 50}, {'nombre': 'Caqui', 'cajones': 150}, {'nombre': 'Mandarina', 'cajones': 200}, {'nombre': 'Durazno', 'cajones': 95}, {'nombre': 'Mandarina', 'cajones': 50}, {'nombre': 'Naranja', 'cajones': 100}] >>> Ya vimos esto en el Ejercicio 4.12 . Vas a necesitar insertar la siguiente porci\u00f3n de c\u00f3digo en tu implementaci\u00f3n: ... if types: fila = [func(val) for func, val in zip(types, fila) ] ... Ejercicio 6.9: Trabajando sin encabezados Algunos archivos CSV no tiene informaci\u00f3n de los encabezados. Por ejemplo, el archivo precios.csv se ve as\u00ed: Lima,40.22 Uva,24.85 Ciruela,44.85 Cereza,11.27 ... Modific\u00e1 la funci\u00f3n parse_csv() de forma que (opcionalmente) pueda trabajar con este tipo de archivos, creando tuplas en lugar de diccionarios cuando no haya encabezados. Por ejemplo: >>> precios = parse_csv('../Data/precios.csv', types=[str,float], has_headers=False) >>> precios [(Lima,40.22), (Uva,24.85), (Ciruela,44.85), (Cereza,11.27), (Frutilla,53.72), (Caqui,105.46), (Tomate,66.67), (Berenjena,28.47), (Lechuga,24.22), (Durazno,73.48), (Remolacha,20.75), (Habas,23.16), (Frambuesa,34.35), (Naranja,106.28), (Bruselas,15.72), (Batata,55.16), (R\u00facula,36.9), (Radicheta,26.11), (Repollo,49.16), (Cebolla,58.99), (Ceboll\u00edn,57.1), (Puerro,27.58), (Mandarina,80.89), (Ajo,15.19), (Rabanito,51.94), (Zapallo,24.79), (Espinaca,52.61), (Acelga,29.26), (Zanahoria,49.74), (Papa,69.35)] >>> Para hacer este cambio, vas a tener que modificar el c\u00f3digo de forma que, si le pas\u00e1s el par\u00e1metro has_headers = False , la primera l\u00ednea de datos no sea interpretada como encabezado. Adem\u00e1s, en ese caso, vas a tener que asegurarte de no crear diccionarios, dado que no ten\u00e9s m\u00e1s los nombres de las columnas para usar en el encabezado. Vale aclarar que este par\u00e1metro debe tener como valor por omisi\u00f3n True , con lo que la funci\u00f3n sigue funcionando igual que antes si no se especifica has_headers = False . Si bien no es dif\u00edcil, este es un cambio muy grande en esta funci\u00f3n. Un camino posible es poner un if has_headers al principio y resolver cada caso por separado. Otro camino es poner condicionales en cada paso donde sea necesario operar de manera diferente. Incorpor\u00e1 todos estos cambios en el archivo fileparse.py . Comentario Llegaste lejos. Hasta este punto creaste una biblioteca de funciones que es genuinamente \u00fatil. La pod\u00e9s usar para parsear archivos CSV de formato arbitrario, eligiendo las columnas relevantes y cambiando el tipo de datos devuelto, todo esto sin tener que preocuparte mucho por el manejo de archivos o entender c\u00f3mo funciona el m\u00f3dulo csv . Contenidos | Anterior (2 Scripting) | Pr\u00f3ximo (4 M\u00f3dulos)","title":"03 Funciones"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#63-funciones","text":"Aunque ya hablamos sobre funciones, dimos pocos detalles sobre su funcionamiento a un nivel algo m\u00e1s profundo. En esta secci\u00f3n esperamos completar algunos conceptos como convenciones de uso, alcance ( scope ) y otros temas.","title":"6.3 Funciones"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#llamando-a-una-funcion","text":"Imagin\u00e1 la siguiente funci\u00f3n: def leer_precios(nombre_archivo, debug): ... Pod\u00e9s llamar a la funci\u00f3n pasando los argumentos por orden: precios = leer_precios('precios.csv', True) O pod\u00e9s llamarla usando palabras clave ( keywords ): precios = leer_precios(nombre_archivo = 'precios.csv', debug = True)","title":"Llamando a una funci\u00f3n"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#argumentos-por-omision","text":"Si prefer\u00eds que un argumento sea opcional (que tenga un valor por omisi\u00f3n o by default ), en ese caso asignale un valor en la definici\u00f3n de la funci\u00f3n. \u00c9se ser\u00e1 el valor del argumento si llam\u00e1s a la funci\u00f3n sin especificar un valor para ese argumento. def leer_precios(nombre_archivo, debug = False): ... En la declaraci\u00f3n de la funci\u00f3n pod\u00e9s asignar un valor a un argumento. Entonces, ese argumento ser\u00e1 opcional al invocar a esa funcion y si lo omit\u00eds al invocar a la funci\u00f3n va a tomar su valor asignado. A ese valor lo llamamos valor por omisi\u00f3n. d = leer_precios('precios.csv') e = leer_precios('precios.dat', True) Nota: Todos los argumentos con valores por omisi\u00f3n deben aparecer al final de la lista de argumentos (primero se declaran todos los argumentos no-opcionales)","title":"Argumentos por omisi\u00f3n"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#si-un-argumento-es-opcional-dale-un-nombre","text":"Comparemos estos dos estilos de invocar funciones: cortar_datos(data, False, True) # ????? cortar_datos(data, ignore_errores = True) cortar_datos(data, debug = True) cortar_datos(data, debug = True, ignore_errores = True) En la mayor\u00eda de los casos los argumentos con nombre hacen al c\u00f3digo m\u00e1s claro, m\u00e1s f\u00e1cil de entender, especialmente si estos argumentos son booleanos, que determinan opciones si-no.","title":"Si un argumento es opcional, dale un nombre."},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#buenas-practicas-de-diseno","text":"Compar\u00e1 estas dos formas de declarar una misma funci\u00f3n. Para comprender c\u00f3mo usar la primera, tendr\u00edamos que explorar dentro de la funci\u00f3n y saber que significan sus par\u00e1metros. Us\u00e1 siempre nombres cortos para los argumentos, pero con significado. def leer_precios(f, d = False): ... def leer_precios(nombre_archivo, debug = False): ... Quien use la funci\u00f3n podr\u00eda elegir llamarla con argumentos nombrados. d = leer_precios('precios.csv', debug = True) Hay herramientas que crean autom\u00e1ticamente documentaci\u00f3n sobre el uso de las funciones y sus argumentos. Si los nombres tienen significado, la documentaci\u00f3n resulta m\u00e1s clara.","title":"Buenas pr\u00e1cticas de dise\u00f1o"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#devolver-un-resultado","text":"El comando return termina la funci\u00f3n y devuelve un valor. def cuadrado(x): return x * x Si no se define un resultado, o si falta el comando return, la funci\u00f3n devuelve la constante None . def bar(x): instrucciones return a = bar(4) # a = None # O TAMBIEN... def foo(x): instrucciones # No hay `return` b = foo(4) # b = None","title":"Devolver un resultado"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#devolver-multiples-resultados","text":"Las funciones s\u00f3lo pueden devolver una cosa. Si necesit\u00e1s devolver m\u00e1s de un valor, pod\u00e9s armar una tupla con ellos y devolver la tupla. def dividir(a,b): c = a // b # Cociente r = a % b # Resto return c, r # Devolver una tupla con c y r Ejemplo: x, y = dividir(37,5) # x = 7, y = 2 x = dividir(37, 5) # x = (7, 2)","title":"Devolver m\u00faltiples resultados"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#alcance-de-variables","text":"En un programa se declaran variables y se les asignan valores. Esto ocurre dentro y fuera de funciones. x = valor # Variable Global def foo(): y = valor # Variable Local Las variables declaradas fuera de funciones son \"globales\". Las variables declaradas dentro de funciones son \"locales\". A esto se llama el alcance ( scope ) de una variable.","title":"Alcance de variables"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#variables-locales","text":"Las variables locales, declaradas dentro de funciones, son privadas. def leer_camion(nombre_archivo): camion = [] for linea in open(nombre_archivo): campos = line.split(',') s = (campos[0], int(campos[1]), float(campos[2])) camion.append(s) return camion En este ejemplo, nombre_archivo , camion , linea , campos y s son variables locales. >>> cajones = leer_camion('camion.csv') >>> campos Traceback (most recent call last): File \"<stdin>\", line 1, in ? NameError: name 'campos' is not defined >>> El error significa: Error de Nombre: el nombre 'campos' no est\u00e1 definido. No hay conflicto entre variables locales y variables declaradas en otras partes (funciones o globales).","title":"Variables locales"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#variables-globales","text":"Desde cualquier funci\u00f3n se puede acceder a las variables globales declaradas en ese mismo archivo. nombre = 'Dave' def saludo(): print('Hola', nombre) # Usa la variable global `nombre` Las funciones, sin embargo, no alteran normalmente el valor de una variable global. nombre = 'Dave' def spam(): nombre = 'Guido' spam() print(nombre) # imprime 'Dave' Aqu\u00ed hay dos variables diferentes: nombre global, que vale 'Dave' , y nombre local, declarada dentro de la funci\u00f3n spam() que vale 'Guido' . Cambiar una no cambia la otra: al cambiar el valor de nombre local, nombre global no cambia. Acordate: Las asignaciones de valores a variables y las declaraciones de variables dentro de funciones son locales.","title":"Variables globales"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#modificar-el-valor-de-una-variable-global","text":"Si necesit\u00e1s modificar el valor de una variable global desde dentro de una funci\u00f3n, la variable tiene que estar declarada como global dentro de la misma funci\u00f3n. nombre = 'Dave' def spam(): global nombre nombre = 'Guido' # Cambia el valor de la variable global Si declaramos global nombre dentro de la funci\u00f3n, entonces nombre fuera de la funci\u00f3n spam() y dentro de la funci\u00f3n spam() refieren a la misma variable, y al modificar una de ellas modific\u00e1s la otra. La declaraci\u00f3n de globalidad de la variable (con la palabra reservada global ) tiene que aparecer antes del uso de la variable dentro de una funci\u00f3n, y la declaraci\u00f3n de la variable global fuera de la funci\u00f3n debe ocurrir en el mismo archivo que \u00e9sta. Dicho esto, hay que decir tambi\u00e9n que usar variables globales se considera una mala pr\u00e1ctica. Trat\u00e1 de evitar completamente el uso de global . Si ten\u00e9s una funci\u00f3n que depende del estado de una variable global, tu programa es menos modular: no pod\u00e9s reutilizar la funci\u00f3n en otro contexto sin agregar una variable global. Si necesit\u00e1s que una funci\u00f3n modifique el estado de algo fuera de esa funci\u00f3n, es mejor entonces usar una clase en lugar de una funci\u00f3n. Hablaremos de \u00e9sto m\u00e1s adelante, en la segunda mitad de la materia.","title":"Modificar el valor de una variable global"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#pasaje-de-argumentos","text":"Cuando llam\u00e1s a una funci\u00f3n, los argumentos son los nombres que refieren a los valores que le pas\u00e1s. Estos valores no son copias de los originales (ver Secci\u00f3n 4.4 ). Si le pas\u00e1s tipos mutables, como listas o diccionarios, la funci\u00f3n s\u00ed los puede modificar. def foo(items): items.append(42) # Cambia el valor de items a = [1, 2, 3] foo(a) print(a) # [1, 2, 3, 42] Fundamental: Las funciones no reciben una copia de los argumentos, sino los argumentos mismos.","title":"Pasaje de argumentos"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#reasignar-versus-modificar","text":"Existe una sutil pero importante diferencia entre modificar el valor de una variable y reasignar una variable. Es importante que entiendas esta diferencia. def foo(items): items.append(42) # Modifica el valor de 'items' a = [1, 2, 3] foo(a) print(a) # [1, 2, 3, 42] # Versus def bar(items): items = [4,5,6] # Cambia la variable local 'items' y # hace que apunte a otro objeto completamente diferente. b = [1, 2, 3] bar(b) print(b) # imprime [1, 2, 3] Record\u00e1: reasignar una variable nunca sobreescribe la memoria que ocupaba. S\u00f3lo se asocia el nombre de la variable a un nuevo valor.","title":"Reasignar versus modificar"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#ejercicios","text":"Este conjunto de ejercicios te llevan a implementar un programa medianamente complejo. Es no trivial. Hay varios pasos involucrados e implica articular muchos conceptos al mismo tiempo. La soluci\u00f3n que vas a desarrollar involucra s\u00f3lo unas 25 l\u00edneas de c\u00f3digo, pero tomate tu tiempo para asegurarte de que entend\u00e9s cada concepto y cada parte del c\u00f3digo por separado. La parte central del programa informe_funciones.py resuelve la lectura de archivos de tipo CSV. Por ejemplo, la funci\u00f3n leer_camion() lee un archivo que contiene los datos de un cami\u00f3n organizados como filas, y la funci\u00f3n leer_precios() lee un archivo que contiene precios. En ambas funciones hay una variedad de acciones detallistas y minuciosas, por ejemplo, ambos abren un archivo y lo envuelven con el m\u00f3dulo csv y ambos convierten cada uno de los campos a un tipo de datos diferente. Si tu tarea fuera de verdad leer datos de archivos, entonces querr\u00edas limpiar este c\u00f3digo un poco, hacerlo m\u00e1s prolijo, y aplicable a un uso m\u00e1s general. \u00c9sa es nuestra intenci\u00f3n ahora: Comenz\u00e1 este ejercicio creando un nuevo archivo fileparse.py en la carpeta ejercicios_python/Clase06 . Ah\u00ed vamos a trabajar. Nota: En ingl\u00e9s to parse significa analizar gramaticalmente (por ejemplo una frase), separ\u00e1ndola en sus partes constitutivas. Es un t\u00e9rmino muy usado en ciencias de la computaci\u00f3n que no tiene una traducci\u00f3n compacta al castellano. Mucha gente usa el anglicismo parsear para referirse a esta actividad.","title":"Ejercicios"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#ejercicio-66-parsear-un-archivo-csv","text":"Vamos a empezar por el problema simple de leer un archivo CSV para guardar los datos que contiene en una lista de diccionarios. En el archivo fileparse.py defin\u00ed la siguiente funci\u00f3n: # fileparse.py import csv def parse_csv(nombre_archivo): ''' Parsea un archivo CSV en una lista de registros ''' with open(nombre_archivo) as f: rows = csv.reader(f) # Lee los encabezados headers = next(rows) registros = [] for row in rows: if not row: # Saltea filas sin datos continue registro = dict(zip(headers, row)) registros.append(registro) return registros Esta funci\u00f3n lee un archivo CSV y arma una lista de diccionarios a partir del contenido del archivo CSV. La funci\u00f3n a\u00edsla al programador de los m\u00faltiples peque\u00f1os pasos necesarios para abrir un archivo, \"envolverlo\" con el m\u00f3dulo csv , ignorar l\u00edneas vac\u00edas, y dem\u00e1s minucias. ( un \"wrapper\" (envoltorio) en programaci\u00f3n es una estructura que expone la interfase de un objeto, pero a\u00edsla al usuario de los detalles de funcionamiento de ese objeto. ) Prob\u00e9moslo en tu IDE o con python3 -i fileparse.py . >>> camion = parse_csv('../Data/camion.csv') >>> camion [{'nombre': 'Lima', 'cajones': '100', 'precio': '32.2'}, {'nombre': 'Naranja', 'cajones': '50', 'precio': '91.1'}, {'nombre': 'Caqui', 'cajones': '150', 'precio': '103.44'}, {'nombre': 'Mandarina', 'cajones': '200', 'precio': '51.23'}, {'nombre': 'Durazno', 'cajones': '95', 'precio': '40.37'}, {'nombre': 'Mandarina', 'cajones': '50', 'precio': '65.1'}, {'nombre': 'Naranja', 'cajones': '100', 'precio': '70.44'}] >>> La funci\u00f3n hace lo que quer\u00edamos, pero no podemos usar los resultados para hacer c\u00e1lculos porque todos los datos recuperados son de tipo cadena ( string ). Ya vamos a solucionar esto. Por ahora sigamos extendiendo sus funciones.","title":"Ejercicio 6.6: Parsear un archivo CSV"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#ejercicio-67-selector-de-columnas","text":"La mayor\u00eda de los casos, uno no est\u00e1 interesado en todos los datos que contiene el archivo CSV, sino s\u00f3lo en algunas columnas. Modifiquemos la funci\u00f3n parse_csv de modo que permita al usuario elegir (opcionalmente) algunas columnas del siguiente modo: >>> # Lee todos los datos >>> camion = parse_csv('../Data/camion.csv') >>> camion [{'nombre': 'Lima', 'cajones': '100', 'precio': '32.2'}, {'nombre': 'Naranja', 'cajones': '50', 'precio': '91.1'}, {'nombre': 'Caqui', 'cajones': '150', 'precio': '103.44'}, {'nombre': 'Mandarina', 'cajones': '200', 'precio': '51.23'}, {'nombre': 'Durazno', 'cajones': '95', 'precio': '40.37'}, {'nombre': 'Mandarina', 'cajones': '50', 'precio': '65.1'}, {'nombre': 'Naranja', 'cajones': '100', 'precio': '70.44'}] >>> # Lee solo algunos datos >>> cajones_retenidos = parse_csv('../Data/camion.csv', select=['nombre','cajones']) >>> cajones_retenidos [{'nombre': 'Lima', 'cajones': '100'}, {'nombre': 'Naranja', 'cajones': '50'}, {'nombre': 'Caqui', 'cajones': '150'}, {'nombre': 'Mandarina', 'cajones': '200'}, {'nombre': 'Durazno', 'cajones': '95'}, {'nombre': 'Mandarina', 'cajones': '50'}, {'nombre': 'Naranja', 'cajones': '100'}] >>> Vimos un ejemplo de un selector de columnas en el Ejercicio 4.11 . De todos modos, \u00e9sta es otra forma de resolverlo: # fileparse.py import csv def parse_csv(nombre_archivo, select = None): ''' Parsea un archivo CSV en una lista de registros. Se puede seleccionar s\u00f3lo un subconjunto de las columnas, determinando el par\u00e1metro select, que debe ser una lista de nombres de las columnas a considerar. ''' with open(nombre_archivo) as f: filas = csv.reader(f) # Lee los encabezados del archivo encabezados = next(filas) # Si se indic\u00f3 un selector de columnas, # buscar los \u00edndices de las columnas especificadas. # Y en ese caso achicar el conjunto de encabezados para diccionarios if select: indices = [encabezados.index(nombre_columna) for nombre_columna in select] encabezados = select else: indices = [] registros = [] for fila in filas: if not fila: # Saltear filas vac\u00edas continue # Filtrar la fila si se especificaron columnas if indices: fila = [fila[index] for index in indices] # Armar el diccionario registro = dict(zip(encabezados, fila)) registros.append(registro) return registros Esta parte es un toque t\u00e9cnica y merece una mirada de m\u00e1s cerca. El paso m\u00e1s delicado es traducir los nombres de las columnas seleccionadas a \u00edndices. Por ejemplo, supongamos que los encabezados en el archivo de entrada fueran los siguientes: >>> encabezados = ['nombre', 'dia', 'hora', 'cajones', 'precio'] >>> Y que las columnas seleccionadas fueran: >>> select = ['nombre', 'cajones'] >>> Para hacer la selecci\u00f3n correctamente, ten\u00e9s que conventir los nombres de las columnas listadas en select a \u00edndices (posiciones) de columnas en el archivo. Esto es exactamente lo que hace este paso: >>> indices = [encabezados.index(nombre_columna) for nombre_columna in select ] >>> indices [0, 3] >>> En otras palabras, \"nombre\" es la columna 0 y \"cajones\" es la columna 3. Al leer una l\u00ednea de datos del archivo, us\u00e1s los \u00edndices para filtrarla y rescatar s\u00f3lo las columnas que te interesan: >>> linea = ['Lima', '6/11/2007', '9:50am', '100', '32.20' ] >>> linea = [ linea[indice] for indice in indices ] >>> linea ['Lima', '100'] >>>","title":"Ejercicio 6.7: Selector de Columnas"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#ejercicio-68-conversion-de-tipo","text":"Modific\u00e1 la funci\u00f3n parse_csv() de modo que permita, opcionalmente, convertir el tipo de los datos recuperados antes de devolverlos. >>> camion = parse_csv('../Data/camion.csv', types=[str, int, float]) >>> camion [{'nombre': 'Lima', 'cajones': 100, 'precio': 32.2}, {'nombre': 'Naranja', 'cajones': 50, 'precio': 91.1}, {'nombre': 'Caqui', 'cajones': 150, 'precio': 103.44}, {'nombre': 'Mandarina', 'cajones': 200, 'precio': 51.23}, {'nombre': 'Durazno', 'cajones': 95, 'precio': 40.37}, {'nombre': 'Mandarina', 'cajones': 50, 'precio': 65.1}, {'nombre': 'Naranja', 'cajones': 100, 'precio': 70.44}] >>> cajones_lote = parse_csv('../Data/camion.csv', select=['nombre', 'cajones'], types=[str, int]) >>> cajones_lote [{'nombre': 'Lima', 'cajones': 100}, {'nombre': 'Naranja', 'cajones': 50}, {'nombre': 'Caqui', 'cajones': 150}, {'nombre': 'Mandarina', 'cajones': 200}, {'nombre': 'Durazno', 'cajones': 95}, {'nombre': 'Mandarina', 'cajones': 50}, {'nombre': 'Naranja', 'cajones': 100}] >>> Ya vimos esto en el Ejercicio 4.12 . Vas a necesitar insertar la siguiente porci\u00f3n de c\u00f3digo en tu implementaci\u00f3n: ... if types: fila = [func(val) for func, val in zip(types, fila) ] ...","title":"Ejercicio 6.8: Conversi\u00f3n de tipo"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#ejercicio-69-trabajando-sin-encabezados","text":"Algunos archivos CSV no tiene informaci\u00f3n de los encabezados. Por ejemplo, el archivo precios.csv se ve as\u00ed: Lima,40.22 Uva,24.85 Ciruela,44.85 Cereza,11.27 ... Modific\u00e1 la funci\u00f3n parse_csv() de forma que (opcionalmente) pueda trabajar con este tipo de archivos, creando tuplas en lugar de diccionarios cuando no haya encabezados. Por ejemplo: >>> precios = parse_csv('../Data/precios.csv', types=[str,float], has_headers=False) >>> precios [(Lima,40.22), (Uva,24.85), (Ciruela,44.85), (Cereza,11.27), (Frutilla,53.72), (Caqui,105.46), (Tomate,66.67), (Berenjena,28.47), (Lechuga,24.22), (Durazno,73.48), (Remolacha,20.75), (Habas,23.16), (Frambuesa,34.35), (Naranja,106.28), (Bruselas,15.72), (Batata,55.16), (R\u00facula,36.9), (Radicheta,26.11), (Repollo,49.16), (Cebolla,58.99), (Ceboll\u00edn,57.1), (Puerro,27.58), (Mandarina,80.89), (Ajo,15.19), (Rabanito,51.94), (Zapallo,24.79), (Espinaca,52.61), (Acelga,29.26), (Zanahoria,49.74), (Papa,69.35)] >>> Para hacer este cambio, vas a tener que modificar el c\u00f3digo de forma que, si le pas\u00e1s el par\u00e1metro has_headers = False , la primera l\u00ednea de datos no sea interpretada como encabezado. Adem\u00e1s, en ese caso, vas a tener que asegurarte de no crear diccionarios, dado que no ten\u00e9s m\u00e1s los nombres de las columnas para usar en el encabezado. Vale aclarar que este par\u00e1metro debe tener como valor por omisi\u00f3n True , con lo que la funci\u00f3n sigue funcionando igual que antes si no se especifica has_headers = False . Si bien no es dif\u00edcil, este es un cambio muy grande en esta funci\u00f3n. Un camino posible es poner un if has_headers al principio y resolver cada caso por separado. Otro camino es poner condicionales en cada paso donde sea necesario operar de manera diferente. Incorpor\u00e1 todos estos cambios en el archivo fileparse.py .","title":"Ejercicio 6.9: Trabajando sin encabezados"},{"location":"06_Organizacion_y_Complejidad/03_Funciones/#comentario","text":"Llegaste lejos. Hasta este punto creaste una biblioteca de funciones que es genuinamente \u00fatil. La pod\u00e9s usar para parsear archivos CSV de formato arbitrario, eligiendo las columnas relevantes y cambiando el tipo de datos devuelto, todo esto sin tener que preocuparte mucho por el manejo de archivos o entender c\u00f3mo funciona el m\u00f3dulo csv . Contenidos | Anterior (2 Scripting) | Pr\u00f3ximo (4 M\u00f3dulos)","title":"Comentario"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/","text":"Contenidos | Anterior (3 Funciones) | Pr\u00f3ximo (5 B\u00fasqueda binaria) 6.4 M\u00f3dulos En esta secci\u00f3n vamos a introducir conceptos que nos permiten crear m\u00f3dulos y trabajar con programas cuyas partes est\u00e1n repartidas en m\u00faltiples archivos. M\u00f3dulos y la instrucci\u00f3n import Todos los archivos con c\u00f3digo Python son m\u00f3dulos. # foo.py def grok(a): ... def spam(b): ... El comando import carga un m\u00f3dulo y lo ejecuta . # programa.py import foo a = foo.grok(2) b = foo.spam('Hola') ... Namespaces Se puede decir que un m\u00f3dulo es una colecci\u00f3n de valores asignados a nombres. A \u00e9sto se lo llama un namespace (espacio de nombres). Es el contexto en el cual esos nombres existen: todas las variables globales y las funciones definidas en un m\u00f3dulo pertenecen a ese m\u00f3dulo. Una vez importado, el nombre del m\u00f3dulo se usa como un prefijo al nombrar esas variables y funciones. Por eso se llama un namespace. import foo a = foo.grok(2) b = foo.spam('Hello') ... El nombre del m\u00f3dulo es el nombre del archivo que lo contiene. Definiciones globales El espacio de nombres contiene todo aquello definido con visibilidad global . Supongamos dos m\u00f3dulos diferentes que definen cada uno una variable x : # foo.py x = 42 def grok(a): ... # bar.py x = 37 def spam(a): ... Entonces hay dos definiciones de x y cada una refiere a una variable diferente. Una de ellas es foo.x y la otra es bar.x . De este modo, diferentes m\u00f3dulos tienen la libertad de definir variables con el mismo nombre sin que existan ambig\u00fcedades ni conflictos. Los m\u00f3dulos est\u00e1n aislados uno de otro. M\u00f3dulos como entornos Los m\u00f3dulos crean un entorno que contiene a todo el c\u00f3digo definido ah\u00ed. # foo.py x = 42 def grok(a): print(x) Incluso las variables globales son visibles s\u00f3lo dentro del m\u00f3dulo en que fueron definidas (el mismo archivo). Cada m\u00f3dulo es un peque\u00f1o universo. Ejecuci\u00f3n de m\u00f3dulos Cuando import\u00e1s un m\u00f3dulo se ejecutan todas las instrucciones en ese m\u00f3dulo, una tras otra, hasta llegar al final del archivo. El namespace del m\u00f3dulo est\u00e1 poblado por todas las funciones y variables globales cuya definici\u00f3n siga vigente al terminar de ejecutar el m\u00f3dulo. Si existen comandos que se ejecutan en el namespace global del m\u00f3dulo y hacen tareas como crear archivos, imprimir mensajes, etc., se van a ejecutar al importar el m\u00f3dulo. El comando import as En el momento de importar un m\u00f3dulo, pod\u00e9s cambiar el nombre que le asign\u00e1s dentro del contexto en que lo import\u00e1s. import math as m def rectangular(r, theta): x = r * m.cos(theta) y = r * m.sin(theta) return x, y Funciona del mismo modo que un import com\u00fan salvo que, para quien lo importa, el nombre del m\u00f3dulo cambia. from m\u00f3dulo import nombre Este comando toma ciertos nombres selectos de un m\u00f3dulo, y los hace accesibles localmente. from math import sin, cos def rectangular(r, theta): x = r * cos(theta) y = r * sin(theta) return x, y Esta forma de importar te permite usar partes de un m\u00f3dulo sin necesidad de especificar la pertenencia a un m\u00f3dulo como prefijo. Es \u00fatil para nombres (funciones o variables) que se usan mucho. Si us\u00e1s from math import * vas a importar todas las funciones y constantes del m\u00f3dulo math como si estuvieran definidas localmente. No es coveniente hacer esto ya que se pierden las ventajas que da trabajar con namespaces. Notas sobre import Estas distintas formas de usar import no modifican el funcionamiento de un m\u00f3dulo. import math # vs import math as m # vs from math import cos, sin ... M\u00e1s espec\u00edficamente, import siempre ejecuta el m\u00f3dulo completo, y los m\u00f3dulos siguen siendo peque\u00f1os entornos aislados. El comando import m\u00f3dulo as s\u00f3lo cambia el nombre local del m\u00f3dulo. El comando from math import cos, sin , aunque s\u00f3lo hace accesibles las funciones sin y cos , de todos modos carga todo el m\u00f3dulo y lo ejecuta. La \u00fanica diferencia es que copia los nombres de las funciones sin y cos al namespace local. Carga de m\u00f3dulos Cada m\u00f3dulo es cargado y ejecutado s\u00f3lo una vez. Observaci\u00f3n: Repetir la instrucci\u00f3n import s\u00f3lo devuelve una referencia al m\u00f3dulo ya cargado. La variable sys.modules es un diccionario de los m\u00f3dulos cargados. >>> import sys >>> sys.modules.keys() ['copy_reg', '__main__', 'site', '__builtin__', 'encodings', 'encodings.encodings', 'posixpath', ...] >>> Precauci\u00f3n: Si cambi\u00e1s el c\u00f3digo de un m\u00f3dulo y lo volv\u00e9s a cargar sucede algo que suele causar confusi\u00f3n hasta que lo entend\u00e9s: Dado que existe la lista de m\u00f3dulos cargados sys.modules , un pedido de cargar un m\u00f3dulo por segunda vez siempre devolver\u00e1 el m\u00f3dulo ya cargado, a\u00fan si el m\u00f3dulo fue modificado, si se trata de una versi\u00f3n nueva de ese m\u00f3dulo y si el archivo en disco ha sido modificado. Es posible usar reload(m\u00f3dulo) pero s\u00f3lo en ciertos casos. El m\u00e9todo que asegura que el m\u00f3dulo se vuelva a cargar es cerrar y volver a abrir el int\u00e9rprete de Python. Ejercicios Para estos ejercicios que involucran m\u00f3dulos, es de suma importancia que te asegures de que est\u00e1s ejecutando Python en el directorio adecuado. Ejercicio 6.10: Importar m\u00f3dulos En el Ejercicio 6.6 creamos una funci\u00f3n llamada parse_csv() para parsear el contenido de archivos de datos en formato CSV. Ahora vamos a ver c\u00f3mo usar esa funci\u00f3n en otros programas. Empez\u00e1 por copiarte los archivos rebotes.py , hipoteca.py y fileparse.py a la carpeta de ejercicios de esta clase. Los vamos a importar. Con el directorio de trabajo adecuado (puede que tengas que reiniciar tu int\u00e9rprete para que tome efecto un cambio), intent\u00e1 importar los programas que escribiste antes. Con s\u00f3lo importarlos deber\u00edas ver su salida exactamente como cuando los terminaste de escribir. Repetimos: al importar un m\u00f3dulo ejecut\u00e1s su c\u00f3digo. >>> import rebotes #... mir\u00e1 la salida ... >>> import hipoteca #... mir\u00e1 la salida ... >>> import informe_funciones #... mir\u00e1 la salida ... >>> Si nada de esto funciona, es probable que est\u00e9s ejecutando Python desde la carpeta equivocada. Ahora prob\u00e1 importar tu m\u00f3dulo fileparse y pedile help . >>> import fileparse >>> help(fileparse) ... mir\u00e1 la salida ... >>> dir(fileparse) ... mir\u00e1 la salida ... >>> Intent\u00e1 usar el m\u00f3dulo para leer datos de un archivo: >>> camion = fileparse.parse_csv('../Data/camion.csv', select = ['nombre', 'cajones', 'precio'], types = [str, int, float]) >>> camion ... mir\u00e1 la salida ... >>> lista_precios = fileparse.parse_csv('../Data/precios.csv', types = [str, float], has_headers = False) >>> lista_precios ... mir\u00e1 la salida ... >>> precios = dict(lista_precios) >>> precios ... fijate la salida ... >>> precios['Naranja'] 106.28 >>> Import\u00e1 s\u00f3lo la funci\u00f3n para evitar escribir el nombre del m\u00f3dulo: >>> from fileparse import parse_csv >>> camion = parse_csv('../Data/camion.csv', select = ['nombre', 'cajones', 'precio'], types = [str, int, float]) >>> camion ... fijate la salida ... >>> Ejercicio 6.11: Usemos tu m\u00f3dulo En el Ejercicio 6.4 escribiste un programa informe_funciones.py que produce un informe como \u00e9ste: Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 $32.20 8.02 Naranja 50 $91.10 15.18 Caqui 150 $103.44 2.02 Mandarina 200 $51.23 29.66 Durazno 95 $40.37 33.11 Mandarina 50 $65.10 15.79 Naranja 100 $70.44 35.84 Retom\u00e1 ese programa (si lo perdiste, te dejamos una versi\u00f3n para que la leas y la puedas usar) y modificalo de modo que todo el procesamiento de archivos de entrada de datos se haga usando funciones del m\u00f3dulo fileparse . Para lograr \u00e9so, import\u00e1 fileparse como un m\u00f3dulo y cambi\u00e1 las funciones leer_camion() y leer_precios() para que usen la funci\u00f3n parse_csv() . Guiate por el ejemplo interactivo que dimos un poco m\u00e1s arriba. Al final, deber\u00edas obtener exactamente el mismo resultado que al principio. Ejercicio 6.12: Un poco m\u00e1s all\u00e1 En Ejercicio 2.6 escribiste el programa costo_camion.py que lee, mediante una funci\u00f3n llamada costo_camion() los datos de un cami\u00f3n y calcula su costo. >>> import costo_camion >>> costo_camion.costo_camion('../Data/camion.csv') 47671.15 >>> Modific\u00e1 el archivo costo_camion.py para que use la funci\u00f3n informe_funciones.leer_camion() del programa informe_funciones.py . Comentario Al terminar este ejercicio ten\u00e9s tres programas. fileparse.py contiene una funci\u00f3n para parsear datos de archivos CSV en general, parse_csv() . Por otra parte, informe_funciones.py que produce un bello informe, y que contiene las funciones leer_camion() y leer_precios() . Finalmente, costo_camion.py calcula el costo de un cami\u00f3n, pero usando la funci\u00f3n leer_camion() que fue escrita para el programa que genera el informe. Contenidos | Anterior (3 Funciones) | Pr\u00f3ximo (5 B\u00fasqueda binaria)","title":"04 Modulos"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#64-modulos","text":"En esta secci\u00f3n vamos a introducir conceptos que nos permiten crear m\u00f3dulos y trabajar con programas cuyas partes est\u00e1n repartidas en m\u00faltiples archivos.","title":"6.4 M\u00f3dulos"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#modulos-y-la-instruccion-import","text":"Todos los archivos con c\u00f3digo Python son m\u00f3dulos. # foo.py def grok(a): ... def spam(b): ... El comando import carga un m\u00f3dulo y lo ejecuta . # programa.py import foo a = foo.grok(2) b = foo.spam('Hola') ...","title":"M\u00f3dulos y la instrucci\u00f3n import"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#namespaces","text":"Se puede decir que un m\u00f3dulo es una colecci\u00f3n de valores asignados a nombres. A \u00e9sto se lo llama un namespace (espacio de nombres). Es el contexto en el cual esos nombres existen: todas las variables globales y las funciones definidas en un m\u00f3dulo pertenecen a ese m\u00f3dulo. Una vez importado, el nombre del m\u00f3dulo se usa como un prefijo al nombrar esas variables y funciones. Por eso se llama un namespace. import foo a = foo.grok(2) b = foo.spam('Hello') ... El nombre del m\u00f3dulo es el nombre del archivo que lo contiene.","title":"Namespaces"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#definiciones-globales","text":"El espacio de nombres contiene todo aquello definido con visibilidad global . Supongamos dos m\u00f3dulos diferentes que definen cada uno una variable x : # foo.py x = 42 def grok(a): ... # bar.py x = 37 def spam(a): ... Entonces hay dos definiciones de x y cada una refiere a una variable diferente. Una de ellas es foo.x y la otra es bar.x . De este modo, diferentes m\u00f3dulos tienen la libertad de definir variables con el mismo nombre sin que existan ambig\u00fcedades ni conflictos. Los m\u00f3dulos est\u00e1n aislados uno de otro.","title":"Definiciones globales"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#modulos-como-entornos","text":"Los m\u00f3dulos crean un entorno que contiene a todo el c\u00f3digo definido ah\u00ed. # foo.py x = 42 def grok(a): print(x) Incluso las variables globales son visibles s\u00f3lo dentro del m\u00f3dulo en que fueron definidas (el mismo archivo). Cada m\u00f3dulo es un peque\u00f1o universo.","title":"M\u00f3dulos como entornos"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#ejecucion-de-modulos","text":"Cuando import\u00e1s un m\u00f3dulo se ejecutan todas las instrucciones en ese m\u00f3dulo, una tras otra, hasta llegar al final del archivo. El namespace del m\u00f3dulo est\u00e1 poblado por todas las funciones y variables globales cuya definici\u00f3n siga vigente al terminar de ejecutar el m\u00f3dulo. Si existen comandos que se ejecutan en el namespace global del m\u00f3dulo y hacen tareas como crear archivos, imprimir mensajes, etc., se van a ejecutar al importar el m\u00f3dulo.","title":"Ejecuci\u00f3n de m\u00f3dulos"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#el-comando-import-as","text":"En el momento de importar un m\u00f3dulo, pod\u00e9s cambiar el nombre que le asign\u00e1s dentro del contexto en que lo import\u00e1s. import math as m def rectangular(r, theta): x = r * m.cos(theta) y = r * m.sin(theta) return x, y Funciona del mismo modo que un import com\u00fan salvo que, para quien lo importa, el nombre del m\u00f3dulo cambia.","title":"El comando import as"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#from-modulo-import-nombre","text":"Este comando toma ciertos nombres selectos de un m\u00f3dulo, y los hace accesibles localmente. from math import sin, cos def rectangular(r, theta): x = r * cos(theta) y = r * sin(theta) return x, y Esta forma de importar te permite usar partes de un m\u00f3dulo sin necesidad de especificar la pertenencia a un m\u00f3dulo como prefijo. Es \u00fatil para nombres (funciones o variables) que se usan mucho. Si us\u00e1s from math import * vas a importar todas las funciones y constantes del m\u00f3dulo math como si estuvieran definidas localmente. No es coveniente hacer esto ya que se pierden las ventajas que da trabajar con namespaces.","title":"from m\u00f3dulo import nombre"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#notas-sobre-import","text":"Estas distintas formas de usar import no modifican el funcionamiento de un m\u00f3dulo. import math # vs import math as m # vs from math import cos, sin ... M\u00e1s espec\u00edficamente, import siempre ejecuta el m\u00f3dulo completo, y los m\u00f3dulos siguen siendo peque\u00f1os entornos aislados. El comando import m\u00f3dulo as s\u00f3lo cambia el nombre local del m\u00f3dulo. El comando from math import cos, sin , aunque s\u00f3lo hace accesibles las funciones sin y cos , de todos modos carga todo el m\u00f3dulo y lo ejecuta. La \u00fanica diferencia es que copia los nombres de las funciones sin y cos al namespace local.","title":"Notas sobre import"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#carga-de-modulos","text":"Cada m\u00f3dulo es cargado y ejecutado s\u00f3lo una vez. Observaci\u00f3n: Repetir la instrucci\u00f3n import s\u00f3lo devuelve una referencia al m\u00f3dulo ya cargado. La variable sys.modules es un diccionario de los m\u00f3dulos cargados. >>> import sys >>> sys.modules.keys() ['copy_reg', '__main__', 'site', '__builtin__', 'encodings', 'encodings.encodings', 'posixpath', ...] >>> Precauci\u00f3n: Si cambi\u00e1s el c\u00f3digo de un m\u00f3dulo y lo volv\u00e9s a cargar sucede algo que suele causar confusi\u00f3n hasta que lo entend\u00e9s: Dado que existe la lista de m\u00f3dulos cargados sys.modules , un pedido de cargar un m\u00f3dulo por segunda vez siempre devolver\u00e1 el m\u00f3dulo ya cargado, a\u00fan si el m\u00f3dulo fue modificado, si se trata de una versi\u00f3n nueva de ese m\u00f3dulo y si el archivo en disco ha sido modificado. Es posible usar reload(m\u00f3dulo) pero s\u00f3lo en ciertos casos. El m\u00e9todo que asegura que el m\u00f3dulo se vuelva a cargar es cerrar y volver a abrir el int\u00e9rprete de Python.","title":"Carga de m\u00f3dulos"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#ejercicios","text":"Para estos ejercicios que involucran m\u00f3dulos, es de suma importancia que te asegures de que est\u00e1s ejecutando Python en el directorio adecuado.","title":"Ejercicios"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#ejercicio-610-importar-modulos","text":"En el Ejercicio 6.6 creamos una funci\u00f3n llamada parse_csv() para parsear el contenido de archivos de datos en formato CSV. Ahora vamos a ver c\u00f3mo usar esa funci\u00f3n en otros programas. Empez\u00e1 por copiarte los archivos rebotes.py , hipoteca.py y fileparse.py a la carpeta de ejercicios de esta clase. Los vamos a importar. Con el directorio de trabajo adecuado (puede que tengas que reiniciar tu int\u00e9rprete para que tome efecto un cambio), intent\u00e1 importar los programas que escribiste antes. Con s\u00f3lo importarlos deber\u00edas ver su salida exactamente como cuando los terminaste de escribir. Repetimos: al importar un m\u00f3dulo ejecut\u00e1s su c\u00f3digo. >>> import rebotes #... mir\u00e1 la salida ... >>> import hipoteca #... mir\u00e1 la salida ... >>> import informe_funciones #... mir\u00e1 la salida ... >>> Si nada de esto funciona, es probable que est\u00e9s ejecutando Python desde la carpeta equivocada. Ahora prob\u00e1 importar tu m\u00f3dulo fileparse y pedile help . >>> import fileparse >>> help(fileparse) ... mir\u00e1 la salida ... >>> dir(fileparse) ... mir\u00e1 la salida ... >>> Intent\u00e1 usar el m\u00f3dulo para leer datos de un archivo: >>> camion = fileparse.parse_csv('../Data/camion.csv', select = ['nombre', 'cajones', 'precio'], types = [str, int, float]) >>> camion ... mir\u00e1 la salida ... >>> lista_precios = fileparse.parse_csv('../Data/precios.csv', types = [str, float], has_headers = False) >>> lista_precios ... mir\u00e1 la salida ... >>> precios = dict(lista_precios) >>> precios ... fijate la salida ... >>> precios['Naranja'] 106.28 >>> Import\u00e1 s\u00f3lo la funci\u00f3n para evitar escribir el nombre del m\u00f3dulo: >>> from fileparse import parse_csv >>> camion = parse_csv('../Data/camion.csv', select = ['nombre', 'cajones', 'precio'], types = [str, int, float]) >>> camion ... fijate la salida ... >>>","title":"Ejercicio 6.10: Importar m\u00f3dulos"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#ejercicio-611-usemos-tu-modulo","text":"En el Ejercicio 6.4 escribiste un programa informe_funciones.py que produce un informe como \u00e9ste: Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 $32.20 8.02 Naranja 50 $91.10 15.18 Caqui 150 $103.44 2.02 Mandarina 200 $51.23 29.66 Durazno 95 $40.37 33.11 Mandarina 50 $65.10 15.79 Naranja 100 $70.44 35.84 Retom\u00e1 ese programa (si lo perdiste, te dejamos una versi\u00f3n para que la leas y la puedas usar) y modificalo de modo que todo el procesamiento de archivos de entrada de datos se haga usando funciones del m\u00f3dulo fileparse . Para lograr \u00e9so, import\u00e1 fileparse como un m\u00f3dulo y cambi\u00e1 las funciones leer_camion() y leer_precios() para que usen la funci\u00f3n parse_csv() . Guiate por el ejemplo interactivo que dimos un poco m\u00e1s arriba. Al final, deber\u00edas obtener exactamente el mismo resultado que al principio.","title":"Ejercicio 6.11: Usemos tu m\u00f3dulo"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#ejercicio-612-un-poco-mas-alla","text":"En Ejercicio 2.6 escribiste el programa costo_camion.py que lee, mediante una funci\u00f3n llamada costo_camion() los datos de un cami\u00f3n y calcula su costo. >>> import costo_camion >>> costo_camion.costo_camion('../Data/camion.csv') 47671.15 >>> Modific\u00e1 el archivo costo_camion.py para que use la funci\u00f3n informe_funciones.leer_camion() del programa informe_funciones.py .","title":"Ejercicio 6.12: Un poco m\u00e1s all\u00e1"},{"location":"06_Organizacion_y_Complejidad/04_Modulos/#comentario","text":"Al terminar este ejercicio ten\u00e9s tres programas. fileparse.py contiene una funci\u00f3n para parsear datos de archivos CSV en general, parse_csv() . Por otra parte, informe_funciones.py que produce un bello informe, y que contiene las funciones leer_camion() y leer_precios() . Finalmente, costo_camion.py calcula el costo de un cami\u00f3n, pero usando la funci\u00f3n leer_camion() que fue escrita para el programa que genera el informe. Contenidos | Anterior (3 Funciones) | Pr\u00f3ximo (5 B\u00fasqueda binaria)","title":"Comentario"},{"location":"06_Organizacion_y_Complejidad/05_BusqBinaria/","text":"Contenidos | Anterior (4 M\u00f3dulos) | Pr\u00f3ximo (6 Complejidad de algoritmos) 6.5 B\u00fasqueda binaria Hace un par de clases vimos la b\u00fasqueda secuencial de un elemento en una lista. Si la lista est\u00e1 previamente ordenada, \u00bfpodemos encontrar una manera m\u00e1s eficiente de buscar elementos sobre ella? B\u00fasqueda sobre listas ordenadas Si la lista est\u00e1 ordenada, hay una modificaci\u00f3n muy simple que podemos hacer sobre el algoritmo de b\u00fasqueda lineal: si estamos buscando el elemento e en una lista que est\u00e1 ordenada de menor a mayor, en cuanto encontremos alg\u00fan elemento mayor a e podemos estar seguros de que e no est\u00e1 en la lista, por lo que no es necesario continuar recorriendo el resto. Ejercicio 6.13: B\u00fasqueda lineal sobre listas ordenadas. Modific\u00e1 la funci\u00f3n busqueda_lineal(lista, e) de la Secci\u00f3n 4.2 para el caso de listas ordenadas, de forma que la funci\u00f3n pare cuando encuentre un elemento mayor a e . Llam\u00e1 a tu nueva funci\u00f3n busqueda_lineal_lordenada(lista,e) y guardala en el archivo busqueda_en_listas.py . En el peor caso, \u00bfcu\u00e1l es nuestra nueva hip\u00f3tesis sobre comportamiento del algoritmo? \u00bfEs realmente m\u00e1s eficiente? B\u00fasqueda binaria \u00bfPodemos hacer algo mejor? Trataremos de aprovechar el hecho de que la lista est\u00e1 ordenada y vamos a hacer algo distinto: nuestro espacio de b\u00fasqueda se ir\u00e1 achicando a segmentos cada vez menores de la lista original. La idea es descartar segmentos de la lista donde el valor seguro que no puede estar: Consideramos como segmento inicial de b\u00fasqueda a la lista completa. Analizamos el punto medio del segmento (el valor central); si es el valor buscado, devolvemos el \u00edndice del punto medio. Si el valor central es mayor al buscado, podemos descartar el segmento que est\u00e1 desde el punto medio hacia la derecha. Si el valor central es menor al buscado, podemos descartar el segmento que est\u00e1 desde el punto medio hacia la izquierda. Una vez descartado el segmento que no nos interesa, volvemos a analizar el segmento restante, de la misma forma. Si en alg\u00fan momento el segmento a analizar tiene longitud 0 significa que el valor buscado no se encuentra en la lista. Para se\u00f1alar la porci\u00f3n del segmento que se est\u00e1 analizando a cada paso, utilizaremos dos variables ( izq y der ) que contienen la posici\u00f3n de inicio y la posici\u00f3n de fin del segmento que se est\u00e1 considerando. De la misma manera usaremos la varible medio para contener la posici\u00f3n del punto medio del segmento. A continuaci\u00f3n ilustramos qu\u00e9 pasa cuando se busca el valor 18 en la lista [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23] . Ejemplo de una b\u00fasqueda usando el algoritmo de b\u00fasqueda binaria. Como no se encontr\u00f3 al valor buscado, devuelve -1. El siguiente fragmento de c\u00f3digo muestra una implementaci\u00f3n de este algoritmo, incluyendo una instrucci\u00f3n de depuraci\u00f3n (debug) con print para verificar su funcionamiento. def busqueda_binaria(lista, x, verbose = False): '''B\u00fasqueda binaria Precondici\u00f3n: la lista est\u00e1 ordenada Devuelve -1 si x no est\u00e1 en lista; Devuelve p tal que lista[p] == x, si x est\u00e1 en lista ''' if verbose: print(f'[DEBUG] izq |der |medio') pos = -1 # Inicializo respuesta, el valor no fue encontrado izq = 0 der = len(lista) - 1 while izq <= der: medio = (izq + der) // 2 if verbose: print(f'[DEBUG] {izq:3d} |{der:>3d} |{medio:3d}') if lista[medio] == x: pos = medio # elemento encontrado! if lista[medio] > x: der = medio - 1 # descarto mitad derecha else: # if lista[medio] < x: izq = medio + 1 # descarto mitad izquierda return pos A continuaci\u00f3n varias ejecuciones de prueba: >>> busqueda_binaria([1, 3, 5], 0, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 2 | 1 [DEBUG] 0 | 0 | 0 -1 >>> busqueda_binaria([1, 3, 5], 1, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 2 | 1 [DEBUG] 0 | 0 | 0 0 >>> busqueda_binaria([1, 3, 5], 2, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 2 | 1 [DEBUG] 0 | 0 | 0 -1 >>> busqueda_binaria([1, 3, 5], 3, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 2 | 1 [DEBUG] 2 | 2 | 2 1 >>> busqueda_binaria([1, 3, 5], 5, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 2 | 1 [DEBUG] 2 | 2 | 2 2 >>> busqueda_binaria([1, 3, 5], 6, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 2 | 1 [DEBUG] 2 | 2 | 2 -1 >>> busqueda_binaria([], 0, verbose = True) [DEBUG] izq |der |medio -1 >>> busqueda_binaria([1], 1, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 0 | 0 0 >>> busqueda_binaria([1], 3, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 0 | 0 -1 >>> busqueda_binaria([1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23],18, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 11 | 5 [DEBUG] 6 | 11 | 8 [DEBUG] 9 | 11 | 10 [DEBUG] 9 | 9 | 9 -1 Pregunta : En la l\u00ednea medio = (izq + der) // 2 efectuamos la divisi\u00f3n usando el operador // en lugar de / . \u00bfQu\u00e9 pasar\u00eda su us\u00e1ramos / ? \u00bfCu\u00e1ntas comparaciones hace este programa? Para responder esto pensemos en el peor caso, es decir, que se descartaron varias veces partes del segmento para finalmente llegar a un segmento vac\u00edo y el valor buscado se encontr\u00f3 en este \u00faltimo paso o directamente no se encontraba en la lista. En cada paso el segmento se divide por la mitad y se desecha una de esas mitades, y en cada paso se hace una comparaci\u00f3n con el valor buscado. Por lo tanto, la cantidad de comparaciones que hacen con el valor buscado es aproximadamente igual a la cantidad de pasos necesarios para llegar a un segmento de tama\u00f1o 1. Veamos el caso m\u00e1s sencillo para razonar, y supongamos que la longitud de la lista es una potencia de 2, digamos len(lista) = 2^k : Antes del primer paso, el segmento a tratar es de tama\u00f1o 2^k . Antes del segundo paso, el segmento a tratar es de tama\u00f1o 2^(k-1) . Antes del tercer paso, el segmento a tratar es de tama\u00f1o 2^(k-2) . ... Antes del paso k , el segmento a tratar es de tama\u00f1o 2^(k-k)=2^0=1 . Por lo tanto este programa hace a lo sumo (en el peor caso) k comparaciones con el valor buscado cuando len(lista) = 2^k . Pero si despejamos k de la ecuaci\u00f3n anterior, podemos ver que este programa realiza aproximadamente log2(len(lista)) comparaciones. Cuando len(lista) no es una potencia de 2 el razonamiento es menos prolijo, pero tambi\u00e9n vale que este programa realiza aproximadamente log2(len(lista)) comparaciones. Comparaci\u00f3n entre ambos m\u00e9todos Veamos un ejemplo para entender cu\u00e1nto m\u00e1s eficiente es la b\u00fasqueda binaria. Supongamos que tenemos una lista con un mill\u00f3n de elementos. El algoritmo de b\u00fasqueda lineal har\u00e1, en el peor caso, un mill\u00f3n de comparaciones. Este caso se da si el elemento buscado no est\u00e1 en la lista o est\u00e1 en la \u00faltima posici\u00f3n. Como se ve la cantidad de operaciones es proporcional al largo de la lista. Si el elemento buscado est\u00e1 en la lista el algoritmo realizar\u00e1, en promedio, 500,000 comparaciones. El algoritmo de b\u00fasqueda binaria har\u00e1 como m\u00e1ximo log2(1,000,000) comparaciones, o sea \u00a1no m\u00e1s que 20 comparaciones!. Conclusi\u00f3n : Si una lista est\u00e1 previamente ordenada, podemos utilizar el algoritmo de b\u00fasqueda binaria, cuyo comportamiento es proporcional al logaritmo de la cantidad de elementos de la lista, y por lo tanto much\u00edsimo m\u00e1s eficiente que la b\u00fasqueda lineal, especialmente si la lista es larga. Ejercicio 6.14: B\u00fasqueda binaria Modificando la funci\u00f3n busqueda_binaria(lista, x) adecuadamente, defin\u00ed una funci\u00f3n donde_insertar(lista, x) de forma que reciba una lista ordenada y un elemento y devuelva la posici\u00f3n de ese elemento en la lista (si se encuentra en la lista) o la posici\u00f3n donde se podr\u00eda insertar el elemento para que la lista permanezca ordenada (si no est\u00e1 en la lista). Por ejemplo: el elemento 3 podr\u00eda insertarse en la posici\u00f3n 2 en la lista [0,2,4,6] para mantenerla ordenada. Por lo tanto, el llamado donde_insertar([0,2,4,6], 3) deber\u00e1 devolver 2 , al igual que el llamado donde_insertar([0,2,4,6], 4) . Guarda tu modificaci\u00f3n en un archivo bbin.py . Contenidos | Anterior (4 M\u00f3dulos) | Pr\u00f3ximo (6 Complejidad de algoritmos)","title":"05 BusqBinaria"},{"location":"06_Organizacion_y_Complejidad/05_BusqBinaria/#65-busqueda-binaria","text":"Hace un par de clases vimos la b\u00fasqueda secuencial de un elemento en una lista. Si la lista est\u00e1 previamente ordenada, \u00bfpodemos encontrar una manera m\u00e1s eficiente de buscar elementos sobre ella?","title":"6.5 B\u00fasqueda binaria"},{"location":"06_Organizacion_y_Complejidad/05_BusqBinaria/#busqueda-sobre-listas-ordenadas","text":"Si la lista est\u00e1 ordenada, hay una modificaci\u00f3n muy simple que podemos hacer sobre el algoritmo de b\u00fasqueda lineal: si estamos buscando el elemento e en una lista que est\u00e1 ordenada de menor a mayor, en cuanto encontremos alg\u00fan elemento mayor a e podemos estar seguros de que e no est\u00e1 en la lista, por lo que no es necesario continuar recorriendo el resto.","title":"B\u00fasqueda sobre listas ordenadas"},{"location":"06_Organizacion_y_Complejidad/05_BusqBinaria/#ejercicio-613-busqueda-lineal-sobre-listas-ordenadas","text":"Modific\u00e1 la funci\u00f3n busqueda_lineal(lista, e) de la Secci\u00f3n 4.2 para el caso de listas ordenadas, de forma que la funci\u00f3n pare cuando encuentre un elemento mayor a e . Llam\u00e1 a tu nueva funci\u00f3n busqueda_lineal_lordenada(lista,e) y guardala en el archivo busqueda_en_listas.py . En el peor caso, \u00bfcu\u00e1l es nuestra nueva hip\u00f3tesis sobre comportamiento del algoritmo? \u00bfEs realmente m\u00e1s eficiente?","title":"Ejercicio 6.13: B\u00fasqueda lineal sobre listas ordenadas."},{"location":"06_Organizacion_y_Complejidad/05_BusqBinaria/#busqueda-binaria","text":"\u00bfPodemos hacer algo mejor? Trataremos de aprovechar el hecho de que la lista est\u00e1 ordenada y vamos a hacer algo distinto: nuestro espacio de b\u00fasqueda se ir\u00e1 achicando a segmentos cada vez menores de la lista original. La idea es descartar segmentos de la lista donde el valor seguro que no puede estar: Consideramos como segmento inicial de b\u00fasqueda a la lista completa. Analizamos el punto medio del segmento (el valor central); si es el valor buscado, devolvemos el \u00edndice del punto medio. Si el valor central es mayor al buscado, podemos descartar el segmento que est\u00e1 desde el punto medio hacia la derecha. Si el valor central es menor al buscado, podemos descartar el segmento que est\u00e1 desde el punto medio hacia la izquierda. Una vez descartado el segmento que no nos interesa, volvemos a analizar el segmento restante, de la misma forma. Si en alg\u00fan momento el segmento a analizar tiene longitud 0 significa que el valor buscado no se encuentra en la lista. Para se\u00f1alar la porci\u00f3n del segmento que se est\u00e1 analizando a cada paso, utilizaremos dos variables ( izq y der ) que contienen la posici\u00f3n de inicio y la posici\u00f3n de fin del segmento que se est\u00e1 considerando. De la misma manera usaremos la varible medio para contener la posici\u00f3n del punto medio del segmento. A continuaci\u00f3n ilustramos qu\u00e9 pasa cuando se busca el valor 18 en la lista [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23] . Ejemplo de una b\u00fasqueda usando el algoritmo de b\u00fasqueda binaria. Como no se encontr\u00f3 al valor buscado, devuelve -1. El siguiente fragmento de c\u00f3digo muestra una implementaci\u00f3n de este algoritmo, incluyendo una instrucci\u00f3n de depuraci\u00f3n (debug) con print para verificar su funcionamiento. def busqueda_binaria(lista, x, verbose = False): '''B\u00fasqueda binaria Precondici\u00f3n: la lista est\u00e1 ordenada Devuelve -1 si x no est\u00e1 en lista; Devuelve p tal que lista[p] == x, si x est\u00e1 en lista ''' if verbose: print(f'[DEBUG] izq |der |medio') pos = -1 # Inicializo respuesta, el valor no fue encontrado izq = 0 der = len(lista) - 1 while izq <= der: medio = (izq + der) // 2 if verbose: print(f'[DEBUG] {izq:3d} |{der:>3d} |{medio:3d}') if lista[medio] == x: pos = medio # elemento encontrado! if lista[medio] > x: der = medio - 1 # descarto mitad derecha else: # if lista[medio] < x: izq = medio + 1 # descarto mitad izquierda return pos A continuaci\u00f3n varias ejecuciones de prueba: >>> busqueda_binaria([1, 3, 5], 0, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 2 | 1 [DEBUG] 0 | 0 | 0 -1 >>> busqueda_binaria([1, 3, 5], 1, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 2 | 1 [DEBUG] 0 | 0 | 0 0 >>> busqueda_binaria([1, 3, 5], 2, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 2 | 1 [DEBUG] 0 | 0 | 0 -1 >>> busqueda_binaria([1, 3, 5], 3, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 2 | 1 [DEBUG] 2 | 2 | 2 1 >>> busqueda_binaria([1, 3, 5], 5, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 2 | 1 [DEBUG] 2 | 2 | 2 2 >>> busqueda_binaria([1, 3, 5], 6, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 2 | 1 [DEBUG] 2 | 2 | 2 -1 >>> busqueda_binaria([], 0, verbose = True) [DEBUG] izq |der |medio -1 >>> busqueda_binaria([1], 1, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 0 | 0 0 >>> busqueda_binaria([1], 3, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 0 | 0 -1 >>> busqueda_binaria([1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23],18, verbose = True) [DEBUG] izq |der |medio [DEBUG] 0 | 11 | 5 [DEBUG] 6 | 11 | 8 [DEBUG] 9 | 11 | 10 [DEBUG] 9 | 9 | 9 -1 Pregunta : En la l\u00ednea medio = (izq + der) // 2 efectuamos la divisi\u00f3n usando el operador // en lugar de / . \u00bfQu\u00e9 pasar\u00eda su us\u00e1ramos / ?","title":"B\u00fasqueda binaria"},{"location":"06_Organizacion_y_Complejidad/05_BusqBinaria/#cuantas-comparaciones-hace-este-programa","text":"Para responder esto pensemos en el peor caso, es decir, que se descartaron varias veces partes del segmento para finalmente llegar a un segmento vac\u00edo y el valor buscado se encontr\u00f3 en este \u00faltimo paso o directamente no se encontraba en la lista. En cada paso el segmento se divide por la mitad y se desecha una de esas mitades, y en cada paso se hace una comparaci\u00f3n con el valor buscado. Por lo tanto, la cantidad de comparaciones que hacen con el valor buscado es aproximadamente igual a la cantidad de pasos necesarios para llegar a un segmento de tama\u00f1o 1. Veamos el caso m\u00e1s sencillo para razonar, y supongamos que la longitud de la lista es una potencia de 2, digamos len(lista) = 2^k : Antes del primer paso, el segmento a tratar es de tama\u00f1o 2^k . Antes del segundo paso, el segmento a tratar es de tama\u00f1o 2^(k-1) . Antes del tercer paso, el segmento a tratar es de tama\u00f1o 2^(k-2) . ... Antes del paso k , el segmento a tratar es de tama\u00f1o 2^(k-k)=2^0=1 . Por lo tanto este programa hace a lo sumo (en el peor caso) k comparaciones con el valor buscado cuando len(lista) = 2^k . Pero si despejamos k de la ecuaci\u00f3n anterior, podemos ver que este programa realiza aproximadamente log2(len(lista)) comparaciones. Cuando len(lista) no es una potencia de 2 el razonamiento es menos prolijo, pero tambi\u00e9n vale que este programa realiza aproximadamente log2(len(lista)) comparaciones.","title":"\u00bfCu\u00e1ntas comparaciones hace este programa?"},{"location":"06_Organizacion_y_Complejidad/05_BusqBinaria/#comparacion-entre-ambos-metodos","text":"Veamos un ejemplo para entender cu\u00e1nto m\u00e1s eficiente es la b\u00fasqueda binaria. Supongamos que tenemos una lista con un mill\u00f3n de elementos. El algoritmo de b\u00fasqueda lineal har\u00e1, en el peor caso, un mill\u00f3n de comparaciones. Este caso se da si el elemento buscado no est\u00e1 en la lista o est\u00e1 en la \u00faltima posici\u00f3n. Como se ve la cantidad de operaciones es proporcional al largo de la lista. Si el elemento buscado est\u00e1 en la lista el algoritmo realizar\u00e1, en promedio, 500,000 comparaciones. El algoritmo de b\u00fasqueda binaria har\u00e1 como m\u00e1ximo log2(1,000,000) comparaciones, o sea \u00a1no m\u00e1s que 20 comparaciones!. Conclusi\u00f3n : Si una lista est\u00e1 previamente ordenada, podemos utilizar el algoritmo de b\u00fasqueda binaria, cuyo comportamiento es proporcional al logaritmo de la cantidad de elementos de la lista, y por lo tanto much\u00edsimo m\u00e1s eficiente que la b\u00fasqueda lineal, especialmente si la lista es larga.","title":"Comparaci\u00f3n entre ambos m\u00e9todos"},{"location":"06_Organizacion_y_Complejidad/05_BusqBinaria/#ejercicio-614-busqueda-binaria","text":"Modificando la funci\u00f3n busqueda_binaria(lista, x) adecuadamente, defin\u00ed una funci\u00f3n donde_insertar(lista, x) de forma que reciba una lista ordenada y un elemento y devuelva la posici\u00f3n de ese elemento en la lista (si se encuentra en la lista) o la posici\u00f3n donde se podr\u00eda insertar el elemento para que la lista permanezca ordenada (si no est\u00e1 en la lista). Por ejemplo: el elemento 3 podr\u00eda insertarse en la posici\u00f3n 2 en la lista [0,2,4,6] para mantenerla ordenada. Por lo tanto, el llamado donde_insertar([0,2,4,6], 3) deber\u00e1 devolver 2 , al igual que el llamado donde_insertar([0,2,4,6], 4) . Guarda tu modificaci\u00f3n en un archivo bbin.py . Contenidos | Anterior (4 M\u00f3dulos) | Pr\u00f3ximo (6 Complejidad de algoritmos)","title":"Ejercicio 6.14: B\u00fasqueda binaria"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/","text":"Contenidos | Anterior (5 B\u00fasqueda binaria) | Pr\u00f3ximo (7 Gr\u00e1ficos de complejidad) 6.6 Complejidad de algoritmos Resumen de algoritmos de B\u00fasqueda La b\u00fasqueda de un elemento en una secuencia es un algoritmo b\u00e1sico pero importante. El problema que intenta resolver puede plantearse de la siguiente manera: Dada una secuencia de valores y un valor, devolver el \u00edndice del valor en la secuencia, si se encuentra, de no encontrarse el valor en la secuencia se\u00f1alarlo apropiadamente. Una de las formas de resolver el problema es mediante la b\u00fasqueda lineal , que consiste en ir revisando uno a uno los elementos de la secuencia y compar\u00e1ndolos con el elemento a buscar. Este algoritmo no requiere que la secuencia se encuentre ordenada, la cantidad de comparaciones que realiza es proporcional a len(secuencia) . Cuando la secuencia sobre la que se quiere buscar est\u00e1 ordenada, se puede utilizar el algoritmo de b\u00fasqueda binaria . Al estar ordenada la secuencia, se puede desacartar en cada paso la mitad de los elementos, quedando entonces con una eficiencia algor\u00edtmica proporcional a log2(len(secuencia)) . El an\u00e1lisis del comportamiento de un algoritmo puede ser muy enga\u00f1oso si se tiene en cuenta el mejor caso, por eso suele ser mucho m\u00e1s ilustrativo tener en cuenta el peor caso . En algunos casos particulares podr\u00e1 ser \u00fatil tener en cuenta, adem\u00e1s, el caso promedio . Complejidad de algoritmos En las ciencias de la computaci\u00f3n, el an\u00e1lisis de algoritmos es el proceso que permite determinar la complejidad de un algoritmo. Esta complejidad est\u00e1 t\u00edpicamente medida en unidades de tiempo, o, an\u00e1logamente, en la cantidad de operaciones que realiza el procesador antes de dar la respuesta. Esto permite comparar la eficiencia de diferentes algoritmos. Optimizar la eficiencia de los algoritmos es central en la tarea de un buen programador. Un algoritmo ineficiente puede no servir para nada. Esto es obvio en algoritmos que corren en tiempo real (imaginemos un algoritmo que conduce un veh\u00edculo y tarda demasiado en detectar a un peat\u00f3n), pero tambi\u00e9n es importante en otros algoritmos. Escribir programas eficientes no es una tarea sencilla. Muchas veces, las soluciones m\u00e1s directas no son las m\u00e1s eficientes. Los algoritmos m\u00e1s eficientes suelen aprovechar sutilezas que no son simples de comprender de un vistazo. En muchos casos les programadores deben incrementar la complejidad conceptual de un algoritmo para disminu\u00edr la complejidad computacional. Por ejemplo, buscar la posici\u00f3n de un n\u00famero en una lista recorriendo la lista lugar a lugar (b\u00fasqueda secuencial) demanda una cantidad de operaciones proporcional a la longitud de la lista (por cada elemento de la lista hacemos algunas operaciones fijas: comparar el elemento contra la clave, incrementar un contador, etc). Solemos decir que el algoritmo de b\u00fasqueda secuencial tiene un complejidad lineal en la longitud de la lista (ya que toma un tiempo f(n) , donde f es una funci\u00f3n lineal en n, la cantidad de elementos de la lista). No vamos a preocuparnos aqu\u00ed si f (n) = 3 \u00b7 n + 5 \u00f3 f (n) = 2 \u00b7 n + 18 . No nos importan las constantes: simplemente diremos que f (n) es lineal en n. En la literatura esto se escribe f(n) = O(n) y se lee 'la funci\u00f3n f tiene orden n' , o 'f es un O de n' . En cambio, la b\u00fasqueda binaria que vimos anteriormente, si bien es conceptualmente m\u00e1s compleja, resulta mucho m\u00e1s eficiente. Dada una clave y una lista ordenada, este algoritmo aprovecha el orden de la lista para no tener que comparar la clave con todos los elementos. En un primer paso compara con el elemento central de la lista y descarta toda una mitad de la lista realizando una sola comparaci\u00f3n. No es obvio c\u00f3mo calcular la complejidad de este m\u00e9todo, pero explicamos que si la lista tiene longitud n = 2^k, el algoritmo de b\u00fasqueda binaria realiza a lo sumo log2(n) + 1 = k + 1 comparaciones antes de dar la respuesta (hac\u00e9 un ejemplo con n = 2^3 = 8 o n = 2^4 = 16 para convencerte). En general, procediendo de esta forma el algoritmo encuentra la posici\u00f3n de la clave en O(log2(n)) pasos. Decimos en este caso que el algoritmo requiere tiempo logar\u00edtmico. Comparando la funcion f(n) = n con g(n) = log2(n) para valores grandes de n resulta claro que la b\u00fasqueda binaria es mucho m\u00e1s eficiente que la b\u00fasqueda secuencial para listas ordendas. En la pr\u00f3xima secci\u00f3n te vamos a proponer que hagas esta comparaci\u00f3n gr\u00e1ficamente. Un algoritmo cuadr\u00e1tico Para dar un \u00faltimo ejemplo, supongamos que dada una lista de n\u00fameros (de longitud n) y un valor m queremos ver si m = p \u00b7 q con p y q en la lista dada. Consideremos el siguiente algoritmo: for p in lista : for q in lista : if m == p * q : print ( \" %d= %d* %d \" %(m, p , q ) ) Este algoritmo realiza una comparaci\u00f3n ( m == p*q ) para cada elemento p y cada elemento q de la lista. Es decir, realiza n*n = n^2 comparaciones. Es un algoritmo cuadr\u00e1tico. Su complejidad es O(n^2). Complejidad en el peor caso El t\u00e9rmino an\u00e1lisis de algoritmos fue acu\u00f1ado por Donald Knuth, uno de los fundadores de las ciencias de la computaci\u00f3n. El an\u00e1lisis de algoritmos es una parte de la teor\u00eda de la complejidad computacional que no solo estudia la complejidad de los algoritmos sino de los problemas computacionales (la pregunta general de la teor\u00eda de la complejidad no ser\u00eda cu\u00e1l es la complejidad de la b\u00fasqueda secuencial o binaria, sino cu\u00e1l es la complejidad m\u00ednima que puede tener un algoritmo que realice la tarea de buscar un elemento en una lista ordenada). En general, y sin mencionarlo, hablamos de la complejidad en el peor caso de un algoritmo. En algunos casos puede ocurrir que la b\u00fasqueda secuencial sea m\u00e1s eficiente que la b\u00fasqueda binaria (por ejemplo, consider\u00e1 el caso en que el elemento buscado es justo el primer elemento de la lista, \u00bfcu\u00e1nto tarda cada m\u00e9todo?). Al hablar de la complejidad de una algoritmo (salvo que se mencione otra cosa) hablamos del tiempo que tarda ese algoritmo en el peor caso posible. Estructuras de datos y Tipos Abstractos de Datos El dise\u00f1o de un algoritmo eficiente para resolver un problema requiere comprender profundamente los datos que este algoritmo manipular\u00e1 para poder dise\u00f1ar adecuadamente las estructuras de datos que los contendr\u00e1n. El dise\u00f1o de algoritmos eficientes requiere del dise\u00f1o simult\u00e1neo de algoritmos y estructuras de datos adecuadas. Diferentes estructuras de datos son adecuadas para diferentes tipos de aplicaciones y algunas estructuras est\u00e1n dise\u00f1adas especialmente para un problema concreto. Una estructura de datos eficiente puede ser la clave para el dise\u00f1o de un algoritmo eficiente. La estructura l\u00f3gica de las estructuras de datos se llaman Tipos Abstractos de Datos (TAD). Estos TAD son el modelo matem\u00e1tico de las estructuras de datos. Un TAD es una abstracci\u00f3n del tipo de datos: define su comportamiento desde el punto de vista de le usuarie pero no dice c\u00f3mo lo hace, no se mete en la implementaci\u00f3n. Una estructura de datos concreta surge idealmente de la implementaci\u00f3n de un TAD. Ejercicios: Ejercicio 6.15: Insertar un elemento en una lista Uno de los problemas de la b\u00fasqueda binaria es que requiere que la lista est\u00e9 ordenada. Si la lista se encuentra ordenada podemos mantener el orden evitando adjuntar nuevos elementos de forma desordenada. Usando lo que hiciste en el Ejercicio 6.14 , agregale al archivo bbin.py una funci\u00f3n insertar(lista, x) que reciba una lista ordenada y un elemento. Si el elemento se encuentra en la lista solamente devuelve su posici\u00f3n; si no se encuentra en la lista, lo inserta en la posici\u00f3n correcta para mantener el orden. En este segundo caso, tambi\u00e9n debe devolver su posici\u00f3n. Ejercicio 6.16: C\u00e1lcular la complejidad de dos resoluciones de propagar Ahora que ten\u00e9s algunas herramientas te\u00f3ricas m\u00e1s, volv\u00e9 a leer las dos versiones de propagar del Ejercicio 6.1 y el Ejercicio 6.2 y compar\u00e1 sus complejidades. Secuencias binarias Para nosotres, una secuencia binaria es una lista que contiene solo 0\u2019s y 1\u2019s. Por ejemplo s = [0, 1, 0, 0, 1] es una secuencia binaria de longitud 5. La primera secuencia binaria de esa longitud es [0, 0, 0, 0, 0] , mientras que la \u00faltima es [1, 1, 1, 1, 1] . Cada secuencia tiene una siguiente (salvo la \u00faltima). No vamos a dar una definici\u00f3n precisa, pero escencialmente las secuencias pueden pensarse como representando n\u00fameros enteros en base dos y la siguiente secuencia es la que representa al siguiente n\u00famero. Por convenci\u00f3n, diremos que la secuencia siguiente de la \u00faltima es la primera. Ejemplos: [0, 0, 0, 0, 0] -> [0, 0, 0, 0, 1] [0, 0, 1, 1, 0] -> [0, 0, 1, 1, 1] [0, 0, 1, 1, 1] -> [0, 1, 0, 0, 0] [1, 1, 1, 1, 1] -> [0, 0, 0, 0, 0] La funci\u00f3n incrementar(s) calcula la secuencia siguiente de una secuencia dada: def incrementar(s): carry = 1 l = len(s) for i in range(l-1,-1,-1): if (s[i] == 1 and carry == 1): s[i] = 0 carry = 1 else: s[i] = s[i] + carry carry = 0 return s Ejercicio 6.17: Complejidad de incrementar() Si tomamos n = len(s) podemos tratar de medir la complejidad de la funci\u00f3n incrementar() en t\u00e9rminos de la longitud n de la secuencia. \u00bfTe parece que incrementar() es una funci\u00f3n lineal, cuadr\u00e1tica, logar\u00edtmica o exponencial? \u00bfPor qu\u00e9? Ejercicio 6.18: Un ejemplo m\u00e1s complejo Por \u00faltimo, escrib\u00ed una funcion listar_secuencias(n) que devuelva una lista con todas las secuencias binarias de longitud n comenzando con la primera ( [0]*n ) y usando en cada paso la funci\u00f3n incrementar() definida m\u00e1s arriba. \u00bfCu\u00e1ntas listas hay de longitud n ? \u00bfY de longitud n+1 ? \u00bfPod\u00e9s correr listar_secuencias(15) ? \u00bfY listar_secuencias(20) ? \u00bfHasta c\u00faanto llegas a correr en un tiempo razonable? \u00bfTe parece que listar_secuencias(n) es una funci\u00f3n lineal, cuadr\u00e1tica, logar\u00edtmica o exponencial en n ? \u00bfPor qu\u00e9? Contenidos | Anterior (5 B\u00fasqueda binaria) | Pr\u00f3ximo (7 Gr\u00e1ficos de complejidad)","title":"06 Complejidad"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/#66-complejidad-de-algoritmos","text":"","title":"6.6 Complejidad de algoritmos"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/#resumen-de-algoritmos-de-busqueda","text":"La b\u00fasqueda de un elemento en una secuencia es un algoritmo b\u00e1sico pero importante. El problema que intenta resolver puede plantearse de la siguiente manera: Dada una secuencia de valores y un valor, devolver el \u00edndice del valor en la secuencia, si se encuentra, de no encontrarse el valor en la secuencia se\u00f1alarlo apropiadamente. Una de las formas de resolver el problema es mediante la b\u00fasqueda lineal , que consiste en ir revisando uno a uno los elementos de la secuencia y compar\u00e1ndolos con el elemento a buscar. Este algoritmo no requiere que la secuencia se encuentre ordenada, la cantidad de comparaciones que realiza es proporcional a len(secuencia) . Cuando la secuencia sobre la que se quiere buscar est\u00e1 ordenada, se puede utilizar el algoritmo de b\u00fasqueda binaria . Al estar ordenada la secuencia, se puede desacartar en cada paso la mitad de los elementos, quedando entonces con una eficiencia algor\u00edtmica proporcional a log2(len(secuencia)) . El an\u00e1lisis del comportamiento de un algoritmo puede ser muy enga\u00f1oso si se tiene en cuenta el mejor caso, por eso suele ser mucho m\u00e1s ilustrativo tener en cuenta el peor caso . En algunos casos particulares podr\u00e1 ser \u00fatil tener en cuenta, adem\u00e1s, el caso promedio .","title":"Resumen de algoritmos de B\u00fasqueda"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/#complejidad-de-algoritmos","text":"En las ciencias de la computaci\u00f3n, el an\u00e1lisis de algoritmos es el proceso que permite determinar la complejidad de un algoritmo. Esta complejidad est\u00e1 t\u00edpicamente medida en unidades de tiempo, o, an\u00e1logamente, en la cantidad de operaciones que realiza el procesador antes de dar la respuesta. Esto permite comparar la eficiencia de diferentes algoritmos. Optimizar la eficiencia de los algoritmos es central en la tarea de un buen programador. Un algoritmo ineficiente puede no servir para nada. Esto es obvio en algoritmos que corren en tiempo real (imaginemos un algoritmo que conduce un veh\u00edculo y tarda demasiado en detectar a un peat\u00f3n), pero tambi\u00e9n es importante en otros algoritmos. Escribir programas eficientes no es una tarea sencilla. Muchas veces, las soluciones m\u00e1s directas no son las m\u00e1s eficientes. Los algoritmos m\u00e1s eficientes suelen aprovechar sutilezas que no son simples de comprender de un vistazo. En muchos casos les programadores deben incrementar la complejidad conceptual de un algoritmo para disminu\u00edr la complejidad computacional. Por ejemplo, buscar la posici\u00f3n de un n\u00famero en una lista recorriendo la lista lugar a lugar (b\u00fasqueda secuencial) demanda una cantidad de operaciones proporcional a la longitud de la lista (por cada elemento de la lista hacemos algunas operaciones fijas: comparar el elemento contra la clave, incrementar un contador, etc). Solemos decir que el algoritmo de b\u00fasqueda secuencial tiene un complejidad lineal en la longitud de la lista (ya que toma un tiempo f(n) , donde f es una funci\u00f3n lineal en n, la cantidad de elementos de la lista). No vamos a preocuparnos aqu\u00ed si f (n) = 3 \u00b7 n + 5 \u00f3 f (n) = 2 \u00b7 n + 18 . No nos importan las constantes: simplemente diremos que f (n) es lineal en n. En la literatura esto se escribe f(n) = O(n) y se lee 'la funci\u00f3n f tiene orden n' , o 'f es un O de n' . En cambio, la b\u00fasqueda binaria que vimos anteriormente, si bien es conceptualmente m\u00e1s compleja, resulta mucho m\u00e1s eficiente. Dada una clave y una lista ordenada, este algoritmo aprovecha el orden de la lista para no tener que comparar la clave con todos los elementos. En un primer paso compara con el elemento central de la lista y descarta toda una mitad de la lista realizando una sola comparaci\u00f3n. No es obvio c\u00f3mo calcular la complejidad de este m\u00e9todo, pero explicamos que si la lista tiene longitud n = 2^k, el algoritmo de b\u00fasqueda binaria realiza a lo sumo log2(n) + 1 = k + 1 comparaciones antes de dar la respuesta (hac\u00e9 un ejemplo con n = 2^3 = 8 o n = 2^4 = 16 para convencerte). En general, procediendo de esta forma el algoritmo encuentra la posici\u00f3n de la clave en O(log2(n)) pasos. Decimos en este caso que el algoritmo requiere tiempo logar\u00edtmico. Comparando la funcion f(n) = n con g(n) = log2(n) para valores grandes de n resulta claro que la b\u00fasqueda binaria es mucho m\u00e1s eficiente que la b\u00fasqueda secuencial para listas ordendas. En la pr\u00f3xima secci\u00f3n te vamos a proponer que hagas esta comparaci\u00f3n gr\u00e1ficamente.","title":"Complejidad de algoritmos"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/#un-algoritmo-cuadratico","text":"Para dar un \u00faltimo ejemplo, supongamos que dada una lista de n\u00fameros (de longitud n) y un valor m queremos ver si m = p \u00b7 q con p y q en la lista dada. Consideremos el siguiente algoritmo: for p in lista : for q in lista : if m == p * q : print ( \" %d= %d* %d \" %(m, p , q ) ) Este algoritmo realiza una comparaci\u00f3n ( m == p*q ) para cada elemento p y cada elemento q de la lista. Es decir, realiza n*n = n^2 comparaciones. Es un algoritmo cuadr\u00e1tico. Su complejidad es O(n^2).","title":"Un algoritmo cuadr\u00e1tico"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/#complejidad-en-el-peor-caso","text":"El t\u00e9rmino an\u00e1lisis de algoritmos fue acu\u00f1ado por Donald Knuth, uno de los fundadores de las ciencias de la computaci\u00f3n. El an\u00e1lisis de algoritmos es una parte de la teor\u00eda de la complejidad computacional que no solo estudia la complejidad de los algoritmos sino de los problemas computacionales (la pregunta general de la teor\u00eda de la complejidad no ser\u00eda cu\u00e1l es la complejidad de la b\u00fasqueda secuencial o binaria, sino cu\u00e1l es la complejidad m\u00ednima que puede tener un algoritmo que realice la tarea de buscar un elemento en una lista ordenada). En general, y sin mencionarlo, hablamos de la complejidad en el peor caso de un algoritmo. En algunos casos puede ocurrir que la b\u00fasqueda secuencial sea m\u00e1s eficiente que la b\u00fasqueda binaria (por ejemplo, consider\u00e1 el caso en que el elemento buscado es justo el primer elemento de la lista, \u00bfcu\u00e1nto tarda cada m\u00e9todo?). Al hablar de la complejidad de una algoritmo (salvo que se mencione otra cosa) hablamos del tiempo que tarda ese algoritmo en el peor caso posible.","title":"Complejidad en el peor caso"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/#estructuras-de-datos-y-tipos-abstractos-de-datos","text":"El dise\u00f1o de un algoritmo eficiente para resolver un problema requiere comprender profundamente los datos que este algoritmo manipular\u00e1 para poder dise\u00f1ar adecuadamente las estructuras de datos que los contendr\u00e1n. El dise\u00f1o de algoritmos eficientes requiere del dise\u00f1o simult\u00e1neo de algoritmos y estructuras de datos adecuadas. Diferentes estructuras de datos son adecuadas para diferentes tipos de aplicaciones y algunas estructuras est\u00e1n dise\u00f1adas especialmente para un problema concreto. Una estructura de datos eficiente puede ser la clave para el dise\u00f1o de un algoritmo eficiente. La estructura l\u00f3gica de las estructuras de datos se llaman Tipos Abstractos de Datos (TAD). Estos TAD son el modelo matem\u00e1tico de las estructuras de datos. Un TAD es una abstracci\u00f3n del tipo de datos: define su comportamiento desde el punto de vista de le usuarie pero no dice c\u00f3mo lo hace, no se mete en la implementaci\u00f3n. Una estructura de datos concreta surge idealmente de la implementaci\u00f3n de un TAD.","title":"Estructuras de datos y Tipos Abstractos de Datos"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/#ejercicios","text":"","title":"Ejercicios:"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/#ejercicio-615-insertar-un-elemento-en-una-lista","text":"Uno de los problemas de la b\u00fasqueda binaria es que requiere que la lista est\u00e9 ordenada. Si la lista se encuentra ordenada podemos mantener el orden evitando adjuntar nuevos elementos de forma desordenada. Usando lo que hiciste en el Ejercicio 6.14 , agregale al archivo bbin.py una funci\u00f3n insertar(lista, x) que reciba una lista ordenada y un elemento. Si el elemento se encuentra en la lista solamente devuelve su posici\u00f3n; si no se encuentra en la lista, lo inserta en la posici\u00f3n correcta para mantener el orden. En este segundo caso, tambi\u00e9n debe devolver su posici\u00f3n.","title":"Ejercicio 6.15: Insertar un elemento en una lista"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/#ejercicio-616-calcular-la-complejidad-de-dos-resoluciones-de-propagar","text":"Ahora que ten\u00e9s algunas herramientas te\u00f3ricas m\u00e1s, volv\u00e9 a leer las dos versiones de propagar del Ejercicio 6.1 y el Ejercicio 6.2 y compar\u00e1 sus complejidades.","title":"Ejercicio 6.16: C\u00e1lcular la complejidad de dos resoluciones de propagar"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/#secuencias-binarias","text":"Para nosotres, una secuencia binaria es una lista que contiene solo 0\u2019s y 1\u2019s. Por ejemplo s = [0, 1, 0, 0, 1] es una secuencia binaria de longitud 5. La primera secuencia binaria de esa longitud es [0, 0, 0, 0, 0] , mientras que la \u00faltima es [1, 1, 1, 1, 1] . Cada secuencia tiene una siguiente (salvo la \u00faltima). No vamos a dar una definici\u00f3n precisa, pero escencialmente las secuencias pueden pensarse como representando n\u00fameros enteros en base dos y la siguiente secuencia es la que representa al siguiente n\u00famero. Por convenci\u00f3n, diremos que la secuencia siguiente de la \u00faltima es la primera. Ejemplos: [0, 0, 0, 0, 0] -> [0, 0, 0, 0, 1] [0, 0, 1, 1, 0] -> [0, 0, 1, 1, 1] [0, 0, 1, 1, 1] -> [0, 1, 0, 0, 0] [1, 1, 1, 1, 1] -> [0, 0, 0, 0, 0] La funci\u00f3n incrementar(s) calcula la secuencia siguiente de una secuencia dada: def incrementar(s): carry = 1 l = len(s) for i in range(l-1,-1,-1): if (s[i] == 1 and carry == 1): s[i] = 0 carry = 1 else: s[i] = s[i] + carry carry = 0 return s","title":"Secuencias binarias"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/#ejercicio-617-complejidad-de-incrementar","text":"Si tomamos n = len(s) podemos tratar de medir la complejidad de la funci\u00f3n incrementar() en t\u00e9rminos de la longitud n de la secuencia. \u00bfTe parece que incrementar() es una funci\u00f3n lineal, cuadr\u00e1tica, logar\u00edtmica o exponencial? \u00bfPor qu\u00e9?","title":"Ejercicio 6.17: Complejidad de incrementar()"},{"location":"06_Organizacion_y_Complejidad/06_Complejidad/#ejercicio-618-un-ejemplo-mas-complejo","text":"Por \u00faltimo, escrib\u00ed una funcion listar_secuencias(n) que devuelva una lista con todas las secuencias binarias de longitud n comenzando con la primera ( [0]*n ) y usando en cada paso la funci\u00f3n incrementar() definida m\u00e1s arriba. \u00bfCu\u00e1ntas listas hay de longitud n ? \u00bfY de longitud n+1 ? \u00bfPod\u00e9s correr listar_secuencias(15) ? \u00bfY listar_secuencias(20) ? \u00bfHasta c\u00faanto llegas a correr en un tiempo razonable? \u00bfTe parece que listar_secuencias(n) es una funci\u00f3n lineal, cuadr\u00e1tica, logar\u00edtmica o exponencial en n ? \u00bfPor qu\u00e9? Contenidos | Anterior (5 B\u00fasqueda binaria) | Pr\u00f3ximo (7 Gr\u00e1ficos de complejidad)","title":"Ejercicio 6.18: Un ejemplo m\u00e1s complejo"},{"location":"06_Organizacion_y_Complejidad/07_gr%C3%A1ficos_de_complejidad/","text":"Contenidos | Anterior (6 Complejidad de algoritmos) | Pr\u00f3ximo (8 Cierre de la clase) 6.7 Gr\u00e1ficos de complejidad Contar la cantidad de operaciones de un algoritmo La siguiente funci\u00f3n realiza una b\u00fasqueda secuencial de un elemento en una lista. Devuelve la posici\u00f3n del elemento si lo encuentra y -1 si no lo encuentra. def busqueda_secuencial(lista, x): '''Si x est\u00e1 en la lista devuelve el \u00edndice de su primera aparici\u00f3n, de lo contrario devuelve -1. ''' pos = -1 for i,z in enumerate(lista): if z == x: pos = i break return pos Esta modificaci\u00f3n de la funci\u00f3n cuenta (y devuelve) adem\u00e1s cu\u00e1ntas comparaciones ( z == x ) hace la funci\u00f3n. Observ\u00e1 que devuelve un par de datos. def busqueda_secuencial_(lista, x): '''Si x est\u00e1 en la lista devuelve el \u00edndice de su primera aparici\u00f3n, de lo contrario devuelve -1. Adem\u00e1s devuelve la cantidad de comparaciones que hace la funci\u00f3n. ''' comps = 0 # inicializo en cero la cantidad de comparaciones pos = -1 for i,z in enumerate(lista): comps += 1 # sumo la comparaci\u00f3n que estoy por hacer if z == x: pos = i break return pos, comps Si quer\u00e9s acceder a la posici\u00f3n pod\u00e9s usar busqueda_secuencial_(lista, x)[0] y para acceder a la cantidad de comparaciones que hizo busqueda_secuencial_(lista, x)[1] . Ejercicio 6.19: Contar comparaciones en la b\u00fasqueda binaria Modific\u00e1 el c\u00f3digo de b\u00fasqueda binaria ( busqueda_binaria(lista, x) ) introducido en la Secci\u00f3n 6.5 , de forma que devuelva (adem\u00e1s de la posici\u00f3n del elemento en la lista) la cantidad de comparaciones que realiz\u00f3 el algoritmo para encontrarlo o decidir que no est\u00e1. Gr\u00e1ficar la cantidad de comparaciones promedio La siguiente funci\u00f3n generar_lista(n, m) devuelve una lista ordenada de n elementos diferentes entre 0 y m-1 , mientras que generar_elemento(m) devuelve un elemento aleatorio en el mismo rango de valores. import random def generar_lista(n, m): l = random.sample(range(m), k = n) l.sort() return l def generar_elemento(m): return random.randint(0, m-1) Dada una lista ya generada, digamos que un experimento elemental es generar un elemento, buscarlo en la lista y contar la cantidad de comparaciones realizadas. Esta cantidad de operaciones es el resultado del experimento elemental. m = 10000 n = 100 lista = generar_lista(n, m) # ac\u00e1 comienza el experimento x = generar_elemento(m) comps = busqueda_secuencial_(lista, x)[1] Entonces, el siguiente c\u00f3digo da la cantidad de comparaciones promedio en k experimentos elementales. Observ\u00e1 que hay muchas variables diferentes dando vueltas: n , m y k . m = 10000 n = 100 k = 1000 lista = generar_lista(n, m) def experimento_secuencial_promedio(lista, m, k): comps_tot = 0 for i in range(k): x = generar_elemento(m) comps_tot += busqueda_secuencial_(lista,x)[1] comps_prom = comps_tot / k return comps_prom Como las listas tienen n = 100 elementos y estoy buscando un n\u00famero cualquiera entre m n\u00fameros diferentes, es casi seguro que no lo voy a encontrar y que voy a tener que recorrer toda la lista para concluir esto (aunque en alg\u00fan caso puede ser que est\u00e9 y lo encuentre antes de recorrerla toda!). Entonces el promedio de comparaciones va a dar cercano al largo n de la lista, quiz\u00e1s un poco menor. Tiene una componente aleatoria, es un experimento num\u00e9rico. Si dec\u00edamos que buscar un elemento era un experimento elemental digamos que repetir k experimentos elementales y calcular el promedio de comparaciones es un experimento de promedios . Grafiquemos los resultados de estos experimentos de promedios para diferentes listas de largos n entre 1 y 256. Es decir, estaremos graficando la cantidad de comparaciones que hace en promedio el algoritmo de b\u00fasqueda secuencial sobre una lista de largo n , para diferentes valores de n . import matplotlib.pyplot as plt import numpy as np m = 10000 k = 1000 largos = np.arange(256) + 1 # estos son los largos de listas que voy a usar comps_promedio = np.zeros(256) # aca guardo el promedio de comparaciones sobre una lista de largo i, para i entre 1 y 256. for i, n in enumerate(largos): lista = generar_lista(n, m) # genero lista de largo n comps_promedio[i] = experimento_secuencial_promedio(lista, m, k) # ahora grafico largos de listas contra operaciones promedio de b\u00fasqueda. plt.plot(largos,comps_promedio,label = 'B\u00fasqueda Secuencial') plt.xlabel(\"Largo de la lista\") plt.ylabel(\"Cantidad de comparaciones\") plt.title(\"Complejidad de la B\u00fasqueda\") plt.legend() plt.show() En la pr\u00f3xima clase estudiaremos en detalle la librer\u00eda matplotlib que ya empezamos a usar la clase pasada. Por ahora solo agregamos la funci\u00f3n plot(x, y) a la que se le pasan dos vectores (o listas) x e y y realiza una gr\u00e1fico de l\u00edneas uniendo los puntos con esas coordenadas. El par\u00e1metro label permite ponerle un nombre a la curva que se muestra luego con la funci\u00f3n plt.legend() . Este gr\u00e1fico parece medio sonso, pero en el pr\u00f3ximo ejercicio va a ir tomando color. Ejercicio 6.20: B\u00fasqueda binaria vs. b\u00fasqueda secuencial En este Ejercicio vamos a rehacer los gr\u00e1ficos del ejemplo anterior, pero primero cambiando el algoritmo de b\u00fasqueda y luego comparando ambos algoritmos. Usando experimento_secuencial_promedio(lista, m, k) como base, escrib\u00ed una funci\u00f3n experimento_binario_promedio(lista, m, k) que cuente la cantidad de comparaciones que realiza en promedio (entre k experimentos elementales) la b\u00fasqueda binaria sobre la lista pasada como par\u00e1metro. Grafic\u00e1 los resultados de estos experimentos para listas de largo entre 1 y 256. Grafic\u00e1 ambas curvas en una misma figura, nombrando adecuadamente las curvas, los ejes y la figura completa. Jug\u00e1 con xlim e ylim para visualizar bien las dos curvas, aunque tengas que restringir el rango. \u00bfQu\u00e9 observas en estos gr\u00e1ficos? \u00bfQu\u00e9 pod\u00e9s decir sobre la complejidad de cada algoritmo? \u00bfSon similares? El c\u00f3digo de este ejercicio guardalo en plot_bbin_vs_bsec.py . Contenidos | Anterior (6 Complejidad de algoritmos) | Pr\u00f3ximo (8 Cierre de la clase)","title":"07 gr\u00e1ficos de complejidad"},{"location":"06_Organizacion_y_Complejidad/07_gr%C3%A1ficos_de_complejidad/#67-graficos-de-complejidad","text":"","title":"6.7 Gr\u00e1ficos de complejidad"},{"location":"06_Organizacion_y_Complejidad/07_gr%C3%A1ficos_de_complejidad/#contar-la-cantidad-de-operaciones-de-un-algoritmo","text":"La siguiente funci\u00f3n realiza una b\u00fasqueda secuencial de un elemento en una lista. Devuelve la posici\u00f3n del elemento si lo encuentra y -1 si no lo encuentra. def busqueda_secuencial(lista, x): '''Si x est\u00e1 en la lista devuelve el \u00edndice de su primera aparici\u00f3n, de lo contrario devuelve -1. ''' pos = -1 for i,z in enumerate(lista): if z == x: pos = i break return pos Esta modificaci\u00f3n de la funci\u00f3n cuenta (y devuelve) adem\u00e1s cu\u00e1ntas comparaciones ( z == x ) hace la funci\u00f3n. Observ\u00e1 que devuelve un par de datos. def busqueda_secuencial_(lista, x): '''Si x est\u00e1 en la lista devuelve el \u00edndice de su primera aparici\u00f3n, de lo contrario devuelve -1. Adem\u00e1s devuelve la cantidad de comparaciones que hace la funci\u00f3n. ''' comps = 0 # inicializo en cero la cantidad de comparaciones pos = -1 for i,z in enumerate(lista): comps += 1 # sumo la comparaci\u00f3n que estoy por hacer if z == x: pos = i break return pos, comps Si quer\u00e9s acceder a la posici\u00f3n pod\u00e9s usar busqueda_secuencial_(lista, x)[0] y para acceder a la cantidad de comparaciones que hizo busqueda_secuencial_(lista, x)[1] .","title":"Contar la cantidad de operaciones de un algoritmo"},{"location":"06_Organizacion_y_Complejidad/07_gr%C3%A1ficos_de_complejidad/#ejercicio-619-contar-comparaciones-en-la-busqueda-binaria","text":"Modific\u00e1 el c\u00f3digo de b\u00fasqueda binaria ( busqueda_binaria(lista, x) ) introducido en la Secci\u00f3n 6.5 , de forma que devuelva (adem\u00e1s de la posici\u00f3n del elemento en la lista) la cantidad de comparaciones que realiz\u00f3 el algoritmo para encontrarlo o decidir que no est\u00e1.","title":"Ejercicio 6.19: Contar comparaciones en la b\u00fasqueda binaria"},{"location":"06_Organizacion_y_Complejidad/07_gr%C3%A1ficos_de_complejidad/#graficar-la-cantidad-de-comparaciones-promedio","text":"La siguiente funci\u00f3n generar_lista(n, m) devuelve una lista ordenada de n elementos diferentes entre 0 y m-1 , mientras que generar_elemento(m) devuelve un elemento aleatorio en el mismo rango de valores. import random def generar_lista(n, m): l = random.sample(range(m), k = n) l.sort() return l def generar_elemento(m): return random.randint(0, m-1) Dada una lista ya generada, digamos que un experimento elemental es generar un elemento, buscarlo en la lista y contar la cantidad de comparaciones realizadas. Esta cantidad de operaciones es el resultado del experimento elemental. m = 10000 n = 100 lista = generar_lista(n, m) # ac\u00e1 comienza el experimento x = generar_elemento(m) comps = busqueda_secuencial_(lista, x)[1] Entonces, el siguiente c\u00f3digo da la cantidad de comparaciones promedio en k experimentos elementales. Observ\u00e1 que hay muchas variables diferentes dando vueltas: n , m y k . m = 10000 n = 100 k = 1000 lista = generar_lista(n, m) def experimento_secuencial_promedio(lista, m, k): comps_tot = 0 for i in range(k): x = generar_elemento(m) comps_tot += busqueda_secuencial_(lista,x)[1] comps_prom = comps_tot / k return comps_prom Como las listas tienen n = 100 elementos y estoy buscando un n\u00famero cualquiera entre m n\u00fameros diferentes, es casi seguro que no lo voy a encontrar y que voy a tener que recorrer toda la lista para concluir esto (aunque en alg\u00fan caso puede ser que est\u00e9 y lo encuentre antes de recorrerla toda!). Entonces el promedio de comparaciones va a dar cercano al largo n de la lista, quiz\u00e1s un poco menor. Tiene una componente aleatoria, es un experimento num\u00e9rico. Si dec\u00edamos que buscar un elemento era un experimento elemental digamos que repetir k experimentos elementales y calcular el promedio de comparaciones es un experimento de promedios . Grafiquemos los resultados de estos experimentos de promedios para diferentes listas de largos n entre 1 y 256. Es decir, estaremos graficando la cantidad de comparaciones que hace en promedio el algoritmo de b\u00fasqueda secuencial sobre una lista de largo n , para diferentes valores de n . import matplotlib.pyplot as plt import numpy as np m = 10000 k = 1000 largos = np.arange(256) + 1 # estos son los largos de listas que voy a usar comps_promedio = np.zeros(256) # aca guardo el promedio de comparaciones sobre una lista de largo i, para i entre 1 y 256. for i, n in enumerate(largos): lista = generar_lista(n, m) # genero lista de largo n comps_promedio[i] = experimento_secuencial_promedio(lista, m, k) # ahora grafico largos de listas contra operaciones promedio de b\u00fasqueda. plt.plot(largos,comps_promedio,label = 'B\u00fasqueda Secuencial') plt.xlabel(\"Largo de la lista\") plt.ylabel(\"Cantidad de comparaciones\") plt.title(\"Complejidad de la B\u00fasqueda\") plt.legend() plt.show() En la pr\u00f3xima clase estudiaremos en detalle la librer\u00eda matplotlib que ya empezamos a usar la clase pasada. Por ahora solo agregamos la funci\u00f3n plot(x, y) a la que se le pasan dos vectores (o listas) x e y y realiza una gr\u00e1fico de l\u00edneas uniendo los puntos con esas coordenadas. El par\u00e1metro label permite ponerle un nombre a la curva que se muestra luego con la funci\u00f3n plt.legend() . Este gr\u00e1fico parece medio sonso, pero en el pr\u00f3ximo ejercicio va a ir tomando color.","title":"Gr\u00e1ficar la cantidad de comparaciones promedio"},{"location":"06_Organizacion_y_Complejidad/07_gr%C3%A1ficos_de_complejidad/#ejercicio-620-busqueda-binaria-vs-busqueda-secuencial","text":"En este Ejercicio vamos a rehacer los gr\u00e1ficos del ejemplo anterior, pero primero cambiando el algoritmo de b\u00fasqueda y luego comparando ambos algoritmos. Usando experimento_secuencial_promedio(lista, m, k) como base, escrib\u00ed una funci\u00f3n experimento_binario_promedio(lista, m, k) que cuente la cantidad de comparaciones que realiza en promedio (entre k experimentos elementales) la b\u00fasqueda binaria sobre la lista pasada como par\u00e1metro. Grafic\u00e1 los resultados de estos experimentos para listas de largo entre 1 y 256. Grafic\u00e1 ambas curvas en una misma figura, nombrando adecuadamente las curvas, los ejes y la figura completa. Jug\u00e1 con xlim e ylim para visualizar bien las dos curvas, aunque tengas que restringir el rango. \u00bfQu\u00e9 observas en estos gr\u00e1ficos? \u00bfQu\u00e9 pod\u00e9s decir sobre la complejidad de cada algoritmo? \u00bfSon similares? El c\u00f3digo de este ejercicio guardalo en plot_bbin_vs_bsec.py . Contenidos | Anterior (6 Complejidad de algoritmos) | Pr\u00f3ximo (8 Cierre de la clase)","title":"Ejercicio 6.20: B\u00fasqueda binaria vs. b\u00fasqueda secuencial"},{"location":"06_Organizacion_y_Complejidad/08_Cierre/","text":"Contenidos | Anterior (7 Gr\u00e1ficos de complejidad) 6.8 Cierre de la clase En esta clase trabajamos con funciones y creamos m\u00f3dulos. Tambi\u00e9n aprendimos algunas nociones de complejidad de algoritmos, estudiamos la b\u00fasqueda binaria y comparamos su performance con la de la b\u00fasqueda secuencial.. Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: El archivo fileparse.py del Ejercicio 6.8 o del siguiente. El archivo informe_funciones.py de Ejercicio 6.11 . El archivo costo_camion.py del Ejercicio 6.12 . El archivo bbin.py del Ejercicio 6.15 . El archivo plot_bbin_vs_bsec.py del Ejercicio 6.20 . Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y podr\u00e1s participar de la revisi\u00f3n de pares. \u00a1Gracias! Contenidos | Anterior (7 Gr\u00e1ficos de complejidad)","title":"08 Cierre"},{"location":"06_Organizacion_y_Complejidad/08_Cierre/#68-cierre-de-la-clase","text":"En esta clase trabajamos con funciones y creamos m\u00f3dulos. Tambi\u00e9n aprendimos algunas nociones de complejidad de algoritmos, estudiamos la b\u00fasqueda binaria y comparamos su performance con la de la b\u00fasqueda secuencial.. Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: El archivo fileparse.py del Ejercicio 6.8 o del siguiente. El archivo informe_funciones.py de Ejercicio 6.11 . El archivo costo_camion.py del Ejercicio 6.12 . El archivo bbin.py del Ejercicio 6.15 . El archivo plot_bbin_vs_bsec.py del Ejercicio 6.20 . Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y podr\u00e1s participar de la revisi\u00f3n de pares. \u00a1Gracias! Contenidos | Anterior (7 Gr\u00e1ficos de complejidad)","title":"6.8 Cierre de la clase"},{"location":"07_Plt_Especificacion_y_Documentacion/00_Resumen/","text":"Contenidos | Anterior (6 Complejidad y Organizaci\u00f3n de programas) | Pr\u00f3ximo (8 Fechas, Carpetas y Pandas) 7. Dise\u00f1o, especificaci\u00f3n, documentaci\u00f3n y estilo. En este curso queremos que aprendas a escribir un script que te resuelva un problema computacional. Pero tambi\u00e9n queremos que puedas escribir adecuadamente programas m\u00e1s grandes, que los puedas compartir y volver a usar vos misme unos a\u00f1os m\u00e1s tarde. Por eso insistimos con algunos temas de estilo, documentaci\u00f3n, especificiaci\u00f3n y dise\u00f1o que ya hemos comentado anteriormente y sobre los que volveremos en esta clase. Uno de ellos es que es conveniente administrar los errores; seguiremos hablando sobre las formas adecuadas de hacerlo y porqu\u00e9 no conviene hacerlo de m\u00e1s. Tambi\u00e9n se vuelve indispensable estructurar adecuadamente el c\u00f3digo y aprender a definir una funci\u00f3n main . Vamos a continuar con nuestras discusiones sobre el dise\u00f1o de algoritmos y sus estructuras de datos asociadas. Tambi\u00e9n queremos que aprendas algunos conceptos elementales sobre especificaci\u00f3n de problemas. Son procesos de abstracci\u00f3n que nos ayudan a pensar con mayor claridad. Al especificar un problema con precondiciones y poscondiciones estamos definiendo qu\u00e9 es lo que debe pasar en una funci\u00f3n, por ejemplo (aunque en ning\u00fan momento decimos c\u00f3mo debe pasar esto). Una especificaci\u00f3n es como un contrato y podemos definir varias funciones que cumplan el contrato, y cada una puede resolverlo a su manera. Finalmente, daremos un poco m\u00e1s sistem\u00e1ticamente algunos conceptos de la biblioteca matplotlib , incluyendo el manejo de figuras y subplots. \u00c9sta es la \u00faltima clase antes del primer parcial. El mi\u00e9rcoles dentro de dos semanas acordate de estar atente de 14 a 16hs que tomaremos el parcial on-line. Sabemos que hay gente que no est\u00e1 haciendo la materia por los cr\u00e9ditos, sino para aprender los contenidos. Les pedimos que igual rindan los ex\u00e1menes y soliciten el certificado final de aprobaci\u00f3n. Para nosotros es importante que los que hayan seguido el curso figuren formalmente para que esta expericiencia pueda tener continuidad en el tiempo. 7.1 Repaso de temas pasados 7.2 Control de errores 7.3 El m\u00f3dulo principal 7.4 Cuestiones de dise\u00f1o 7.5 Contratos: Especificaci\u00f3n y Documentaci\u00f3n 7.6 Estilos de codeo 7.7 La biblioteca matplotlib 7.8 Cierre de la clase Contenidos | Anterior (6 Complejidad y Organizaci\u00f3n de programas) | Pr\u00f3ximo (8 Fechas, Carpetas y Pandas)","title":"00 Resumen"},{"location":"07_Plt_Especificacion_y_Documentacion/00_Resumen/#7-diseno-especificacion-documentacion-y-estilo","text":"En este curso queremos que aprendas a escribir un script que te resuelva un problema computacional. Pero tambi\u00e9n queremos que puedas escribir adecuadamente programas m\u00e1s grandes, que los puedas compartir y volver a usar vos misme unos a\u00f1os m\u00e1s tarde. Por eso insistimos con algunos temas de estilo, documentaci\u00f3n, especificiaci\u00f3n y dise\u00f1o que ya hemos comentado anteriormente y sobre los que volveremos en esta clase. Uno de ellos es que es conveniente administrar los errores; seguiremos hablando sobre las formas adecuadas de hacerlo y porqu\u00e9 no conviene hacerlo de m\u00e1s. Tambi\u00e9n se vuelve indispensable estructurar adecuadamente el c\u00f3digo y aprender a definir una funci\u00f3n main . Vamos a continuar con nuestras discusiones sobre el dise\u00f1o de algoritmos y sus estructuras de datos asociadas. Tambi\u00e9n queremos que aprendas algunos conceptos elementales sobre especificaci\u00f3n de problemas. Son procesos de abstracci\u00f3n que nos ayudan a pensar con mayor claridad. Al especificar un problema con precondiciones y poscondiciones estamos definiendo qu\u00e9 es lo que debe pasar en una funci\u00f3n, por ejemplo (aunque en ning\u00fan momento decimos c\u00f3mo debe pasar esto). Una especificaci\u00f3n es como un contrato y podemos definir varias funciones que cumplan el contrato, y cada una puede resolverlo a su manera. Finalmente, daremos un poco m\u00e1s sistem\u00e1ticamente algunos conceptos de la biblioteca matplotlib , incluyendo el manejo de figuras y subplots. \u00c9sta es la \u00faltima clase antes del primer parcial. El mi\u00e9rcoles dentro de dos semanas acordate de estar atente de 14 a 16hs que tomaremos el parcial on-line. Sabemos que hay gente que no est\u00e1 haciendo la materia por los cr\u00e9ditos, sino para aprender los contenidos. Les pedimos que igual rindan los ex\u00e1menes y soliciten el certificado final de aprobaci\u00f3n. Para nosotros es importante que los que hayan seguido el curso figuren formalmente para que esta expericiencia pueda tener continuidad en el tiempo. 7.1 Repaso de temas pasados 7.2 Control de errores 7.3 El m\u00f3dulo principal 7.4 Cuestiones de dise\u00f1o 7.5 Contratos: Especificaci\u00f3n y Documentaci\u00f3n 7.6 Estilos de codeo 7.7 La biblioteca matplotlib 7.8 Cierre de la clase Contenidos | Anterior (6 Complejidad y Organizaci\u00f3n de programas) | Pr\u00f3ximo (8 Fechas, Carpetas y Pandas)","title":"7. Dise\u00f1o, especificaci\u00f3n, documentaci\u00f3n y estilo."},{"location":"07_Plt_Especificacion_y_Documentacion/01_Repaso/","text":"Contenidos | Pr\u00f3ximo (2 Control de errores) 7.1 Repaso de temas pasados A continuaci\u00f3n dejamos unos links a unos videos retomando temas de la clase anterior e introduciendo los nuevos mediante ejemplos. En este video hablamos sobre complejidad de algoritmos. B\u00fasqueda secuencial y b\u00fasqueda binaria. El problema de la mochila. En este video seguimos hablando sobre complejidad de la b\u00fasqueda secuencial y la b\u00fasqueda binaria. Mencionamos las pre y post-condiciones y los invariantes de ciclo que veremos m\u00e1s adelante en esta misma clase. En este video resolvemos el Ejercicio Ejercicio 6.14 de insertar en una lista ordenada. De paso ilustramos los conceptos de pre y post-condiciones de una funci\u00f3n y de varios temas de complejidad de algoritmos. Finalmente, en este video hablamos sobre la importancia de documentar para poder compartir y reutilizar el c\u00f3digo]. Contenidos | Pr\u00f3ximo (2 Control de errores)","title":"01 Repaso"},{"location":"07_Plt_Especificacion_y_Documentacion/01_Repaso/#71-repaso-de-temas-pasados","text":"A continuaci\u00f3n dejamos unos links a unos videos retomando temas de la clase anterior e introduciendo los nuevos mediante ejemplos. En este video hablamos sobre complejidad de algoritmos. B\u00fasqueda secuencial y b\u00fasqueda binaria. El problema de la mochila. En este video seguimos hablando sobre complejidad de la b\u00fasqueda secuencial y la b\u00fasqueda binaria. Mencionamos las pre y post-condiciones y los invariantes de ciclo que veremos m\u00e1s adelante en esta misma clase. En este video resolvemos el Ejercicio Ejercicio 6.14 de insertar en una lista ordenada. De paso ilustramos los conceptos de pre y post-condiciones de una funci\u00f3n y de varios temas de complejidad de algoritmos. Finalmente, en este video hablamos sobre la importancia de documentar para poder compartir y reutilizar el c\u00f3digo]. Contenidos | Pr\u00f3ximo (2 Control de errores)","title":"7.1 Repaso de temas pasados"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/","text":"Contenidos | Anterior (1 Repaso de temas pasados) | Pr\u00f3ximo (3 El m\u00f3dulo principal) 7.2 Control de errores Aunque ya hablamos de excepciones , en esta secci\u00f3n hablaremos de administraci\u00f3n de excepciones y control de errores con mayor detalle. Dejamos este video con una introducci\u00f3n breve a esta secci\u00f3n. Formas en que los programas fallan Python no hace ning\u00fan control ni validaci\u00f3n sobre los tipos de los argumentos que las funciones reciben ni los valores de estos argumentos. Las funciones trabajar\u00e1n sobre todo dato que sea compatible con las instrucciones dentro de la funci\u00f3n. def add(x, y): return x + y add(3, 4) # 7 add('Hola', 'mundo') # 'Holamundo' add('3', '4') # '34' Si existen errores en una funci\u00f3n, ser\u00e1n evidentes durante la ejecuci\u00f3n de la funci\u00f3n (en forma de una excepci\u00f3n). def add(x, y): return x + y >>> add(3, '4') Traceback (most recent call last): ... TypeError: unsupported operand type(s) for +:: 'int' and 'str' >>> Python acusa los errores en ingl\u00e9s. El error acusado ac\u00e1 puede traducirse como: Recapitulando (llamada m\u00e1s reciente al final) ... Error de tipo (de datos): tipo de argumento no admitido para +: 'int' y 'str'. Es decir: la funci\u00f3n intent\u00f3 aplicar el operador + (suma) a dos argumentos de tipos distintos (entero y cadena) y no supo hacerlo. Por eso levant\u00f3 una excepci\u00f3n. Excepciones Como ya dijimos, las excepciones son una forma de se\u00f1alar errores en tiempo de ejecuci\u00f3n. Acordate de que pod\u00e9s levantar una excepci\u00f3n usando la instrucci\u00f3n raise . if nombre not in autorizados: raise RuntimeError(f'{nombre} no autorizado') Para atrapar una excepci\u00f3n, us\u00e1 un bloque try-except . try: authenticate(nusuario) except RuntimeError as e: print(e) Administraci\u00f3n de excepciones Una excepci\u00f3n se propagar\u00e1 hasta el primer except que coincida con ella. def grok(): ... raise RuntimeError('Epa!') # Levanta una excepci\u00f3n ac\u00e1 def spam(): grok() # Esta llamada va a levantar una excepci\u00f3n def bar(): try: spam() except RuntimeError as e: # Ac\u00e1 atrapamos la excepci\u00f3n ... def foo(): try: bar() except RuntimeError as e: # Por lo tanto la excepci\u00f3n no llega ac\u00e1 ... foo() Para administrar la excepci\u00f3n, us\u00e1 instrucciones en el bloque except . Cualquier instrucci\u00f3n har\u00e1 que Python considere a la excepci\u00f3n como administrada, incluso un pass pero es pertinente realizar acciones relacionadas con la excepci\u00f3n espec\u00edfica a administrar. def grok(): ... raise RuntimeError('Epa!') def bar(): try: grok() except RuntimeError as e: # Excepci\u00f3n atrapada instrucciones # Ejecuta estos comandos instrucciones ... bar() Una vez atrapada la excepci\u00f3n, la ejecuci\u00f3n contin\u00faa en la primera instrucci\u00f3n a continuaci\u00f3n del try-except . def grok(): ... raise RuntimeError('Epa !') def bar(): try: grok() except RuntimeError as e: # Excepci\u00f3n atrapada instrucciones instrucciones ... instrucciones # La ejecuci\u00f3n del programa instrucciones # contin\u00faa ac\u00e1 ... bar() Excepciones integradas Hay m\u00e1s de una veintena de tipos de excepciones ya integradas en Python. Normalmente, el nombre de la excepci\u00f3n indica qu\u00e9 anduvo mal (por ejemplo, se levanta un ValueError si el valor suministrado no es adecuado). La siguiente no es una lista completa. Vas a encontrar m\u00e1s en la documentaci\u00f3n del lenguaje . ArithmeticError AssertionError EnvironmentError EOFError ImportError IndexError KeyboardInterrupt KeyError MemoryError NameError ReferenceError RuntimeError SyntaxError SystemError TypeError ValueError Valores asociados a excepciones Usualmente las excepciones llevan valores asociados, que te dan m\u00e1s informaci\u00f3n sobre la causa precisa del error. Este valor puede ser una cadena ( string ) o una tupla con valores diversos (por ejemplo un c\u00f3digo de error y un texto explicando ese c\u00f3digo). raise RuntimeError('Nombre de usuario inv\u00e1lido') La instancia de la variable suministrada a except (en nuestros ejemplos e ) lleva asociado este valor. try: ... except RuntimeError as e: # `e` contiene la excepci\u00f3n lanzada con su mensaje espec\u00edfico ... e es una instancia del mismo tipo que la excepci\u00f3n, aunque si la imprim\u00eds suele tener aspecto de una cadena de caracteres. except RuntimeError as e: print('Fracas\u00e9. Motivo:', e) Pod\u00e9s atrapar m\u00faltiples excepciones Es posible atrapar diferentes tipos de excepciones en la misma porci\u00f3n de c\u00f3digo, si inclu\u00eds varios except en tu try: . try: ... except LookupError as e: ... except RuntimeError as e: ... except IOError as e: ... except KeyboardInterrupt as e: ... Como alternativa, si las vas a procesar a todas de la misma manera, las pod\u00e9s agrupar: try: ... except (IOError, LookupError, RuntimeError) as e: ... Todas las excepciones Para atrapar todas y cualquier excepci\u00f3n, se usa Exception as\u00ed: try: ... except Exception: # PELIGRO. (ver abajo) print('Hubo un error') En general es mala idea \"administrar\" las excepciones de este modo, porque no te da ninguna pista de por qu\u00e9 fall\u00f3 el programa. S\u00f3lo sab\u00e9s que \"Hubo un error\". As\u00ed NO se atrapan excepciones. As\u00ed es como NO debe hacerse la administraci\u00f3n de excepciones. try: hacer_algo() except Exception: print('Hubo un error.') Esto atrapa todos los errores posibles, y puede complicar mucho el debugging cuando el c\u00f3digo falla por alg\u00fan motivo que no esperabas (por ejemplo, falta alg\u00fan m\u00f3dulo de Python y lo \u00fanico que te dice es \"Hubo un error\"). As\u00ed es un poco mejor. Si vas a atrapar todas las excepciones, ac\u00e1 hay un modo algo m\u00e1s decente: try: hacer_algo() except Exception as e: print('Hubo un error. Porque...', e) Exception incluye toda excepci\u00f3n posible, de modo que no sab\u00e9s cu\u00e1l atrapaste. Al menos esta versi\u00f3n te informa el motivo espec\u00edfico del error. Siempre es bueno tener alguna forma de ver o informar errores cuando atrap\u00e1s todas las excepciones posibles. Sin embargo, por lo general es mejor atrapar errores espec\u00edficos, y s\u00f3lo aquellos que pod\u00e9s administrar. Errores que no sepas como manejar adecuadamente, d\u00e9jalos correr (tal vez alguna otra porci\u00f3n de c\u00f3digo los atrape y administre correctamente o tal vez lo mejor sea detener la ejecuci\u00f3n). Re-lanzar una excepci\u00f3n Si necesit\u00e1s hacer algo en respuesta a una excepci\u00f3n pero no quer\u00e9s atraparla, pod\u00e9s usar raise para volver a lanzar la misma excepci\u00f3n. try: hacer_algo() except Exception as e: print('Hubo un error. Porque...', e) raise Esto te permite, por ejemplo, llevar un registro de las excepciones ( log ) sin administrarla, y re-lanzarla para administrarla adecuadamente m\u00e1s tarde. Buenas pr\u00e1cticas al administrar excepciones No atrapes excepciones que no vayas a manejar adecuadamente. Dejalas caer ruidosamente. Si es importante, alguien se va a encargar del problema. S\u00f3lo atrap\u00e1 excepciones si sos ese \"alguien\" . Es decir: s\u00f3lo atrap\u00e1 aquellos errores que pod\u00e9s administrar elegantemente de forma que permita que el programa se siga ejecutando. La instrucci\u00f3n finally . finally especifica que esa porci\u00f3n de c\u00f3digo debe ejecutarse sin importar si una excepci\u00f3n fue atrapada o no. lock = Lock() ... lock.acquire() try: ... finally: lock.release() # esto SIEMPRE se ejecuta. Haya o no haya excepciones. Una estructura como \u00e9sa resulta en un manejo seguro de los recursos disponibles (seguros, archivos, hardware, etc.) Ejercicios Trabaj\u00e1 siempre con las \u00faltimas versiones de tus archivos. En esta clase vamos a trabajar con el archivo fileparse.py y tambi\u00e9n con una nueva versi\u00f3n de informe.py . Por favor, copi\u00e1 informe_funciones.py a informe.py , que trabajaremos sobre este \u00faltimo archivo. Lancemos excepciones La funci\u00f3n parse_csv() que escribiste en el Ejercicio 6.9 admite seleccionar algunas columnas por le usuarie, pero eso s\u00f3lo funciona si el archivo de entrada tiene encabezados. Modifc\u00e1 tu c\u00f3digo para que lance una excepci\u00f3n en caso que ambos par\u00e1metros select y has_headers = False sean pasados juntos. Y que resulte: >>> parse_csv('../Data/precios.csv', select = ['nombre','precio'], has_headers = False) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"fileparse.py\", line 9, in parse_csv raise RuntimeError(\"Para seleccionar, necesito encabezados.\") RuntimeError: Para seleccionar, necesito encabezados. >>> Ahora que agregaste este control, te estar\u00e1s preguntando si no deber\u00edas comprobar otras cosas tambi\u00e9n en tu funci\u00f3n. Por ejemplo, \u00bfdeber\u00edas comprobar que nombre_archivo sea una cadena, que tipos sea una lista y otras cosas de ese estilo? Como regla general, es mejor no controlar esas cosas, y dejar que el programa d\u00e9 un error ante entradas inv\u00e1lidas. El mensaje de error va a darte una idea del origen del problema y te va ayudar a solucionarlo. El motivo principal para agregar controles de calidad sobre los par\u00e1metros de entrada es evitar que tu programa sea ejecutado en condiciones que no tienen sentido. Si le ped\u00eds que haga algo que requiere encabezados y simult\u00e1neamente le dec\u00eds que no existen encabezados implica est\u00e1s usando la funci\u00f3n incorrectamente. La idea general es estar protegido contra situaciones que \"no deber\u00edan suceder\" pero podr\u00edan. Atrapemos excepciones La funci\u00f3n parse_csv() que escribiste est\u00e1 destinada a procesar un archivo completo. Pero en una situacion real, es posible que los archivos CSV de entrada est\u00e9n \"rotos\", ausentes, o que su contenido no se adec\u00fae al formato esperado. Prob\u00e1 esto: >>> camion = parse_csv('../Data/missing.csv', types = [str, int, float]) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"fileparse.py\", line 36, in parse_csv row = [func(val) for func, val in zip(types, row)] ValueError: invalid literal for int() with base 10: '' >>> El error es: el texto '' es inv\u00e1lido para la funci\u00f3n int() Modific\u00e1 la funci\u00f3n parse_csv() de modo que atrape todas las excepciones de tipo ValueError generadas durante el armado de los registros a devolver e imprima un mensaje de advertencia para las filas que no pudieron ser convertidas. Estas filas no deben ser procesadas (ya que no se puede hacer adecuadamente), y deben ser omitidas en el output de la funci\u00f3n. Este mensaje deber\u00e1 incluir el n\u00famero de fila que caus\u00f3 el problema y el motivo por el cual fall\u00f3 la conversi\u00f3n. Para probar tu nueva funci\u00f3n, intent\u00e1 procesar Data/missing.csv . Deber\u00eda darte algo as\u00ed: >>> camion = parse_csv('../Data/missing.csv', types = [str, int, float]) Fila 4: No pude convertir ['Mandarina', '', '51.23'] Fila 4: Motivo: invalid literal for int() with base 10: '' Fila 7: No pude convertir ['Naranja', '', '70.44'] Fila 7: Motivo: invalid literal for int() with base 10: '' >>> >>> camion [{'cajones': 100, 'nombre': 'Lima', 'precio': 32.2}, {'cajones': 50, 'nombre': 'Naranja', 'precio': 91.1}, {'cajones': 150, 'nombre': 'Caqui', 'precio': 103.44}, {'cajones': 95, 'nombre': 'Durazno', 'precio': 40.37}, {'cajones': 50, 'nombre': 'Mandarina', 'precio': 65.1}] >>> Ejercicio 7.1: Errores silenciados Modific\u00e1 parse_csv() de modo que le usuarie pueda silenciar los informes de errores en el parseo de los datos que agregaste antes.Por ejemplo: >>> camion = parse_csv('../Data/missing.csv', types = [str,int,float], silence_errors = True) >>> camion [{'cajones': 100, 'nombre': 'Lima', 'precio': 32.2}, {'cajones': 50, 'nombre': 'Naranja', 'precio': 91.1}, {'cajones': 150, 'nombre': 'Caqui', 'precio': 103.44}, {'cajones': 95, 'nombre': 'Durazno', 'precio': 40.37}, {'cajones': 50, 'nombre': 'Mandarina', 'precio': 65.1}] >>> Guard\u00e1 estos cambios que los vamos a usar m\u00e1s adelante. Comentarios Lograr un buen manejo o administraci\u00f3n de errores es una de las partes m\u00e1s dif\u00edciles en la mayor\u00eda de los programas. Est\u00e1s intentando prever imprevistos. Como regla general, no silencies los errores. Es mejor informar los problemas y darle al usuarie la opci\u00f3n de silenciarlos expl\u00edcitamente. Un buen di\u00e1logo entre el c\u00f3digo y el usuarie facilita el debugging y el buen uso del programa. Contenidos | Anterior (1 Repaso de temas pasados) | Pr\u00f3ximo (3 El m\u00f3dulo principal)","title":"02 Excepciones"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#72-control-de-errores","text":"Aunque ya hablamos de excepciones , en esta secci\u00f3n hablaremos de administraci\u00f3n de excepciones y control de errores con mayor detalle. Dejamos este video con una introducci\u00f3n breve a esta secci\u00f3n.","title":"7.2 Control de errores"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#formas-en-que-los-programas-fallan","text":"Python no hace ning\u00fan control ni validaci\u00f3n sobre los tipos de los argumentos que las funciones reciben ni los valores de estos argumentos. Las funciones trabajar\u00e1n sobre todo dato que sea compatible con las instrucciones dentro de la funci\u00f3n. def add(x, y): return x + y add(3, 4) # 7 add('Hola', 'mundo') # 'Holamundo' add('3', '4') # '34' Si existen errores en una funci\u00f3n, ser\u00e1n evidentes durante la ejecuci\u00f3n de la funci\u00f3n (en forma de una excepci\u00f3n). def add(x, y): return x + y >>> add(3, '4') Traceback (most recent call last): ... TypeError: unsupported operand type(s) for +:: 'int' and 'str' >>> Python acusa los errores en ingl\u00e9s. El error acusado ac\u00e1 puede traducirse como: Recapitulando (llamada m\u00e1s reciente al final) ... Error de tipo (de datos): tipo de argumento no admitido para +: 'int' y 'str'. Es decir: la funci\u00f3n intent\u00f3 aplicar el operador + (suma) a dos argumentos de tipos distintos (entero y cadena) y no supo hacerlo. Por eso levant\u00f3 una excepci\u00f3n.","title":"Formas en que los programas fallan"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#excepciones","text":"Como ya dijimos, las excepciones son una forma de se\u00f1alar errores en tiempo de ejecuci\u00f3n. Acordate de que pod\u00e9s levantar una excepci\u00f3n usando la instrucci\u00f3n raise . if nombre not in autorizados: raise RuntimeError(f'{nombre} no autorizado') Para atrapar una excepci\u00f3n, us\u00e1 un bloque try-except . try: authenticate(nusuario) except RuntimeError as e: print(e)","title":"Excepciones"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#administracion-de-excepciones","text":"Una excepci\u00f3n se propagar\u00e1 hasta el primer except que coincida con ella. def grok(): ... raise RuntimeError('Epa!') # Levanta una excepci\u00f3n ac\u00e1 def spam(): grok() # Esta llamada va a levantar una excepci\u00f3n def bar(): try: spam() except RuntimeError as e: # Ac\u00e1 atrapamos la excepci\u00f3n ... def foo(): try: bar() except RuntimeError as e: # Por lo tanto la excepci\u00f3n no llega ac\u00e1 ... foo() Para administrar la excepci\u00f3n, us\u00e1 instrucciones en el bloque except . Cualquier instrucci\u00f3n har\u00e1 que Python considere a la excepci\u00f3n como administrada, incluso un pass pero es pertinente realizar acciones relacionadas con la excepci\u00f3n espec\u00edfica a administrar. def grok(): ... raise RuntimeError('Epa!') def bar(): try: grok() except RuntimeError as e: # Excepci\u00f3n atrapada instrucciones # Ejecuta estos comandos instrucciones ... bar() Una vez atrapada la excepci\u00f3n, la ejecuci\u00f3n contin\u00faa en la primera instrucci\u00f3n a continuaci\u00f3n del try-except . def grok(): ... raise RuntimeError('Epa !') def bar(): try: grok() except RuntimeError as e: # Excepci\u00f3n atrapada instrucciones instrucciones ... instrucciones # La ejecuci\u00f3n del programa instrucciones # contin\u00faa ac\u00e1 ... bar()","title":"Administraci\u00f3n de excepciones"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#excepciones-integradas","text":"Hay m\u00e1s de una veintena de tipos de excepciones ya integradas en Python. Normalmente, el nombre de la excepci\u00f3n indica qu\u00e9 anduvo mal (por ejemplo, se levanta un ValueError si el valor suministrado no es adecuado). La siguiente no es una lista completa. Vas a encontrar m\u00e1s en la documentaci\u00f3n del lenguaje . ArithmeticError AssertionError EnvironmentError EOFError ImportError IndexError KeyboardInterrupt KeyError MemoryError NameError ReferenceError RuntimeError SyntaxError SystemError TypeError ValueError","title":"Excepciones integradas"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#valores-asociados-a-excepciones","text":"Usualmente las excepciones llevan valores asociados, que te dan m\u00e1s informaci\u00f3n sobre la causa precisa del error. Este valor puede ser una cadena ( string ) o una tupla con valores diversos (por ejemplo un c\u00f3digo de error y un texto explicando ese c\u00f3digo). raise RuntimeError('Nombre de usuario inv\u00e1lido') La instancia de la variable suministrada a except (en nuestros ejemplos e ) lleva asociado este valor. try: ... except RuntimeError as e: # `e` contiene la excepci\u00f3n lanzada con su mensaje espec\u00edfico ... e es una instancia del mismo tipo que la excepci\u00f3n, aunque si la imprim\u00eds suele tener aspecto de una cadena de caracteres. except RuntimeError as e: print('Fracas\u00e9. Motivo:', e)","title":"Valores asociados a excepciones"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#podes-atrapar-multiples-excepciones","text":"Es posible atrapar diferentes tipos de excepciones en la misma porci\u00f3n de c\u00f3digo, si inclu\u00eds varios except en tu try: . try: ... except LookupError as e: ... except RuntimeError as e: ... except IOError as e: ... except KeyboardInterrupt as e: ... Como alternativa, si las vas a procesar a todas de la misma manera, las pod\u00e9s agrupar: try: ... except (IOError, LookupError, RuntimeError) as e: ...","title":"Pod\u00e9s atrapar m\u00faltiples excepciones"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#todas-las-excepciones","text":"Para atrapar todas y cualquier excepci\u00f3n, se usa Exception as\u00ed: try: ... except Exception: # PELIGRO. (ver abajo) print('Hubo un error') En general es mala idea \"administrar\" las excepciones de este modo, porque no te da ninguna pista de por qu\u00e9 fall\u00f3 el programa. S\u00f3lo sab\u00e9s que \"Hubo un error\".","title":"Todas las excepciones"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#asi-no-se-atrapan-excepciones","text":"As\u00ed es como NO debe hacerse la administraci\u00f3n de excepciones. try: hacer_algo() except Exception: print('Hubo un error.') Esto atrapa todos los errores posibles, y puede complicar mucho el debugging cuando el c\u00f3digo falla por alg\u00fan motivo que no esperabas (por ejemplo, falta alg\u00fan m\u00f3dulo de Python y lo \u00fanico que te dice es \"Hubo un error\").","title":"As\u00ed NO se atrapan excepciones."},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#asi-es-un-poco-mejor","text":"Si vas a atrapar todas las excepciones, ac\u00e1 hay un modo algo m\u00e1s decente: try: hacer_algo() except Exception as e: print('Hubo un error. Porque...', e) Exception incluye toda excepci\u00f3n posible, de modo que no sab\u00e9s cu\u00e1l atrapaste. Al menos esta versi\u00f3n te informa el motivo espec\u00edfico del error. Siempre es bueno tener alguna forma de ver o informar errores cuando atrap\u00e1s todas las excepciones posibles. Sin embargo, por lo general es mejor atrapar errores espec\u00edficos, y s\u00f3lo aquellos que pod\u00e9s administrar. Errores que no sepas como manejar adecuadamente, d\u00e9jalos correr (tal vez alguna otra porci\u00f3n de c\u00f3digo los atrape y administre correctamente o tal vez lo mejor sea detener la ejecuci\u00f3n).","title":"As\u00ed es un poco mejor."},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#re-lanzar-una-excepcion","text":"Si necesit\u00e1s hacer algo en respuesta a una excepci\u00f3n pero no quer\u00e9s atraparla, pod\u00e9s usar raise para volver a lanzar la misma excepci\u00f3n. try: hacer_algo() except Exception as e: print('Hubo un error. Porque...', e) raise Esto te permite, por ejemplo, llevar un registro de las excepciones ( log ) sin administrarla, y re-lanzarla para administrarla adecuadamente m\u00e1s tarde.","title":"Re-lanzar una excepci\u00f3n"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#buenas-practicas-al-administrar-excepciones","text":"No atrapes excepciones que no vayas a manejar adecuadamente. Dejalas caer ruidosamente. Si es importante, alguien se va a encargar del problema. S\u00f3lo atrap\u00e1 excepciones si sos ese \"alguien\" . Es decir: s\u00f3lo atrap\u00e1 aquellos errores que pod\u00e9s administrar elegantemente de forma que permita que el programa se siga ejecutando.","title":"Buenas pr\u00e1cticas al administrar excepciones"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#la-instruccion-finally","text":"finally especifica que esa porci\u00f3n de c\u00f3digo debe ejecutarse sin importar si una excepci\u00f3n fue atrapada o no. lock = Lock() ... lock.acquire() try: ... finally: lock.release() # esto SIEMPRE se ejecuta. Haya o no haya excepciones. Una estructura como \u00e9sa resulta en un manejo seguro de los recursos disponibles (seguros, archivos, hardware, etc.)","title":"La instrucci\u00f3n finally."},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#ejercicios","text":"Trabaj\u00e1 siempre con las \u00faltimas versiones de tus archivos. En esta clase vamos a trabajar con el archivo fileparse.py y tambi\u00e9n con una nueva versi\u00f3n de informe.py . Por favor, copi\u00e1 informe_funciones.py a informe.py , que trabajaremos sobre este \u00faltimo archivo.","title":"Ejercicios"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#lancemos-excepciones","text":"La funci\u00f3n parse_csv() que escribiste en el Ejercicio 6.9 admite seleccionar algunas columnas por le usuarie, pero eso s\u00f3lo funciona si el archivo de entrada tiene encabezados. Modifc\u00e1 tu c\u00f3digo para que lance una excepci\u00f3n en caso que ambos par\u00e1metros select y has_headers = False sean pasados juntos. Y que resulte: >>> parse_csv('../Data/precios.csv', select = ['nombre','precio'], has_headers = False) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"fileparse.py\", line 9, in parse_csv raise RuntimeError(\"Para seleccionar, necesito encabezados.\") RuntimeError: Para seleccionar, necesito encabezados. >>> Ahora que agregaste este control, te estar\u00e1s preguntando si no deber\u00edas comprobar otras cosas tambi\u00e9n en tu funci\u00f3n. Por ejemplo, \u00bfdeber\u00edas comprobar que nombre_archivo sea una cadena, que tipos sea una lista y otras cosas de ese estilo? Como regla general, es mejor no controlar esas cosas, y dejar que el programa d\u00e9 un error ante entradas inv\u00e1lidas. El mensaje de error va a darte una idea del origen del problema y te va ayudar a solucionarlo. El motivo principal para agregar controles de calidad sobre los par\u00e1metros de entrada es evitar que tu programa sea ejecutado en condiciones que no tienen sentido. Si le ped\u00eds que haga algo que requiere encabezados y simult\u00e1neamente le dec\u00eds que no existen encabezados implica est\u00e1s usando la funci\u00f3n incorrectamente. La idea general es estar protegido contra situaciones que \"no deber\u00edan suceder\" pero podr\u00edan.","title":"Lancemos excepciones"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#atrapemos-excepciones","text":"La funci\u00f3n parse_csv() que escribiste est\u00e1 destinada a procesar un archivo completo. Pero en una situacion real, es posible que los archivos CSV de entrada est\u00e9n \"rotos\", ausentes, o que su contenido no se adec\u00fae al formato esperado. Prob\u00e1 esto: >>> camion = parse_csv('../Data/missing.csv', types = [str, int, float]) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"fileparse.py\", line 36, in parse_csv row = [func(val) for func, val in zip(types, row)] ValueError: invalid literal for int() with base 10: '' >>> El error es: el texto '' es inv\u00e1lido para la funci\u00f3n int() Modific\u00e1 la funci\u00f3n parse_csv() de modo que atrape todas las excepciones de tipo ValueError generadas durante el armado de los registros a devolver e imprima un mensaje de advertencia para las filas que no pudieron ser convertidas. Estas filas no deben ser procesadas (ya que no se puede hacer adecuadamente), y deben ser omitidas en el output de la funci\u00f3n. Este mensaje deber\u00e1 incluir el n\u00famero de fila que caus\u00f3 el problema y el motivo por el cual fall\u00f3 la conversi\u00f3n. Para probar tu nueva funci\u00f3n, intent\u00e1 procesar Data/missing.csv . Deber\u00eda darte algo as\u00ed: >>> camion = parse_csv('../Data/missing.csv', types = [str, int, float]) Fila 4: No pude convertir ['Mandarina', '', '51.23'] Fila 4: Motivo: invalid literal for int() with base 10: '' Fila 7: No pude convertir ['Naranja', '', '70.44'] Fila 7: Motivo: invalid literal for int() with base 10: '' >>> >>> camion [{'cajones': 100, 'nombre': 'Lima', 'precio': 32.2}, {'cajones': 50, 'nombre': 'Naranja', 'precio': 91.1}, {'cajones': 150, 'nombre': 'Caqui', 'precio': 103.44}, {'cajones': 95, 'nombre': 'Durazno', 'precio': 40.37}, {'cajones': 50, 'nombre': 'Mandarina', 'precio': 65.1}] >>>","title":"Atrapemos excepciones"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#ejercicio-71-errores-silenciados","text":"Modific\u00e1 parse_csv() de modo que le usuarie pueda silenciar los informes de errores en el parseo de los datos que agregaste antes.Por ejemplo: >>> camion = parse_csv('../Data/missing.csv', types = [str,int,float], silence_errors = True) >>> camion [{'cajones': 100, 'nombre': 'Lima', 'precio': 32.2}, {'cajones': 50, 'nombre': 'Naranja', 'precio': 91.1}, {'cajones': 150, 'nombre': 'Caqui', 'precio': 103.44}, {'cajones': 95, 'nombre': 'Durazno', 'precio': 40.37}, {'cajones': 50, 'nombre': 'Mandarina', 'precio': 65.1}] >>> Guard\u00e1 estos cambios que los vamos a usar m\u00e1s adelante.","title":"Ejercicio 7.1: Errores silenciados"},{"location":"07_Plt_Especificacion_y_Documentacion/02_Excepciones/#comentarios","text":"Lograr un buen manejo o administraci\u00f3n de errores es una de las partes m\u00e1s dif\u00edciles en la mayor\u00eda de los programas. Est\u00e1s intentando prever imprevistos. Como regla general, no silencies los errores. Es mejor informar los problemas y darle al usuarie la opci\u00f3n de silenciarlos expl\u00edcitamente. Un buen di\u00e1logo entre el c\u00f3digo y el usuarie facilita el debugging y el buen uso del programa. Contenidos | Anterior (1 Repaso de temas pasados) | Pr\u00f3ximo (3 El m\u00f3dulo principal)","title":"Comentarios"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/","text":"Contenidos | Anterior (2 Control de errores) | Pr\u00f3ximo (4 Cuestiones de dise\u00f1o) 7.3 El m\u00f3dulo principal En esta secci\u00f3n introducimos el concepto de m\u00f3dulo principal . Dejamos este video con una introducci\u00f3n breve a esta secci\u00f3n y la siguiente. Funci\u00f3n principal En muchos lenguajes de programaci\u00f3n existe el concepto de m\u00e9todo o funci\u00f3n principal . // c / c++ int main(int argc, char *argv[]) { ... } // java class myprog { public static void main(String args[]) { ... } } Se refiere a la primera funci\u00f3n que es ejecutada cuando corremos un programa. M\u00f3dulo principal en Python Python no tiene una funci\u00f3n o m\u00e9todo principal. En su lugar existe un m\u00f3dulo principal y \u00e9ste ser\u00e1 el archivo con c\u00f3digo fuente que se ejecuta primero. bash % python3 prog.py ... El archivo que le pases al int\u00e9rprete al invocarlo ser\u00e1 el m\u00f3dulo principal. No importa c\u00f3mo lo llames. Chequear __main__ Es una pr\u00e1ctica est\u00e1ndar usar la siguiente convenci\u00f3n en m\u00f3dulos que son ejecutados como scripts principales: # prog.py ... if __name__ == '__main__': # Soy el programa principal ... comandos ... Los comandos dentro del if constituyen el programa principal M\u00f3dulo principal vs. m\u00f3dulo importado Cualquier archivo .py puede ejecutarse ya sea como el programa principal o como un m\u00f3dulo importado: bash % python3 prog.py # Corriendo como principal import prog # Corriendo como m\u00f3dulo importado La variable __name__ es el nombre del m\u00f3dulo. Sin embargo, esta variable __name__ valdr\u00e1 __main__ si ese m\u00f3dulo est\u00e1 siendo ejecutado como el script principal. Normalmente deseamos que los comandos que son parte del comportamiento del script en modo principal s\u00f3lo se ejecuten si efectivamente el script es el m\u00f3dulo principal. No queremos que esos comandos se ejecuten si el m\u00f3dulo fue importado. Por lo tanto es com\u00fan escribir una condici\u00f3n if que decida c\u00f3mo se va a portar el c\u00f3digo cuando \u00e9ste puede ser usado de ambas maneras. if __name__ == '__main__': # Esto no se ejecuta en un m\u00f3dulo importado ... Modelo de programa \u00c9ste es un modelo usual para escribir un programa en Python: # prog.py # Comandos import (bibliotecas o m\u00f3dulos) import modules # Funciones def spam(): ... def blah(): ... # Funci\u00f3n principal def main(): ... if __name__ == '__main__': main() Herramientas para la consola Python se usa muy frecuentemente para correr herramientas desde la l\u00ednea de comandos. En clase vimos alg\u00fan ejemplo: bash % python3 informe.py camion.csv precios.csv Esto permite que los scripts sean ejecutados desde la terminal para correr ciertos procesos autom\u00e1ticos, ejecutar tareas en segundo plano, etc. Argumentos en la l\u00ednea de comandos Python interpreta una l\u00ednea de comandos como una lista de cadenas de texto. bash % python3 informe.py camion.csv precios.csv Como el script informe.py no est\u00e1 preparado para leer par\u00e1metros, no los va a usar. Igual, pod\u00e9s acceder a esta lista de cadenas usando sys.argv . Por ejemplo, si usas el par\u00e1metro -i para invocar a python de modo que el int\u00e9rprete interactivo no termine luego de llamar a informe.py con los par\u00e1metros anteriores bash % python3 -i informe.py camion.csv precios.csv luego podr\u00e1s ver el contenido de esta lista: # Llamado como reci\u00e9n, sys.argv contiene import sys sys.argv # ['informe.py, 'camion.csv', 'precios.csv'] Ahora vamos a hacer que los tenga en cuenta. El siguiente es un ejemplo de script simple para procesar los argumentos recibidos al invocarlo desde la terminal. Te permite usar tu script para generar el informe con archivos de diferentes camiones o precios, pasados como par\u00e1metros por la l\u00ednea de comandos: import sys if len(sys.argv) != 3: raise SystemExit(f'Uso adecuado: {sys.argv[0]} ' 'archivo_camion archivo_precios') camion = sys.argv[1] precios = sys.argv[2] ... Para ir un poco m\u00e1s all\u00e1, pod\u00e9s mirar el m\u00f3dulo argparse de Python permite escribir interfaces para programas que corren por linea de comandos de una manera amigables y profesional. Standard I/O Los archivos de entrada y salida est\u00e1ndard (Standard Input / Output (stdio)) son archivos que se portan como archivos normales, pero est\u00e1n definidos por el sistema operativo. sys.stdout sys.stderr sys.stdin Por omisi\u00f3n, la salida impresa es dirigida a sys.stdout (usualmente la pantalla), la entrada se lee de sys.stdin (usualmente el teclado), y la recapitulaci\u00f3n de errores es dirigida a sys.stderr (usualmente, la pantalla otra vez). Las entradas y salidas de stdio pueden estar ligadas al teclado, a la pantalla, a una impresora, a diferentes archivos o incluir cosas m\u00e1s extra\u00f1as como pipes, etc. bash % python3 prog.py > resultados.txt # o si no bash % cmd1 | python3 prog.py | cmd2 Esta sintaxis se llama \"piping\" o redireccionamiento y significa: ejecutar cmd1, enviar su salida como entrada a prog.py invocado desde la terminal, y la salida de \u00e9ste ser\u00e1 la entrada para cmd2. Terminaci\u00f3n del programa La terminaci\u00f3n y salida del programa se administran a trav\u00e9s de excepciones. raise SystemExit raise SystemExit(codigo_salida) raise SystemExit('Mensaje informativo') O, alternativamente: import sys sys.exit(codigo_salida) Es est\u00e1ndar que un codigo de salida de 0 indica que no hubo problemas y otro valor, que los hubo. El comando #! Bajo Unix (Linux es un Unix) una l\u00ednea que comienza con #! ejecutar\u00e1 un script en el int\u00e9rprete Python. Por ejemplo, si agreg\u00e1s la siguiente l\u00ednea al comienzo de tu script pod\u00e9s ejecutar directamente el script (sin invocar manualmente a Python en la misma l\u00ednea). #!/usr/bin/env python3 # prog.py ... Para porder ser ejecutado, el archivo prog.py requiere permiso de ejecuci\u00f3n asignado. Pod\u00e9s asignarle este permiso as\u00ed: bash % chmod +x prog.py # Ahora lo pod\u00e9s ejecutar bash % ./prog.py ... salida ... Observaci\u00f3n: Al iniciar un script Python en Windows, se lee la l\u00ednea que comienza con #! dentro del script para saber qu\u00e9 versi\u00f3n del int\u00e9rprete invocar. Modelo de script con par\u00e1metros Para terminar, \u00e9ste es un modelo usual de programa en Python que se ejecuta invocado desde la terminal. #!/usr/bin/env python3 # prog.py # Import (bibliotecas) import modules # Funciones def spam(): ... def blah(): ... # Funcion principal def main(parametros): # Analizar la l\u00ednea de comandos, # usando la variable par\u00e1metros en lugar # de sys.argv, donde corresponda ... if __name__ == '__main__': import sys main(sys.argv) Observaci\u00f3n: Este modelo es flexible en el sentido que te permite escribir programas que pod\u00e9s llamar desde la terminal pas\u00e1ndole par\u00e1metros o ejecutar directamente dentro de un int\u00e9rprete usando import y llamando a su funci\u00f3n main como veremos en los siguientes ejercicios. Ejercicios Record\u00e1 trabajar siempre con las \u00faltimas versiones de tus archivos. Ejercicio 7.2: Funci\u00f3n main() Usando estas ideas, agreg\u00e1 a tu programa informe.py una funci\u00f3n main() que tome una lista de par\u00e1metros en la l\u00ednea de comandos y produzca la misma salida que antes. bash % python3 informe.py ../Data/camion.csv ../Data/precios.csv Tambi\u00e9n deber\u00edas poder ejecutarlo del siguiente modo dentro del int\u00e9rprete interactivo de Python: >>> import informe >>> informe.main(['informe.py', '../Data/camion.csv', '../Data/precios.csv']) Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 $32.2 8.02 Naranja 50 $91.1 15.18 Caqui 150 $103.44 2.02 Mandarina 200 $51.23 29.66 Durazno 95 $40.37 33.11 Mandarina 50 $65.1 15.79 Naranja 100 $70.44 35.84 >>> An\u00e1logamente, modific\u00e1 el archivo costo_camion.py para que incluya una funci\u00f3n similar main() que te permita hacer esto: >>> import costo_camion >>> costo_camion.main(['costo_camion.py', '../Data/camion.csv']) Total cost: 47671.15 >>> Ejercicio 7.3: Hacer un script Finalmente, modific\u00e1 tus programas informe.py y costo_camion.py para que puedan ser ejecutados como scripts desde la l\u00ednea de comandos: bash $ python3 informe.py ../Data/camion.csv ../Data/precios.csv Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 $32.2 8.02 Naranja 50 $91.1 15.18 Caqui 150 $103.44 2.02 Mandarina 200 $51.23 29.66 Durazno 95 $40.37 33.11 Mandarina 50 $65.1 15.79 Naranja 100 $70.44 35.84 bash $ python3 costo_camion.py Data/camion.csv Costo total: 47671.15 Aclaraci\u00f3n: En el ejercicio anterior ya agregaste una funci\u00f3n main() a tu c\u00f3digo. En este simplemente deber\u00edas verificar si __name__ == '__main__' y llamar a esa funci\u00f3n para que se ejecute autom\u00e1ticamente cuando llames a tu programa desde la l\u00ednea de comandos. Contenidos | Anterior (2 Control de errores) | Pr\u00f3ximo (4 Cuestiones de dise\u00f1o)","title":"03 Modulo principal"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#73-el-modulo-principal","text":"En esta secci\u00f3n introducimos el concepto de m\u00f3dulo principal . Dejamos este video con una introducci\u00f3n breve a esta secci\u00f3n y la siguiente.","title":"7.3 El m\u00f3dulo principal"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#funcion-principal","text":"En muchos lenguajes de programaci\u00f3n existe el concepto de m\u00e9todo o funci\u00f3n principal . // c / c++ int main(int argc, char *argv[]) { ... } // java class myprog { public static void main(String args[]) { ... } } Se refiere a la primera funci\u00f3n que es ejecutada cuando corremos un programa.","title":"Funci\u00f3n principal"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#modulo-principal-en-python","text":"Python no tiene una funci\u00f3n o m\u00e9todo principal. En su lugar existe un m\u00f3dulo principal y \u00e9ste ser\u00e1 el archivo con c\u00f3digo fuente que se ejecuta primero. bash % python3 prog.py ... El archivo que le pases al int\u00e9rprete al invocarlo ser\u00e1 el m\u00f3dulo principal. No importa c\u00f3mo lo llames.","title":"M\u00f3dulo principal en Python"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#chequear-__main__","text":"Es una pr\u00e1ctica est\u00e1ndar usar la siguiente convenci\u00f3n en m\u00f3dulos que son ejecutados como scripts principales: # prog.py ... if __name__ == '__main__': # Soy el programa principal ... comandos ... Los comandos dentro del if constituyen el programa principal","title":"Chequear __main__"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#modulo-principal-vs-modulo-importado","text":"Cualquier archivo .py puede ejecutarse ya sea como el programa principal o como un m\u00f3dulo importado: bash % python3 prog.py # Corriendo como principal import prog # Corriendo como m\u00f3dulo importado La variable __name__ es el nombre del m\u00f3dulo. Sin embargo, esta variable __name__ valdr\u00e1 __main__ si ese m\u00f3dulo est\u00e1 siendo ejecutado como el script principal. Normalmente deseamos que los comandos que son parte del comportamiento del script en modo principal s\u00f3lo se ejecuten si efectivamente el script es el m\u00f3dulo principal. No queremos que esos comandos se ejecuten si el m\u00f3dulo fue importado. Por lo tanto es com\u00fan escribir una condici\u00f3n if que decida c\u00f3mo se va a portar el c\u00f3digo cuando \u00e9ste puede ser usado de ambas maneras. if __name__ == '__main__': # Esto no se ejecuta en un m\u00f3dulo importado ...","title":"M\u00f3dulo principal vs. m\u00f3dulo importado"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#modelo-de-programa","text":"\u00c9ste es un modelo usual para escribir un programa en Python: # prog.py # Comandos import (bibliotecas o m\u00f3dulos) import modules # Funciones def spam(): ... def blah(): ... # Funci\u00f3n principal def main(): ... if __name__ == '__main__': main()","title":"Modelo de programa"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#herramientas-para-la-consola","text":"Python se usa muy frecuentemente para correr herramientas desde la l\u00ednea de comandos. En clase vimos alg\u00fan ejemplo: bash % python3 informe.py camion.csv precios.csv Esto permite que los scripts sean ejecutados desde la terminal para correr ciertos procesos autom\u00e1ticos, ejecutar tareas en segundo plano, etc.","title":"Herramientas para la consola"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#argumentos-en-la-linea-de-comandos","text":"Python interpreta una l\u00ednea de comandos como una lista de cadenas de texto. bash % python3 informe.py camion.csv precios.csv Como el script informe.py no est\u00e1 preparado para leer par\u00e1metros, no los va a usar. Igual, pod\u00e9s acceder a esta lista de cadenas usando sys.argv . Por ejemplo, si usas el par\u00e1metro -i para invocar a python de modo que el int\u00e9rprete interactivo no termine luego de llamar a informe.py con los par\u00e1metros anteriores bash % python3 -i informe.py camion.csv precios.csv luego podr\u00e1s ver el contenido de esta lista: # Llamado como reci\u00e9n, sys.argv contiene import sys sys.argv # ['informe.py, 'camion.csv', 'precios.csv'] Ahora vamos a hacer que los tenga en cuenta. El siguiente es un ejemplo de script simple para procesar los argumentos recibidos al invocarlo desde la terminal. Te permite usar tu script para generar el informe con archivos de diferentes camiones o precios, pasados como par\u00e1metros por la l\u00ednea de comandos: import sys if len(sys.argv) != 3: raise SystemExit(f'Uso adecuado: {sys.argv[0]} ' 'archivo_camion archivo_precios') camion = sys.argv[1] precios = sys.argv[2] ... Para ir un poco m\u00e1s all\u00e1, pod\u00e9s mirar el m\u00f3dulo argparse de Python permite escribir interfaces para programas que corren por linea de comandos de una manera amigables y profesional.","title":"Argumentos en la l\u00ednea de comandos"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#standard-io","text":"Los archivos de entrada y salida est\u00e1ndard (Standard Input / Output (stdio)) son archivos que se portan como archivos normales, pero est\u00e1n definidos por el sistema operativo. sys.stdout sys.stderr sys.stdin Por omisi\u00f3n, la salida impresa es dirigida a sys.stdout (usualmente la pantalla), la entrada se lee de sys.stdin (usualmente el teclado), y la recapitulaci\u00f3n de errores es dirigida a sys.stderr (usualmente, la pantalla otra vez). Las entradas y salidas de stdio pueden estar ligadas al teclado, a la pantalla, a una impresora, a diferentes archivos o incluir cosas m\u00e1s extra\u00f1as como pipes, etc. bash % python3 prog.py > resultados.txt # o si no bash % cmd1 | python3 prog.py | cmd2 Esta sintaxis se llama \"piping\" o redireccionamiento y significa: ejecutar cmd1, enviar su salida como entrada a prog.py invocado desde la terminal, y la salida de \u00e9ste ser\u00e1 la entrada para cmd2.","title":"Standard I/O"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#terminacion-del-programa","text":"La terminaci\u00f3n y salida del programa se administran a trav\u00e9s de excepciones. raise SystemExit raise SystemExit(codigo_salida) raise SystemExit('Mensaje informativo') O, alternativamente: import sys sys.exit(codigo_salida) Es est\u00e1ndar que un codigo de salida de 0 indica que no hubo problemas y otro valor, que los hubo.","title":"Terminaci\u00f3n del programa"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#el-comando","text":"Bajo Unix (Linux es un Unix) una l\u00ednea que comienza con #! ejecutar\u00e1 un script en el int\u00e9rprete Python. Por ejemplo, si agreg\u00e1s la siguiente l\u00ednea al comienzo de tu script pod\u00e9s ejecutar directamente el script (sin invocar manualmente a Python en la misma l\u00ednea). #!/usr/bin/env python3 # prog.py ... Para porder ser ejecutado, el archivo prog.py requiere permiso de ejecuci\u00f3n asignado. Pod\u00e9s asignarle este permiso as\u00ed: bash % chmod +x prog.py # Ahora lo pod\u00e9s ejecutar bash % ./prog.py ... salida ... Observaci\u00f3n: Al iniciar un script Python en Windows, se lee la l\u00ednea que comienza con #! dentro del script para saber qu\u00e9 versi\u00f3n del int\u00e9rprete invocar.","title":"El comando #!"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#modelo-de-script-con-parametros","text":"Para terminar, \u00e9ste es un modelo usual de programa en Python que se ejecuta invocado desde la terminal. #!/usr/bin/env python3 # prog.py # Import (bibliotecas) import modules # Funciones def spam(): ... def blah(): ... # Funcion principal def main(parametros): # Analizar la l\u00ednea de comandos, # usando la variable par\u00e1metros en lugar # de sys.argv, donde corresponda ... if __name__ == '__main__': import sys main(sys.argv) Observaci\u00f3n: Este modelo es flexible en el sentido que te permite escribir programas que pod\u00e9s llamar desde la terminal pas\u00e1ndole par\u00e1metros o ejecutar directamente dentro de un int\u00e9rprete usando import y llamando a su funci\u00f3n main como veremos en los siguientes ejercicios.","title":"Modelo de script con par\u00e1metros"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#ejercicios","text":"Record\u00e1 trabajar siempre con las \u00faltimas versiones de tus archivos.","title":"Ejercicios"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#ejercicio-72-funcion-main","text":"Usando estas ideas, agreg\u00e1 a tu programa informe.py una funci\u00f3n main() que tome una lista de par\u00e1metros en la l\u00ednea de comandos y produzca la misma salida que antes. bash % python3 informe.py ../Data/camion.csv ../Data/precios.csv Tambi\u00e9n deber\u00edas poder ejecutarlo del siguiente modo dentro del int\u00e9rprete interactivo de Python: >>> import informe >>> informe.main(['informe.py', '../Data/camion.csv', '../Data/precios.csv']) Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 $32.2 8.02 Naranja 50 $91.1 15.18 Caqui 150 $103.44 2.02 Mandarina 200 $51.23 29.66 Durazno 95 $40.37 33.11 Mandarina 50 $65.1 15.79 Naranja 100 $70.44 35.84 >>> An\u00e1logamente, modific\u00e1 el archivo costo_camion.py para que incluya una funci\u00f3n similar main() que te permita hacer esto: >>> import costo_camion >>> costo_camion.main(['costo_camion.py', '../Data/camion.csv']) Total cost: 47671.15 >>>","title":"Ejercicio 7.2: Funci\u00f3n main()"},{"location":"07_Plt_Especificacion_y_Documentacion/03_Modulo_principal/#ejercicio-73-hacer-un-script","text":"Finalmente, modific\u00e1 tus programas informe.py y costo_camion.py para que puedan ser ejecutados como scripts desde la l\u00ednea de comandos: bash $ python3 informe.py ../Data/camion.csv ../Data/precios.csv Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 $32.2 8.02 Naranja 50 $91.1 15.18 Caqui 150 $103.44 2.02 Mandarina 200 $51.23 29.66 Durazno 95 $40.37 33.11 Mandarina 50 $65.1 15.79 Naranja 100 $70.44 35.84 bash $ python3 costo_camion.py Data/camion.csv Costo total: 47671.15 Aclaraci\u00f3n: En el ejercicio anterior ya agregaste una funci\u00f3n main() a tu c\u00f3digo. En este simplemente deber\u00edas verificar si __name__ == '__main__' y llamar a esa funci\u00f3n para que se ejecute autom\u00e1ticamente cuando llames a tu programa desde la l\u00ednea de comandos. Contenidos | Anterior (2 Control de errores) | Pr\u00f3ximo (4 Cuestiones de dise\u00f1o)","title":"Ejercicio 7.3: Hacer un script"},{"location":"07_Plt_Especificacion_y_Documentacion/04_Flexibilidad/","text":"Contenidos | Anterior (3 El m\u00f3dulo principal) | Pr\u00f3ximo (5 Contratos: Especificaci\u00f3n y Documentaci\u00f3n) 7.4 Cuestiones de dise\u00f1o En esta breve secci\u00f3n, volvemos a discutir algunas decisiones de dise\u00f1o que tomamos antes. Archivos versus iterables Compar\u00e1 estos dos programas que resultan en la misma salida. # Necesita el nombre de un archivo def read_data(nombre_archivo): records = [] with open(nombre_archivo) as f: for line in f: ... records.append(r) return records d = read_data('file.csv') # Necesita l\u00edneas de texto def read_data(lines): records = [] for line in lines: ... records.append(r) return records with open('file.csv') as f: d = read_data(f) \u00bfCu\u00e1l de las funciones read_data() prefer\u00eds y por qu\u00e9? \u00bfCu\u00e1l de las funciones permite mayor flexibilidad? Una idea profunda: \"Duck Typing\" (Identificaci\u00f3n de patos) Duck Typing del ingl\u00e9s o en espa\u00f1ol \"Test del pato\" es un concepto usado en programaci\u00f3n para determinar si un objeto puede ser usado para un prop\u00f3sito en particular. Se trata de una aplicaci\u00f3n particular del test del pato que puede resumirse as\u00ed: Si algo se parece a un pato, nada como un pato, y hace el mismo ruido que un pato, entonces probablemente se trate de un pato. Mientras que la primera versi\u00f3n de read_data() requiere espec\u00edficamente l\u00edneas de un archivo de texto, la segunda versi\u00f3n funciona con cualquier iterable. def read_data(lines): records = [] for line in lines: ... records.append(r) return records Esto implica que la podemos usar con otro tipo de l\u00edneas , no necesariamente archivos. Veamos algunos ejemplos. # Un archivo .csv lines = open('data.csv') data = read_data(lines) # Un archivo zipeado lines = gzip.open('data.csv.gz','rt') data = read_data(lines) # La entrada est\u00e1ndar (Standard Input), por teclado lines = sys.stdin data = read_data(lines) # Una lista de cadenas lines = ['Quinoto,50,91.1','Naranja,75,123.45', ... ] data = read_data(lines) Esto nos lleva nuevamente a la identificaci\u00f3n de patos: es suficiente con saber que grazna como pato, camina como pato y vuela como pato para saber que pod\u00e9s usarlo como pato. Volveremos a esta idea al hablar de dise\u00f1o de objetos, dentro de un par de clases. En este caso en particular, todos nuestros \"patos\" ... lines = open('data.csv') lines = gzip.open('data.csv.gz','rt') lines = sys.stdin lines = ['Quinoto,50,91.1','Naranja,75,123.45', ... ] son iterables de texto, por lo tanto los usaremos como \"patos\" en la funci\u00f3n read_data() . Si el concepto te resulta oscuro, tal vez esta explicaci\u00f3n te ayude. La flexibilidad que este dise\u00f1o permite es considerable. Pregunta: \u00bfDebemos favorecer u oponernos a esta flexibilidad? Buenas pr\u00e1cticas en el dise\u00f1o de bibliotecas Las bibliotecas de c\u00f3digo suelen ser m\u00e1s \u00fatiles si son flexibles. No restrinjas las opciones innecesariamente. Con mayor flexibilidad suele venir asociada una mayor potencia. Ejercicio Ejercicio 7.4: De archivos a \"objetos cual archivos\" >>> import fileparse >>> camion = fileparse.parse_csv('../Data/camion.csv', types=[str,int,float]) >>> Actualmente la funci\u00f3n solicita el nombre de un archivo, pero pod\u00e9s hacer el c\u00f3digo m\u00e1s flexible. Modific\u00e1 la funci\u00f3n de modo que funcione con cualquier objeto o iterable que se comporte como un archivo. Por ejemplo: >>> import fileparse >>> import gzip >>> with gzip.open('../Data/camion.csv.gz', 'rt') as file: ... camion = fileparse.parse_csv(file, types=[str,int,float]) ... >>> lines = ['nombre,cajones,precio', 'Lima,100,34.23', 'Naranja,50,91.1', 'Mburucuya,75,45.1'] >>> camion = fileparse.parse_csv(lines, types=[str,int,float]) >>> Atenci\u00f3n: Si lo hac\u00e9s con delicadeza, los cambios a hacer en tu c\u00f3digo son realmente m\u00ednimos. Fijate en la documentaci\u00f3n de la funci\u00f3n csv.reader (por ejemplo con help(csv.reader) ) que lo que le pas\u00e1s debe ser un objeto iterable, pero no necesariamente un archivo. Una vez que hayas incorporado esta modificaci\u00f3n, \u00bfqu\u00e9 pasa si le pas\u00e1s un nombre de archivo como antes? >>> camion = fileparse.parse_csv('../Data/camion.csv', types=[str,int,float]) >>> camion ... mir\u00e1 la salida (deber\u00eda ser un l\u00edo) ... >>> S\u00ed, hay que tener cuidado. Ejercicio 7.5: Arreglemos las funciones existentes Arregl\u00e1 las funciones leer_camion() y leer_precios() en el archivo informe.py de modo que funcionen con la nueva versi\u00f3n de parse_csv() . Con una peque\u00f1a modificaci\u00f3n es suficiente. Despu\u00e9s de esto tus programas informe.py y costo_camion.py deber\u00edan funcionar tan bien como antes. Por ahora dejamos estos archivos y pasamos a otras discusiones. Dej\u00e1 estos archivos listos para entregar al final de la clase. Contenidos | Anterior (3 El m\u00f3dulo principal) | Pr\u00f3ximo (5 Contratos: Especificaci\u00f3n y Documentaci\u00f3n)","title":"04 Flexibilidad"},{"location":"07_Plt_Especificacion_y_Documentacion/04_Flexibilidad/#74-cuestiones-de-diseno","text":"En esta breve secci\u00f3n, volvemos a discutir algunas decisiones de dise\u00f1o que tomamos antes.","title":"7.4 Cuestiones de dise\u00f1o"},{"location":"07_Plt_Especificacion_y_Documentacion/04_Flexibilidad/#archivos-versus-iterables","text":"Compar\u00e1 estos dos programas que resultan en la misma salida. # Necesita el nombre de un archivo def read_data(nombre_archivo): records = [] with open(nombre_archivo) as f: for line in f: ... records.append(r) return records d = read_data('file.csv') # Necesita l\u00edneas de texto def read_data(lines): records = [] for line in lines: ... records.append(r) return records with open('file.csv') as f: d = read_data(f) \u00bfCu\u00e1l de las funciones read_data() prefer\u00eds y por qu\u00e9? \u00bfCu\u00e1l de las funciones permite mayor flexibilidad?","title":"Archivos versus iterables"},{"location":"07_Plt_Especificacion_y_Documentacion/04_Flexibilidad/#una-idea-profunda-duck-typing-identificacion-de-patos","text":"Duck Typing del ingl\u00e9s o en espa\u00f1ol \"Test del pato\" es un concepto usado en programaci\u00f3n para determinar si un objeto puede ser usado para un prop\u00f3sito en particular. Se trata de una aplicaci\u00f3n particular del test del pato que puede resumirse as\u00ed: Si algo se parece a un pato, nada como un pato, y hace el mismo ruido que un pato, entonces probablemente se trate de un pato. Mientras que la primera versi\u00f3n de read_data() requiere espec\u00edficamente l\u00edneas de un archivo de texto, la segunda versi\u00f3n funciona con cualquier iterable. def read_data(lines): records = [] for line in lines: ... records.append(r) return records Esto implica que la podemos usar con otro tipo de l\u00edneas , no necesariamente archivos. Veamos algunos ejemplos. # Un archivo .csv lines = open('data.csv') data = read_data(lines) # Un archivo zipeado lines = gzip.open('data.csv.gz','rt') data = read_data(lines) # La entrada est\u00e1ndar (Standard Input), por teclado lines = sys.stdin data = read_data(lines) # Una lista de cadenas lines = ['Quinoto,50,91.1','Naranja,75,123.45', ... ] data = read_data(lines) Esto nos lleva nuevamente a la identificaci\u00f3n de patos: es suficiente con saber que grazna como pato, camina como pato y vuela como pato para saber que pod\u00e9s usarlo como pato. Volveremos a esta idea al hablar de dise\u00f1o de objetos, dentro de un par de clases. En este caso en particular, todos nuestros \"patos\" ... lines = open('data.csv') lines = gzip.open('data.csv.gz','rt') lines = sys.stdin lines = ['Quinoto,50,91.1','Naranja,75,123.45', ... ] son iterables de texto, por lo tanto los usaremos como \"patos\" en la funci\u00f3n read_data() . Si el concepto te resulta oscuro, tal vez esta explicaci\u00f3n te ayude. La flexibilidad que este dise\u00f1o permite es considerable. Pregunta: \u00bfDebemos favorecer u oponernos a esta flexibilidad?","title":"Una idea profunda: \"Duck Typing\" (Identificaci\u00f3n de patos)"},{"location":"07_Plt_Especificacion_y_Documentacion/04_Flexibilidad/#buenas-practicas-en-el-diseno-de-bibliotecas","text":"Las bibliotecas de c\u00f3digo suelen ser m\u00e1s \u00fatiles si son flexibles. No restrinjas las opciones innecesariamente. Con mayor flexibilidad suele venir asociada una mayor potencia.","title":"Buenas pr\u00e1cticas en el dise\u00f1o de bibliotecas"},{"location":"07_Plt_Especificacion_y_Documentacion/04_Flexibilidad/#ejercicio","text":"","title":"Ejercicio"},{"location":"07_Plt_Especificacion_y_Documentacion/04_Flexibilidad/#ejercicio-74-de-archivos-a-objetos-cual-archivos","text":">>> import fileparse >>> camion = fileparse.parse_csv('../Data/camion.csv', types=[str,int,float]) >>> Actualmente la funci\u00f3n solicita el nombre de un archivo, pero pod\u00e9s hacer el c\u00f3digo m\u00e1s flexible. Modific\u00e1 la funci\u00f3n de modo que funcione con cualquier objeto o iterable que se comporte como un archivo. Por ejemplo: >>> import fileparse >>> import gzip >>> with gzip.open('../Data/camion.csv.gz', 'rt') as file: ... camion = fileparse.parse_csv(file, types=[str,int,float]) ... >>> lines = ['nombre,cajones,precio', 'Lima,100,34.23', 'Naranja,50,91.1', 'Mburucuya,75,45.1'] >>> camion = fileparse.parse_csv(lines, types=[str,int,float]) >>> Atenci\u00f3n: Si lo hac\u00e9s con delicadeza, los cambios a hacer en tu c\u00f3digo son realmente m\u00ednimos. Fijate en la documentaci\u00f3n de la funci\u00f3n csv.reader (por ejemplo con help(csv.reader) ) que lo que le pas\u00e1s debe ser un objeto iterable, pero no necesariamente un archivo. Una vez que hayas incorporado esta modificaci\u00f3n, \u00bfqu\u00e9 pasa si le pas\u00e1s un nombre de archivo como antes? >>> camion = fileparse.parse_csv('../Data/camion.csv', types=[str,int,float]) >>> camion ... mir\u00e1 la salida (deber\u00eda ser un l\u00edo) ... >>> S\u00ed, hay que tener cuidado.","title":"Ejercicio 7.4: De archivos a \"objetos cual archivos\""},{"location":"07_Plt_Especificacion_y_Documentacion/04_Flexibilidad/#ejercicio-75-arreglemos-las-funciones-existentes","text":"Arregl\u00e1 las funciones leer_camion() y leer_precios() en el archivo informe.py de modo que funcionen con la nueva versi\u00f3n de parse_csv() . Con una peque\u00f1a modificaci\u00f3n es suficiente. Despu\u00e9s de esto tus programas informe.py y costo_camion.py deber\u00edan funcionar tan bien como antes. Por ahora dejamos estos archivos y pasamos a otras discusiones. Dej\u00e1 estos archivos listos para entregar al final de la clase. Contenidos | Anterior (3 El m\u00f3dulo principal) | Pr\u00f3ximo (5 Contratos: Especificaci\u00f3n y Documentaci\u00f3n)","title":"Ejercicio 7.5: Arreglemos las funciones existentes"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/","text":"Contenidos | Anterior (4 Cuestiones de dise\u00f1o) | Pr\u00f3ximo (6 Estilos de codeo) 7.5 Contratos: Especificaci\u00f3n y Documentaci\u00f3n En esta unidad formalizamos algunos temas que ya mencionamos brevemente en las clases anteriores sobre la especificaci\u00f3n y documentaci\u00f3n de funciones. Dejamos este video con una introducci\u00f3n breve a esta secci\u00f3n y la siguiente. Trabajaremos informalmente con conceptos formales. Por ejemplo, trataremos de responder en algunos casos concretos: \u00bfqu\u00e9 condiciones debe cumplir una funci\u00f3n al comenzar? \u00bfQu\u00e9 condiciones se mantinen durante su ejecuci\u00f3n? \u00bfQu\u00e9 debemos garantizar cuando se termina de ejecutar? Y veremos algunas t\u00e9cnicas para tener en cuenta estas condiciones. Documentaci\u00f3n Comenzamos formalizando un poco m\u00e1s algunos conceptos relacionados con la documentaci\u00f3n, cu\u00e1l es su objetivo y las distintas formas de documentar. Comentarios vs documentaci\u00f3n En Python tenemos dos convenciones diferentes para documentar nuestro c\u00f3digo: la documentaci\u00f3n propiamente dicha (lo que ponemos entre ' o ''' al principio de cada funci\u00f3n o m\u00f3dulo se llama docstring ), y los comentarios ( # ). En la mayor\u00eda de los lenguajes de programaci\u00f3n hay convenciones similares. \u00bfPor qu\u00e9 tenemos dos formas diferentes de documentar? La documentaci\u00f3n tiene como objetivo explicar qu\u00e9 hace el c\u00f3digo. La documentaci\u00f3n est\u00e1 dirigida a cualquier persona que desee utilizar la funci\u00f3n o m\u00f3dulo, para que pueda entender c\u00f3mo usarla sin necesidad de leer el c\u00f3digo fuente. Esto es \u00fatil incluso cuando quien implement\u00f3 la funci\u00f3n es la misma persona que la va a utilizar, ya que permite separar responsabilidades. Los comentarios tienen como objetivo explicar c\u00f3mo funciona el c\u00f3digo, y por qu\u00e9 se decidi\u00f3 implementarlo de esa manera. Los comentarios est\u00e1n dirigidos a quien est\u00e9 leyendo el c\u00f3digo fuente. Podemos ver la diferencia entre la documentaci\u00f3n y los comentarios en la funci\u00f3n elegir_codigo : def elegir_codigo(): '''Devuelve un codigo de 4 digitos elegido al azar''' digitos = ('0','1','2','3','4','5','6','7','8','9') codigo = \"\" for i in range(4): candidato = random.choice(digitos) # Debemos asegurarnos de no repetir digitos while candidato in codigo: candidato = random.choice(digitos) codigo = codigo + candidato return codigo \u00bfPor qu\u00e9 documentamos? Muchas veces se plantea el siguiente interrogante: \u00bfPara qu\u00e9 repetir con palabras lo que ya est\u00e1 estipulado en el c\u00f3digo? La documentaci\u00f3n es algo que muy a menudo se deja para despu\u00e9s por resultar tedioso y quiz\u00e1s aburrido en el momento de escribir el c\u00f3digo. Pero en ese despu\u00e9s , est\u00e1 el yo del futuro, u otre del futuro que quiere volver a usar el c\u00f3digo y que agradecer\u00e1 esas l\u00edneas que le evitar\u00e1n varios dolores de cabeza. Es muy frecuente que durante el desarrollo de un proyecto el c\u00f3digo evolucione con el tiempo. Si nos olvidamos de actualizar la documentaci\u00f3n para reflejar los cambios, entonces tendremos documentaci\u00f3n de mala calidad, ya que posiblemente est\u00e9 incompleta e incluso incorrecta. Una buena documentaci\u00f3n es componente esencial de cualquier proyecto exitoso (NumPy, matplotlib, etc. tienen buena documentaci\u00f3n). Esto en parte se debe a que el c\u00f3digo fuente transmite en detalle las operaciones individuales que componen un algoritmo o programa, pero no suele transmitir en forma transparente cosas como la intenci\u00f3n del programa, el dise\u00f1o de alto nivel, las razones por las que se decidi\u00f3 utilizar un algoritmo u otro, etc. Tambi\u00e9n se pueden incluir ejemplos para clarificar su uso . C\u00f3digo autodocumentado En teor\u00eda, si nuestro c\u00f3digo pudiera transmitir en forma eficiente todos esos conceptos, la documentaci\u00f3n ser\u00eda menos necesaria. De hecho, existe una t\u00e9cnica de programaci\u00f3n llamada c\u00f3digo autodocumentado , en la que la idea principal es elegir los nombres de funciones y variables de forma tal que la documentaci\u00f3n sea menos indispensable. Tomemos como ejemplo el siguiente c\u00f3digo: a = 9.81 b = 5 c = 0.5 * a * b**2 Leyendo esas tres l\u00edneas de c\u00f3digo podemos razonar cu\u00e1l ser\u00e1 el valor final de las variables a , b y c , pero no hay nada que nos indique qu\u00e9 representan esas variables, o cu\u00e1l es la intenci\u00f3n del c\u00f3digo. Una opci\u00f3n para mejorarlo ser\u00eda utilizar comentarios para aclarar la intenci\u00f3n: a = 9.81 # Valor de la constante G (aceleraci\u00f3n gravitacional), en m/s\u00b2 b = 5 # Tiempo en segundos c = 0.5 * a * b**2 # Desplazamiento (en metros) Otra opci\u00f3n, seg\u00fan la t\u00e9cnica de c\u00f3digo autodocumentado, es simplemente asignar nombres descriptivos a las variables: aceleracion_gravitacional = 9.81 tiempo_segundos = 5 desplazamiento_metros = 0.5 * aceleracion_gravitacional * tiempo_segundos ** 2 De esta manera logramos que la intenci\u00f3n del c\u00f3digo est\u00e9 m\u00e1s clara, y que se reduzca la necesidad de comentarios y documentaci\u00f3n para comprenderlo. La t\u00e9cnica de c\u00f3digo autodocumentado presenta varias limitaciones. Entre ellas: Elegir buenos nombres es una tarea dif\u00edcil, que requiere tener en cuenta cosas como: qu\u00e9 tan descriptivo es el nombre (cuanto m\u00e1s, mejor), la longitud del identificador (no debe ser excesivamente largo), el alcance del identificador (cu\u00e1nto m\u00e1s grande, m\u00e1s descriptivo debe ser el nombre), y convenciones ( i para \u00edndices, c para caracteres, etc). La documentaci\u00f3n de todas formas termina siendo necesaria, ya que por muy bien que elijamos los nombres, muchas veces la \u00fanica forma de explicar la intenci\u00f3n del c\u00f3digo y todos sus detalles es en lenguaje coloquial. En ciertos contextos sigue siendo deseable, o imprescindible, que quien quiera utilizar nuestra funci\u00f3n o m\u00f3dulo pueda entender su funcionamiento sin necesidad de leer el c\u00f3digo fuente. Un error com\u00fan: la sobredocumentaci\u00f3n Si bien la ausencia de documentaci\u00f3n suele ser perjudicial, el otro extremo tambi\u00e9n lo es: la sobredocumentaci\u00f3n . Despu\u00e9s de todo, en la vida diaria no necesitamos carteles que nos recuerden cosas como \"esta es la puerta\", \"este es el picaporte\" y \"empujar hacia abajo para abrir\". De la misma manera, podr\u00edamos decir que el siguiente c\u00f3digo peca de ser sobredocumentado: def buscar_elemento(lista_de_numeros, numero): '''Esta funci\u00f3n devuelve el \u00edndice (contando desde 0) en el que se encuentra el n\u00famero `numero` en la lista `lista_de_numeros`. Si el elemento no est\u00e1 en la lista devuelve -1. ''' # Recorremos todos los \u00edndices de la lista, desde 0 (inclusive) hasta N # (no inclusive) for indice in range(len(lista_de_numeros)): # Si el elemento en la posicion `indice` es el buscado if lista_de_numeros[indice] == numero: # Devolvemos el \u00edndice en el que est\u00e1 el elemento return indice # No lo encontramos, devolvemos -1 return -1 Algunas cosas que podemos mejorar: En la firma de la funci\u00f3n los nombres buscar_elemento , lista_de_numeros y numero se pueden simplificar a indice , secuencia y elemento . Cambiamos lista_de_numeros por lista , ya que la funci\u00f3n puede recibir secuencias de cualquier tipo, con elementos de cualquier tipo, y no hay ninguna raz\u00f3n para limitar a que sea una lista de n\u00fameros. Las variable interna indice tambi\u00e9n se puede simplificar: por convenci\u00f3n podemos usar i . \"Esta funci\u00f3n\" es redundante: cuando alguien lea la documentaci\u00f3n ya va a saber que se trata de una funci\u00f3n. \"contando desde 0\" es redundante: en Python siempre contamos desde 0. Los comentarios son excesivos: la funci\u00f3n es suficientemente simple y cualquier persona que sepa programaci\u00f3n b\u00e1sica podr\u00e1 entender el algoritmo. Corrigiendo todos estos detalles resulta: def indice(lista, elemento): '''Devuelve el \u00edndice en el que se encuentra el `elemento` en la `lista`, o -1 si no est\u00e1. ''' for i in range(len(lista)): if lista[i] == elemento: return i return -1 Contratos Cuando hablamos de contratos o programaci\u00f3n por contratos , nos referimos a una forma de estipular tanto lo que nuestro c\u00f3digo asume sobre los par\u00e1metros, como lo que devuelve. En los contratos se establecen compromisos que garantizan que si se cumplen los requisitos estipulados, la funci\u00f3n devolver\u00e1 cierto resultado. Es bueno que el contrato de una funci\u00f3n est\u00e9 incluido en su documentaci\u00f3n. Algunos ejemplos de cosas que deben ser estipuladas como parte del contrato son: c\u00f3mo deben ser los par\u00e1metros recibidos, qu\u00e9 va a ser lo que se devuelve, y si la funci\u00f3n provoca alg\u00fan efecto secundario (como por ejemplo modificar alguno de los par\u00e1metros recibidos). Las condiciones que se deben cumplir al momento de ejecutar el c\u00f3digo o funci\u00f3n se llaman precondiciones . Si se cumplen las precondiciones, el c\u00f3digo se ejecutar\u00e1 de manera que al finalizar su ejecuci\u00f3n el estado final de las variables y de valor de retorno, estar\u00e1n caracterizados en una poscondici\u00f3n . Precondiciones La precondici\u00f3n de una funci\u00f3n debe cumplirse antes de ejecutarla para que se comporte correctamente: c\u00f3mo deben ser los par\u00e1metros que recibe, c\u00f3mo debe ser el estado global, etc. Si no se cumplen, no hay garant\u00edas del funcionamiento del c\u00f3digo (podr\u00eda colgarse, o dar error, o peor a\u00fan dar resultados err\u00f3neos). Por ejemplo, en una funci\u00f3n que realiza la divisi\u00f3n entre dos n\u00fameros, la precondici\u00f3n debe decir que ambos par\u00e1metros deben ser n\u00fameros, y que el divisor debe ser distinto de 0. Si incluimos las precondiciones como parte de la documentaci\u00f3n, en el cuerpo de la funci\u00f3n podremos asumir que son ciertas, y no ser\u00e1 necesario escribir c\u00f3digo para lidiar con los casos en los que no se cumplan. Poscondiciones La poscondici\u00f3n caracterizar\u00e1 c\u00f3mo ser\u00e1 el valor de retorno y c\u00f3mo se modificar\u00e1n las variables de entrada (en caso de que corresponda) al finalizar la ejecuci\u00f3n siempre asumiendo que se cumpli\u00f3 la precondici\u00f3n al inicio. En el ejemplo anterior, la funci\u00f3n divisi\u00f3n nos garantiza que si se satisface la precondici\u00f3n, la funci\u00f3n devolver\u00e1 un n\u00famero y \u00e9ste ser\u00e1 el cociente solicitado. El qu\u00e9, no el c\u00f3mo Notar que al especificar un problema con pre y poscondici\u00f3n estamos definiendo qu\u00e9 es lo que debe suceder. En ning\u00fan momento decimos c\u00f3mo es que esto sucede. Para una misma especificaci\u00f3n podemos definir varias funciones que cumplan el contrato, y cada una puede resolverlo a su manera. Por ejemplo, volviendo a los ejemplos que trabajamos antes, mir\u00e1 la documentaci\u00f3n del csv.reader . Deber\u00edas nota que la precondici\u00f3n dice que el primer par\u00e1metro debe ser un interable y no un archivo espec\u00edficamente. Aseveraciones Retomamos ac\u00e1 el concepto de aseveraci\u00f3n que introdujimos en la Secci\u00f3n 4.1 . Tanto las precondiciones como las poscondiciones pueden pensarse como aseveraciones (en ingl\u00e9s assertions ). Es decir, afirmaciones realizadas en un momento particular de la ejecuci\u00f3n sobre el estado computacional. Si una aseveraci\u00f3n llegara a ser falsa, se levanta una excepci\u00f3n interrumpiendo la normal ejecuci\u00f3n del programa. En algunos casos puede ser \u00fatil incorporar estas afirmaciones desde el c\u00f3digo, y para eso podemos utilizar la instrucci\u00f3n assert . Esta instrucci\u00f3n recibe una condici\u00f3n a verificar (o sea, una expresi\u00f3n booleana). Si la condici\u00f3n es True , la instrucci\u00f3n no hace nada; en caso contrario se produce un error. >>> assert True >>> assert False (Traceback (most recent call last): File '<stdin>', line 1, in <module> AssertionError^) Opcionalmente, la instrucci\u00f3n assert puede recibir un mensaje de error que se mostrar\u00e1 en caso de que la condici\u00f3n no se cumpla. >>> x = 0 >>> assert x != 0, 'El divisor no puede ser 0' (^Traceback (most recent call last): File '<stdin>', line 1, in <module> AssertionError: El divisor no puede ser 0) Atenci\u00f3n: Es importante tener en cuenta que assert est\u00e1 pensado para ser usado en la etapa de desarrollo. Un programa terminado nunca deber\u00eda dejar de funcionar por este tipo de errores. Ejemplos Usando los ejemplos anteriores, la funci\u00f3n division nos quedar\u00eda de la siguiente forma: def division(dividendo, divisor): '''C\u00e1lculo de la divisi\u00f3n Pre: Recibe dos n\u00fameros, divisor debe ser distinto de 0. Pos: Devuelve un n\u00famero real, con el cociente de ambos. ''' assert divisor != 0, 'El divisor no puede ser 0' return dividendo / divisor o directamente def division(dividendo, divisor): '''C\u00e1lculo de la divisi\u00f3n Pre: Recibe dos n\u00fameros, divisor debe ser distinto de 0. Pos: Devuelve un n\u00famero real, con el cociente de ambos. ''' return dividendo / divisor Es interesante discutir un poco en detalle este ejemplo. La funci\u00f3n asume que el divisor es no nulo. Esto tiene sentido, ya que no podemos dividir por cero. Podr\u00edamos atrapar el error y, si nos pasan un divisor nulo, devolver por ejemplo cero . De esta forma evitamos que se termine el programa. Pero \u00bftiene sentido esto? \u00bfNos ahorra un problema o nos genera un nuevo problema? No es una buena pr\u00e1ctica atrapar errores que no sabemos manejar. Que 1/0 devuelva cero en principio no es correcto . Como ya mencionamos en la Secci\u00f3n 7.2 , es mejor que los errores generen excepciones ruidosamente y no atraparlas si no sabemos exactamente c\u00f3mo manejarlas. Veamos otro ejemplo, tal vez m\u00e1s interesante. Consideremos una funci\u00f3n sumar_enteros(desde, hasta) que implementa la sumatoria sum_i=desde^hasta i . En este caso, analizando los par\u00e1metros que recibir\u00e1 la funci\u00f3n, podemos definir la precondici\u00f3n para indicar lo que \u00e9stos deber\u00e1n cumplir. La funci\u00f3n sumar_enteros tomar\u00e1 un valor desde y un valor hasta . Es decir que recibe dos par\u00e1metros. def sumar_enteros(desde, hasta): Tanto desde como hasta deben ser n\u00fameros enteros, y dependiendo de la implementaci\u00f3n a realizar o de los requisitos con los que nos enfrentamos al escribir la precondici\u00f3n puede ser necesario exigir que hasta sea mayor o igual a desde . La declaraci\u00f3n de la funci\u00f3n, incluyendo documentaci\u00f3n, precondici\u00f3n y poscondici\u00f3n queda de la siguiente manera. def sumar_enteros(desde, hasta): '''Calcula la sumatoria de los n\u00fameros entre desde y hasta. Si hasta < desde, entonces devuelve cero. Pre: desde y hasta son n\u00fameros enteros Pos: Se devuelve el valor de sumar todos los n\u00fameros del intervalo [desde, hasta]. Si el intervalo es vac\u00edo se devuelve 0 ''' Prest\u00e1 atenci\u00f3n a que tanto la pre como la pos no dicen c\u00f3mo hace la funci\u00f3n para resolver el problema, sino que caracterizan el resultado. La implementaci\u00f3n (o c\u00f3digo) ser\u00e1n el c\u00f3mo. En este caso puede ser con un ciclo que emule los pasos de dichas sumas, podr\u00eda utilizarse una f\u00f3rmula cerrada que calcule el valor sin utilizar un ciclo, entre otras opciones. Lo importante es ver que a fines de la especificaci\u00f3n, esto no importa. En definitiva, la estipulaci\u00f3n de pre y poscondiciones dentro de la documentaci\u00f3n de las funciones es una forma de definir claramente el comportamiento del c\u00f3digo. Son, en efecto, un contrato entre el c\u00f3digo invocante (o usuarie) y el c\u00f3digo invocado (o funci\u00f3n). Ejercicio 7.6: Sumas En este ejercicio vas a realizar dos implementaciones correspondientes a la funci\u00f3n sumar_enteros definida reci\u00e9n. En la primera implementaci\u00f3n te pedimos que uses un ciclo. En la segunda te pedimos que lo hagas sin ciclos: implement\u00e1 la funci\u00f3n de manera que trabaje en tiempo constante (es decir, usando una cantidad de operaciones que no depende de las entradas a la funci\u00f3n. Ayuda: Estas sumas se pueden escribir como diferencia de dos n\u00fameros triangulares . Invariantes de ciclo Los invariantes se refieren a estados o condiciones que no cambian dentro de un contexto o porci\u00f3n de c\u00f3digo. Hay invariantes de ciclo, que son los que veremos a continuaci\u00f3n, e invariantes de estado, que se ver\u00e1n m\u00e1s adelante. Un invariante de ciclo es una aseveraci\u00f3n que debe ser verdadera al comienzo de cada iteraci\u00f3n del ciclo y al salir del mismo. Por ejemplo, si el problema es ir desde el punto A al punto B, la precondici\u00f3n dice que tenemos que estar parados en A y la poscondici\u00f3n que al terminar estaremos parados en B. En este caso las siguientes aseveraciones son invariantes: \"estamos en alg\u00fan punto entre A y B\", \"estamos en el punto m\u00e1s cercano a B que estuvimos hasta ahora\". Son aseveraciones que podr\u00eda tener nuestro c\u00f3digo (y dependen exclusivamente de c\u00f3mo lo programamos). Pensar en t\u00e9rminos de invariantes de ciclo nos ayuda a reflexionar y comprender mejor qu\u00e9 es lo que debe realizar nuestro c\u00f3digo y nos ayuda a desarrollarlo. Por ejemplo, para la funci\u00f3n maximo , que busca el valor m\u00e1s grande de una lista desordenada, podemos enunciar: - precondici\u00f3n: la lista contiene elementos que tienen una relaci\u00f3n de orden (son comparables con <) - poscondici\u00f3n: se devolver\u00e1 el elemento m\u00e1ximo de la lista, si es que tiene elementos, y si no se devolver\u00e1 None. def maximo(lista): 'Devuelve el elemento m\u00e1ximo de la lista o None si est\u00e1 vac\u00eda.' if not lista: return None max_elem = lista[0] for elemento in lista: if elemento > max_elem: max_elem = elemento return max_elem En este caso, el invariante del ciclo es que max_elem contiene el valor m\u00e1ximo de la porci\u00f3n de lista que ya fue analizada. Los invariantes son de gran importancia al momento de demostrar formalmente que un algoritmo funciona, pero a\u00fan cuando no hagamos una demostraci\u00f3n formal resulta \u00fatil tener los invariantes a la vista, ya que de esta forma es m\u00e1s f\u00e1cil entender c\u00f3mo funciona un algoritmo y encontrar posibles errores. Los invariantes, adem\u00e1s, son \u00fatiles a la hora de determinar las condiciones iniciales de un algoritmo, ya que tambi\u00e9n deben cumplirse para ese caso. Por ejemplo, consideremos el algoritmo para obtener la potencia n de un n\u00famero. def potencia(base, exp): 'Calcula la potencia exp del n\u00famero base, con exp entero mayor que 0.' resultado = 1 for i in range(exp): resultado *= base return resultado En este caso, el invariante del ciclo es que la variable resultado contiene el valor de la potencia correspondiente al \u00edndice i de la iteraci\u00f3n. Teniendo en cuenta esta condici\u00f3n, es f\u00e1cil ver que resultado debe comenzar el ciclo con un valor de 1, ya que ese es el valor correspondiente a base ** 0 . De la misma manera, si la operaci\u00f3n que se quiere realizar es sumar todos los elementos de una lista, el invariante ser\u00e1 que una variable suma contenga la suma de todos los elementos ya recorridos. Antes de empezar a recorrer la lista, seg\u00fan lo expresado en este invariante, esta suma debe ser 0 ya que no recorri\u00f3 ning\u00fan elemento. def suma(lista): 'Devuelve la suma de todos los elementos de la lista.' suma = 0 for elemento in lista: suma += elemento return suma En resumen, el concepto de invariante de ciclo es una herramienta que nos permite comprender (explicitar) mejor c\u00f3mo funciona un algoritmo. Resulta fundamental en la teor\u00eda de algoritmos, donde es necesario para demostrar que: - un algoritmo es correcto, es decir que realiza la tarea descripta por la pre y poscondici\u00f3n. - un algoritmo termina (y no se cuelga). Ejercicio 7.7: Invariante en sumas En el Ejercicio 7.6 , escribiste una funci\u00f3n sumar_enteros(desde, hasta) que utiliza un ciclo. \u00bfCu\u00e1l es el invariante de este ciclo? Par\u00e1metros mutables e inmutables Las funciones reciben par\u00e1metros que pueden ser mutables o inmutables. Si dentro del cuerpo de la funci\u00f3n se modifica uno de estos par\u00e1metros para que referencie a otro valor, este cambio no se ver\u00e1 reflejado fuera de la funci\u00f3n. Si, en cambio, se modifica el contenido de alguno de los par\u00e1metros mutables, este cambio s\u00ed se ver\u00e1 reflejado fuera de la funci\u00f3n. A continuaci\u00f3n vemos un ejemplo en el cual se asigna la variable recibida a un nuevo valor. Esa asignaci\u00f3n s\u00f3lo tiene efecto dentro de la funci\u00f3n. >>> def no_cambia_lista(lista): ... lista = [0, 1, 2, 3] ... print('Dentro de la funcion lista =', lista) ... >>> lista = [10, 20, 30, 40] >>> no_cambia_lista(lista) Dentro de la funcion lista = [0, 1, 2, 3] >>> lista [10, 20, 30, 40] A continuaci\u00f3n un ejemplo en el cual se modifica la variable recibida. En este caso, los cambios realizados tienen efecto tanto dentro como fuera de la funci\u00f3n. >>> def cambia_lista(lista): ... for i in range(len(lista)): ... lista[i] = lista[i] ** 3 ... >>> lista = [1, 2, 3, 4] >>> cambia_lista(lista) >>> lista [1, 8, 27, 64] Atenci\u00f3n: Salvo que sea expl\u00edcitamente aclarado, una funci\u00f3n no debe modificar los valores de sus par\u00e1metros. En el caso en que por una decisi\u00f3n de dise\u00f1o o especificaci\u00f3n se modifiquen los par\u00e1metros mutables recibidos, esto debe estar claramente documentado como parte de las poscondiciones. Repaso Dejamos un par de videos. En el primer video discutimos brevemente la importancia de establecer contratos y explicamos c\u00f3mo estos y los invariantes pueden ayudarnos a demostrar matem\u00e1ticamente que una funci\u00f3n hace lo que creemos que hace. En el segundo video damos algunos ejemplos de invariantes de ciclos discutidos paso a paso y hablamos de pre- y post-condiciones. Resumen El contrato de una funci\u00f3n especifica qu\u00e9 condiciones se deben cumplir para que la funci\u00f3n pueda ser invocada ( precondici\u00f3n ), y qu\u00e9 condiciones se garantiza que ser\u00e1n v\u00e1lidas cuando la funci\u00f3n termine su ejecuci\u00f3n ( poscondici\u00f3n ). La documentaci\u00f3n tiene como objetivo explicar qu\u00e9 hace el c\u00f3digo, y est\u00e1 dirigida a quien desee utilizar la funci\u00f3n o m\u00f3dulo. Es una buena pr\u00e1ctica incluir el contrato en la documentaci\u00f3n. Si una funci\u00f3n modifica un valor mutable que recibe por par\u00e1metro, eso debe estar expl\u00edcitamente aclarado en su documentaci\u00f3n. Los comentarios tienen como objetivo explicar c\u00f3mo funciona el c\u00f3digo y por qu\u00e9 se decidi\u00f3 implementarlo de esa manera, y est\u00e1n dirigidos a quien est\u00e9 leyendo el c\u00f3digo fuente. Los invariantes de ciclo son las condiciones que deben cumplirse al comienzo de cada iteraci\u00f3n de un ciclo. Ejercicios Ejercicio 7.8: Funciones y documentaci\u00f3n Para cada una de las siguientes funciones: * Pens\u00e1 cu\u00e1l es el contrato de la funci\u00f3n. * Agregale la documentaci\u00f3n adecuada. * Coment\u00e1 el c\u00f3digo si te parece que aporta. * Detect\u00e1 si hay invariantes de ciclo y comentalo al final de la funci\u00f3n Guard\u00e1 estos c\u00f3digos con tus modificaciones en el archivo documentacion.py . def valor_absoluto(n): if n >= 0: return n else: return -n def suma_pares(l): res = 0 for e in l: if e % 2 ==0: res += e else: res += 0 return res def veces(a, b): res = 0 nb = b while nb != 0: #print(nb * a + res) res += a nb -= 1 return res def collatz(n): res = 1 while n!=1: if n % 2 == 0: n = n//2 else: n = 3 * n + 1 res += 1 return res Contenidos | Anterior (4 Cuestiones de dise\u00f1o) | Pr\u00f3ximo (6 Estilos de codeo)","title":"05 Especificacion y Documentacion"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#75-contratos-especificacion-y-documentacion","text":"En esta unidad formalizamos algunos temas que ya mencionamos brevemente en las clases anteriores sobre la especificaci\u00f3n y documentaci\u00f3n de funciones. Dejamos este video con una introducci\u00f3n breve a esta secci\u00f3n y la siguiente. Trabajaremos informalmente con conceptos formales. Por ejemplo, trataremos de responder en algunos casos concretos: \u00bfqu\u00e9 condiciones debe cumplir una funci\u00f3n al comenzar? \u00bfQu\u00e9 condiciones se mantinen durante su ejecuci\u00f3n? \u00bfQu\u00e9 debemos garantizar cuando se termina de ejecutar? Y veremos algunas t\u00e9cnicas para tener en cuenta estas condiciones.","title":"7.5 Contratos: Especificaci\u00f3n y Documentaci\u00f3n"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#documentacion","text":"Comenzamos formalizando un poco m\u00e1s algunos conceptos relacionados con la documentaci\u00f3n, cu\u00e1l es su objetivo y las distintas formas de documentar.","title":"Documentaci\u00f3n"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#comentarios-vs-documentacion","text":"En Python tenemos dos convenciones diferentes para documentar nuestro c\u00f3digo: la documentaci\u00f3n propiamente dicha (lo que ponemos entre ' o ''' al principio de cada funci\u00f3n o m\u00f3dulo se llama docstring ), y los comentarios ( # ). En la mayor\u00eda de los lenguajes de programaci\u00f3n hay convenciones similares. \u00bfPor qu\u00e9 tenemos dos formas diferentes de documentar? La documentaci\u00f3n tiene como objetivo explicar qu\u00e9 hace el c\u00f3digo. La documentaci\u00f3n est\u00e1 dirigida a cualquier persona que desee utilizar la funci\u00f3n o m\u00f3dulo, para que pueda entender c\u00f3mo usarla sin necesidad de leer el c\u00f3digo fuente. Esto es \u00fatil incluso cuando quien implement\u00f3 la funci\u00f3n es la misma persona que la va a utilizar, ya que permite separar responsabilidades. Los comentarios tienen como objetivo explicar c\u00f3mo funciona el c\u00f3digo, y por qu\u00e9 se decidi\u00f3 implementarlo de esa manera. Los comentarios est\u00e1n dirigidos a quien est\u00e9 leyendo el c\u00f3digo fuente. Podemos ver la diferencia entre la documentaci\u00f3n y los comentarios en la funci\u00f3n elegir_codigo : def elegir_codigo(): '''Devuelve un codigo de 4 digitos elegido al azar''' digitos = ('0','1','2','3','4','5','6','7','8','9') codigo = \"\" for i in range(4): candidato = random.choice(digitos) # Debemos asegurarnos de no repetir digitos while candidato in codigo: candidato = random.choice(digitos) codigo = codigo + candidato return codigo","title":"Comentarios vs documentaci\u00f3n"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#por-que-documentamos","text":"Muchas veces se plantea el siguiente interrogante: \u00bfPara qu\u00e9 repetir con palabras lo que ya est\u00e1 estipulado en el c\u00f3digo? La documentaci\u00f3n es algo que muy a menudo se deja para despu\u00e9s por resultar tedioso y quiz\u00e1s aburrido en el momento de escribir el c\u00f3digo. Pero en ese despu\u00e9s , est\u00e1 el yo del futuro, u otre del futuro que quiere volver a usar el c\u00f3digo y que agradecer\u00e1 esas l\u00edneas que le evitar\u00e1n varios dolores de cabeza. Es muy frecuente que durante el desarrollo de un proyecto el c\u00f3digo evolucione con el tiempo. Si nos olvidamos de actualizar la documentaci\u00f3n para reflejar los cambios, entonces tendremos documentaci\u00f3n de mala calidad, ya que posiblemente est\u00e9 incompleta e incluso incorrecta. Una buena documentaci\u00f3n es componente esencial de cualquier proyecto exitoso (NumPy, matplotlib, etc. tienen buena documentaci\u00f3n). Esto en parte se debe a que el c\u00f3digo fuente transmite en detalle las operaciones individuales que componen un algoritmo o programa, pero no suele transmitir en forma transparente cosas como la intenci\u00f3n del programa, el dise\u00f1o de alto nivel, las razones por las que se decidi\u00f3 utilizar un algoritmo u otro, etc. Tambi\u00e9n se pueden incluir ejemplos para clarificar su uso .","title":"\u00bfPor qu\u00e9 documentamos?"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#codigo-autodocumentado","text":"En teor\u00eda, si nuestro c\u00f3digo pudiera transmitir en forma eficiente todos esos conceptos, la documentaci\u00f3n ser\u00eda menos necesaria. De hecho, existe una t\u00e9cnica de programaci\u00f3n llamada c\u00f3digo autodocumentado , en la que la idea principal es elegir los nombres de funciones y variables de forma tal que la documentaci\u00f3n sea menos indispensable. Tomemos como ejemplo el siguiente c\u00f3digo: a = 9.81 b = 5 c = 0.5 * a * b**2 Leyendo esas tres l\u00edneas de c\u00f3digo podemos razonar cu\u00e1l ser\u00e1 el valor final de las variables a , b y c , pero no hay nada que nos indique qu\u00e9 representan esas variables, o cu\u00e1l es la intenci\u00f3n del c\u00f3digo. Una opci\u00f3n para mejorarlo ser\u00eda utilizar comentarios para aclarar la intenci\u00f3n: a = 9.81 # Valor de la constante G (aceleraci\u00f3n gravitacional), en m/s\u00b2 b = 5 # Tiempo en segundos c = 0.5 * a * b**2 # Desplazamiento (en metros) Otra opci\u00f3n, seg\u00fan la t\u00e9cnica de c\u00f3digo autodocumentado, es simplemente asignar nombres descriptivos a las variables: aceleracion_gravitacional = 9.81 tiempo_segundos = 5 desplazamiento_metros = 0.5 * aceleracion_gravitacional * tiempo_segundos ** 2 De esta manera logramos que la intenci\u00f3n del c\u00f3digo est\u00e9 m\u00e1s clara, y que se reduzca la necesidad de comentarios y documentaci\u00f3n para comprenderlo. La t\u00e9cnica de c\u00f3digo autodocumentado presenta varias limitaciones. Entre ellas: Elegir buenos nombres es una tarea dif\u00edcil, que requiere tener en cuenta cosas como: qu\u00e9 tan descriptivo es el nombre (cuanto m\u00e1s, mejor), la longitud del identificador (no debe ser excesivamente largo), el alcance del identificador (cu\u00e1nto m\u00e1s grande, m\u00e1s descriptivo debe ser el nombre), y convenciones ( i para \u00edndices, c para caracteres, etc). La documentaci\u00f3n de todas formas termina siendo necesaria, ya que por muy bien que elijamos los nombres, muchas veces la \u00fanica forma de explicar la intenci\u00f3n del c\u00f3digo y todos sus detalles es en lenguaje coloquial. En ciertos contextos sigue siendo deseable, o imprescindible, que quien quiera utilizar nuestra funci\u00f3n o m\u00f3dulo pueda entender su funcionamiento sin necesidad de leer el c\u00f3digo fuente.","title":"C\u00f3digo autodocumentado"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#un-error-comun-la-sobredocumentacion","text":"Si bien la ausencia de documentaci\u00f3n suele ser perjudicial, el otro extremo tambi\u00e9n lo es: la sobredocumentaci\u00f3n . Despu\u00e9s de todo, en la vida diaria no necesitamos carteles que nos recuerden cosas como \"esta es la puerta\", \"este es el picaporte\" y \"empujar hacia abajo para abrir\". De la misma manera, podr\u00edamos decir que el siguiente c\u00f3digo peca de ser sobredocumentado: def buscar_elemento(lista_de_numeros, numero): '''Esta funci\u00f3n devuelve el \u00edndice (contando desde 0) en el que se encuentra el n\u00famero `numero` en la lista `lista_de_numeros`. Si el elemento no est\u00e1 en la lista devuelve -1. ''' # Recorremos todos los \u00edndices de la lista, desde 0 (inclusive) hasta N # (no inclusive) for indice in range(len(lista_de_numeros)): # Si el elemento en la posicion `indice` es el buscado if lista_de_numeros[indice] == numero: # Devolvemos el \u00edndice en el que est\u00e1 el elemento return indice # No lo encontramos, devolvemos -1 return -1 Algunas cosas que podemos mejorar: En la firma de la funci\u00f3n los nombres buscar_elemento , lista_de_numeros y numero se pueden simplificar a indice , secuencia y elemento . Cambiamos lista_de_numeros por lista , ya que la funci\u00f3n puede recibir secuencias de cualquier tipo, con elementos de cualquier tipo, y no hay ninguna raz\u00f3n para limitar a que sea una lista de n\u00fameros. Las variable interna indice tambi\u00e9n se puede simplificar: por convenci\u00f3n podemos usar i . \"Esta funci\u00f3n\" es redundante: cuando alguien lea la documentaci\u00f3n ya va a saber que se trata de una funci\u00f3n. \"contando desde 0\" es redundante: en Python siempre contamos desde 0. Los comentarios son excesivos: la funci\u00f3n es suficientemente simple y cualquier persona que sepa programaci\u00f3n b\u00e1sica podr\u00e1 entender el algoritmo. Corrigiendo todos estos detalles resulta: def indice(lista, elemento): '''Devuelve el \u00edndice en el que se encuentra el `elemento` en la `lista`, o -1 si no est\u00e1. ''' for i in range(len(lista)): if lista[i] == elemento: return i return -1","title":"Un error com\u00fan: la sobredocumentaci\u00f3n"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#contratos","text":"Cuando hablamos de contratos o programaci\u00f3n por contratos , nos referimos a una forma de estipular tanto lo que nuestro c\u00f3digo asume sobre los par\u00e1metros, como lo que devuelve. En los contratos se establecen compromisos que garantizan que si se cumplen los requisitos estipulados, la funci\u00f3n devolver\u00e1 cierto resultado. Es bueno que el contrato de una funci\u00f3n est\u00e9 incluido en su documentaci\u00f3n. Algunos ejemplos de cosas que deben ser estipuladas como parte del contrato son: c\u00f3mo deben ser los par\u00e1metros recibidos, qu\u00e9 va a ser lo que se devuelve, y si la funci\u00f3n provoca alg\u00fan efecto secundario (como por ejemplo modificar alguno de los par\u00e1metros recibidos). Las condiciones que se deben cumplir al momento de ejecutar el c\u00f3digo o funci\u00f3n se llaman precondiciones . Si se cumplen las precondiciones, el c\u00f3digo se ejecutar\u00e1 de manera que al finalizar su ejecuci\u00f3n el estado final de las variables y de valor de retorno, estar\u00e1n caracterizados en una poscondici\u00f3n .","title":"Contratos"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#precondiciones","text":"La precondici\u00f3n de una funci\u00f3n debe cumplirse antes de ejecutarla para que se comporte correctamente: c\u00f3mo deben ser los par\u00e1metros que recibe, c\u00f3mo debe ser el estado global, etc. Si no se cumplen, no hay garant\u00edas del funcionamiento del c\u00f3digo (podr\u00eda colgarse, o dar error, o peor a\u00fan dar resultados err\u00f3neos). Por ejemplo, en una funci\u00f3n que realiza la divisi\u00f3n entre dos n\u00fameros, la precondici\u00f3n debe decir que ambos par\u00e1metros deben ser n\u00fameros, y que el divisor debe ser distinto de 0. Si incluimos las precondiciones como parte de la documentaci\u00f3n, en el cuerpo de la funci\u00f3n podremos asumir que son ciertas, y no ser\u00e1 necesario escribir c\u00f3digo para lidiar con los casos en los que no se cumplan.","title":"Precondiciones"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#poscondiciones","text":"La poscondici\u00f3n caracterizar\u00e1 c\u00f3mo ser\u00e1 el valor de retorno y c\u00f3mo se modificar\u00e1n las variables de entrada (en caso de que corresponda) al finalizar la ejecuci\u00f3n siempre asumiendo que se cumpli\u00f3 la precondici\u00f3n al inicio. En el ejemplo anterior, la funci\u00f3n divisi\u00f3n nos garantiza que si se satisface la precondici\u00f3n, la funci\u00f3n devolver\u00e1 un n\u00famero y \u00e9ste ser\u00e1 el cociente solicitado.","title":"Poscondiciones"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#el-que-no-el-como","text":"Notar que al especificar un problema con pre y poscondici\u00f3n estamos definiendo qu\u00e9 es lo que debe suceder. En ning\u00fan momento decimos c\u00f3mo es que esto sucede. Para una misma especificaci\u00f3n podemos definir varias funciones que cumplan el contrato, y cada una puede resolverlo a su manera. Por ejemplo, volviendo a los ejemplos que trabajamos antes, mir\u00e1 la documentaci\u00f3n del csv.reader . Deber\u00edas nota que la precondici\u00f3n dice que el primer par\u00e1metro debe ser un interable y no un archivo espec\u00edficamente.","title":"El qu\u00e9, no el c\u00f3mo"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#aseveraciones","text":"Retomamos ac\u00e1 el concepto de aseveraci\u00f3n que introdujimos en la Secci\u00f3n 4.1 . Tanto las precondiciones como las poscondiciones pueden pensarse como aseveraciones (en ingl\u00e9s assertions ). Es decir, afirmaciones realizadas en un momento particular de la ejecuci\u00f3n sobre el estado computacional. Si una aseveraci\u00f3n llegara a ser falsa, se levanta una excepci\u00f3n interrumpiendo la normal ejecuci\u00f3n del programa. En algunos casos puede ser \u00fatil incorporar estas afirmaciones desde el c\u00f3digo, y para eso podemos utilizar la instrucci\u00f3n assert . Esta instrucci\u00f3n recibe una condici\u00f3n a verificar (o sea, una expresi\u00f3n booleana). Si la condici\u00f3n es True , la instrucci\u00f3n no hace nada; en caso contrario se produce un error. >>> assert True >>> assert False (Traceback (most recent call last): File '<stdin>', line 1, in <module> AssertionError^) Opcionalmente, la instrucci\u00f3n assert puede recibir un mensaje de error que se mostrar\u00e1 en caso de que la condici\u00f3n no se cumpla. >>> x = 0 >>> assert x != 0, 'El divisor no puede ser 0' (^Traceback (most recent call last): File '<stdin>', line 1, in <module> AssertionError: El divisor no puede ser 0) Atenci\u00f3n: Es importante tener en cuenta que assert est\u00e1 pensado para ser usado en la etapa de desarrollo. Un programa terminado nunca deber\u00eda dejar de funcionar por este tipo de errores.","title":"Aseveraciones"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#ejemplos","text":"Usando los ejemplos anteriores, la funci\u00f3n division nos quedar\u00eda de la siguiente forma: def division(dividendo, divisor): '''C\u00e1lculo de la divisi\u00f3n Pre: Recibe dos n\u00fameros, divisor debe ser distinto de 0. Pos: Devuelve un n\u00famero real, con el cociente de ambos. ''' assert divisor != 0, 'El divisor no puede ser 0' return dividendo / divisor o directamente def division(dividendo, divisor): '''C\u00e1lculo de la divisi\u00f3n Pre: Recibe dos n\u00fameros, divisor debe ser distinto de 0. Pos: Devuelve un n\u00famero real, con el cociente de ambos. ''' return dividendo / divisor Es interesante discutir un poco en detalle este ejemplo. La funci\u00f3n asume que el divisor es no nulo. Esto tiene sentido, ya que no podemos dividir por cero. Podr\u00edamos atrapar el error y, si nos pasan un divisor nulo, devolver por ejemplo cero . De esta forma evitamos que se termine el programa. Pero \u00bftiene sentido esto? \u00bfNos ahorra un problema o nos genera un nuevo problema? No es una buena pr\u00e1ctica atrapar errores que no sabemos manejar. Que 1/0 devuelva cero en principio no es correcto . Como ya mencionamos en la Secci\u00f3n 7.2 , es mejor que los errores generen excepciones ruidosamente y no atraparlas si no sabemos exactamente c\u00f3mo manejarlas. Veamos otro ejemplo, tal vez m\u00e1s interesante. Consideremos una funci\u00f3n sumar_enteros(desde, hasta) que implementa la sumatoria sum_i=desde^hasta i . En este caso, analizando los par\u00e1metros que recibir\u00e1 la funci\u00f3n, podemos definir la precondici\u00f3n para indicar lo que \u00e9stos deber\u00e1n cumplir. La funci\u00f3n sumar_enteros tomar\u00e1 un valor desde y un valor hasta . Es decir que recibe dos par\u00e1metros. def sumar_enteros(desde, hasta): Tanto desde como hasta deben ser n\u00fameros enteros, y dependiendo de la implementaci\u00f3n a realizar o de los requisitos con los que nos enfrentamos al escribir la precondici\u00f3n puede ser necesario exigir que hasta sea mayor o igual a desde . La declaraci\u00f3n de la funci\u00f3n, incluyendo documentaci\u00f3n, precondici\u00f3n y poscondici\u00f3n queda de la siguiente manera. def sumar_enteros(desde, hasta): '''Calcula la sumatoria de los n\u00fameros entre desde y hasta. Si hasta < desde, entonces devuelve cero. Pre: desde y hasta son n\u00fameros enteros Pos: Se devuelve el valor de sumar todos los n\u00fameros del intervalo [desde, hasta]. Si el intervalo es vac\u00edo se devuelve 0 ''' Prest\u00e1 atenci\u00f3n a que tanto la pre como la pos no dicen c\u00f3mo hace la funci\u00f3n para resolver el problema, sino que caracterizan el resultado. La implementaci\u00f3n (o c\u00f3digo) ser\u00e1n el c\u00f3mo. En este caso puede ser con un ciclo que emule los pasos de dichas sumas, podr\u00eda utilizarse una f\u00f3rmula cerrada que calcule el valor sin utilizar un ciclo, entre otras opciones. Lo importante es ver que a fines de la especificaci\u00f3n, esto no importa. En definitiva, la estipulaci\u00f3n de pre y poscondiciones dentro de la documentaci\u00f3n de las funciones es una forma de definir claramente el comportamiento del c\u00f3digo. Son, en efecto, un contrato entre el c\u00f3digo invocante (o usuarie) y el c\u00f3digo invocado (o funci\u00f3n).","title":"Ejemplos"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#ejercicio-76-sumas","text":"En este ejercicio vas a realizar dos implementaciones correspondientes a la funci\u00f3n sumar_enteros definida reci\u00e9n. En la primera implementaci\u00f3n te pedimos que uses un ciclo. En la segunda te pedimos que lo hagas sin ciclos: implement\u00e1 la funci\u00f3n de manera que trabaje en tiempo constante (es decir, usando una cantidad de operaciones que no depende de las entradas a la funci\u00f3n. Ayuda: Estas sumas se pueden escribir como diferencia de dos n\u00fameros triangulares .","title":"Ejercicio 7.6: Sumas"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#invariantes-de-ciclo","text":"Los invariantes se refieren a estados o condiciones que no cambian dentro de un contexto o porci\u00f3n de c\u00f3digo. Hay invariantes de ciclo, que son los que veremos a continuaci\u00f3n, e invariantes de estado, que se ver\u00e1n m\u00e1s adelante. Un invariante de ciclo es una aseveraci\u00f3n que debe ser verdadera al comienzo de cada iteraci\u00f3n del ciclo y al salir del mismo. Por ejemplo, si el problema es ir desde el punto A al punto B, la precondici\u00f3n dice que tenemos que estar parados en A y la poscondici\u00f3n que al terminar estaremos parados en B. En este caso las siguientes aseveraciones son invariantes: \"estamos en alg\u00fan punto entre A y B\", \"estamos en el punto m\u00e1s cercano a B que estuvimos hasta ahora\". Son aseveraciones que podr\u00eda tener nuestro c\u00f3digo (y dependen exclusivamente de c\u00f3mo lo programamos). Pensar en t\u00e9rminos de invariantes de ciclo nos ayuda a reflexionar y comprender mejor qu\u00e9 es lo que debe realizar nuestro c\u00f3digo y nos ayuda a desarrollarlo. Por ejemplo, para la funci\u00f3n maximo , que busca el valor m\u00e1s grande de una lista desordenada, podemos enunciar: - precondici\u00f3n: la lista contiene elementos que tienen una relaci\u00f3n de orden (son comparables con <) - poscondici\u00f3n: se devolver\u00e1 el elemento m\u00e1ximo de la lista, si es que tiene elementos, y si no se devolver\u00e1 None. def maximo(lista): 'Devuelve el elemento m\u00e1ximo de la lista o None si est\u00e1 vac\u00eda.' if not lista: return None max_elem = lista[0] for elemento in lista: if elemento > max_elem: max_elem = elemento return max_elem En este caso, el invariante del ciclo es que max_elem contiene el valor m\u00e1ximo de la porci\u00f3n de lista que ya fue analizada. Los invariantes son de gran importancia al momento de demostrar formalmente que un algoritmo funciona, pero a\u00fan cuando no hagamos una demostraci\u00f3n formal resulta \u00fatil tener los invariantes a la vista, ya que de esta forma es m\u00e1s f\u00e1cil entender c\u00f3mo funciona un algoritmo y encontrar posibles errores. Los invariantes, adem\u00e1s, son \u00fatiles a la hora de determinar las condiciones iniciales de un algoritmo, ya que tambi\u00e9n deben cumplirse para ese caso. Por ejemplo, consideremos el algoritmo para obtener la potencia n de un n\u00famero. def potencia(base, exp): 'Calcula la potencia exp del n\u00famero base, con exp entero mayor que 0.' resultado = 1 for i in range(exp): resultado *= base return resultado En este caso, el invariante del ciclo es que la variable resultado contiene el valor de la potencia correspondiente al \u00edndice i de la iteraci\u00f3n. Teniendo en cuenta esta condici\u00f3n, es f\u00e1cil ver que resultado debe comenzar el ciclo con un valor de 1, ya que ese es el valor correspondiente a base ** 0 . De la misma manera, si la operaci\u00f3n que se quiere realizar es sumar todos los elementos de una lista, el invariante ser\u00e1 que una variable suma contenga la suma de todos los elementos ya recorridos. Antes de empezar a recorrer la lista, seg\u00fan lo expresado en este invariante, esta suma debe ser 0 ya que no recorri\u00f3 ning\u00fan elemento. def suma(lista): 'Devuelve la suma de todos los elementos de la lista.' suma = 0 for elemento in lista: suma += elemento return suma En resumen, el concepto de invariante de ciclo es una herramienta que nos permite comprender (explicitar) mejor c\u00f3mo funciona un algoritmo. Resulta fundamental en la teor\u00eda de algoritmos, donde es necesario para demostrar que: - un algoritmo es correcto, es decir que realiza la tarea descripta por la pre y poscondici\u00f3n. - un algoritmo termina (y no se cuelga).","title":"Invariantes de ciclo"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#ejercicio-77-invariante-en-sumas","text":"En el Ejercicio 7.6 , escribiste una funci\u00f3n sumar_enteros(desde, hasta) que utiliza un ciclo. \u00bfCu\u00e1l es el invariante de este ciclo?","title":"Ejercicio 7.7: Invariante en sumas"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#parametros-mutables-e-inmutables","text":"Las funciones reciben par\u00e1metros que pueden ser mutables o inmutables. Si dentro del cuerpo de la funci\u00f3n se modifica uno de estos par\u00e1metros para que referencie a otro valor, este cambio no se ver\u00e1 reflejado fuera de la funci\u00f3n. Si, en cambio, se modifica el contenido de alguno de los par\u00e1metros mutables, este cambio s\u00ed se ver\u00e1 reflejado fuera de la funci\u00f3n. A continuaci\u00f3n vemos un ejemplo en el cual se asigna la variable recibida a un nuevo valor. Esa asignaci\u00f3n s\u00f3lo tiene efecto dentro de la funci\u00f3n. >>> def no_cambia_lista(lista): ... lista = [0, 1, 2, 3] ... print('Dentro de la funcion lista =', lista) ... >>> lista = [10, 20, 30, 40] >>> no_cambia_lista(lista) Dentro de la funcion lista = [0, 1, 2, 3] >>> lista [10, 20, 30, 40] A continuaci\u00f3n un ejemplo en el cual se modifica la variable recibida. En este caso, los cambios realizados tienen efecto tanto dentro como fuera de la funci\u00f3n. >>> def cambia_lista(lista): ... for i in range(len(lista)): ... lista[i] = lista[i] ** 3 ... >>> lista = [1, 2, 3, 4] >>> cambia_lista(lista) >>> lista [1, 8, 27, 64] Atenci\u00f3n: Salvo que sea expl\u00edcitamente aclarado, una funci\u00f3n no debe modificar los valores de sus par\u00e1metros. En el caso en que por una decisi\u00f3n de dise\u00f1o o especificaci\u00f3n se modifiquen los par\u00e1metros mutables recibidos, esto debe estar claramente documentado como parte de las poscondiciones.","title":"Par\u00e1metros mutables e inmutables"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#repaso","text":"Dejamos un par de videos. En el primer video discutimos brevemente la importancia de establecer contratos y explicamos c\u00f3mo estos y los invariantes pueden ayudarnos a demostrar matem\u00e1ticamente que una funci\u00f3n hace lo que creemos que hace. En el segundo video damos algunos ejemplos de invariantes de ciclos discutidos paso a paso y hablamos de pre- y post-condiciones.","title":"Repaso"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#resumen","text":"El contrato de una funci\u00f3n especifica qu\u00e9 condiciones se deben cumplir para que la funci\u00f3n pueda ser invocada ( precondici\u00f3n ), y qu\u00e9 condiciones se garantiza que ser\u00e1n v\u00e1lidas cuando la funci\u00f3n termine su ejecuci\u00f3n ( poscondici\u00f3n ). La documentaci\u00f3n tiene como objetivo explicar qu\u00e9 hace el c\u00f3digo, y est\u00e1 dirigida a quien desee utilizar la funci\u00f3n o m\u00f3dulo. Es una buena pr\u00e1ctica incluir el contrato en la documentaci\u00f3n. Si una funci\u00f3n modifica un valor mutable que recibe por par\u00e1metro, eso debe estar expl\u00edcitamente aclarado en su documentaci\u00f3n. Los comentarios tienen como objetivo explicar c\u00f3mo funciona el c\u00f3digo y por qu\u00e9 se decidi\u00f3 implementarlo de esa manera, y est\u00e1n dirigidos a quien est\u00e9 leyendo el c\u00f3digo fuente. Los invariantes de ciclo son las condiciones que deben cumplirse al comienzo de cada iteraci\u00f3n de un ciclo.","title":"Resumen"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#ejercicios","text":"","title":"Ejercicios"},{"location":"07_Plt_Especificacion_y_Documentacion/05_Especificacion_y_Documentacion/#ejercicio-78-funciones-y-documentacion","text":"Para cada una de las siguientes funciones: * Pens\u00e1 cu\u00e1l es el contrato de la funci\u00f3n. * Agregale la documentaci\u00f3n adecuada. * Coment\u00e1 el c\u00f3digo si te parece que aporta. * Detect\u00e1 si hay invariantes de ciclo y comentalo al final de la funci\u00f3n Guard\u00e1 estos c\u00f3digos con tus modificaciones en el archivo documentacion.py . def valor_absoluto(n): if n >= 0: return n else: return -n def suma_pares(l): res = 0 for e in l: if e % 2 ==0: res += e else: res += 0 return res def veces(a, b): res = 0 nb = b while nb != 0: #print(nb * a + res) res += a nb -= 1 return res def collatz(n): res = 1 while n!=1: if n % 2 == 0: n = n//2 else: n = 3 * n + 1 res += 1 return res Contenidos | Anterior (4 Cuestiones de dise\u00f1o) | Pr\u00f3ximo (6 Estilos de codeo)","title":"Ejercicio 7.8: Funciones y documentaci\u00f3n"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/","text":"Contenidos | Anterior (5 Contratos: Especificaci\u00f3n y Documentaci\u00f3n) | Pr\u00f3ximo (7 La biblioteca matplotlib) 7.6 Estilos de codeo PEP 8 - La gu\u00eda de estilo para Python La comunidad de usuaries de Python ha adoptado una gu\u00eda de estilo que facilita la lectura del c\u00f3digo y la consistencia entre programas de distintos usuaries. Esta gu\u00eda no es de seguimiento obligatorio, pero es altamente recomendable. El documento completo se denomina PEP 8 y est\u00e1 escrito originalmente en ingl\u00e9s , aunque hay alguna traducci\u00f3n al castellano . A continuaci\u00f3n presentamos un resumen con solo algunas recomendaciones. Indentaci\u00f3n Utilizar siempre 4 espacios y nunca mezclar tabuladores y espacios. Si se contin\u00faa una l\u00ednea hay dos opciones aceptables: # Correcto # opci\u00f3n 1, indentar a la apertura del par\u00e9ntesis: foo = funcion_que_crea_bar(variable_1, variable2, variable_3, variable_4) # opcion 2, agregar 4 espacios: foo = funcion_que_crea_bar( variable_1, variable2, variable_3) # Incorrecto, en cualquier lado. foo = funcion_que_crea_bar(variable_1, variable2, variable_3) Tama\u00f1o m\u00e1ximo de l\u00ednea Las l\u00edneas deben limitarse a un m\u00e1ximo de 79 caracteres. L\u00edneas en blanco Separar las definiciones de las clases y funciones con dos l\u00edneas en blanco. Los m\u00e9todos dentro de clases se separan con una l\u00ednea en blanco. Se recomienda utilizar l\u00edneas en blanco para separar partes del c\u00f3digo, por ejemplo dentro de una funci\u00f3n, que realizan tareas diferenciadas. Imports Los imports de distintos m\u00f3dulos deben estar en l\u00edneas diferentes: # S\u00ed: import os import sys # No: import os, sys S\u00ed se pueden poner en una l\u00ednea los elementos que se importan de un mismo m\u00f3dulo: from subprocess import Popen, PIPE Los imports deben ponerse siempre al principio del archivo, justo despu\u00e9s de los comentarios y de la documentaci\u00f3n del archivo y antes de la definici\u00f3n de las variables globales y las constantes. Los imports deben agruparse en el siguiente orden: bibliotecas o m\u00f3dulos est\u00e1ndar. bibliotecas o m\u00f3dulos de terceros. bibliotecas o m\u00f3dulos locales o propios. Cada grupo de imports debe estar separado por una l\u00ednea en blanco. Espacios en blanco en expresiones Evitar espacios en blanco extra en: Dentro de par\u00e9ntesis, corchetes o llaves. # S\u00ed: spam(ham[1], {eggs: 2}) # No: spam( ham[ 1 ], { eggs: 2 }) Antes de una coma. # S\u00ed: if x == 4: print x, y; x, y = y, x # No: if x == 4 : print x , y ; x , y = y , x Antes del par\u00e9ntesis de una llamada a una funci\u00f3n. # S\u00ed: spam(1) # No, ese espacio es espantoso spam (1) Antes del corchete de un \u00edndice o clave. # S\u00ed: dict['key'] = list[index] # No, ese espacio es igual de espantoso que el anterior dict ['key'] = list [index] Siempre separ\u00e1 los operadores binarios con un espacio simple a ambos lados: asignaci\u00f3n (=), asignaci\u00f3n aumentada (+=, -= , etc.), comparaci\u00f3n (==, <, >, !=, <>, <=, >=, in, not in, is, is not), booleanos (and, or, not). Us\u00e1 espacios alrededor de operadores artim\u00e9ticos: # S\u00ed: i = i + 1 submitted += 1 x = x * 2 - 1 hypot2 = x * x + y * y c = (a + b) * (a - b) # No: i=i+1 submitted +=1 x = x*2 - 1 #no es recomendado pero a veces lo usamos hypot2 = x*x + y*y c = (a+b) * (a-b) Convenciones de nombres Las convenciones de nombres en Python son un l\u00edo y probablemente nunca lograremos que todo sea consistente. Sin embargo, te damos algunas de las recomendaciones actuales sobre nombres. Los nuevos m\u00f3dulos deber\u00edan ser escritos respet\u00e1ndolos, aunque la consistencia interna es preferible para bibliotecas que ya tengan partes hechas... Estilos de nombres Hay muchos estilos para nombrar variable, funciones, etc. Es \u00fatil reconocer qu\u00e9 estilo se est\u00e1 usando, independientemente de para qu\u00e9 se est\u00e1 usando. \u00c9stos son algunos estilos: b (una sola letra, en min\u00fascula) B (una sola letra, en may\u00fascula) minusculas minusculas_con_guiones_bajos MAYUSCULAS MAYUSCULAS_CON_GUIONES_BAJOS PalabrasConMayusculas (tambi\u00e9n llamado estilo camello por las jorobas) mixedCase (difiere del camello en la inicial) Con_Mayusculas_Y_Guiones_Bajos (horrible!) Se recomienda no usar acentos ni caracteres especiales de ning\u00fan tipo para evitar problemas de compatibilidadd. Los nombres de funciones y variables deber\u00edan estar escritos en min\u00fasculas, eventualmente usando guiones bajos para mejorar la legibilidad. Hay mucho m\u00e1s! Esto es solo un breve resumen, mir\u00e1 el PEP 8 para tener toda la informaci\u00f3n sobre estilo recomendado en Python. El c\u00f3digo no es solo le\u00eddo: el c\u00f3digo de percibe M\u00e1s all\u00e1 de los gustos por los diferentes estilos posibles, es importante recordar que hay una m\u00e9trica que no falla nunca para evaluar la calidad de un c\u00f3digo: la cantidad de puteadas por minuto de un lector externo . Las reglas de estilo pueden ser discutidas, acatadas o no, en diferentes contextos. Es importante entender que un programador enfrentado a un c\u00f3digo en Python no solo lee el c\u00f3digo sino que percibe su dise\u00f1o en el espacio, el uso de bloques y espacios, de indentaciones y may\u00fasculas. El dise\u00f1o gr\u00e1fico del c\u00f3digo es una parte importante de las herramientas de transmisi\u00f3n de la informaci\u00f3n que permite nuestro archivo. Creeamos estas ideas con tres citas en ingl\u00e9s, extra\u00eddas de este excelente art\u00edculo de Aleksandr Skobelev que expresan la convicci\u00f3n de que el c\u00f3digo en un lenguaje de programaci\u00f3n no se escribe solamente para ser ejecutado por una computadora sino principalmente para ser le\u00eddo y percibido por otras personas: Usually, when evaluating the text of a program in terms of its ease of perception , the term readability is used. Strictly speaking, they are not exactly the same thing, because, as will be shown later, the process of perceiving a program is more than just reading. -- Aleksandr Skobelev, Fundamentals of Optimal Code Style. First, we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology. Thus, programs must be written for people to read, and only incidentally for machines to execute. -- Harold Abelson and Gerald Jay Sussman, Structure and Interpretation of Computer Programs. Indeed, the ratio of time spent reading vs. writing is well over 10:1\u2026 Because this ratio is so high, we want the reading of code to be easy, even if it makes the writing harder. -- Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship. Zen de Pyhton Ya que estamos hablando de los PEPs, queremos mencionar el PEP 20 (PEP viene de Python Enhancement Proposals), tambi\u00e9n conocido como el Zen de Python El Zen de Python es una colecci\u00f3n de principios de software que influyen en el dise\u00f1o del lenguaje. El texto, que copiamos a continuaci\u00f3n se puede encontrar en el sitio oficial de Python y tambi\u00e9n se incluye como sorpresa en el int\u00e9rprete de Python al escribir la instrucci\u00f3n import this .\u200b Zen de Pyhton Bello es mejor que feo. Expl\u00edcito es mejor que impl\u00edcito. Simple es mejor que complejo. Complejo es mejor que complicado. Plano es mejor que anidado. Espaciado es mejor que denso. La legibilidad es importante. Los casos especiales no son lo suficientemente especiales como para romper las reglas. Sin embargo la practicidad le gana a la pureza. Los errores nunca deber\u00edan pasar silenciosamente. A menos que se silencien expl\u00edcitamente. Frente a la ambig\u00fcedad, evit\u00e1 la tentaci\u00f3n de adivinar. Deber\u00eda haber una, y preferiblemente solo una, manera obvia de hacerlo. A pesar de que esa manera no sea obvia a menos que seas Holand\u00e9s. Ahora es mejor que nunca. A pesar de que nunca es muchas veces mejor que justo ahora. Si la implementaci\u00f3n es dif\u00edcil de explicar, es una mala idea. Si la implementaci\u00f3n es f\u00e1cil de explicar, puede que sea una buena idea. Los espacios de nombres son una gran idea, \u00a1hagamos m\u00e1s de ellos! Contenidos | Anterior (5 Contratos: Especificaci\u00f3n y Documentaci\u00f3n) | Pr\u00f3ximo (7 La biblioteca matplotlib)","title":"06 Estilo"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/#76-estilos-de-codeo","text":"","title":"7.6 Estilos de codeo"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/#pep-8-la-guia-de-estilo-para-python","text":"La comunidad de usuaries de Python ha adoptado una gu\u00eda de estilo que facilita la lectura del c\u00f3digo y la consistencia entre programas de distintos usuaries. Esta gu\u00eda no es de seguimiento obligatorio, pero es altamente recomendable. El documento completo se denomina PEP 8 y est\u00e1 escrito originalmente en ingl\u00e9s , aunque hay alguna traducci\u00f3n al castellano . A continuaci\u00f3n presentamos un resumen con solo algunas recomendaciones.","title":"PEP 8 - La gu\u00eda de estilo para Python"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/#indentacion","text":"Utilizar siempre 4 espacios y nunca mezclar tabuladores y espacios. Si se contin\u00faa una l\u00ednea hay dos opciones aceptables: # Correcto # opci\u00f3n 1, indentar a la apertura del par\u00e9ntesis: foo = funcion_que_crea_bar(variable_1, variable2, variable_3, variable_4) # opcion 2, agregar 4 espacios: foo = funcion_que_crea_bar( variable_1, variable2, variable_3) # Incorrecto, en cualquier lado. foo = funcion_que_crea_bar(variable_1, variable2, variable_3)","title":"Indentaci\u00f3n"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/#tamano-maximo-de-linea","text":"Las l\u00edneas deben limitarse a un m\u00e1ximo de 79 caracteres.","title":"Tama\u00f1o m\u00e1ximo de l\u00ednea"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/#lineas-en-blanco","text":"Separar las definiciones de las clases y funciones con dos l\u00edneas en blanco. Los m\u00e9todos dentro de clases se separan con una l\u00ednea en blanco. Se recomienda utilizar l\u00edneas en blanco para separar partes del c\u00f3digo, por ejemplo dentro de una funci\u00f3n, que realizan tareas diferenciadas.","title":"L\u00edneas en blanco"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/#imports","text":"Los imports de distintos m\u00f3dulos deben estar en l\u00edneas diferentes: # S\u00ed: import os import sys # No: import os, sys S\u00ed se pueden poner en una l\u00ednea los elementos que se importan de un mismo m\u00f3dulo: from subprocess import Popen, PIPE Los imports deben ponerse siempre al principio del archivo, justo despu\u00e9s de los comentarios y de la documentaci\u00f3n del archivo y antes de la definici\u00f3n de las variables globales y las constantes. Los imports deben agruparse en el siguiente orden: bibliotecas o m\u00f3dulos est\u00e1ndar. bibliotecas o m\u00f3dulos de terceros. bibliotecas o m\u00f3dulos locales o propios. Cada grupo de imports debe estar separado por una l\u00ednea en blanco.","title":"Imports"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/#espacios-en-blanco-en-expresiones","text":"Evitar espacios en blanco extra en: Dentro de par\u00e9ntesis, corchetes o llaves. # S\u00ed: spam(ham[1], {eggs: 2}) # No: spam( ham[ 1 ], { eggs: 2 }) Antes de una coma. # S\u00ed: if x == 4: print x, y; x, y = y, x # No: if x == 4 : print x , y ; x , y = y , x Antes del par\u00e9ntesis de una llamada a una funci\u00f3n. # S\u00ed: spam(1) # No, ese espacio es espantoso spam (1) Antes del corchete de un \u00edndice o clave. # S\u00ed: dict['key'] = list[index] # No, ese espacio es igual de espantoso que el anterior dict ['key'] = list [index] Siempre separ\u00e1 los operadores binarios con un espacio simple a ambos lados: asignaci\u00f3n (=), asignaci\u00f3n aumentada (+=, -= , etc.), comparaci\u00f3n (==, <, >, !=, <>, <=, >=, in, not in, is, is not), booleanos (and, or, not). Us\u00e1 espacios alrededor de operadores artim\u00e9ticos: # S\u00ed: i = i + 1 submitted += 1 x = x * 2 - 1 hypot2 = x * x + y * y c = (a + b) * (a - b) # No: i=i+1 submitted +=1 x = x*2 - 1 #no es recomendado pero a veces lo usamos hypot2 = x*x + y*y c = (a+b) * (a-b)","title":"Espacios en blanco en expresiones"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/#convenciones-de-nombres","text":"Las convenciones de nombres en Python son un l\u00edo y probablemente nunca lograremos que todo sea consistente. Sin embargo, te damos algunas de las recomendaciones actuales sobre nombres. Los nuevos m\u00f3dulos deber\u00edan ser escritos respet\u00e1ndolos, aunque la consistencia interna es preferible para bibliotecas que ya tengan partes hechas...","title":"Convenciones de nombres"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/#estilos-de-nombres","text":"Hay muchos estilos para nombrar variable, funciones, etc. Es \u00fatil reconocer qu\u00e9 estilo se est\u00e1 usando, independientemente de para qu\u00e9 se est\u00e1 usando. \u00c9stos son algunos estilos: b (una sola letra, en min\u00fascula) B (una sola letra, en may\u00fascula) minusculas minusculas_con_guiones_bajos MAYUSCULAS MAYUSCULAS_CON_GUIONES_BAJOS PalabrasConMayusculas (tambi\u00e9n llamado estilo camello por las jorobas) mixedCase (difiere del camello en la inicial) Con_Mayusculas_Y_Guiones_Bajos (horrible!) Se recomienda no usar acentos ni caracteres especiales de ning\u00fan tipo para evitar problemas de compatibilidadd. Los nombres de funciones y variables deber\u00edan estar escritos en min\u00fasculas, eventualmente usando guiones bajos para mejorar la legibilidad.","title":"Estilos de nombres"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/#hay-mucho-mas","text":"Esto es solo un breve resumen, mir\u00e1 el PEP 8 para tener toda la informaci\u00f3n sobre estilo recomendado en Python.","title":"Hay mucho m\u00e1s!"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/#el-codigo-no-es-solo-leido-el-codigo-de-percibe","text":"M\u00e1s all\u00e1 de los gustos por los diferentes estilos posibles, es importante recordar que hay una m\u00e9trica que no falla nunca para evaluar la calidad de un c\u00f3digo: la cantidad de puteadas por minuto de un lector externo . Las reglas de estilo pueden ser discutidas, acatadas o no, en diferentes contextos. Es importante entender que un programador enfrentado a un c\u00f3digo en Python no solo lee el c\u00f3digo sino que percibe su dise\u00f1o en el espacio, el uso de bloques y espacios, de indentaciones y may\u00fasculas. El dise\u00f1o gr\u00e1fico del c\u00f3digo es una parte importante de las herramientas de transmisi\u00f3n de la informaci\u00f3n que permite nuestro archivo. Creeamos estas ideas con tres citas en ingl\u00e9s, extra\u00eddas de este excelente art\u00edculo de Aleksandr Skobelev que expresan la convicci\u00f3n de que el c\u00f3digo en un lenguaje de programaci\u00f3n no se escribe solamente para ser ejecutado por una computadora sino principalmente para ser le\u00eddo y percibido por otras personas: Usually, when evaluating the text of a program in terms of its ease of perception , the term readability is used. Strictly speaking, they are not exactly the same thing, because, as will be shown later, the process of perceiving a program is more than just reading. -- Aleksandr Skobelev, Fundamentals of Optimal Code Style. First, we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology. Thus, programs must be written for people to read, and only incidentally for machines to execute. -- Harold Abelson and Gerald Jay Sussman, Structure and Interpretation of Computer Programs. Indeed, the ratio of time spent reading vs. writing is well over 10:1\u2026 Because this ratio is so high, we want the reading of code to be easy, even if it makes the writing harder. -- Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship.","title":"El c\u00f3digo no es solo le\u00eddo: el c\u00f3digo de percibe"},{"location":"07_Plt_Especificacion_y_Documentacion/06_Estilo/#zen-de-pyhton","text":"Ya que estamos hablando de los PEPs, queremos mencionar el PEP 20 (PEP viene de Python Enhancement Proposals), tambi\u00e9n conocido como el Zen de Python El Zen de Python es una colecci\u00f3n de principios de software que influyen en el dise\u00f1o del lenguaje. El texto, que copiamos a continuaci\u00f3n se puede encontrar en el sitio oficial de Python y tambi\u00e9n se incluye como sorpresa en el int\u00e9rprete de Python al escribir la instrucci\u00f3n import this .\u200b Zen de Pyhton Bello es mejor que feo. Expl\u00edcito es mejor que impl\u00edcito. Simple es mejor que complejo. Complejo es mejor que complicado. Plano es mejor que anidado. Espaciado es mejor que denso. La legibilidad es importante. Los casos especiales no son lo suficientemente especiales como para romper las reglas. Sin embargo la practicidad le gana a la pureza. Los errores nunca deber\u00edan pasar silenciosamente. A menos que se silencien expl\u00edcitamente. Frente a la ambig\u00fcedad, evit\u00e1 la tentaci\u00f3n de adivinar. Deber\u00eda haber una, y preferiblemente solo una, manera obvia de hacerlo. A pesar de que esa manera no sea obvia a menos que seas Holand\u00e9s. Ahora es mejor que nunca. A pesar de que nunca es muchas veces mejor que justo ahora. Si la implementaci\u00f3n es dif\u00edcil de explicar, es una mala idea. Si la implementaci\u00f3n es f\u00e1cil de explicar, puede que sea una buena idea. Los espacios de nombres son una gran idea, \u00a1hagamos m\u00e1s de ellos! Contenidos | Anterior (5 Contratos: Especificaci\u00f3n y Documentaci\u00f3n) | Pr\u00f3ximo (7 La biblioteca matplotlib)","title":"Zen de Pyhton"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/","text":"Contenidos | Anterior (6 Estilos de codeo) | Pr\u00f3ximo (8 Cierre de la clase) 7.7 La biblioteca matplotlib Matplotlib es probablemente la biblioteca de Python m\u00e1s usada para crear gr\u00e1ficos en 2D, tambi\u00e9n llamados plots. Provee una forma r\u00e1pida de graficar datos en varios formatos de alta calidad que pueden ser compartidos y/o publicados. En esta secci\u00f3n vamos a ver los usos m\u00e1s comunes de matplotlib. En este video encontrar\u00e1n una introducci\u00f3n breve a esta secci\u00f3n. pyplot pyplot proporciona una interfase a la biblioteca de matplotlib. Pyplot est\u00e1 dise\u00f1ada siguiendo el estilo de Matlab y la mayor\u00eda de los comandos para graficar en pyplot tienen an\u00e1logos en Matlab con argumentos similares. Explicaremos las instrucciones m\u00e1s importantes con ejemplos interactivos. from matplotlib import pyplot as plt Un plot simple Para empezar, vamos a plotear las funciones seno y coseno en el mismo gr\u00e1fico. Partiendo de la configuraci\u00f3n b\u00e1sica, vamos a ir cambiando el gr\u00e1fico paso por paso para que quede como queremos. Primero hay que obtener los datos para graficar: import numpy as np X = np.linspace(-np.pi, np.pi, 256) C, S = np.cos(X), np.sin(X) Ahora tenemos un array de numpy con 256 valores que van desde -\u03c0 a +\u03c0 (inclu\u00eddo). C tiene los valores del coseno (256 valores) y S tiene los valores del seno (256 valores). El ploteo est\u00e1ndar En Matplotlib los gr\u00e1ficos tienen una configuraci\u00f3n por omisi\u00f3n. Cambi\u00e1ndolas pod\u00e9s configurar muchas propiedades del gr\u00e1fico. Pod\u00e9s cambiar el tama\u00f1o de la figura, los DPI (viene de dots per inch, puntos por pulgada, y determina la resoluci\u00f3n), el tama\u00f1o, color y estilo del trazo, las propiedades de los ejes y el cuadriculado, los textos y sus propiedades, etc. import numpy as np import matplotlib.pyplot as plt X = np.linspace(-np.pi, np.pi, 256) C, S = np.cos(X), np.sin(X) plt.plot(X, C) plt.plot(X, S) plt.show() Un gr\u00e1fico b\u00e1sico En el siguiente script, hemos explicitado y comentado todas las propiedades de una figura que influyen en la apariencia de un gr\u00e1fico. Cada propiedad se configur\u00f3 a un valor t\u00edpico y cercano al valor por omisi\u00f3n. Pod\u00e9s modificarlos y jugar con ellos para ver sus efectos sobre el gr\u00e1fico. Sobre propiedades y estilos de las l\u00edneas hablaremos luego. import numpy as np import matplotlib.pyplot as plt # Crea una figura nueva, de 8x6 pulgadas, con 80 puntos por pulgada plt.figure(figsize=(8, 6), dpi=80) # Crea un nuevo subplot, en una grilla de 1x1 plt.subplot(1, 1, 1) X = np.linspace(-np.pi, np.pi, 256) C, S = np.cos(X), np.sin(X) # Plotea el coseno con una l\u00ednea azul cont\u00ednua de ancho 1 (en pixeles) plt.plot(X, C, color=\"blue\", linewidth=1.0, linestyle=\"-\") # Plotea el seno con una l\u00ednea verde cont\u00ednua de ancho 1 (en pixeles) plt.plot(X, S, color=\"green\", linewidth=1.0, linestyle=\"-\") # Rango del eje x plt.xlim(-4.0, 4.0) # Ponemos marcas (ticks) en el eje x plt.xticks(np.linspace(-4, 4, 9)) # Rango del eje y plt.ylim(-1.0, 1.0) # Ponemos marcas (ticks) en el eje y plt.yticks(np.linspace(-1, 1, 5)) # Podemos grabar el gr\u00e1fico (con 72 dpi) # plt.savefig(\"ejercicio_2.png)\", dpi=72) # Mostramos el resultado en pantalla plt.show() Los gr\u00e1ficos que genera matplotlib son muy flexibles, te dejamos un machete resumiendo las variaciones m\u00e1s usuales. A continuaci\u00f3n presentamos detalles t\u00e9cnicos de esta biblioteca tan \u00fatil. No hace falta que te los aprendas (igual te los vas a olvidar), ni que pruebes todas las combinaciones. Pod\u00e9s volver a esta p\u00e1gina o a la documentaci\u00f3n cuando lo necesites. Igu\u00e1l mir\u00e1 los ejercicios al final de esta secci\u00f3n, te pediremos que entregues el segundo. Detalles de un plot simple C\u00f3mo cambiar los colores y ancho de los trazos Ahora vamos a modificar el gr\u00e1fico para que quede un poco mejor. Primero, queremos trazar el coseno en azul y el seno en rojo, y ambos con una l\u00ednea algo m\u00e1s gruesa. Adem\u00e1s, vamos a cambiar un poco el tama\u00f1o de la figura para hacerla apaisada. Corr\u00e9 el siguiente c\u00f3digo y compar\u00e1 el resultado con la figura anterior. ... plt.figure(figsize=(10, 6), dpi=80) plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\") plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\") ... L\u00edmites de los ejes El rango de valores de los ejes es un poco angosto y necesitamos m\u00e1s espacio alrededor para ver claramente todos los puntos. ... plt.xlim(X.min() * 1.1, X.max() * 1.1) plt.ylim(C.min() * 1.1, C.max() * 1.1) ... Marcas en los ejes As\u00ed como est\u00e1n, las marcas sobre los ejes no son lo m\u00e1s \u00fatil. Ser\u00eda bueno destacar los valores interesantes para seno y coseno (+/-\u03c0,+/-\u03c0/2). Cambi\u00e9moslos para mostrar \u00fanicamente esos valores. ... plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi]) plt.yticks([-1, 0, +1]) ... Texto de las marcas en los ejes Las marcas en los ejes ahora est\u00e1n donde los queremos, pero el texto no es muy expl\u00edcito. Aunque podemos darnos cuenta que 3.142 es \u03c0 ser\u00eda mejor dejarlo expl\u00edcito. Al definir un valor para las marcas en los ejes podemos proveer un texto en la segunda lista de argumentos para usar como etiqueta. Fijate que vamos a usar LaTeX para hacer que los s\u00edmbolos tengan mejor pinta (otro de los geniales inventos de Donald Knuth, el mismo acu\u00f1\u00f3 el t\u00e9rmino an\u00e1lisis de algoritmos ). ... plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r'$-\\pi$', r'$-\\pi/2$', r'$0$', r'$+\\pi/2$', r'$+\\pi$']) plt.yticks([-1, 0, +1], [r'$-1$', r'$0$', r'$+1$']) ... Movamos el contorno El contorno es el conjunto de l\u00edneas que delimitan el \u00e1rea de graficaci\u00f3n y que unen todas las marcas en los ejes. Podemos ubicarlas en cualquier posici\u00f3n y, hasta ahora, han estado en el extremo de cada eje. Cambiemos eso, as\u00ed las ubicamos en el centro. Como hay cuatro (arriba, abajo, izquierda y derecha) vamos a esconder dos de ellas d\u00e1ndoles color none y vamos a mover la de abajo y la de la izquierda a la posici\u00f3n 0 del espacio de coordenadas. ... ax = plt.gca() # gca es 'get current axis' \u00f3 'tomar eje actual' ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data',0)) ax.yaxis.set_ticks_position('left') ax.spines['left'].set_position(('data',0)) ... Pong\u00e1mosle un t\u00edtulo Pong\u00e1mosle nombres a los trazos al gr\u00e1fico en la esquina superior izquierda. Para esto alcanza con agregar a la instrucci\u00f3n plot la palabra clave label y ese texto ser\u00e1 usado para el recuadro con los nombres. ... plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\", label=\"coseno\") plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\", label=\"seno\") plt.legend(loc='upper left') ... Algunos puntos interesantes Vamos a marcar algunos puntos interesantes usando el comando annotate . Elegimos el valor 2\u03c0/3 y queremos marcar tanto el seno como el coseno. Vamos a dibujar una marca en la curva y una l\u00ednea recta punteada. Adem\u00e1s, vamos a usar annotate para mostrar texto y una flecha para destacar el valor de las funciones. ... t = 2 * np.pi / 3 plt.plot([t, t], [0, np.cos(t)], color='blue', linewidth=2.5, linestyle=\"--\") plt.scatter([t, ], [np.cos(t), ], 50, color='blue') plt.annotate(r'$cos(\\frac{2\\pi}{3})=-\\frac{1}{2}$', xy=(t, np.cos(t)), xycoords='data', xytext=(-90, -50), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\")) plt.plot([t, t],[0, np.sin(t)], color='red', linewidth=2.5, linestyle=\"--\") plt.scatter([t, ],[np.sin(t), ], 50, color='red') plt.annotate(r'$sin(\\frac{2\\pi}{3})=\\frac{\\sqrt{3}}{2}$', xy=(t, np.sin(t)), xycoords='data', xytext=(+10, +30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\")) ... El diablo est\u00e1 en los detalles Not\u00e1 (vas a tener que mirar muy de cerca) que los ejes tapan los trazos de las funciones seno y coseno, y \u00e9stas tapan los valores escritos sobre los ejes. Si esto fuera una publicaci\u00f3n quedar\u00eda feo. Podemos hacer m\u00e1s grandes las marcas y los textos y ajustar sus propiedades de modo que tengan sean semi-transparentes. Esto nos permitir\u00e1 ver un poco mejor los datos y los textos. ... for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(16) label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.65)) ... Figuras, subplots, ejes y marcas (ticks) En matplotlib el t\u00e9rmino \"figura\" se refiere a toda la ventana que conforma la interfase al usuarie. Dentro de esta ventana o figura pueden existir diversos subplots. Hasta ac\u00e1 dibujamos gr\u00e1ficos y creamos sus ejes de forma impl\u00edcita. Esto es bueno para obtener ploteos r\u00e1pidos. Pero podemos controlar mejor la apariencia de la figura que generamos si definimos todo en forma expl\u00edcita. Podemos definir la figura, los subplots y los ejes. Mientras que subplot ubica a sus plots en posiciones espaciadas regularmente (una grilla) uno puede ubicar los ejes libremente en la figura. Ambas cosas pueden ser \u00fatiles, depende de qu\u00e9 est\u00e9s buscando. Aunque trabajamos con figuras y subplots sin llamarlos explicitamente, es bueno saber que al invocar plot() matplotlib llama a gca() (get current axes) para obtener acceso a los ejes, y gca() a su vez llama a gcf() (get current figure) para obtener acceso a la figura. Si no existe tal figura, llama a figure() para crearla o m\u00e1s estrictamente hablando, para crear un un \u00fanico subplot (el n\u00famero 1 en una grilla de 1x1). Aunque no pidamos expl\u00edcitamente crear una figura, \u00e9sta es creada cuando la necesitamos. Veamos un poco los detalles. Figuras Una \"figura\" es la ventana en la interfase al usuarie que lleva como t\u00edtulo \"Figura #\". Las figuras se enumeran comenzando en 1. Varios par\u00e1metros determinan la pinta que tiene una figura: Argumento Por Omisi\u00f3n Descripci\u00f3n num 1 n\u00famero de figura figsize figure.figsize tama\u00f1o de figura en pulgadas (ancho, alto) dpi figure.dpi resoluci\u00f3n en puntos por pulgada facecolor figure.facecolor color del fondo edgecolor figure.edgecolor color del borde rodeando el fondo frameon True dibujar un recuadro para la figura ? Si est\u00e1s trabajando en una interfaz gr\u00e1fica pod\u00e9s cerrar una figura clickeando en la X de la ventana. Tambien pod\u00e9s cerrar una ventana desde tu programa llamando al m\u00e9todo close(). Dependiendo del par\u00e1metro que le pases va a cerrar la figura con que est\u00e1s trabajando (sin argumentos), una figura espec\u00edfica (como argumento le pas\u00e1s el n\u00famero de figura) o todas las figuras (el argumento es \"all\"). plt.close(1) # Cierra la figura 1 A pesar de que en casi todo el mundo usamos el sistema m\u00e9trico, incre\u00edblemente el imperialismo llega al punto que no hay un modo directo de especificar distancias o tama\u00f1os en cent\u00edmetros en matplotlib. Podemos usar una funci\u00f3n auxiliar como \u00e9sta para convertir una distancia de cm a pulgadas : def cm2inch(value): return value/2.54 fig = plt.figure(figsize=(cm2inch(12.8), cm2inch(9.6))) Subplots Pod\u00e9s disponer tus plots en una grilla de intervalos regulares si us\u00e1s subplots . S\u00f3lo ten\u00e9s que especificar el n\u00famero de filas, el de columnas y finalmente el n\u00famero de subplot para activar el subplot correspondiente. Ejemplo: Ejemplo: Ejemplo: Ejes Pod\u00e9s usar los ejes para ubicar los plots en cualquier lugar de la figura. Si queremos poner un peque\u00f1o gr\u00e1fico como inserto en uno m\u00e1s grande, lo podemos hacer moviendo sus ejes. Ejemplo: Ejemplo: Ejercicios: Solo te pedimos que entregues el segundo ejercicio, los otros son optativos. Ejercicio 7.9: Subplots fuera de una grilla Modific\u00e1 el siguiente c\u00f3digo para reproducir el gr\u00e1fico que se muestra. Prest\u00e1 atenci\u00f3n a c\u00f3mo se numeran los subplots. import matplotlib.pyplot as plt fig = plt.figure() plt.subplot(2, 1, 1) # define la figura de arriba plt.plot([0,1,2],[0,1,0]) # dibuja la curva plt.xticks([]), plt.yticks([]) # saca las marcas plt.subplot(2, 2, 3) # define la primera de abajo, que ser\u00eda la tercera si fuera una grilla regular de 2x2 plt.plot([0,1],[0,1]) plt.xticks([]), plt.yticks([]) plt.subplot(2, 2, 4) # define la segunda de abajo, que ser\u00eda la cuarta figura si fuera una grilla regular de 2x2 plt.plot([0,1],[1,0]) plt.xticks([]), plt.yticks([]) plt.show() Ejercicio 7.10: Caminatas al azar Una caminata al azar o random walk es una formalizaci\u00f3n matem\u00e1tica de la trayectoria que resulta de hacer sucesivos pasos aleatorios. Por ejemplo, la ruta trazada por una mol\u00e9cula mientras viaja por un l\u00edquido o un gas, el camino que sigue un animal en su b\u00fasqueda de comida, el precio de una acci\u00f3n fluctuante y la situaci\u00f3n financiera de un jugador pueden tratarse, bajo ciertas hip\u00f3tesis, como una caminata aleatoria. El siguiente c\u00f3digo genera una caminata al azar de N pasos de largo y la grafica. import numpy as np import matplotlib.pyplot as plt def randomwalk(largo): pasos=np.random.randint (-1,2,largo) return pasos.cumsum() N = 100000 plt.plot(randomwalk(N)) plt.show() En este ejercicio te pedimos: Modific\u00e1 el c\u00f3digo anterior para ponerles nombres a los ejes (\"tiempo\" y distancia al origen\") y al gr\u00e1fico. Grafic\u00e1 12 trayectorias en la misma figura, con diferentes colores. Us\u00e1 la estructura de subplots sugerida en el Ejercicio 7.9 para graficar tres pubplots en una figura: Arriba, grande, 12 trayectorias aleatorias como en el inciso anterior Abajo a la izquierda la trayectoria que m\u00e1s se aleja del origen. Abajo a la derecha la trayectoria que menos se aleja del origen. Ojo, cuando decimos la que m\u00e1s o menos se aleja, nos referimos a en alg\u00fan momento , no necesariamente a la que termina m\u00e1s cerca o m\u00e1s lejos. Guard\u00e1 tu soluci\u00f3n del inciso 3 en el archivo random_walk.py . Deber\u00eda verse aproximadamente como este plot: Optativos: Los siguientes ejercicios profundizan en algunos estilos particulares y son optativos. Si quer\u00e9s ver las soluciones exactas a algunos de estos ejercicios y otros problemas m\u00e1s, pod\u00e9s consultar ac\u00e1 . Ejercicio 7.11: Gr\u00e1ficos de barras Modific\u00e1 el siguiente c\u00f3digo para generar un gr\u00e1fico similar al que se muestra: ten\u00e9s que agregar etiquetas para las barras rojas cuidando la alineaci\u00f3n del texto. n = 12 X = np.arange(n) Y1 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) Y2 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) plt.bar(X, +Y1, facecolor='#9999ff', edgecolor='white') plt.bar(X, -Y2, facecolor='#ff9999', edgecolor='white') for x, y in zip(X, Y1): plt.text(x + 0.4, y + 0.05, '%.2f' % y, ha='right', va='bottom') plt.ylim(-1.25, +1.25) Ejercicio 7.12: Coordenadas polares A partir de este c\u00f3digo, gener\u00e1 un gr\u00e1fico como el siguiente. plt.axes([0, 0, 1, 1]) N = 20 theta = np.arange(0., 2 * np.pi, 2 * np.pi / N) radii = 10 * np.random.rand(N) width = np.pi / 4 * np.random.rand(N) bars = plt.bar(theta, radii, width=width, bottom=0.0) for r, bar in zip(radii, bars): bar.set_facecolor(plt.cm.jet(r / 10.)) bar.set_alpha(0.5) Pista : s\u00f3lo necesit\u00e1s modifcar los ejes en la primera l\u00ednea. Fijate que hay un par\u00e1metro polar que tiene por omisi\u00f3n valor False . Ejercicio 7.13: Setear el color de un scatter plot Modific\u00e1 el c\u00f3digo que sigue para generar un gr\u00e1fico similar al que se muestra, prestando atenci\u00f3n a los l\u00edmites, el tama\u00f1o de las marcas, el color, y la transparencia de los trazos. n = 1024 X = np.random.normal(0,1,n) Y = np.random.normal(0,1,n) plt.scatter(X,Y) Pista : El color depende del \u00e1ngulo que forma el vector (X,Y) con los ejes. Hay diversas formas de calcularlo. Contenidos | Anterior (6 Estilos de codeo) | Pr\u00f3ximo (8 Cierre de la clase)","title":"07 Matplotlib"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#77-la-biblioteca-matplotlib","text":"Matplotlib es probablemente la biblioteca de Python m\u00e1s usada para crear gr\u00e1ficos en 2D, tambi\u00e9n llamados plots. Provee una forma r\u00e1pida de graficar datos en varios formatos de alta calidad que pueden ser compartidos y/o publicados. En esta secci\u00f3n vamos a ver los usos m\u00e1s comunes de matplotlib. En este video encontrar\u00e1n una introducci\u00f3n breve a esta secci\u00f3n.","title":"7.7 La biblioteca matplotlib"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#pyplot","text":"pyplot proporciona una interfase a la biblioteca de matplotlib. Pyplot est\u00e1 dise\u00f1ada siguiendo el estilo de Matlab y la mayor\u00eda de los comandos para graficar en pyplot tienen an\u00e1logos en Matlab con argumentos similares. Explicaremos las instrucciones m\u00e1s importantes con ejemplos interactivos. from matplotlib import pyplot as plt","title":"pyplot"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#un-plot-simple","text":"Para empezar, vamos a plotear las funciones seno y coseno en el mismo gr\u00e1fico. Partiendo de la configuraci\u00f3n b\u00e1sica, vamos a ir cambiando el gr\u00e1fico paso por paso para que quede como queremos. Primero hay que obtener los datos para graficar: import numpy as np X = np.linspace(-np.pi, np.pi, 256) C, S = np.cos(X), np.sin(X) Ahora tenemos un array de numpy con 256 valores que van desde -\u03c0 a +\u03c0 (inclu\u00eddo). C tiene los valores del coseno (256 valores) y S tiene los valores del seno (256 valores).","title":"Un plot simple"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#el-ploteo-estandar","text":"En Matplotlib los gr\u00e1ficos tienen una configuraci\u00f3n por omisi\u00f3n. Cambi\u00e1ndolas pod\u00e9s configurar muchas propiedades del gr\u00e1fico. Pod\u00e9s cambiar el tama\u00f1o de la figura, los DPI (viene de dots per inch, puntos por pulgada, y determina la resoluci\u00f3n), el tama\u00f1o, color y estilo del trazo, las propiedades de los ejes y el cuadriculado, los textos y sus propiedades, etc. import numpy as np import matplotlib.pyplot as plt X = np.linspace(-np.pi, np.pi, 256) C, S = np.cos(X), np.sin(X) plt.plot(X, C) plt.plot(X, S) plt.show()","title":"El ploteo est\u00e1ndar"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#un-grafico-basico","text":"En el siguiente script, hemos explicitado y comentado todas las propiedades de una figura que influyen en la apariencia de un gr\u00e1fico. Cada propiedad se configur\u00f3 a un valor t\u00edpico y cercano al valor por omisi\u00f3n. Pod\u00e9s modificarlos y jugar con ellos para ver sus efectos sobre el gr\u00e1fico. Sobre propiedades y estilos de las l\u00edneas hablaremos luego. import numpy as np import matplotlib.pyplot as plt # Crea una figura nueva, de 8x6 pulgadas, con 80 puntos por pulgada plt.figure(figsize=(8, 6), dpi=80) # Crea un nuevo subplot, en una grilla de 1x1 plt.subplot(1, 1, 1) X = np.linspace(-np.pi, np.pi, 256) C, S = np.cos(X), np.sin(X) # Plotea el coseno con una l\u00ednea azul cont\u00ednua de ancho 1 (en pixeles) plt.plot(X, C, color=\"blue\", linewidth=1.0, linestyle=\"-\") # Plotea el seno con una l\u00ednea verde cont\u00ednua de ancho 1 (en pixeles) plt.plot(X, S, color=\"green\", linewidth=1.0, linestyle=\"-\") # Rango del eje x plt.xlim(-4.0, 4.0) # Ponemos marcas (ticks) en el eje x plt.xticks(np.linspace(-4, 4, 9)) # Rango del eje y plt.ylim(-1.0, 1.0) # Ponemos marcas (ticks) en el eje y plt.yticks(np.linspace(-1, 1, 5)) # Podemos grabar el gr\u00e1fico (con 72 dpi) # plt.savefig(\"ejercicio_2.png)\", dpi=72) # Mostramos el resultado en pantalla plt.show() Los gr\u00e1ficos que genera matplotlib son muy flexibles, te dejamos un machete resumiendo las variaciones m\u00e1s usuales. A continuaci\u00f3n presentamos detalles t\u00e9cnicos de esta biblioteca tan \u00fatil. No hace falta que te los aprendas (igual te los vas a olvidar), ni que pruebes todas las combinaciones. Pod\u00e9s volver a esta p\u00e1gina o a la documentaci\u00f3n cuando lo necesites. Igu\u00e1l mir\u00e1 los ejercicios al final de esta secci\u00f3n, te pediremos que entregues el segundo.","title":"Un gr\u00e1fico b\u00e1sico"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#detalles-de-un-plot-simple","text":"","title":"Detalles de un plot simple"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#como-cambiar-los-colores-y-ancho-de-los-trazos","text":"Ahora vamos a modificar el gr\u00e1fico para que quede un poco mejor. Primero, queremos trazar el coseno en azul y el seno en rojo, y ambos con una l\u00ednea algo m\u00e1s gruesa. Adem\u00e1s, vamos a cambiar un poco el tama\u00f1o de la figura para hacerla apaisada. Corr\u00e9 el siguiente c\u00f3digo y compar\u00e1 el resultado con la figura anterior. ... plt.figure(figsize=(10, 6), dpi=80) plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\") plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\") ...","title":"C\u00f3mo cambiar los colores y ancho de los trazos"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#limites-de-los-ejes","text":"El rango de valores de los ejes es un poco angosto y necesitamos m\u00e1s espacio alrededor para ver claramente todos los puntos. ... plt.xlim(X.min() * 1.1, X.max() * 1.1) plt.ylim(C.min() * 1.1, C.max() * 1.1) ...","title":"L\u00edmites de los ejes"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#marcas-en-los-ejes","text":"As\u00ed como est\u00e1n, las marcas sobre los ejes no son lo m\u00e1s \u00fatil. Ser\u00eda bueno destacar los valores interesantes para seno y coseno (+/-\u03c0,+/-\u03c0/2). Cambi\u00e9moslos para mostrar \u00fanicamente esos valores. ... plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi]) plt.yticks([-1, 0, +1]) ...","title":"Marcas en los ejes"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#texto-de-las-marcas-en-los-ejes","text":"Las marcas en los ejes ahora est\u00e1n donde los queremos, pero el texto no es muy expl\u00edcito. Aunque podemos darnos cuenta que 3.142 es \u03c0 ser\u00eda mejor dejarlo expl\u00edcito. Al definir un valor para las marcas en los ejes podemos proveer un texto en la segunda lista de argumentos para usar como etiqueta. Fijate que vamos a usar LaTeX para hacer que los s\u00edmbolos tengan mejor pinta (otro de los geniales inventos de Donald Knuth, el mismo acu\u00f1\u00f3 el t\u00e9rmino an\u00e1lisis de algoritmos ). ... plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r'$-\\pi$', r'$-\\pi/2$', r'$0$', r'$+\\pi/2$', r'$+\\pi$']) plt.yticks([-1, 0, +1], [r'$-1$', r'$0$', r'$+1$']) ...","title":"Texto de las marcas en los ejes"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#movamos-el-contorno","text":"El contorno es el conjunto de l\u00edneas que delimitan el \u00e1rea de graficaci\u00f3n y que unen todas las marcas en los ejes. Podemos ubicarlas en cualquier posici\u00f3n y, hasta ahora, han estado en el extremo de cada eje. Cambiemos eso, as\u00ed las ubicamos en el centro. Como hay cuatro (arriba, abajo, izquierda y derecha) vamos a esconder dos de ellas d\u00e1ndoles color none y vamos a mover la de abajo y la de la izquierda a la posici\u00f3n 0 del espacio de coordenadas. ... ax = plt.gca() # gca es 'get current axis' \u00f3 'tomar eje actual' ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') ax.xaxis.set_ticks_position('bottom') ax.spines['bottom'].set_position(('data',0)) ax.yaxis.set_ticks_position('left') ax.spines['left'].set_position(('data',0)) ...","title":"Movamos el contorno"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#pongamosle-un-titulo","text":"Pong\u00e1mosle nombres a los trazos al gr\u00e1fico en la esquina superior izquierda. Para esto alcanza con agregar a la instrucci\u00f3n plot la palabra clave label y ese texto ser\u00e1 usado para el recuadro con los nombres. ... plt.plot(X, C, color=\"blue\", linewidth=2.5, linestyle=\"-\", label=\"coseno\") plt.plot(X, S, color=\"red\", linewidth=2.5, linestyle=\"-\", label=\"seno\") plt.legend(loc='upper left') ...","title":"Pong\u00e1mosle un t\u00edtulo"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#algunos-puntos-interesantes","text":"Vamos a marcar algunos puntos interesantes usando el comando annotate . Elegimos el valor 2\u03c0/3 y queremos marcar tanto el seno como el coseno. Vamos a dibujar una marca en la curva y una l\u00ednea recta punteada. Adem\u00e1s, vamos a usar annotate para mostrar texto y una flecha para destacar el valor de las funciones. ... t = 2 * np.pi / 3 plt.plot([t, t], [0, np.cos(t)], color='blue', linewidth=2.5, linestyle=\"--\") plt.scatter([t, ], [np.cos(t), ], 50, color='blue') plt.annotate(r'$cos(\\frac{2\\pi}{3})=-\\frac{1}{2}$', xy=(t, np.cos(t)), xycoords='data', xytext=(-90, -50), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\")) plt.plot([t, t],[0, np.sin(t)], color='red', linewidth=2.5, linestyle=\"--\") plt.scatter([t, ],[np.sin(t), ], 50, color='red') plt.annotate(r'$sin(\\frac{2\\pi}{3})=\\frac{\\sqrt{3}}{2}$', xy=(t, np.sin(t)), xycoords='data', xytext=(+10, +30), textcoords='offset points', fontsize=16, arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\")) ...","title":"Algunos puntos interesantes"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#el-diablo-esta-en-los-detalles","text":"Not\u00e1 (vas a tener que mirar muy de cerca) que los ejes tapan los trazos de las funciones seno y coseno, y \u00e9stas tapan los valores escritos sobre los ejes. Si esto fuera una publicaci\u00f3n quedar\u00eda feo. Podemos hacer m\u00e1s grandes las marcas y los textos y ajustar sus propiedades de modo que tengan sean semi-transparentes. Esto nos permitir\u00e1 ver un poco mejor los datos y los textos. ... for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(16) label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.65)) ...","title":"El diablo est\u00e1 en los detalles"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#figuras-subplots-ejes-y-marcas-ticks","text":"En matplotlib el t\u00e9rmino \"figura\" se refiere a toda la ventana que conforma la interfase al usuarie. Dentro de esta ventana o figura pueden existir diversos subplots. Hasta ac\u00e1 dibujamos gr\u00e1ficos y creamos sus ejes de forma impl\u00edcita. Esto es bueno para obtener ploteos r\u00e1pidos. Pero podemos controlar mejor la apariencia de la figura que generamos si definimos todo en forma expl\u00edcita. Podemos definir la figura, los subplots y los ejes. Mientras que subplot ubica a sus plots en posiciones espaciadas regularmente (una grilla) uno puede ubicar los ejes libremente en la figura. Ambas cosas pueden ser \u00fatiles, depende de qu\u00e9 est\u00e9s buscando. Aunque trabajamos con figuras y subplots sin llamarlos explicitamente, es bueno saber que al invocar plot() matplotlib llama a gca() (get current axes) para obtener acceso a los ejes, y gca() a su vez llama a gcf() (get current figure) para obtener acceso a la figura. Si no existe tal figura, llama a figure() para crearla o m\u00e1s estrictamente hablando, para crear un un \u00fanico subplot (el n\u00famero 1 en una grilla de 1x1). Aunque no pidamos expl\u00edcitamente crear una figura, \u00e9sta es creada cuando la necesitamos. Veamos un poco los detalles.","title":"Figuras, subplots, ejes y marcas (ticks)"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#figuras","text":"Una \"figura\" es la ventana en la interfase al usuarie que lleva como t\u00edtulo \"Figura #\". Las figuras se enumeran comenzando en 1. Varios par\u00e1metros determinan la pinta que tiene una figura: Argumento Por Omisi\u00f3n Descripci\u00f3n num 1 n\u00famero de figura figsize figure.figsize tama\u00f1o de figura en pulgadas (ancho, alto) dpi figure.dpi resoluci\u00f3n en puntos por pulgada facecolor figure.facecolor color del fondo edgecolor figure.edgecolor color del borde rodeando el fondo frameon True dibujar un recuadro para la figura ? Si est\u00e1s trabajando en una interfaz gr\u00e1fica pod\u00e9s cerrar una figura clickeando en la X de la ventana. Tambien pod\u00e9s cerrar una ventana desde tu programa llamando al m\u00e9todo close(). Dependiendo del par\u00e1metro que le pases va a cerrar la figura con que est\u00e1s trabajando (sin argumentos), una figura espec\u00edfica (como argumento le pas\u00e1s el n\u00famero de figura) o todas las figuras (el argumento es \"all\"). plt.close(1) # Cierra la figura 1 A pesar de que en casi todo el mundo usamos el sistema m\u00e9trico, incre\u00edblemente el imperialismo llega al punto que no hay un modo directo de especificar distancias o tama\u00f1os en cent\u00edmetros en matplotlib. Podemos usar una funci\u00f3n auxiliar como \u00e9sta para convertir una distancia de cm a pulgadas : def cm2inch(value): return value/2.54 fig = plt.figure(figsize=(cm2inch(12.8), cm2inch(9.6)))","title":"Figuras"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#subplots","text":"Pod\u00e9s disponer tus plots en una grilla de intervalos regulares si us\u00e1s subplots . S\u00f3lo ten\u00e9s que especificar el n\u00famero de filas, el de columnas y finalmente el n\u00famero de subplot para activar el subplot correspondiente. Ejemplo: Ejemplo: Ejemplo:","title":"Subplots"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#ejes","text":"Pod\u00e9s usar los ejes para ubicar los plots en cualquier lugar de la figura. Si queremos poner un peque\u00f1o gr\u00e1fico como inserto en uno m\u00e1s grande, lo podemos hacer moviendo sus ejes. Ejemplo: Ejemplo:","title":"Ejes"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#ejercicios","text":"Solo te pedimos que entregues el segundo ejercicio, los otros son optativos.","title":"Ejercicios:"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#ejercicio-79-subplots-fuera-de-una-grilla","text":"Modific\u00e1 el siguiente c\u00f3digo para reproducir el gr\u00e1fico que se muestra. Prest\u00e1 atenci\u00f3n a c\u00f3mo se numeran los subplots. import matplotlib.pyplot as plt fig = plt.figure() plt.subplot(2, 1, 1) # define la figura de arriba plt.plot([0,1,2],[0,1,0]) # dibuja la curva plt.xticks([]), plt.yticks([]) # saca las marcas plt.subplot(2, 2, 3) # define la primera de abajo, que ser\u00eda la tercera si fuera una grilla regular de 2x2 plt.plot([0,1],[0,1]) plt.xticks([]), plt.yticks([]) plt.subplot(2, 2, 4) # define la segunda de abajo, que ser\u00eda la cuarta figura si fuera una grilla regular de 2x2 plt.plot([0,1],[1,0]) plt.xticks([]), plt.yticks([]) plt.show()","title":"Ejercicio 7.9: Subplots fuera de una grilla"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#ejercicio-710-caminatas-al-azar","text":"Una caminata al azar o random walk es una formalizaci\u00f3n matem\u00e1tica de la trayectoria que resulta de hacer sucesivos pasos aleatorios. Por ejemplo, la ruta trazada por una mol\u00e9cula mientras viaja por un l\u00edquido o un gas, el camino que sigue un animal en su b\u00fasqueda de comida, el precio de una acci\u00f3n fluctuante y la situaci\u00f3n financiera de un jugador pueden tratarse, bajo ciertas hip\u00f3tesis, como una caminata aleatoria. El siguiente c\u00f3digo genera una caminata al azar de N pasos de largo y la grafica. import numpy as np import matplotlib.pyplot as plt def randomwalk(largo): pasos=np.random.randint (-1,2,largo) return pasos.cumsum() N = 100000 plt.plot(randomwalk(N)) plt.show() En este ejercicio te pedimos: Modific\u00e1 el c\u00f3digo anterior para ponerles nombres a los ejes (\"tiempo\" y distancia al origen\") y al gr\u00e1fico. Grafic\u00e1 12 trayectorias en la misma figura, con diferentes colores. Us\u00e1 la estructura de subplots sugerida en el Ejercicio 7.9 para graficar tres pubplots en una figura: Arriba, grande, 12 trayectorias aleatorias como en el inciso anterior Abajo a la izquierda la trayectoria que m\u00e1s se aleja del origen. Abajo a la derecha la trayectoria que menos se aleja del origen. Ojo, cuando decimos la que m\u00e1s o menos se aleja, nos referimos a en alg\u00fan momento , no necesariamente a la que termina m\u00e1s cerca o m\u00e1s lejos. Guard\u00e1 tu soluci\u00f3n del inciso 3 en el archivo random_walk.py . Deber\u00eda verse aproximadamente como este plot:","title":"Ejercicio 7.10: Caminatas al azar"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#optativos","text":"Los siguientes ejercicios profundizan en algunos estilos particulares y son optativos. Si quer\u00e9s ver las soluciones exactas a algunos de estos ejercicios y otros problemas m\u00e1s, pod\u00e9s consultar ac\u00e1 .","title":"Optativos:"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#ejercicio-711-graficos-de-barras","text":"Modific\u00e1 el siguiente c\u00f3digo para generar un gr\u00e1fico similar al que se muestra: ten\u00e9s que agregar etiquetas para las barras rojas cuidando la alineaci\u00f3n del texto. n = 12 X = np.arange(n) Y1 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) Y2 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n) plt.bar(X, +Y1, facecolor='#9999ff', edgecolor='white') plt.bar(X, -Y2, facecolor='#ff9999', edgecolor='white') for x, y in zip(X, Y1): plt.text(x + 0.4, y + 0.05, '%.2f' % y, ha='right', va='bottom') plt.ylim(-1.25, +1.25)","title":"Ejercicio 7.11: Gr\u00e1ficos de barras"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#ejercicio-712-coordenadas-polares","text":"A partir de este c\u00f3digo, gener\u00e1 un gr\u00e1fico como el siguiente. plt.axes([0, 0, 1, 1]) N = 20 theta = np.arange(0., 2 * np.pi, 2 * np.pi / N) radii = 10 * np.random.rand(N) width = np.pi / 4 * np.random.rand(N) bars = plt.bar(theta, radii, width=width, bottom=0.0) for r, bar in zip(radii, bars): bar.set_facecolor(plt.cm.jet(r / 10.)) bar.set_alpha(0.5) Pista : s\u00f3lo necesit\u00e1s modifcar los ejes en la primera l\u00ednea. Fijate que hay un par\u00e1metro polar que tiene por omisi\u00f3n valor False .","title":"Ejercicio 7.12: Coordenadas polares"},{"location":"07_Plt_Especificacion_y_Documentacion/07_Matplotlib/#ejercicio-713-setear-el-color-de-un-scatter-plot","text":"Modific\u00e1 el c\u00f3digo que sigue para generar un gr\u00e1fico similar al que se muestra, prestando atenci\u00f3n a los l\u00edmites, el tama\u00f1o de las marcas, el color, y la transparencia de los trazos. n = 1024 X = np.random.normal(0,1,n) Y = np.random.normal(0,1,n) plt.scatter(X,Y) Pista : El color depende del \u00e1ngulo que forma el vector (X,Y) con los ejes. Hay diversas formas de calcularlo. Contenidos | Anterior (6 Estilos de codeo) | Pr\u00f3ximo (8 Cierre de la clase)","title":"Ejercicio 7.13: Setear el color de un scatter plot"},{"location":"07_Plt_Especificacion_y_Documentacion/08_Cierre/","text":"Contenidos | Anterior (7 La biblioteca matplotlib) 7.8 Cierre de la clase En esta clase vimos c\u00f3mo se hace una administraci\u00f3n eficiente de errores, c\u00f3mo atrapar excepciones, c\u00f3mo lanzarlas, y cu\u00e1ndo conviene hacer o no hacer estas cosas. Vimos que un archivo .py correctamente escrito puede usarse como un m\u00f3dulo, como un programa en s\u00ed mismo, o como ambas cosas dependiendo del caso, y mostramos que aunque uno est\u00e9 escribiendo una peque\u00f1a funci\u00f3n para solucionar un peque\u00f1o problema, es bueno pensar en grande y no imponer restricciones innecesarias. Aprendimos a documentar y comentar de manera \u00fatil, y mostramos el paradigma de contratos. Adem\u00e1s vimos algo sobre estilo c\u00f3digo est\u00e1ndard. Tambi\u00e9n estudiamos diversos estilos de gr\u00e1ficos, como obtener un vistazo r\u00e1pido de los datos y como ajustar cada elemento para obtener un gr\u00e1fico que pueda ser publicado. Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: El archivo fileparse.py del Ejercicio 7.4 . El archivo informe.py del Ejercicio 7.5 . El archivo documentacion.py del Ejercicio 7.8 . El archivo random_walk.py del Ejercicio 7.10 . Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y podr\u00e1s participar de la revisi\u00f3n de pares. \u00a1Gracias! Contenidos | Anterior (7 La biblioteca matplotlib)","title":"08 Cierre"},{"location":"07_Plt_Especificacion_y_Documentacion/08_Cierre/#78-cierre-de-la-clase","text":"En esta clase vimos c\u00f3mo se hace una administraci\u00f3n eficiente de errores, c\u00f3mo atrapar excepciones, c\u00f3mo lanzarlas, y cu\u00e1ndo conviene hacer o no hacer estas cosas. Vimos que un archivo .py correctamente escrito puede usarse como un m\u00f3dulo, como un programa en s\u00ed mismo, o como ambas cosas dependiendo del caso, y mostramos que aunque uno est\u00e9 escribiendo una peque\u00f1a funci\u00f3n para solucionar un peque\u00f1o problema, es bueno pensar en grande y no imponer restricciones innecesarias. Aprendimos a documentar y comentar de manera \u00fatil, y mostramos el paradigma de contratos. Adem\u00e1s vimos algo sobre estilo c\u00f3digo est\u00e1ndard. Tambi\u00e9n estudiamos diversos estilos de gr\u00e1ficos, como obtener un vistazo r\u00e1pido de los datos y como ajustar cada elemento para obtener un gr\u00e1fico que pueda ser publicado. Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: El archivo fileparse.py del Ejercicio 7.4 . El archivo informe.py del Ejercicio 7.5 . El archivo documentacion.py del Ejercicio 7.8 . El archivo random_walk.py del Ejercicio 7.10 . Que completes este formulario usando como identificaci\u00f3n tu direcci\u00f3n de mail. Al terminar vas a obtener un link para enviarnos tus ejercicios y podr\u00e1s participar de la revisi\u00f3n de pares. \u00a1Gracias! Contenidos | Anterior (7 La biblioteca matplotlib)","title":"7.8 Cierre de la clase"},{"location":"08_Fechas_Carpetas_y_Pandas/00_Resumen/","text":"Contenidos | Anterior (7 Dise\u00f1o, especificaci\u00f3n, documentaci\u00f3n y estilo.) | Pr\u00f3ximo (9 Clases y objetos) 8. Fechas, Carpetas y Pandas En esta clase introducimos el m\u00f3dulo datetime para manejar datos relacionados con el tiempo (Secci\u00f3n 2) y un par de funciones del m\u00f3dulo os para leer directorios, procesar archivos y realizar algunas tareas relacionadas con el sistema operativo (Secci\u00f3n 3). Luego te proponemos integrar esto para hacer un script que corra desde l\u00ednea de comandos y te permita ordenar los archivos de cierto tipo (Secci\u00f3n 4). En la segunda mitad introducimos el m\u00f3dulo Pandas y el tipo DataFrame as\u00ed como algunos de sus m\u00e9todos elementales. Usamos pandas para analizar dos datasets de Arbolado Porte\u00f1o graficando algunos de sus datos. En esta parte ten\u00e9s que comparar caracter\u00edsiticas de \u00e1rboles que crecen en los parques con otros que crecen en las veredas (Secci\u00f3n 5 y ejercicio de revisi\u00f3n por pares). En la \u00faltima parte te proponemos an\u00e1lizar ondas de mareas en el R\u00edo de la Plata como excusa para introducir el procesamiento de series temporales. Nos metemos un poco en temas espec\u00edficos con una \u00faltima parte optativa que incluye un breve an\u00e1lsis de la transformada de Fourier para medir el tiempo que tarda esta onda de marea en trasladarse de un puerto a otro. 8.1 Introducci\u00f3n 8.2 Manejo de fechas y horas 8.3 Manejo de archivos y carpetas 8.4 Ordenar archivos en Python 8.5 Introducci\u00f3n a Pandas 8.6 Series temporales 8.7 Cierre de la clase Contenidos | Anterior (7 Dise\u00f1o, especificaci\u00f3n, documentaci\u00f3n y estilo.) | Pr\u00f3ximo (9 Clases y objetos)","title":"00 Resumen"},{"location":"08_Fechas_Carpetas_y_Pandas/00_Resumen/#8-fechas-carpetas-y-pandas","text":"En esta clase introducimos el m\u00f3dulo datetime para manejar datos relacionados con el tiempo (Secci\u00f3n 2) y un par de funciones del m\u00f3dulo os para leer directorios, procesar archivos y realizar algunas tareas relacionadas con el sistema operativo (Secci\u00f3n 3). Luego te proponemos integrar esto para hacer un script que corra desde l\u00ednea de comandos y te permita ordenar los archivos de cierto tipo (Secci\u00f3n 4). En la segunda mitad introducimos el m\u00f3dulo Pandas y el tipo DataFrame as\u00ed como algunos de sus m\u00e9todos elementales. Usamos pandas para analizar dos datasets de Arbolado Porte\u00f1o graficando algunos de sus datos. En esta parte ten\u00e9s que comparar caracter\u00edsiticas de \u00e1rboles que crecen en los parques con otros que crecen en las veredas (Secci\u00f3n 5 y ejercicio de revisi\u00f3n por pares). En la \u00faltima parte te proponemos an\u00e1lizar ondas de mareas en el R\u00edo de la Plata como excusa para introducir el procesamiento de series temporales. Nos metemos un poco en temas espec\u00edficos con una \u00faltima parte optativa que incluye un breve an\u00e1lsis de la transformada de Fourier para medir el tiempo que tarda esta onda de marea en trasladarse de un puerto a otro. 8.1 Introducci\u00f3n 8.2 Manejo de fechas y horas 8.3 Manejo de archivos y carpetas 8.4 Ordenar archivos en Python 8.5 Introducci\u00f3n a Pandas 8.6 Series temporales 8.7 Cierre de la clase Contenidos | Anterior (7 Dise\u00f1o, especificaci\u00f3n, documentaci\u00f3n y estilo.) | Pr\u00f3ximo (9 Clases y objetos)","title":"8. Fechas, Carpetas y Pandas"},{"location":"08_Fechas_Carpetas_y_Pandas/01_Intro/","text":"Contenidos | Pr\u00f3ximo (2 Manejo de fechas y horas) 8.1 Introducci\u00f3n En este video damos una breve introducci\u00f3n a los temas de la clase. Luego, en cada secci\u00f3n vas a encontrar tambi\u00e9n un video corto con mayor nivel de detalle sobre los temas de la secci\u00f3n. En estos videos usamos el c\u00f3digo de este archivo . \u00a1Que disfrutes la clase! Contenidos | Pr\u00f3ximo (2 Manejo de fechas y horas)","title":"01 Intro"},{"location":"08_Fechas_Carpetas_y_Pandas/01_Intro/#81-introduccion","text":"En este video damos una breve introducci\u00f3n a los temas de la clase. Luego, en cada secci\u00f3n vas a encontrar tambi\u00e9n un video corto con mayor nivel de detalle sobre los temas de la secci\u00f3n. En estos videos usamos el c\u00f3digo de este archivo . \u00a1Que disfrutes la clase! Contenidos | Pr\u00f3ximo (2 Manejo de fechas y horas)","title":"8.1 Introducci\u00f3n"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/","text":"Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Manejo de archivos y carpetas) 8.2 Manejo de fechas y horas Esta secci\u00f3n tiene un breve video introductorio sobre el m\u00f3dulo datetime . El m\u00f3dulo datetime A continuaci\u00f3n introducimos el m\u00f3dulo datetime que permite trabajar con fechas y horas. Este m\u00f3dulo define un nuevo tipo de objeto: datetime (s\u00ed, con el mismo nombre del m\u00f3dulo), que permite representar un instante temporal (fecha y hora). Tambi\u00e9n define objetos de tipo date para representar s\u00f3lo una fecha y de tipo time para guardar y trabajar con horarios. Finalmente, en esta breve introducci\u00f3n al m\u00f3dulo datetime mencionamos el tipo timedelta que se usa para representar diferencias entre instantes de tiempos, es decir, duraciones y trabajar con ellas. Ejemplo: Obtener fecha y hora actuales >>> import datetime >>> fecha_hora = datetime.datetime.now() >>> print(fecha_hora) 2020-09-24 10:03:18.636670 Lo que hicimos fue importar el m\u00f3dulo datetime y usar el m\u00e9todo now() de la clase datetime del m\u00f3dulo (con el mismo nombre) para crear el objeto fecha_hora que va a contener la fecha y la hora actuales. Ejemplo: Obtener fecha actual An\u00e1logamente, podemos obtener solo la fecha: >>> fecha = datetime.date.today() >>> print(fecha) 2020-09-24 Ac\u00e1 usamos el m\u00e9todo today() de la clase date para obtener la fecha actual. \u00bfQu\u00e9 hay dentro del m\u00f3dulo datetime? En Python podemos usar la funci\u00f3n dir() para obtener una lista de todos los atributos de un m\u00f3dulo. >>> print(dir(datetime)) ['MAXYEAR', 'MINYEAR', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_divide_and_round', 'date', 'datetime', 'datetime_CAPI', 'time', 'timedelta', 'timezone', 'tzinfo'] Nos vamos a concentrar en lo m\u00e1s usado de datetime : date time datetime timedelta La clase datetime.date Pod\u00e9s generar objetos de tipo fecha con la clase date . Un objeto de esta clase representa una fecha (a\u00f1o, mes, d\u00eda). Ejemplo: Un objeto para representar una fecha >>> d = datetime.date(2019, 4, 13) >>> print(d) 2019-04-13 El comando date() de este ejemplo construye un objeto de tipo date . Este constructor toma tres argumentos: a\u00f1o, mes y d\u00eda. La variable d es un objeto de tipo date (es decir, representa una fecha). Tambi\u00e9n podr\u00edamos importar directamente la clase date del m\u00f3dulo datetime : >>> from datetime import date >>> >>> d = date(2019, 4, 13) >>> print(d) 2019-04-13 Ejemplo: Obtener la fecha a partir de un timestamp En los sistemas operativos derivados de Unix (Mac OS X, Linux, etc.) se toma como medida de tiempo el n\u00famero de segundos transcurridos desde el primero de enero de 1970 a las 0 horas UTC hasta el momento a representar. Se lo conoce como Unix timestamp. Pod\u00e9s convertir un timestamp a fecha usando el m\u00e9todo fromtimestamp() . >>> from datetime import date >>> >>> timestamp = date.fromtimestamp(1326244364) >>> print('Fecha =', timestamp) Fecha = 2012-01-10 Esto es importante porque las fechas de modificaci\u00f3n de los archivos usan timestamps por ejemplo. Ejemplo: Obtener el a\u00f1o, el mes y el d\u00eda por separado. As\u00ed pod\u00e9s obtener el a\u00f1o, el mes, el d\u00eda y el d\u00eda de la semana: from datetime import date hoy = date.today() print('A\u00f1o actual:', hoy.year) print('Mes actual:', hoy.month) print('D\u00eda actual:', hoy.day) print('D\u00eda de la semana:', hoy.weekday()) # va de 0 a 6 empezando en lunes La clase datetime.time Un objeto de la clase time representa la hora local (de como este configurada tu computadora). No nos vamos a meter en esta clase con los husos horarios (conocido tambi\u00e9n como timezones), pero si vas a usar datos provistos por otres, es importante que sepas si est\u00e1 expresado en tu hora local, en la hora local de otro lugar o en UTC . Ejemplo: Representar la hora con un objeto time La clase time se usa para representar horarios. A continuaci\u00f3n damos algunos ejemplos de constructores de esta clase (un constructor es una forma de construir un objeto de una clase dada, una forma de inicializarlo, digamos). >>> from datetime import time >>> >>> a = time() # time(hour = 0, minute = 0, second = 0) >>> print('a =', a) a = 00:00:00 >>> b = time(11, 34, 56) >>> print('b =', b) b = 11:34:56 >>> c = time(hour = 11, minute = 34, second = 56) >>> print('c =', c) c = 11:34:56 >>> d = time(11, 34, 56, 234566) # time(hour, minute, second, microsecond) >>> print('d =', d) d = 11:34:56.234566 Ejemplo: Obtener horas, minutos, segundos y micro-segundos Una vez que creaste un objeto time , pod\u00e9s extraer sus atributos as\u00ed: from datetime import time a = time(11, 34, 56) print('hour =', a.hour) print('minute =', a.minute) print('second =', a.second) print('microsecond =', a.microsecond) Como no le pasaste ning\u00fan valor para el argumento microsecond , \u00e9ste va a tomar el valor predeterminado, que es 0 . La clase datetime.datetime Como ya mencionamos, el m\u00f3dulo datetime tiene una clase con su mismo nombre que permite almacenar informaci\u00f3n de fecha y hora en un solo objeto. Ejemplo: Objeto datetime >>> from datetime import datetime >>> # datetime(year, month, day) >>> a = datetime(2020, 4, 21) >>> print(a) 2020-04-21 00:00:00 >>> # datetime(year, month, day, hour, minute, second, microsecond) >>> b = datetime(2021, 4, 21, 6, 53, 31, 342260) >>> print(b) 2021-04-21 06:53:31.342260 Los primeros tres argumentos, year , month y day del constructor datetime() son obligatorios. Los otros tienen a 0 como valor por omisi\u00f3n. Ejemplo: Obtener a\u00f1o, mes, d\u00eda, hora, minutos, timestamp de un datetime El siguiente c\u00f3digo genera un objeto datetime con valores pasados por par\u00e1metro y luego imprime la informaci\u00f3n. En particular, muestra c\u00f3mo convertir una fecha a timestamp. En general los timestamps son enteros y no tienen en cuenta las d\u00e9cimas de segundos. from datetime import datetime a = datetime(2021, 4, 21, 6, 53, 31, 342260) print('a\u00f1o =', a.year) print('mes =', a.month) print('d\u00eda =', a.day) print('hora =', a.hour) print('minuto =', a.minute) print('timestamp =', a.timestamp()) La clase datetime.timedelta Un objeto timedelta representa una duraci\u00f3n, es decir, la diferencia entre dos instantes de tiempo. Ejemplo: Diferencia entre fechas y horarios >>> from datetime import datetime, date >>> t1 = date(year = 2021, month = 4, day = 21) >>> t2 = date(year = 2020, month = 8, day = 23) >>> t3 = t1 - t2 >>> print(t3) 241 days, 0:00:00 >>> t4 = datetime(year = 2020, month = 7, day = 12, hour = 7, minute = 9, second = 33) >>> t5 = datetime(year = 2021, month = 6, day = 10, hour = 5, minute = 55, second = 13) >>> t6 = t4 - t5 >>> print(t6) -333 days, 1:14:20 >>> print('tipo de t3 =', type(t3)) tipo de t3 = <class 'datetime.timedelta'> >>> print('tipo de t6 =', type(t6)) tipo de t6 = <class 'datetime.timedelta'> Observ\u00e1 que t3 y t6 son de tipo <class 'datetime.timedelta'> . Ejemplo: Diferencia entre objetos timedelta >>> from datetime import timedelta >>> t1 = timedelta(weeks = 1, days = 2, hours = 1, seconds = 33) >>> t2 = timedelta(days = 6, hours = 11, minutes = 4, seconds = 54) >>> t3 = t1 - t2 >>> print('t3 =', t3) 2 days, 13:55:39 t3 tambi\u00e9n es de tipo <class 'datetime.timedelta'> . Ejemplo: Imprimir objetos timedelta negativos >>> from datetime import timedelta >>> t1 = timedelta(seconds = 21) >>> t2 = timedelta(seconds = 55) >>> t3 = t1 - t2 >>> print(t3) -1 day, 23:59:26 >>> print(abs(t3)) 0:00:34 Ejemplo: Duraci\u00f3n en segundos Pod\u00e9s obtener el tiempo medido en segundos usando el m\u00e9todo total_seconds() . >>> from datetime import timedelta >>> t = timedelta(days = 1, hours = 2, seconds = 30, microseconds = 100000) >>> print('segundos totales =', t.total_seconds()) segundos totales = 93630.1 Tambi\u00e9n pod\u00e9s sumar fechas y horarios usando el operador + . Tambi\u00e9n pod\u00e9s multiplicar o dividir un objeto timedelta por n\u00fameros enteros o floats. Formato para fechas y horas Hay diversas formas de representar el tiempo, que var\u00edan seg\u00fan el lugar, la organizaci\u00f3n, etc. Por ejemplo, en Argentina solemos usar dd/mm/yyyy , mientras que en las culturas anglosajonas es m\u00e1s com\u00fan usar mm/dd/yyyy . En Python tenemos los m\u00e9todos strftime() y strptime() para manejar esto. Python strftime() - convertir un objeto datetime a string El m\u00e9todo strftime() est\u00e1 definido en las clases date , datetime y time . Este m\u00e9todo crea una cadena con formato a partir estos objetos. Ejemplo: Formato de fecha usando strftime() >>> from datetime import datetime >>> now = datetime.now() >>> t = now.strftime('%H:%M:%S') >>> print('hora:', t) hora: 14:40:06 >>> s1 = now.strftime('%m/%d/%Y, %H:%M:%S') >>> # en formato mm/dd/YY H:M:S >>> print('s1:', s1) s1: 09/24/2020, 14:40:06 >>> s2 = now.strftime('%d/%m/%Y, %H:%M:%S') >>> # en formato dd/mm/YY H:M:S >>> print('s2:', s2) s2: 24/09/2020, 14:40:06 Ac\u00e1, %Y , %m , %d , %H etc. son c\u00f3digos de formato. El m\u00e9todo strftime() toma uno o m\u00e1s c\u00f3digos de formato y devuelve la cadena con formato basado en esos c\u00f3digos. En el programa de arriba, t , s1 y s2 son cadenas. Y los c\u00f3digos de formato son: %Y - a\u00f1o [0001,..., 2018, 2019,..., 9999] %m - mes [01, 02, ..., 11, 12] %d - d\u00eda [01, 02, ..., 30, 31] %H - hora [00, 01, ..., 22, 23 %M - minuto [00, 01, ..., 58, 59] %S - segundo [00, 01, ..., 58, 59] Para aprender m\u00e1s sobre strftime() visit\u00e1 la documentaci\u00f3n . Python strptime() - convertir una cadena a un objeto datetime El m\u00e9todo strptime() crea un objeto datetime a partir de una cadena. Ejemplo: strptime() >>> from datetime import datetime >>> cadena_con_fecha= '21 September, 2021' >>> print('date_string =', cadena_con_fecha) date_string = 21 September, 2021 >>> date_object = datetime.strptime(cadena_con_fecha, '%d %B, %Y') >>> print('date_object =', date_object) date_object = 2021-09-21 00:00:00 El m\u00e9todo strptime() toma dos argumentos: una cadena que representa una fecha y hora un c\u00f3digo de formato correspondiente al primer argumento Los c\u00f3digos de formato %d , %B , %Y significan day , month (full name) y year respectivamente. Visit\u00e1 la documentaci\u00f3n para m\u00e1s detalles. Ejercicios: Ejercicio 8.1: Segundos vividos Escrib\u00ed una funci\u00f3n a la que le pas\u00e1s tu fecha de nacimiento como cadena en formato 'dd/mm/AAAA' (d\u00eda, mes, a\u00f1o con 2, 2 y 4 d\u00edgitos, separados con barras normales) y te devuelve la cantidad de segundos que viviste (asumiendo que naciste a las 00:00hs de tu fecha de nacimiento). Guard\u00e1 este c\u00f3digo en el archivo vida.py . Ejercicio 8.2: Cu\u00e1nto falta Un conocido canal Argentino tiene por costumbre anunciar la cantidad de d\u00edas que faltan para la pr\u00f3xima primavera. Escrib\u00ed un programa que asista a los t\u00e9cnicos del canal indic\u00e1ndoles, al correr el programa el n\u00famero que deben poner en la placa. Ejercicio 8.3: Fecha de reincorporaci\u00f3n Si ten\u00e9s una licencia por xaternidad que empieza el 26 de septiembre de 2020 y dura 200 d\u00edas, \u00bfqu\u00e9 d\u00eda te reincorpor\u00e1s al trabajo? Ejercicio 8.4: D\u00edas h\u00e1biles Escrib\u00ed una funci\u00f3n dias_habiles(inicio, fin, feriados) que calcule los d\u00edas h\u00e1biles entre dos fechas dadas. La funci\u00f3n debe tener como argumentos el d\u00eda inicial, el d\u00eda final, y una lista con las fechas correspondientes a los feriados que haya en ese lapso, y debe devolver una lista con las fechas de d\u00edas h\u00e1biles del per\u00edodo, incluyendo la fecha inicial y la fecha final indicadas. Las fechas de entrada y salida deben manejarse en formato de texto. Consideramos d\u00eda h\u00e1bil a un d\u00eda que no es feriado ni s\u00e1bado ni domingo. Probala entre el 20 de septiembre de 2020 y el 10 de octubre del mismo a\u00f1o, sabiendo que no hubo feriados en el medio. Probala entre ese d\u00eda y fin del 2020 considerando los siguientes feriados de Argentina: feriados = ['12/10/2020', '23/11/2020', '7/12/2020', '8/12/2020', '25/12/2020'] Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Manejo de archivos y carpetas)","title":"02 Fechas"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#82-manejo-de-fechas-y-horas","text":"Esta secci\u00f3n tiene un breve video introductorio sobre el m\u00f3dulo datetime .","title":"8.2 Manejo de fechas y horas"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#el-modulo-datetime","text":"A continuaci\u00f3n introducimos el m\u00f3dulo datetime que permite trabajar con fechas y horas. Este m\u00f3dulo define un nuevo tipo de objeto: datetime (s\u00ed, con el mismo nombre del m\u00f3dulo), que permite representar un instante temporal (fecha y hora). Tambi\u00e9n define objetos de tipo date para representar s\u00f3lo una fecha y de tipo time para guardar y trabajar con horarios. Finalmente, en esta breve introducci\u00f3n al m\u00f3dulo datetime mencionamos el tipo timedelta que se usa para representar diferencias entre instantes de tiempos, es decir, duraciones y trabajar con ellas.","title":"El m\u00f3dulo datetime"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-obtener-fecha-y-hora-actuales","text":">>> import datetime >>> fecha_hora = datetime.datetime.now() >>> print(fecha_hora) 2020-09-24 10:03:18.636670 Lo que hicimos fue importar el m\u00f3dulo datetime y usar el m\u00e9todo now() de la clase datetime del m\u00f3dulo (con el mismo nombre) para crear el objeto fecha_hora que va a contener la fecha y la hora actuales.","title":"Ejemplo: Obtener fecha y hora actuales"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-obtener-fecha-actual","text":"An\u00e1logamente, podemos obtener solo la fecha: >>> fecha = datetime.date.today() >>> print(fecha) 2020-09-24 Ac\u00e1 usamos el m\u00e9todo today() de la clase date para obtener la fecha actual. \u00bfQu\u00e9 hay dentro del m\u00f3dulo datetime? En Python podemos usar la funci\u00f3n dir() para obtener una lista de todos los atributos de un m\u00f3dulo. >>> print(dir(datetime)) ['MAXYEAR', 'MINYEAR', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_divide_and_round', 'date', 'datetime', 'datetime_CAPI', 'time', 'timedelta', 'timezone', 'tzinfo'] Nos vamos a concentrar en lo m\u00e1s usado de datetime : date time datetime timedelta","title":"Ejemplo: Obtener fecha actual"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#la-clase-datetimedate","text":"Pod\u00e9s generar objetos de tipo fecha con la clase date . Un objeto de esta clase representa una fecha (a\u00f1o, mes, d\u00eda).","title":"La clase datetime.date"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-un-objeto-para-representar-una-fecha","text":">>> d = datetime.date(2019, 4, 13) >>> print(d) 2019-04-13 El comando date() de este ejemplo construye un objeto de tipo date . Este constructor toma tres argumentos: a\u00f1o, mes y d\u00eda. La variable d es un objeto de tipo date (es decir, representa una fecha). Tambi\u00e9n podr\u00edamos importar directamente la clase date del m\u00f3dulo datetime : >>> from datetime import date >>> >>> d = date(2019, 4, 13) >>> print(d) 2019-04-13","title":"Ejemplo: Un objeto para representar una fecha"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-obtener-la-fecha-a-partir-de-un-timestamp","text":"En los sistemas operativos derivados de Unix (Mac OS X, Linux, etc.) se toma como medida de tiempo el n\u00famero de segundos transcurridos desde el primero de enero de 1970 a las 0 horas UTC hasta el momento a representar. Se lo conoce como Unix timestamp. Pod\u00e9s convertir un timestamp a fecha usando el m\u00e9todo fromtimestamp() . >>> from datetime import date >>> >>> timestamp = date.fromtimestamp(1326244364) >>> print('Fecha =', timestamp) Fecha = 2012-01-10 Esto es importante porque las fechas de modificaci\u00f3n de los archivos usan timestamps por ejemplo.","title":"Ejemplo: Obtener la fecha a partir de un timestamp"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-obtener-el-ano-el-mes-y-el-dia-por-separado","text":"As\u00ed pod\u00e9s obtener el a\u00f1o, el mes, el d\u00eda y el d\u00eda de la semana: from datetime import date hoy = date.today() print('A\u00f1o actual:', hoy.year) print('Mes actual:', hoy.month) print('D\u00eda actual:', hoy.day) print('D\u00eda de la semana:', hoy.weekday()) # va de 0 a 6 empezando en lunes","title":"Ejemplo: Obtener el a\u00f1o, el mes y el d\u00eda por separado."},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#la-clase-datetimetime","text":"Un objeto de la clase time representa la hora local (de como este configurada tu computadora). No nos vamos a meter en esta clase con los husos horarios (conocido tambi\u00e9n como timezones), pero si vas a usar datos provistos por otres, es importante que sepas si est\u00e1 expresado en tu hora local, en la hora local de otro lugar o en UTC .","title":"La clase datetime.time"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-representar-la-hora-con-un-objeto-time","text":"La clase time se usa para representar horarios. A continuaci\u00f3n damos algunos ejemplos de constructores de esta clase (un constructor es una forma de construir un objeto de una clase dada, una forma de inicializarlo, digamos). >>> from datetime import time >>> >>> a = time() # time(hour = 0, minute = 0, second = 0) >>> print('a =', a) a = 00:00:00 >>> b = time(11, 34, 56) >>> print('b =', b) b = 11:34:56 >>> c = time(hour = 11, minute = 34, second = 56) >>> print('c =', c) c = 11:34:56 >>> d = time(11, 34, 56, 234566) # time(hour, minute, second, microsecond) >>> print('d =', d) d = 11:34:56.234566","title":"Ejemplo: Representar la hora con un objeto time"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-obtener-horas-minutos-segundos-y-micro-segundos","text":"Una vez que creaste un objeto time , pod\u00e9s extraer sus atributos as\u00ed: from datetime import time a = time(11, 34, 56) print('hour =', a.hour) print('minute =', a.minute) print('second =', a.second) print('microsecond =', a.microsecond) Como no le pasaste ning\u00fan valor para el argumento microsecond , \u00e9ste va a tomar el valor predeterminado, que es 0 .","title":"Ejemplo: Obtener horas, minutos, segundos y micro-segundos"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#la-clase-datetimedatetime","text":"Como ya mencionamos, el m\u00f3dulo datetime tiene una clase con su mismo nombre que permite almacenar informaci\u00f3n de fecha y hora en un solo objeto.","title":"La clase datetime.datetime"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-objeto-datetime","text":">>> from datetime import datetime >>> # datetime(year, month, day) >>> a = datetime(2020, 4, 21) >>> print(a) 2020-04-21 00:00:00 >>> # datetime(year, month, day, hour, minute, second, microsecond) >>> b = datetime(2021, 4, 21, 6, 53, 31, 342260) >>> print(b) 2021-04-21 06:53:31.342260 Los primeros tres argumentos, year , month y day del constructor datetime() son obligatorios. Los otros tienen a 0 como valor por omisi\u00f3n.","title":"Ejemplo: Objeto datetime"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-obtener-ano-mes-dia-hora-minutos-timestamp-de-un-datetime","text":"El siguiente c\u00f3digo genera un objeto datetime con valores pasados por par\u00e1metro y luego imprime la informaci\u00f3n. En particular, muestra c\u00f3mo convertir una fecha a timestamp. En general los timestamps son enteros y no tienen en cuenta las d\u00e9cimas de segundos. from datetime import datetime a = datetime(2021, 4, 21, 6, 53, 31, 342260) print('a\u00f1o =', a.year) print('mes =', a.month) print('d\u00eda =', a.day) print('hora =', a.hour) print('minuto =', a.minute) print('timestamp =', a.timestamp())","title":"Ejemplo: Obtener a\u00f1o, mes, d\u00eda, hora, minutos, timestamp de un datetime"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#la-clase-datetimetimedelta","text":"Un objeto timedelta representa una duraci\u00f3n, es decir, la diferencia entre dos instantes de tiempo.","title":"La clase datetime.timedelta"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-diferencia-entre-fechas-y-horarios","text":">>> from datetime import datetime, date >>> t1 = date(year = 2021, month = 4, day = 21) >>> t2 = date(year = 2020, month = 8, day = 23) >>> t3 = t1 - t2 >>> print(t3) 241 days, 0:00:00 >>> t4 = datetime(year = 2020, month = 7, day = 12, hour = 7, minute = 9, second = 33) >>> t5 = datetime(year = 2021, month = 6, day = 10, hour = 5, minute = 55, second = 13) >>> t6 = t4 - t5 >>> print(t6) -333 days, 1:14:20 >>> print('tipo de t3 =', type(t3)) tipo de t3 = <class 'datetime.timedelta'> >>> print('tipo de t6 =', type(t6)) tipo de t6 = <class 'datetime.timedelta'> Observ\u00e1 que t3 y t6 son de tipo <class 'datetime.timedelta'> .","title":"Ejemplo: Diferencia entre fechas y horarios"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-diferencia-entre-objetos-timedelta","text":">>> from datetime import timedelta >>> t1 = timedelta(weeks = 1, days = 2, hours = 1, seconds = 33) >>> t2 = timedelta(days = 6, hours = 11, minutes = 4, seconds = 54) >>> t3 = t1 - t2 >>> print('t3 =', t3) 2 days, 13:55:39 t3 tambi\u00e9n es de tipo <class 'datetime.timedelta'> .","title":"Ejemplo: Diferencia entre objetos timedelta"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-imprimir-objetos-timedelta-negativos","text":">>> from datetime import timedelta >>> t1 = timedelta(seconds = 21) >>> t2 = timedelta(seconds = 55) >>> t3 = t1 - t2 >>> print(t3) -1 day, 23:59:26 >>> print(abs(t3)) 0:00:34","title":"Ejemplo: Imprimir objetos timedelta negativos"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-duracion-en-segundos","text":"Pod\u00e9s obtener el tiempo medido en segundos usando el m\u00e9todo total_seconds() . >>> from datetime import timedelta >>> t = timedelta(days = 1, hours = 2, seconds = 30, microseconds = 100000) >>> print('segundos totales =', t.total_seconds()) segundos totales = 93630.1 Tambi\u00e9n pod\u00e9s sumar fechas y horarios usando el operador + . Tambi\u00e9n pod\u00e9s multiplicar o dividir un objeto timedelta por n\u00fameros enteros o floats.","title":"Ejemplo: Duraci\u00f3n en segundos"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#formato-para-fechas-y-horas","text":"Hay diversas formas de representar el tiempo, que var\u00edan seg\u00fan el lugar, la organizaci\u00f3n, etc. Por ejemplo, en Argentina solemos usar dd/mm/yyyy , mientras que en las culturas anglosajonas es m\u00e1s com\u00fan usar mm/dd/yyyy . En Python tenemos los m\u00e9todos strftime() y strptime() para manejar esto.","title":"Formato para fechas y horas"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#python-strftime-convertir-un-objeto-datetime-a-string","text":"El m\u00e9todo strftime() est\u00e1 definido en las clases date , datetime y time . Este m\u00e9todo crea una cadena con formato a partir estos objetos.","title":"Python strftime() - convertir un objeto datetime a string"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-formato-de-fecha-usando-strftime","text":">>> from datetime import datetime >>> now = datetime.now() >>> t = now.strftime('%H:%M:%S') >>> print('hora:', t) hora: 14:40:06 >>> s1 = now.strftime('%m/%d/%Y, %H:%M:%S') >>> # en formato mm/dd/YY H:M:S >>> print('s1:', s1) s1: 09/24/2020, 14:40:06 >>> s2 = now.strftime('%d/%m/%Y, %H:%M:%S') >>> # en formato dd/mm/YY H:M:S >>> print('s2:', s2) s2: 24/09/2020, 14:40:06 Ac\u00e1, %Y , %m , %d , %H etc. son c\u00f3digos de formato. El m\u00e9todo strftime() toma uno o m\u00e1s c\u00f3digos de formato y devuelve la cadena con formato basado en esos c\u00f3digos. En el programa de arriba, t , s1 y s2 son cadenas. Y los c\u00f3digos de formato son: %Y - a\u00f1o [0001,..., 2018, 2019,..., 9999] %m - mes [01, 02, ..., 11, 12] %d - d\u00eda [01, 02, ..., 30, 31] %H - hora [00, 01, ..., 22, 23 %M - minuto [00, 01, ..., 58, 59] %S - segundo [00, 01, ..., 58, 59] Para aprender m\u00e1s sobre strftime() visit\u00e1 la documentaci\u00f3n .","title":"Ejemplo: Formato de fecha usando strftime()"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#python-strptime-convertir-una-cadena-a-un-objeto-datetime","text":"El m\u00e9todo strptime() crea un objeto datetime a partir de una cadena.","title":"Python strptime() - convertir una cadena a un objeto datetime"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejemplo-strptime","text":">>> from datetime import datetime >>> cadena_con_fecha= '21 September, 2021' >>> print('date_string =', cadena_con_fecha) date_string = 21 September, 2021 >>> date_object = datetime.strptime(cadena_con_fecha, '%d %B, %Y') >>> print('date_object =', date_object) date_object = 2021-09-21 00:00:00 El m\u00e9todo strptime() toma dos argumentos: una cadena que representa una fecha y hora un c\u00f3digo de formato correspondiente al primer argumento Los c\u00f3digos de formato %d , %B , %Y significan day , month (full name) y year respectivamente. Visit\u00e1 la documentaci\u00f3n para m\u00e1s detalles.","title":"Ejemplo: strptime()"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejercicios","text":"","title":"Ejercicios:"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejercicio-81-segundos-vividos","text":"Escrib\u00ed una funci\u00f3n a la que le pas\u00e1s tu fecha de nacimiento como cadena en formato 'dd/mm/AAAA' (d\u00eda, mes, a\u00f1o con 2, 2 y 4 d\u00edgitos, separados con barras normales) y te devuelve la cantidad de segundos que viviste (asumiendo que naciste a las 00:00hs de tu fecha de nacimiento). Guard\u00e1 este c\u00f3digo en el archivo vida.py .","title":"Ejercicio 8.1: Segundos vividos"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejercicio-82-cuanto-falta","text":"Un conocido canal Argentino tiene por costumbre anunciar la cantidad de d\u00edas que faltan para la pr\u00f3xima primavera. Escrib\u00ed un programa que asista a los t\u00e9cnicos del canal indic\u00e1ndoles, al correr el programa el n\u00famero que deben poner en la placa.","title":"Ejercicio 8.2: Cu\u00e1nto falta"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejercicio-83-fecha-de-reincorporacion","text":"Si ten\u00e9s una licencia por xaternidad que empieza el 26 de septiembre de 2020 y dura 200 d\u00edas, \u00bfqu\u00e9 d\u00eda te reincorpor\u00e1s al trabajo?","title":"Ejercicio 8.3: Fecha de reincorporaci\u00f3n"},{"location":"08_Fechas_Carpetas_y_Pandas/02_Fechas/#ejercicio-84-dias-habiles","text":"Escrib\u00ed una funci\u00f3n dias_habiles(inicio, fin, feriados) que calcule los d\u00edas h\u00e1biles entre dos fechas dadas. La funci\u00f3n debe tener como argumentos el d\u00eda inicial, el d\u00eda final, y una lista con las fechas correspondientes a los feriados que haya en ese lapso, y debe devolver una lista con las fechas de d\u00edas h\u00e1biles del per\u00edodo, incluyendo la fecha inicial y la fecha final indicadas. Las fechas de entrada y salida deben manejarse en formato de texto. Consideramos d\u00eda h\u00e1bil a un d\u00eda que no es feriado ni s\u00e1bado ni domingo. Probala entre el 20 de septiembre de 2020 y el 10 de octubre del mismo a\u00f1o, sabiendo que no hubo feriados en el medio. Probala entre ese d\u00eda y fin del 2020 considerando los siguientes feriados de Argentina: feriados = ['12/10/2020', '23/11/2020', '7/12/2020', '8/12/2020', '25/12/2020'] Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Manejo de archivos y carpetas)","title":"Ejercicio 8.4: D\u00edas h\u00e1biles"},{"location":"08_Fechas_Carpetas_y_Pandas/03_Archivos_y_Directorios/","text":"Contenidos | Anterior (2 Manejo de fechas y horas) | Pr\u00f3ximo (4 Ordenar archivos en Python) 8.3 Manejo de archivos y carpetas Esta secci\u00f3n tiene un breve video introductorio sobre el manejo de archivos y directorios desde Python. Manejo de archivos y directorios Una carpeta o directorio es una colecci\u00f3n de archivos y directorios. Python tiene el m\u00f3dulo os que ofrece muchas herramientas \u00fatiles para trabajar con directorios y archivos. En esta secci\u00f3n vas a aprender c\u00f3mo crear un directorio, renombrarlo, listar todos sus archivos y subdirectorios, etc. Obtener el directorio actual Para obtener el directorio de trabajo actual, usamos el funci\u00f3n getcwd() ( get current working directory ) del m\u00f3dulo os . Esta funci\u00f3n te devuelve el directorio actual en forma de cadena. >>> import os >>> os.getcwd() '/home/usuario/ejercicios_python' Es importante ver que la salida depender\u00e1 del sistema operativo que est\u00e9s usando. Por ejemplo, en Windows podr\u00edas obtener algo as\u00ed: C:\\\\usuario\\\\ejercicios_python . Cambiar el directorio de trabajo Pod\u00e9s cambiar de directorio usando la funci\u00f3n chdir() ( change directory ). Los directorios pueden ser relativos o absolutos (en sistemas operativos basados en Unix '.' es el directorio actual, '..' es el anterior, '/' es el directorio ra\u00edz). >>> os.chdir('../Data') # entro en ../Data >>> print(os.getcwd()) /home/usuario/ejercicios_python/Data >>> os.chdir('..') # subo un nivel >>> os.chdir('..') # subo otro nivel >>> print(os.getcwd()) /home/usuario/ >>> os.chdir('/home') >>> print(os.getcwd()) /home Para cambiar de directorio, le pas\u00e1s el nuevo directorio como cadena a esta funci\u00f3n. En diferentes sistemas operativos las barras de directorio se escriben de diferentes maneras. Es recomendable usar el comando os.path.join como en el siguiente ejemplo de manera que tu c\u00f3digo funcione independientemente del sistema operativo en el que se lo corra. >>> directorio = os.path.join('/home', 'usuario', 'ejercicios_python') >>> os.chdir(directorio) En caso de usarlo en Windows, ser\u00e1 similar a: >>> directorio = os.path.join('c:\\\\', 'usuario', 'ejercicios_python') >>> os.chdir(directorio) Usar directorios relativos al actual (que comienzan con './') y no absolutos (que comienzan con '/') facilita la portabilidad del c\u00f3digo de una compu a otra. Listar directorios y archivos La funci\u00f3n listdir() toma un directorio ( path o camino) y devuelve una lista con todos los archivos y subdirectorios de un directorio. Si no se le pasa ning\u00fan par\u00e1metro, devuelve los del directorio de trabajo actual. >>> os.getcwd() '/home/usuario/ejercicios_python' >>> os.listdir('../Data') ['camion2.csv', 'missing.csv', 'precios.csv', 'camion.csv', 'camion.dat', 'temperaturas.npy', 'camion_blancos.csv', 'camion.csv.gz', 'dowstocks.csv', 'fecha_camion.csv', 'arbolado-en-espacios-verdes.csv'] Crear un nuevo directorio Pod\u00e9s crear un directorio con la funci\u00f3n mkdir() . Esta funci\u00f3n toma como argumento el path del nuevo directorio. Si no se especifica el path absoluto, el directorio nuevo se crea en el directorio de trabajo actual. >>> os.mkdir('test') # creo el directorio test >>> os.mkdir(os.path.join('test', 'carpeta')) # creo el subdirectorio carpeta dentro de test >>> os.listdir('test') ['carpeta'] Renombrar un directorio o un archivo Para renombrar un directorio o archivo, la funci\u00f3n rename() toma dos argumentos, el viejo nombre y el nuevo nombre. >>> os.chdir('test') # entro en el directorio test >>> os.listdir() ['carpeta'] >>> os.rename('carpeta','carpeta_nueva') # cambio el nombre de carpeta >>> os.listdir() ['carpeta_nueva'] Esto mismo se puede hacer trabajando desde el directorio Ejercicios , sin entrar en 'test', marcando el camino hacia la carpeta que queremos renombrar. >>> os.chdir('..') # subo un nivel >>> os.listdir('test') # miro qu\u00e9 hay en test ['carpeta_nueva'] >>> os.rename(os.path.join('test', 'carpeta_nueva'), os.path.join('test','carpeta_vieja')) >>> os.listdir('test') ['carpeta_vieja'] La funci\u00f3n rename() tambi\u00e9n es \u00fatil para mover un archivo o directorio, cambiando el camino ( path ) de acceso al archivo. Prob\u00e1 hacer esto: >>> os.rename(os.path.join('test','carpeta_vieja'), 'carpeta_vieja') # cambio el path >>> os.listdir('test') # test qued\u00f3 vac\u00edo [] La carpeta 'carpeta' ahora se encuentra en 'Ejercicios', y no dentro de 'Ejercicios/test'. Ojo : rename() funciona cuando el archivo (o directorio) no se cambia de disco (o m\u00e1s espec\u00edficamente de una partici\u00f3n). Si quer\u00e9s mover un archivo del disco a un pendrive, por ejemplo, lo correcto es copiar el archivo al pendrive y luego borrarlo del disco. rename() no hace esto: no copia y borra, simplemente cambia el nombre. Para renombrar en caso que se pueda o copiar y borrar si lo primero no es posible, pod\u00e9s usar la funci\u00f3n move() del m\u00f3dulo shutil . Este m\u00f3dulo es de m\u00e1s alto nivel y usa las primitivas de bajo nivel del m\u00f3dulo os . Al usar os tenemos un control m\u00e1s estricto de las operaciones. Las funciones de shutil pueden resultar m\u00e1s c\u00f3modas, pero en el camino pueden invocar a diversas funciones de bajo nivel del m\u00f3dulo os . Eliminar un directorio o un archivo :warning: A continuaci\u00f3n usaremos comandos que borran archivos sin pasar por ninguna papelera de reciclaje. Estas acciones no pueden deshacerse : Usar con precauci\u00f3n, un gran poder conlleva una gran responsabilidad . Pod\u00e9s eliminar un archivo usando la funci\u00f3n remove() . Tambi\u00e9n pod\u00e9s eliminar un directorio vac\u00edo usando rmdir() . En el siguiente c\u00f3digo trabajaremos en una carpeta que tiene esta estructura: otra_carpeta \u251c\u2500\u2500 archivo.txt \u2514\u2500\u2500 subcarpeta >>> os.chdir('otra_carpeta') # entro otra carpeta que tiene # una subcarpeta y un archivo de texto >>> os.listdir() ['subcarpeta', 'archivo.txt'] >>> os.remove('archivo.txt') # elimino el archivo >>> os.listdir() ['subcarpeta'] >>> os.rmdir('subcarpeta') # elimino la subcarpeta >>> os.listdir() [] Ojo : rmdir() solamente puede borrar directorios si est\u00e1n vac\u00edos. Para eliminar un directorio no vac\u00edo, pod\u00e9s usar rmtree() del m\u00f3dulo shutil . >>> os.mkdir(os.path.join('test','carpeta')) # creo nuevamente una carpeta # dentro de test >>> os.mkdir(os.path.join('test','carpeta', 'subcarpeta')) # creo una subcarpeta en carpeta >>> os.chdir('test') # entro en test >>> os.rmdir('carpeta') # quiero eliminar carpeta Traceback (most recent call last): File \"<ipython-input-277-c4255042d84c>\", line 1, in <module> os.rmdir('carpeta') OSError: [Errno 39] Directory not empty: 'carpeta' >>> import shutil >>> shutil.rmtree('carpeta') >>> os.listdir() [] Recorriendo directorios con os.walk() La funci\u00f3n walk() del m\u00f3dulo os genera una lista con los nombres de todos los archivos del \u00e1rbol de subdirectorios de un directorio dado. Es decir, lista los archivos de un directorio dado y luego entra en cada subdirectorio y hace lo mismo, recursivamente ( top-down ). La funci\u00f3n walk() recibe como \u00fanico par\u00e1metro obligatorio el directorio donde comenzar a mirar (la ra\u00edz del \u00e1rbol). Ejemplo En este ejemplo se ve c\u00f3mo se usa os.walk() . import os for root, dirs, files in os.walk(\".\"): for name in files: print(os.path.join(root, name)) for name in dirs: print(os.path.join(root, name)) Cambiar atributos de un archivo Dependiendo del sistema operativo, un archivo puede tener asociadas diferentes fechas (de creaci\u00f3n original, de modificaci\u00f3n del contenido, de cambio en sus metadatos, de acceso para lectura). Vamos a cambiar la fecha de modificaci\u00f3n de un archivo. Para ello necesit\u00e1s importar os y datetime . Despu\u00e9s, convert\u00eds la fecha elegida a timestamp y se la asoc\u00edas al archivo con utime , como se muestra ac\u00e1 abajo: import os import datetime import time camino = './rebotes.py' stats_archivo = os.stat(camino) print(time.ctime(stats_archivo.st_atime)) fecha_acceso = datetime.datetime(year = 2017, month = 9, day = 21, hour = 19, minute =51, second = 0) fecha_modifi = datetime.datetime(year = 2012, month = 9, day = 24, hour = 12, minute =9, second = 24) ts_acceso = fecha_acceso.timestamp() ts_modifi = fecha_modifi.timestamp() os.utime(camino, (ts_acceso, ts_modifi)) stats_archivo = os.stat(camino) print(time.ctime(stats_archivo.st_atime)) Si mir\u00e1s la informaci\u00f3n del archivo ./rebotes.py desde tu gestor de archivos deber\u00edas ver las modificaciones. Contenidos | Anterior (2 Manejo de fechas y horas) | Pr\u00f3ximo (4 Ordenar archivos en Python)","title":"03 Archivos y Directorios"},{"location":"08_Fechas_Carpetas_y_Pandas/03_Archivos_y_Directorios/#83-manejo-de-archivos-y-carpetas","text":"Esta secci\u00f3n tiene un breve video introductorio sobre el manejo de archivos y directorios desde Python.","title":"8.3 Manejo de archivos y carpetas"},{"location":"08_Fechas_Carpetas_y_Pandas/03_Archivos_y_Directorios/#manejo-de-archivos-y-directorios","text":"Una carpeta o directorio es una colecci\u00f3n de archivos y directorios. Python tiene el m\u00f3dulo os que ofrece muchas herramientas \u00fatiles para trabajar con directorios y archivos. En esta secci\u00f3n vas a aprender c\u00f3mo crear un directorio, renombrarlo, listar todos sus archivos y subdirectorios, etc.","title":"Manejo de archivos y directorios"},{"location":"08_Fechas_Carpetas_y_Pandas/03_Archivos_y_Directorios/#obtener-el-directorio-actual","text":"Para obtener el directorio de trabajo actual, usamos el funci\u00f3n getcwd() ( get current working directory ) del m\u00f3dulo os . Esta funci\u00f3n te devuelve el directorio actual en forma de cadena. >>> import os >>> os.getcwd() '/home/usuario/ejercicios_python' Es importante ver que la salida depender\u00e1 del sistema operativo que est\u00e9s usando. Por ejemplo, en Windows podr\u00edas obtener algo as\u00ed: C:\\\\usuario\\\\ejercicios_python .","title":"Obtener el directorio actual"},{"location":"08_Fechas_Carpetas_y_Pandas/03_Archivos_y_Directorios/#cambiar-el-directorio-de-trabajo","text":"Pod\u00e9s cambiar de directorio usando la funci\u00f3n chdir() ( change directory ). Los directorios pueden ser relativos o absolutos (en sistemas operativos basados en Unix '.' es el directorio actual, '..' es el anterior, '/' es el directorio ra\u00edz). >>> os.chdir('../Data') # entro en ../Data >>> print(os.getcwd()) /home/usuario/ejercicios_python/Data >>> os.chdir('..') # subo un nivel >>> os.chdir('..') # subo otro nivel >>> print(os.getcwd()) /home/usuario/ >>> os.chdir('/home') >>> print(os.getcwd()) /home Para cambiar de directorio, le pas\u00e1s el nuevo directorio como cadena a esta funci\u00f3n. En diferentes sistemas operativos las barras de directorio se escriben de diferentes maneras. Es recomendable usar el comando os.path.join como en el siguiente ejemplo de manera que tu c\u00f3digo funcione independientemente del sistema operativo en el que se lo corra. >>> directorio = os.path.join('/home', 'usuario', 'ejercicios_python') >>> os.chdir(directorio) En caso de usarlo en Windows, ser\u00e1 similar a: >>> directorio = os.path.join('c:\\\\', 'usuario', 'ejercicios_python') >>> os.chdir(directorio) Usar directorios relativos al actual (que comienzan con './') y no absolutos (que comienzan con '/') facilita la portabilidad del c\u00f3digo de una compu a otra.","title":"Cambiar el directorio de trabajo"},{"location":"08_Fechas_Carpetas_y_Pandas/03_Archivos_y_Directorios/#listar-directorios-y-archivos","text":"La funci\u00f3n listdir() toma un directorio ( path o camino) y devuelve una lista con todos los archivos y subdirectorios de un directorio. Si no se le pasa ning\u00fan par\u00e1metro, devuelve los del directorio de trabajo actual. >>> os.getcwd() '/home/usuario/ejercicios_python' >>> os.listdir('../Data') ['camion2.csv', 'missing.csv', 'precios.csv', 'camion.csv', 'camion.dat', 'temperaturas.npy', 'camion_blancos.csv', 'camion.csv.gz', 'dowstocks.csv', 'fecha_camion.csv', 'arbolado-en-espacios-verdes.csv']","title":"Listar directorios y archivos"},{"location":"08_Fechas_Carpetas_y_Pandas/03_Archivos_y_Directorios/#crear-un-nuevo-directorio","text":"Pod\u00e9s crear un directorio con la funci\u00f3n mkdir() . Esta funci\u00f3n toma como argumento el path del nuevo directorio. Si no se especifica el path absoluto, el directorio nuevo se crea en el directorio de trabajo actual. >>> os.mkdir('test') # creo el directorio test >>> os.mkdir(os.path.join('test', 'carpeta')) # creo el subdirectorio carpeta dentro de test >>> os.listdir('test') ['carpeta']","title":"Crear un nuevo directorio"},{"location":"08_Fechas_Carpetas_y_Pandas/03_Archivos_y_Directorios/#renombrar-un-directorio-o-un-archivo","text":"Para renombrar un directorio o archivo, la funci\u00f3n rename() toma dos argumentos, el viejo nombre y el nuevo nombre. >>> os.chdir('test') # entro en el directorio test >>> os.listdir() ['carpeta'] >>> os.rename('carpeta','carpeta_nueva') # cambio el nombre de carpeta >>> os.listdir() ['carpeta_nueva'] Esto mismo se puede hacer trabajando desde el directorio Ejercicios , sin entrar en 'test', marcando el camino hacia la carpeta que queremos renombrar. >>> os.chdir('..') # subo un nivel >>> os.listdir('test') # miro qu\u00e9 hay en test ['carpeta_nueva'] >>> os.rename(os.path.join('test', 'carpeta_nueva'), os.path.join('test','carpeta_vieja')) >>> os.listdir('test') ['carpeta_vieja'] La funci\u00f3n rename() tambi\u00e9n es \u00fatil para mover un archivo o directorio, cambiando el camino ( path ) de acceso al archivo. Prob\u00e1 hacer esto: >>> os.rename(os.path.join('test','carpeta_vieja'), 'carpeta_vieja') # cambio el path >>> os.listdir('test') # test qued\u00f3 vac\u00edo [] La carpeta 'carpeta' ahora se encuentra en 'Ejercicios', y no dentro de 'Ejercicios/test'. Ojo : rename() funciona cuando el archivo (o directorio) no se cambia de disco (o m\u00e1s espec\u00edficamente de una partici\u00f3n). Si quer\u00e9s mover un archivo del disco a un pendrive, por ejemplo, lo correcto es copiar el archivo al pendrive y luego borrarlo del disco. rename() no hace esto: no copia y borra, simplemente cambia el nombre. Para renombrar en caso que se pueda o copiar y borrar si lo primero no es posible, pod\u00e9s usar la funci\u00f3n move() del m\u00f3dulo shutil . Este m\u00f3dulo es de m\u00e1s alto nivel y usa las primitivas de bajo nivel del m\u00f3dulo os . Al usar os tenemos un control m\u00e1s estricto de las operaciones. Las funciones de shutil pueden resultar m\u00e1s c\u00f3modas, pero en el camino pueden invocar a diversas funciones de bajo nivel del m\u00f3dulo os .","title":"Renombrar un directorio o un archivo"},{"location":"08_Fechas_Carpetas_y_Pandas/03_Archivos_y_Directorios/#eliminar-un-directorio-o-un-archivo","text":":warning: A continuaci\u00f3n usaremos comandos que borran archivos sin pasar por ninguna papelera de reciclaje. Estas acciones no pueden deshacerse : Usar con precauci\u00f3n, un gran poder conlleva una gran responsabilidad . Pod\u00e9s eliminar un archivo usando la funci\u00f3n remove() . Tambi\u00e9n pod\u00e9s eliminar un directorio vac\u00edo usando rmdir() . En el siguiente c\u00f3digo trabajaremos en una carpeta que tiene esta estructura: otra_carpeta \u251c\u2500\u2500 archivo.txt \u2514\u2500\u2500 subcarpeta >>> os.chdir('otra_carpeta') # entro otra carpeta que tiene # una subcarpeta y un archivo de texto >>> os.listdir() ['subcarpeta', 'archivo.txt'] >>> os.remove('archivo.txt') # elimino el archivo >>> os.listdir() ['subcarpeta'] >>> os.rmdir('subcarpeta') # elimino la subcarpeta >>> os.listdir() [] Ojo : rmdir() solamente puede borrar directorios si est\u00e1n vac\u00edos. Para eliminar un directorio no vac\u00edo, pod\u00e9s usar rmtree() del m\u00f3dulo shutil . >>> os.mkdir(os.path.join('test','carpeta')) # creo nuevamente una carpeta # dentro de test >>> os.mkdir(os.path.join('test','carpeta', 'subcarpeta')) # creo una subcarpeta en carpeta >>> os.chdir('test') # entro en test >>> os.rmdir('carpeta') # quiero eliminar carpeta Traceback (most recent call last): File \"<ipython-input-277-c4255042d84c>\", line 1, in <module> os.rmdir('carpeta') OSError: [Errno 39] Directory not empty: 'carpeta' >>> import shutil >>> shutil.rmtree('carpeta') >>> os.listdir() []","title":"Eliminar un directorio o un archivo"},{"location":"08_Fechas_Carpetas_y_Pandas/03_Archivos_y_Directorios/#recorriendo-directorios-con-oswalk","text":"La funci\u00f3n walk() del m\u00f3dulo os genera una lista con los nombres de todos los archivos del \u00e1rbol de subdirectorios de un directorio dado. Es decir, lista los archivos de un directorio dado y luego entra en cada subdirectorio y hace lo mismo, recursivamente ( top-down ). La funci\u00f3n walk() recibe como \u00fanico par\u00e1metro obligatorio el directorio donde comenzar a mirar (la ra\u00edz del \u00e1rbol).","title":"Recorriendo directorios con os.walk()"},{"location":"08_Fechas_Carpetas_y_Pandas/03_Archivos_y_Directorios/#ejemplo","text":"En este ejemplo se ve c\u00f3mo se usa os.walk() . import os for root, dirs, files in os.walk(\".\"): for name in files: print(os.path.join(root, name)) for name in dirs: print(os.path.join(root, name))","title":"Ejemplo"},{"location":"08_Fechas_Carpetas_y_Pandas/03_Archivos_y_Directorios/#cambiar-atributos-de-un-archivo","text":"Dependiendo del sistema operativo, un archivo puede tener asociadas diferentes fechas (de creaci\u00f3n original, de modificaci\u00f3n del contenido, de cambio en sus metadatos, de acceso para lectura). Vamos a cambiar la fecha de modificaci\u00f3n de un archivo. Para ello necesit\u00e1s importar os y datetime . Despu\u00e9s, convert\u00eds la fecha elegida a timestamp y se la asoc\u00edas al archivo con utime , como se muestra ac\u00e1 abajo: import os import datetime import time camino = './rebotes.py' stats_archivo = os.stat(camino) print(time.ctime(stats_archivo.st_atime)) fecha_acceso = datetime.datetime(year = 2017, month = 9, day = 21, hour = 19, minute =51, second = 0) fecha_modifi = datetime.datetime(year = 2012, month = 9, day = 24, hour = 12, minute =9, second = 24) ts_acceso = fecha_acceso.timestamp() ts_modifi = fecha_modifi.timestamp() os.utime(camino, (ts_acceso, ts_modifi)) stats_archivo = os.stat(camino) print(time.ctime(stats_archivo.st_atime)) Si mir\u00e1s la informaci\u00f3n del archivo ./rebotes.py desde tu gestor de archivos deber\u00edas ver las modificaciones. Contenidos | Anterior (2 Manejo de fechas y horas) | Pr\u00f3ximo (4 Ordenar archivos en Python)","title":"Cambiar atributos de un archivo"},{"location":"08_Fechas_Carpetas_y_Pandas/04_Ordenando_archivos/","text":"Contenidos | Anterior (3 Manejo de archivos y carpetas) | Pr\u00f3ximo (5 Introducci\u00f3n a Pandas) 8.4 Ordenar archivos en Python En esta secci\u00f3n vamos a integrar las \u00faltimas dos secciones con lo que ven\u00edamos viendo antes del parcial. La idea es que descomprimas este archivo en tu carpeta ../Data/ y escribas un script que trabaje con estos archivos. Esta secci\u00f3n tiene un ejercicio para entregar y luego otro m\u00e1s complejo que es optativo. Ejercicio 8.5: Recorrer el \u00e1rbol de archivos Escrib\u00ed un programa que dado un directorio, imprima en pantalla los nombres de todos los archivos .png que se encuentren en alg\u00fan subdirectorio del \u00e9l. Observaci\u00f3n: Al final, tu script deber\u00eda poder ejecutarse desde la l\u00ednea de comandos recibiendo como par\u00e1metro el directorio a leer original. En la Secci\u00f3n 7.3 dimos un modelo de script que te puede servir. Guard\u00e1 el script resultante en un archivo listar_imgs.py . Ejercicio 8.6: Ordenar el \u00e1rbol de archivos (optativo) Escrib\u00ed un programa que te permita ordenar las im\u00e1genes PNG de esta carpeta. Guardalo en un archivo ordenar_imgs.py . Cre\u00e1 un nuevo directorio ../Data/imgs_procesadas/ . Us\u00e1 os.walk() para recorrer los archivos en la carpeta ../Data/ordenar/ (y sus subcarpetas). Cuando encuentres archivos con extensi\u00f3n png los vas a procesar . En este caso procesar significa: Leer la fecha que se encuentra codificada en los \u00faltimos 8 caracteres de su nombre en el formato AAAAMMDD (a\u00f1o en 4 d\u00edgitos, mes en 2 y d\u00eda en 2). Usar la fecha obtenida para setear la fecha de \u00faltima modificaci\u00f3n (y de \u00faltimo acceso si no us\u00e1s Windows). Cambiarle el nombre al archivo para que no tenga m\u00e1s esos d\u00edgitos (ni el gui\u00f3n bajo). Mover el archivo a la carpeta ../Data/imgs_procesadas/ . Los archivos que no son png no los modifiques. Borr\u00e1 todas las subcarpetas de ../Data/ordenar/ que hayan quedado vac\u00edas. Observaci\u00f3n: Al final, tu script deber\u00eda poder ejecutarse desde la l\u00ednea de comandos recibiendo como par\u00e1metro el directorio a leer original y un directorio destino (que deber\u00eda ser creado si no existe). Observaci\u00f3n: Este tipo de tareas se repite con mucha frecuencia. Tener la capacidad de automatizarlas mediante un script de Python te puede ahorrar much\u00edsimo tiempo. Algunos puntos importantes: Te recomendamos que modularices el procesamiento de los archivos png . Pod\u00e9s, por ejemplo, escribir una funci\u00f3n que manipule strings (que tome el nombre de un archivo y devuelva la fecha y el nombre corregido) y otra funci\u00f3n que precese cada archivo (que use la funci\u00f3n anterior para renombrar, mover y modificar la fecha de cada archivo). La modularizaci\u00f3n del c\u00f3digo es clave para que otras personas lo puedan entender y que sea sencillo de mantener. Us\u00e1 docstrings y comentarios en tu c\u00f3digo de manera que sea legible. Contenidos | Anterior (3 Manejo de archivos y carpetas) | Pr\u00f3ximo (5 Introducci\u00f3n a Pandas)","title":"04 Ordenando archivos"},{"location":"08_Fechas_Carpetas_y_Pandas/04_Ordenando_archivos/#84-ordenar-archivos-en-python","text":"En esta secci\u00f3n vamos a integrar las \u00faltimas dos secciones con lo que ven\u00edamos viendo antes del parcial. La idea es que descomprimas este archivo en tu carpeta ../Data/ y escribas un script que trabaje con estos archivos. Esta secci\u00f3n tiene un ejercicio para entregar y luego otro m\u00e1s complejo que es optativo.","title":"8.4 Ordenar archivos en Python"},{"location":"08_Fechas_Carpetas_y_Pandas/04_Ordenando_archivos/#ejercicio-85-recorrer-el-arbol-de-archivos","text":"Escrib\u00ed un programa que dado un directorio, imprima en pantalla los nombres de todos los archivos .png que se encuentren en alg\u00fan subdirectorio del \u00e9l. Observaci\u00f3n: Al final, tu script deber\u00eda poder ejecutarse desde la l\u00ednea de comandos recibiendo como par\u00e1metro el directorio a leer original. En la Secci\u00f3n 7.3 dimos un modelo de script que te puede servir. Guard\u00e1 el script resultante en un archivo listar_imgs.py .","title":"Ejercicio 8.5: Recorrer el \u00e1rbol de archivos"},{"location":"08_Fechas_Carpetas_y_Pandas/04_Ordenando_archivos/#ejercicio-86-ordenar-el-arbol-de-archivos-optativo","text":"Escrib\u00ed un programa que te permita ordenar las im\u00e1genes PNG de esta carpeta. Guardalo en un archivo ordenar_imgs.py . Cre\u00e1 un nuevo directorio ../Data/imgs_procesadas/ . Us\u00e1 os.walk() para recorrer los archivos en la carpeta ../Data/ordenar/ (y sus subcarpetas). Cuando encuentres archivos con extensi\u00f3n png los vas a procesar . En este caso procesar significa: Leer la fecha que se encuentra codificada en los \u00faltimos 8 caracteres de su nombre en el formato AAAAMMDD (a\u00f1o en 4 d\u00edgitos, mes en 2 y d\u00eda en 2). Usar la fecha obtenida para setear la fecha de \u00faltima modificaci\u00f3n (y de \u00faltimo acceso si no us\u00e1s Windows). Cambiarle el nombre al archivo para que no tenga m\u00e1s esos d\u00edgitos (ni el gui\u00f3n bajo). Mover el archivo a la carpeta ../Data/imgs_procesadas/ . Los archivos que no son png no los modifiques. Borr\u00e1 todas las subcarpetas de ../Data/ordenar/ que hayan quedado vac\u00edas. Observaci\u00f3n: Al final, tu script deber\u00eda poder ejecutarse desde la l\u00ednea de comandos recibiendo como par\u00e1metro el directorio a leer original y un directorio destino (que deber\u00eda ser creado si no existe). Observaci\u00f3n: Este tipo de tareas se repite con mucha frecuencia. Tener la capacidad de automatizarlas mediante un script de Python te puede ahorrar much\u00edsimo tiempo. Algunos puntos importantes: Te recomendamos que modularices el procesamiento de los archivos png . Pod\u00e9s, por ejemplo, escribir una funci\u00f3n que manipule strings (que tome el nombre de un archivo y devuelva la fecha y el nombre corregido) y otra funci\u00f3n que precese cada archivo (que use la funci\u00f3n anterior para renombrar, mover y modificar la fecha de cada archivo). La modularizaci\u00f3n del c\u00f3digo es clave para que otras personas lo puedan entender y que sea sencillo de mantener. Us\u00e1 docstrings y comentarios en tu c\u00f3digo de manera que sea legible. Contenidos | Anterior (3 Manejo de archivos y carpetas) | Pr\u00f3ximo (5 Introducci\u00f3n a Pandas)","title":"Ejercicio 8.6: Ordenar el \u00e1rbol de archivos (optativo)"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/","text":"Contenidos | Anterior (4 Ordenar archivos en Python) | Pr\u00f3ximo (6 Series temporales) 8.5 Introducci\u00f3n a Pandas La biblioteca Pandas es una extensi\u00f3n de NumPy para manipulaci\u00f3n y an\u00e1lisis de datos. En particular, ofrece estructuras de datos y operaciones para manipular tablas de datos (num\u00e9ricos y de otros tipos) y series temporales. Se distribuye como software libre. \u00c9sta es una breve introducci\u00f3n a Pandas . Para informaci\u00f3n m\u00e1s completa, te recomendamos consultar la documentaci\u00f3n oficial . Esta biblioteca tiene dos tipos de datos fundamentales: los DataFrames que almacenan tablas de datos y las series que contienen secuencias de datos. Esta secci\u00f3n tiene un breve video introductorio sobre las posibilidades que ofrece la biblioteca Pandas. Lectura de datos Pandas permite leer diversos formatos de tablas de datos directamente. Prob\u00e1 el siguiente c\u00f3digo, para leer un archivo CSV: import pandas as pd import os directorio = '../Data' archivo = 'arbolado-en-espacios-verdes.csv' fname = os.path.join(directorio,archivo) df = pd.read_csv(fname) La variable df es de tipo DataFrame y contiene todos los datos del archivo csv estructurados adecuadamente. Con df.head() pod\u00e9s ver las primeras l\u00edneas de datos. Si a head le pas\u00e1s un n\u00famero como par\u00e1metro pod\u00e9s seleccionar cu\u00e1ntas l\u00edneas quer\u00e9s ver. An\u00e1logamente con df.tail(n) ver\u00e1s las \u00faltimas n l\u00edneas de datos. >>> df.head() long lat id_arbol ... origen coord_x coord_y 0 -58.477564 -34.645015 1 ... Ex\u00f3tico 98692.305719 98253.300738 1 -58.477559 -34.645047 2 ... Ex\u00f3tico 98692.751564 98249.733979 2 -58.477551 -34.645091 3 ... Ex\u00f3tico 98693.494639 98244.829684 3 -58.478129 -34.644567 4 ... Nativo/Aut\u00f3ctono 98640.439091 98302.938142 4 -58.478121 -34.644598 5 ... Nativo/Aut\u00f3ctono 98641.182166 98299.519997 Usando df.columns pandas te va a devolver un \u00edndice con los nombres de las columnas del DataFrame. Record\u00e1 que en la Secci\u00f3n 3.6 describimos la base de datos. A su vez, df.index te mostrar\u00e1 el \u00edndice. En este caso el \u00edndice es num\u00e9rico y se corresponde con el n\u00famero de la l\u00ednea leida del archivo. En principio no es muy interesante para analizar cuestiones de \u00e1rboles, simplemente tenemos las filas numeradas. Veremos otros ejemplos donde el \u00edndice puede contener informaci\u00f3n vital (una categor\u00eda, un timestamp, etc). >>> df.columns Index(['long', 'lat', 'id_arbol', 'altura_tot', 'diametro', 'inclinacio', 'id_especie', 'nombre_com', 'nombre_cie', 'tipo_folla', 'espacio_ve', 'ubicacion', 'nombre_fam', 'nombre_gen', 'origen', 'coord_x', 'coord_y'], dtype='object') >>> df.index RangeIndex(start=0, stop=51502, step=1) Otra herramienta \u00fatil para inspeccionar los datos reci\u00e9n levantados es describe() . Para ver mejor una parte, podemos seleccionar algunas columnas de inter\u00e9s antes de pedirle la descripci\u00f3n. >>> df[['altura_tot', 'diametro', 'inclinacio']].describe() altura_tot diametro inclinacio count 51502.000000 51502.000000 51502.000000 mean 12.167100 39.395616 3.472215 std 7.640309 31.171205 7.039495 min 0.000000 1.000000 0.000000 25% 6.000000 18.000000 0.000000 50% 11.000000 32.000000 0.000000 75% 18.000000 54.000000 5.000000 max 54.000000 500.000000 90.000000 Selecci\u00f3n Una de las operaciones primitivas m\u00e1s importantes es la selecci\u00f3n de fragmentos de las tablas de datos, ya sean filas, columnas o rangos de filas y columnas. Por ejemplo con df['nombre_com'] veremos la columna (que es una serie) de nombres comunes de los \u00e1rboles en la base. Podemos usar unique para ver una vez cada nombre: >>> df['nombre_com'].unique() array(['Washingtonia (Palmera washingtonia)', 'Omb\u00fa', 'Catalpa', 'Ceibo', 'Brachichiton (\u00c1rbol botella, Brachichito)', '\u00c1lamo plateado', 'Acacia de constantinopla', 'Acacia', 'Roble sedoso (Grevillea)', ... 'Jazm\u00edn del Paraguay', 'Plumerillo rojo', '\u00c1rbol fuccia', 'Canela de venado', 'Boj cepillo', 'Caranday'], dtype=object) Podemos preguntar cu\u00e1les se llaman de cierta manera ('Omb\u00fa' en este caso), como hac\u00edamos con los ndarrays en numpy: >>> df['nombre_com'] == 'Omb\u00fa' 0 False 1 False 2 False 3 True ... Observ\u00e1 que esto gener\u00f3 una serie. Podemos sumar los True de esta serie para contar la cantidad de Omb\u00fas: >>> (df['nombre_com'] == 'Omb\u00fa').sum() 590 Si queremos hacer lo mismo para otras especies podemos usar value_counts() >>> cant_ejemplares = df['nombre_com'].value_counts() >>> cant_ejemplares.head(10) Eucalipto 4112 Tipa blanca 4031 Jacarand\u00e1 3255 Palo borracho rosado 3150 Casuarina 2719 Fresno americano 2166 Pl\u00e1tano 1556 Cipr\u00e9s 1467 Ceibo 1149 Pind\u00f3 1068 Name: nombre_com, dtype: int64 De esta forma obtenemos, en orden decreciente, los nombres comunes y las cantidades de las especies m\u00e1s frecuentes en la base de datos. Filtros booleanos La serie booleana que obtuvimos con df['nombre_com'] == 'Omb\u00fa' puede usarse para seleccionar esas filas del DataFrame. Probemos con Jacarand\u00e1: >>> df_jacarandas = df[df['nombre_com'] == 'Jacarand\u00e1'] An\u00e1logamente, podemos seleccionar algunas columnas de inter\u00e9s y generar vistas (ojo, en estos casos no estamos copiando la informaci\u00f3n): >>> cols = ['altura_tot', 'diametro', 'inclinacio'] >>> df_jacarandas = df_jacarandas[cols] >>> df_jacarandas.tail() altura_tot diametro inclinacio 51104 7 97 4 51172 8 28 8 51180 2 30 0 51207 3 10 0 51375 17 40 20 >>> df_jacarandas.describe() altura_tot diametro inclinacio count 3255.000000 3255.000000 3255.000000 mean 10.369585 28.804301 6.549923 std 5.905744 19.166388 8.459921 min 1.000000 1.000000 0.000000 25% 6.000000 14.000000 0.000000 50% 10.000000 25.000000 4.000000 75% 15.000000 41.000000 10.000000 max 49.000000 159.000000 70.000000 Observ\u00e1 que cuando le pedimos los \u00faltimos datos de df_jacarandas nos mostr\u00f3 los \u00faltimos 5 jacarand\u00e1s de la base de datos, respetando los n\u00fameros de \u00edndice de la tabla original (..., 51207, 51375). Si vas a querer modificar df_jacarandas es conveniente crear una copia de los datos de df en lugar de simplemente una vista. Esto se puede hacer con el m\u00e9todo copy() como en el siguiente ejemplo. >>> df_jacarandas = df[df['nombre_com'] == 'Jacarand\u00e1'][cols].copy() Scatterplots Pandas tambi\u00e9n permite hacer gr\u00e1ficos bonitos . Es realmente sencillo: df_jacarandas.plot.scatter(x = 'diametro', y = 'altura_tot') Hay otro m\u00f3dulo para hacer gr\u00e1ficos que interact\u00faa muy bien con pandas y se llama Seaborn . Est\u00e1 basado en matplotlib, y ofrece una interfaz de alto nivel para realizar gr\u00e1ficos estad\u00edsticos atractivos e informativos. En criollo: \"usar pandas para manejar los datos y seaborn para visualizarlos, es la posta\". Fijate que seaborn entiende los DataFrames y las columnas y su sintaxis es muy similar a la de pandas: import seaborn as sns sns.scatterplot(data = df_jacarandas, x = 'diametro', y = 'altura_tot') Filtros por \u00edndice y por posici\u00f3n Como ya mencionamos, el \u00edndice de df no tiene una sem\u00e1ntica interesante. Veamos, en cambio, que la serie que generamos con cant_ejemplares = df['nombre_com'].value_counts() s\u00ed lo tiene: >>> cant_ejemplares.index Index(['Eucalipto', 'Tipa blanca', 'Jacarand\u00e1', 'Palo borracho rosado', 'Casuarina', 'Fresno americano', 'Pl\u00e1tano', 'Cipr\u00e9s', 'Ceibo', 'Pind\u00f3', ... 'Naranjo dulce', 'Peltophorum', 'Ligustrina de California', 'Afrocarpus', 'Caranday', 'Esterculea', 'Boj cepillo', 'Sesbania', 'Ligustrum', '\u00c1rbol del humo'], dtype='object', length=337) cant_ejemplares es una serie (es como un DataFrame de una sola columna). Tiene los nombres de las especies como \u00edndice y sus respectivas cantidades como dato asociado. Podemos acceder a una fila de un DataFarme o una Serie tanto a trav\u00e9s de su posici\u00f3n como a trav\u00e9s de su \u00edndice. Para acceder con el \u00edndice us\u00e1 loc[] como en los siguientes ejemplos: >>> df.loc[165] long -58.4684 lat -34.6648 id_arbol 166 altura_tot 5 diametro 10 inclinacio 0 id_especie 11 nombre_com Jacarand\u00e1 nombre_cie Jacarand\u00e1 mimosifolia tipo_folla \u00c1rbol Latifoliado Caducifolio espacio_ve INDOAMERICANO ubicacion LACARRA, Av. - ESCALADA, Av. - CASTA\u00d1ARES, Av.... nombre_fam Bignoni\u00e1ceas nombre_gen Jacarand\u00e1 origen Nativo/Aut\u00f3ctono coord_x 99534.3 coord_y 96061.8 Name: 165, dtype: object >>> cant_ejemplares.loc['Eucalipto'] 4112 Para acceder por n\u00famero de posici\u00f3n us\u00e1 iloc , como se muestra a continuaci\u00f3n. >>> df_jacarandas.iloc[0] altura_tot 5 diametro 10 inclinacio 0 Name: 165, dtype: int64 Observ\u00e1 que esto nos devuelve los datos de la primera fila de df_jacarandas que corresponde al \u00edndice 165 (lo dice en la \u00faltima l\u00ednea). Tambi\u00e9n podemos acceder a rebanadas (slices) usando iloc : >>> cant_ejemplares.iloc[0:3] Eucalipto 4112 Tipa blanca 4031 Jacarand\u00e1 3255 Name: nombre_com, dtype: int64 Por otra parte, podemos seleccionar tanto filas como columnas, si separamos con comas las respectivas selecciones: >>> df_jacarandas.iloc[-5:,2] 51104 4 51172 8 51180 0 51207 0 51375 20 Name: inclinacio, dtype: int64 Esto nos devuelve los datos correspondientes a las \u00faltimas 5 filas y a la tercera columna ('inclinacio'). Fijate que siempre vienen acompa\u00f1ados del \u00edndice. Selecci\u00f3n de una columna Si queremos seleccionar una sola columna podemos especificarla por medio de su nombre. Recordemos que al tomar una sola columna obtenemos una serie en lugar de un DataFrame: >>> df_jacarandas_diam = df_jacarandas['diametro'] >>> type(df_jacarandas) pandas.core.frame.DataFrame >>> type(df_jacarandas_diam) pandas.core.series.Series Series temporales en Pandas Pandas tiene un gran potencial para el manejo de series temporales. Es muy sencillo crear \u00edndices con fechas y frecuencias seleccionadas. >>> pd.date_range('20200923', periods = 7) DatetimeIndex(['2020-09-23', '2020-09-24', '2020-09-25', '2020-09-26', '2020-09-27', '2020-09-28', '2020-09-29'], dtype='datetime64[ns]', freq='D') >>> pd.date_range('20200923 14:00', periods = 7) DatetimeIndex(['2020-09-23 14:00:00', '2020-09-24 14:00:00', '2020-09-25 14:00:00', '2020-09-26 14:00:00', '2020-09-27 14:00:00', '2020-09-28 14:00:00', '2020-09-29 14:00:00'], dtype='datetime64[ns]', freq='D') >>> pd.date_range('20200923 14:00', periods = 6, freq = 'H') DatetimeIndex(['2020-09-23 14:00:00', '2020-09-23 15:00:00', '2020-09-23 16:00:00', '2020-09-23 17:00:00', '2020-09-23 18:00:00', '2020-09-23 19:00:00'], dtype='datetime64[ns]', freq='H') Luego, pod\u00e9s usar esos \u00edndices junto con datos para armar series temporales o DataFrames: >>> pd.Series([1, 2, 3, 4, 5, 6], index = pd.date_range('20200923 14:00', periods = 6, freq = 'H')) 2020-09-23 14:00:00 1 2020-09-23 15:00:00 2 2020-09-23 16:00:00 3 2020-09-23 17:00:00 4 2020-09-23 18:00:00 5 2020-09-23 19:00:00 6 Freq: H, dtype: int64 Caminatas al azar Volviendo al tema de las caminatas al azar, podemos hacer una caminata de dos horas dando un paso por minuto a partir del comienzo de esta clase con el siguiente comando: import numpy as np idx = pd.date_range('20200923 14:00', periods = 120, freq = 'min') s1 = pd.Series(np.random.randint(-1,2,120), index = idx) s2 = s1.cumsum() Observ\u00e1 que estamos usando random del m\u00f3dulo numpy, no de random. La funci\u00f3n np.random.randint(-1,2,120) genera un array de longitud 120 con valores -1, 0, 1 (no incluye extremo derecho del rango de valores). Podemos ver el gr\u00e1fico sencillamente: s2.plot() O usar una media m\u00f3vil (rolling mean) para suavizar los datos: w = 5 # ancho en minutos de la ventana s3 = s2.rolling(w).mean() s3.plot() Pod\u00e9s ver ambas curvas en un mismo gr\u00e1fico para ver m\u00e1s claramente el efecto del suavizado: df_series_23 = pd.DataFrame([s2, s3]).T # armo un dataframe con ambas series df_series_23.plot() Fijate que los datos de la curva suavizada empiezan m\u00e1s tarde, porque al principio no hay datos sobre los cuales hacer promedio. El par\u00e1metro min_periods = 1 del m\u00e9todo rolling te permite controlar esto. Probalo. Ejemplo: 12 personas caminando 8 horas En el siguiente ejemplo creamos un \u00edndice que contenga un elemento por minuto a partir del comienzo de la clase y durante 8 horas. Armamos tambi\u00e9n una lista de nombres. horas = 8 idx = pd.date_range('20200923 14:00', periods = horas*60, freq = 'min') nombres = ['Pedro', 'Santiago', 'Juan', 'Andr\u00e9s','Bartolom\u00e9','Tiago','Isca','Tadeo','Mateo','Felipe','Sim\u00f3n','Tom\u00e1s'] Luego usamos el m\u00f3dulo random de numpy para generar pasos para cada persona a cada minuto. Los acumulamos con cumsum y los acomodamos en un DataFrame, usando el \u00edndice generado antes y poni\u00e9ndoles nombres adecuados a cada columna: df_walks = pd.DataFrame(np.random.randint(-1,2,[horas*60,12]).cumsum(axis=0), index = idx, columns = nombres) df_walks.plot() Ahora suavizamos los datos, usando min_periods para no perder los datos de los extremos. w = 45 df_walk_suav = df_walks.rolling(w, min_periods = 1).mean() # datos suavizados nsuav = ['S_' + n for n in nombres] df_walk_suav.columns = nsuav # cambio el nombre de las columnas # para los datos suavizados df_walk_suav.plot() Guardando datos Guardar una serie o un DataFrame en el disco es algo realmente sencillo. Prob\u00e1, por ejemplo, el efecto del comando df_walk_suav.to_csv('caminata_apostolica.csv') . Incorporando el Arbolado lineal Ejercicio 8.7: Lectura y selecci\u00f3n Vamos a trabajar ahora con el archivo 'arbolado-publico-lineal-2017-2018.csv' . Descargalo y guardalo en tu directorio '../Data/'. Levantalo y arm\u00e1 un DataFrame df_lineal que tenga solamente las siguiente columnas: cols_sel = ['nombre_cientifico', 'ancho_acera', 'diametro_altura_pecho', 'altura_arbol'] Imprim\u00ed las diez especies m\u00e1s frecuentes con sus respectivas cantidades. Trabajaremos con las siguientes especies seleccionadas: especies_seleccionadas = ['Tilia x moltkei', 'Jacaranda mimosifolia', 'Tipuana tipu'] Una forma de seleccionarlas es la siguiente: df_lineal_seleccion = df_lineal[df_lineal['nombre_cientifico'].isin(especies_seleccionadas)] Ejercicio 8.8: Boxplots El siguiente comando realiza un boxplot de los di\u00e1metros de los \u00e1rboles agrupados por especie. df_lineal_seleccion.boxplot('diametro_altura_pecho', by = 'nombre_cientifico') Realiz\u00e1 un gr\u00e1fico similar pero de los altos en lugar de los di\u00e1metros de los \u00e1rboles. Ejemplo de pairplot Otro gr\u00e1fico interesante que resume muy bien la informaci\u00f3n es el pairplot de seaborn que es una grilla cuadrada de subplots. Prob\u00e1 el siguiente c\u00f3digo: sns.pairplot(data = df_lineal_seleccion[cols_sel], hue = 'nombre_cientifico') El gr\u00e1fico va a tener una fila (y columna) por cada variable num\u00e9rica en el DataFrame pasado como data . En la diagonal del g\u0155afico, va a haber kdeplots (kernel density estimation plots, una versi\u00f3n suavizada de los histogramas) y fuera de la diagonal scatterplots combinando todos los pares de variables (cada combinaci\u00f3n aparece dos veces, una sobre y otra debajo de la diagonal). El hue selecciona la variable categ\u00f3rica a usar para distinguir subgrupos y asociarles colores. En la diagonal de este ejemplo (y en los scatterplots tambi\u00e9n) se ve por ejemplo que las Tipas suelen ser m\u00e1s anchas y m\u00e1s altas que los Tilos y los Jacarand\u00e1s. Pregunta: \u00bfPor qu\u00e9 el ancho_acera no tiene lugar en el gr\u00e1fico? Te recomendamos pegarle una mirada a esta p\u00e1gina donde vas a poder ver un poco m\u00e1s sobre el potencial de seaborn. Ejercicio 8.9: Comparando especies en parques y en veredas Al comienzo de la materia estuvimos trabajando con el dataset de \u00e1rboles en parques. Ahora estuvimos analizando otro dataset: el de \u00e1rboles en veredas. Ahora queremos estudiar si hay diferencias entre los ejemplares de una misma especie seg\u00fan si crecen en un sitio o en otro. Queremos hacer un boxplot del di\u00e1metro a la altura del pecho para las Tipas (su nombre cient\u00edfico es tipuana tipu ), que crecen en ambos tipos de ambiente. Para eso tendremos que juntar datos de dos bases de datos diferentes. Nos vamos en meter en un l\u00edo. El GCBA usa en un dataset 'altura_tot', 'diametro' y 'nombre_cie' para las alturas, di\u00e1metros y nombres cient\u00edficos de los ejemplares, y en el otro dataset usa 'altura_arbol', 'diametro_altura_pecho' y 'nombre_cientifico' para los mismos datos. Es m\u00e1s, los nombres cient\u00edficos var\u00edan de un dataset al otro. 'Tipuana Tipu' se transforma en 'Tipuana tipu' y 'Jacarand\u00e1 mimosifolia' en 'Jacaranda mimosifolia'. Obviamente son cambios menores pero suficientes para desalentar al usuarie desprevenide. En este ejercicio te proponemos los siguientes pasos para comparar los di\u00e1metros a la altura del pecho de las tipas en ambos tipos de entornos. Guard\u00e1 este trabajo en un archivo arbolado_parques_veredas.py . Abr\u00ed ambos datasets a los que llamaremos df_parques y df_veredas. Para cada dataset armate otro seleccionando solamente las filas correspondientes a las tipas (llamalos df_tipas_parques y df_tipas_veredas, respectivamente) y las columnas correspondientes al diametro a la altura del pecho y alturas. Hacelo como copias (usando .copy() como hicimos m\u00e1s arriba) para poder trabajar en estos nuevos dataframes sin modificar los dataframes grandes originales. Renombr\u00e1 las columnas que muestran la altura y el di\u00e1metro a la altura del pecho para que se llamen igual en ambos dataframes, para ello explor\u00e1 el comando rename . Agregale a cada dataframe (df_tipas_parques y df_tipas_veredas) una columna llamada 'ambiente' que en un caso valga siempre 'parque' y en el otro caso 'vereda'. Junt\u00e1 ambos datasets con el comando df_tipas = pd.concat([df_tipas_veredas, df_tipas_parques]) . De esta forma tenemos en un mismo dataframe la informaci\u00f3n de las tipas distinguidas por ambiente. Cre\u00e1 un boxplot para los di\u00e1metros a la altura del pecho de la tipas distinguiendo los ambientes ( boxplot('diametro_altura_pecho',by = 'ambiente') ). Repet\u00ed para alturas. \u00bfQu\u00e9 tendr\u00edas que cambiar para repetir el an\u00e1lisis para otras especies? \u00bfConvendr\u00eda definir una funci\u00f3n? Contenidos | Anterior (4 Ordenar archivos en Python) | Pr\u00f3ximo (6 Series temporales)","title":"05 Pandas"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#85-introduccion-a-pandas","text":"La biblioteca Pandas es una extensi\u00f3n de NumPy para manipulaci\u00f3n y an\u00e1lisis de datos. En particular, ofrece estructuras de datos y operaciones para manipular tablas de datos (num\u00e9ricos y de otros tipos) y series temporales. Se distribuye como software libre. \u00c9sta es una breve introducci\u00f3n a Pandas . Para informaci\u00f3n m\u00e1s completa, te recomendamos consultar la documentaci\u00f3n oficial . Esta biblioteca tiene dos tipos de datos fundamentales: los DataFrames que almacenan tablas de datos y las series que contienen secuencias de datos. Esta secci\u00f3n tiene un breve video introductorio sobre las posibilidades que ofrece la biblioteca Pandas.","title":"8.5 Introducci\u00f3n a Pandas"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#lectura-de-datos","text":"Pandas permite leer diversos formatos de tablas de datos directamente. Prob\u00e1 el siguiente c\u00f3digo, para leer un archivo CSV: import pandas as pd import os directorio = '../Data' archivo = 'arbolado-en-espacios-verdes.csv' fname = os.path.join(directorio,archivo) df = pd.read_csv(fname) La variable df es de tipo DataFrame y contiene todos los datos del archivo csv estructurados adecuadamente. Con df.head() pod\u00e9s ver las primeras l\u00edneas de datos. Si a head le pas\u00e1s un n\u00famero como par\u00e1metro pod\u00e9s seleccionar cu\u00e1ntas l\u00edneas quer\u00e9s ver. An\u00e1logamente con df.tail(n) ver\u00e1s las \u00faltimas n l\u00edneas de datos. >>> df.head() long lat id_arbol ... origen coord_x coord_y 0 -58.477564 -34.645015 1 ... Ex\u00f3tico 98692.305719 98253.300738 1 -58.477559 -34.645047 2 ... Ex\u00f3tico 98692.751564 98249.733979 2 -58.477551 -34.645091 3 ... Ex\u00f3tico 98693.494639 98244.829684 3 -58.478129 -34.644567 4 ... Nativo/Aut\u00f3ctono 98640.439091 98302.938142 4 -58.478121 -34.644598 5 ... Nativo/Aut\u00f3ctono 98641.182166 98299.519997 Usando df.columns pandas te va a devolver un \u00edndice con los nombres de las columnas del DataFrame. Record\u00e1 que en la Secci\u00f3n 3.6 describimos la base de datos. A su vez, df.index te mostrar\u00e1 el \u00edndice. En este caso el \u00edndice es num\u00e9rico y se corresponde con el n\u00famero de la l\u00ednea leida del archivo. En principio no es muy interesante para analizar cuestiones de \u00e1rboles, simplemente tenemos las filas numeradas. Veremos otros ejemplos donde el \u00edndice puede contener informaci\u00f3n vital (una categor\u00eda, un timestamp, etc). >>> df.columns Index(['long', 'lat', 'id_arbol', 'altura_tot', 'diametro', 'inclinacio', 'id_especie', 'nombre_com', 'nombre_cie', 'tipo_folla', 'espacio_ve', 'ubicacion', 'nombre_fam', 'nombre_gen', 'origen', 'coord_x', 'coord_y'], dtype='object') >>> df.index RangeIndex(start=0, stop=51502, step=1) Otra herramienta \u00fatil para inspeccionar los datos reci\u00e9n levantados es describe() . Para ver mejor una parte, podemos seleccionar algunas columnas de inter\u00e9s antes de pedirle la descripci\u00f3n. >>> df[['altura_tot', 'diametro', 'inclinacio']].describe() altura_tot diametro inclinacio count 51502.000000 51502.000000 51502.000000 mean 12.167100 39.395616 3.472215 std 7.640309 31.171205 7.039495 min 0.000000 1.000000 0.000000 25% 6.000000 18.000000 0.000000 50% 11.000000 32.000000 0.000000 75% 18.000000 54.000000 5.000000 max 54.000000 500.000000 90.000000","title":"Lectura de datos"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#seleccion","text":"Una de las operaciones primitivas m\u00e1s importantes es la selecci\u00f3n de fragmentos de las tablas de datos, ya sean filas, columnas o rangos de filas y columnas. Por ejemplo con df['nombre_com'] veremos la columna (que es una serie) de nombres comunes de los \u00e1rboles en la base. Podemos usar unique para ver una vez cada nombre: >>> df['nombre_com'].unique() array(['Washingtonia (Palmera washingtonia)', 'Omb\u00fa', 'Catalpa', 'Ceibo', 'Brachichiton (\u00c1rbol botella, Brachichito)', '\u00c1lamo plateado', 'Acacia de constantinopla', 'Acacia', 'Roble sedoso (Grevillea)', ... 'Jazm\u00edn del Paraguay', 'Plumerillo rojo', '\u00c1rbol fuccia', 'Canela de venado', 'Boj cepillo', 'Caranday'], dtype=object) Podemos preguntar cu\u00e1les se llaman de cierta manera ('Omb\u00fa' en este caso), como hac\u00edamos con los ndarrays en numpy: >>> df['nombre_com'] == 'Omb\u00fa' 0 False 1 False 2 False 3 True ... Observ\u00e1 que esto gener\u00f3 una serie. Podemos sumar los True de esta serie para contar la cantidad de Omb\u00fas: >>> (df['nombre_com'] == 'Omb\u00fa').sum() 590 Si queremos hacer lo mismo para otras especies podemos usar value_counts() >>> cant_ejemplares = df['nombre_com'].value_counts() >>> cant_ejemplares.head(10) Eucalipto 4112 Tipa blanca 4031 Jacarand\u00e1 3255 Palo borracho rosado 3150 Casuarina 2719 Fresno americano 2166 Pl\u00e1tano 1556 Cipr\u00e9s 1467 Ceibo 1149 Pind\u00f3 1068 Name: nombre_com, dtype: int64 De esta forma obtenemos, en orden decreciente, los nombres comunes y las cantidades de las especies m\u00e1s frecuentes en la base de datos.","title":"Selecci\u00f3n"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#filtros-booleanos","text":"La serie booleana que obtuvimos con df['nombre_com'] == 'Omb\u00fa' puede usarse para seleccionar esas filas del DataFrame. Probemos con Jacarand\u00e1: >>> df_jacarandas = df[df['nombre_com'] == 'Jacarand\u00e1'] An\u00e1logamente, podemos seleccionar algunas columnas de inter\u00e9s y generar vistas (ojo, en estos casos no estamos copiando la informaci\u00f3n): >>> cols = ['altura_tot', 'diametro', 'inclinacio'] >>> df_jacarandas = df_jacarandas[cols] >>> df_jacarandas.tail() altura_tot diametro inclinacio 51104 7 97 4 51172 8 28 8 51180 2 30 0 51207 3 10 0 51375 17 40 20 >>> df_jacarandas.describe() altura_tot diametro inclinacio count 3255.000000 3255.000000 3255.000000 mean 10.369585 28.804301 6.549923 std 5.905744 19.166388 8.459921 min 1.000000 1.000000 0.000000 25% 6.000000 14.000000 0.000000 50% 10.000000 25.000000 4.000000 75% 15.000000 41.000000 10.000000 max 49.000000 159.000000 70.000000 Observ\u00e1 que cuando le pedimos los \u00faltimos datos de df_jacarandas nos mostr\u00f3 los \u00faltimos 5 jacarand\u00e1s de la base de datos, respetando los n\u00fameros de \u00edndice de la tabla original (..., 51207, 51375). Si vas a querer modificar df_jacarandas es conveniente crear una copia de los datos de df en lugar de simplemente una vista. Esto se puede hacer con el m\u00e9todo copy() como en el siguiente ejemplo. >>> df_jacarandas = df[df['nombre_com'] == 'Jacarand\u00e1'][cols].copy()","title":"Filtros booleanos"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#scatterplots","text":"Pandas tambi\u00e9n permite hacer gr\u00e1ficos bonitos . Es realmente sencillo: df_jacarandas.plot.scatter(x = 'diametro', y = 'altura_tot') Hay otro m\u00f3dulo para hacer gr\u00e1ficos que interact\u00faa muy bien con pandas y se llama Seaborn . Est\u00e1 basado en matplotlib, y ofrece una interfaz de alto nivel para realizar gr\u00e1ficos estad\u00edsticos atractivos e informativos. En criollo: \"usar pandas para manejar los datos y seaborn para visualizarlos, es la posta\". Fijate que seaborn entiende los DataFrames y las columnas y su sintaxis es muy similar a la de pandas: import seaborn as sns sns.scatterplot(data = df_jacarandas, x = 'diametro', y = 'altura_tot')","title":"Scatterplots"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#filtros-por-indice-y-por-posicion","text":"Como ya mencionamos, el \u00edndice de df no tiene una sem\u00e1ntica interesante. Veamos, en cambio, que la serie que generamos con cant_ejemplares = df['nombre_com'].value_counts() s\u00ed lo tiene: >>> cant_ejemplares.index Index(['Eucalipto', 'Tipa blanca', 'Jacarand\u00e1', 'Palo borracho rosado', 'Casuarina', 'Fresno americano', 'Pl\u00e1tano', 'Cipr\u00e9s', 'Ceibo', 'Pind\u00f3', ... 'Naranjo dulce', 'Peltophorum', 'Ligustrina de California', 'Afrocarpus', 'Caranday', 'Esterculea', 'Boj cepillo', 'Sesbania', 'Ligustrum', '\u00c1rbol del humo'], dtype='object', length=337) cant_ejemplares es una serie (es como un DataFrame de una sola columna). Tiene los nombres de las especies como \u00edndice y sus respectivas cantidades como dato asociado. Podemos acceder a una fila de un DataFarme o una Serie tanto a trav\u00e9s de su posici\u00f3n como a trav\u00e9s de su \u00edndice. Para acceder con el \u00edndice us\u00e1 loc[] como en los siguientes ejemplos: >>> df.loc[165] long -58.4684 lat -34.6648 id_arbol 166 altura_tot 5 diametro 10 inclinacio 0 id_especie 11 nombre_com Jacarand\u00e1 nombre_cie Jacarand\u00e1 mimosifolia tipo_folla \u00c1rbol Latifoliado Caducifolio espacio_ve INDOAMERICANO ubicacion LACARRA, Av. - ESCALADA, Av. - CASTA\u00d1ARES, Av.... nombre_fam Bignoni\u00e1ceas nombre_gen Jacarand\u00e1 origen Nativo/Aut\u00f3ctono coord_x 99534.3 coord_y 96061.8 Name: 165, dtype: object >>> cant_ejemplares.loc['Eucalipto'] 4112 Para acceder por n\u00famero de posici\u00f3n us\u00e1 iloc , como se muestra a continuaci\u00f3n. >>> df_jacarandas.iloc[0] altura_tot 5 diametro 10 inclinacio 0 Name: 165, dtype: int64 Observ\u00e1 que esto nos devuelve los datos de la primera fila de df_jacarandas que corresponde al \u00edndice 165 (lo dice en la \u00faltima l\u00ednea). Tambi\u00e9n podemos acceder a rebanadas (slices) usando iloc : >>> cant_ejemplares.iloc[0:3] Eucalipto 4112 Tipa blanca 4031 Jacarand\u00e1 3255 Name: nombre_com, dtype: int64 Por otra parte, podemos seleccionar tanto filas como columnas, si separamos con comas las respectivas selecciones: >>> df_jacarandas.iloc[-5:,2] 51104 4 51172 8 51180 0 51207 0 51375 20 Name: inclinacio, dtype: int64 Esto nos devuelve los datos correspondientes a las \u00faltimas 5 filas y a la tercera columna ('inclinacio'). Fijate que siempre vienen acompa\u00f1ados del \u00edndice.","title":"Filtros por \u00edndice y por posici\u00f3n"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#seleccion-de-una-columna","text":"Si queremos seleccionar una sola columna podemos especificarla por medio de su nombre. Recordemos que al tomar una sola columna obtenemos una serie en lugar de un DataFrame: >>> df_jacarandas_diam = df_jacarandas['diametro'] >>> type(df_jacarandas) pandas.core.frame.DataFrame >>> type(df_jacarandas_diam) pandas.core.series.Series","title":"Selecci\u00f3n de una columna"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#series-temporales-en-pandas","text":"Pandas tiene un gran potencial para el manejo de series temporales. Es muy sencillo crear \u00edndices con fechas y frecuencias seleccionadas. >>> pd.date_range('20200923', periods = 7) DatetimeIndex(['2020-09-23', '2020-09-24', '2020-09-25', '2020-09-26', '2020-09-27', '2020-09-28', '2020-09-29'], dtype='datetime64[ns]', freq='D') >>> pd.date_range('20200923 14:00', periods = 7) DatetimeIndex(['2020-09-23 14:00:00', '2020-09-24 14:00:00', '2020-09-25 14:00:00', '2020-09-26 14:00:00', '2020-09-27 14:00:00', '2020-09-28 14:00:00', '2020-09-29 14:00:00'], dtype='datetime64[ns]', freq='D') >>> pd.date_range('20200923 14:00', periods = 6, freq = 'H') DatetimeIndex(['2020-09-23 14:00:00', '2020-09-23 15:00:00', '2020-09-23 16:00:00', '2020-09-23 17:00:00', '2020-09-23 18:00:00', '2020-09-23 19:00:00'], dtype='datetime64[ns]', freq='H') Luego, pod\u00e9s usar esos \u00edndices junto con datos para armar series temporales o DataFrames: >>> pd.Series([1, 2, 3, 4, 5, 6], index = pd.date_range('20200923 14:00', periods = 6, freq = 'H')) 2020-09-23 14:00:00 1 2020-09-23 15:00:00 2 2020-09-23 16:00:00 3 2020-09-23 17:00:00 4 2020-09-23 18:00:00 5 2020-09-23 19:00:00 6 Freq: H, dtype: int64","title":"Series temporales en Pandas"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#caminatas-al-azar","text":"Volviendo al tema de las caminatas al azar, podemos hacer una caminata de dos horas dando un paso por minuto a partir del comienzo de esta clase con el siguiente comando: import numpy as np idx = pd.date_range('20200923 14:00', periods = 120, freq = 'min') s1 = pd.Series(np.random.randint(-1,2,120), index = idx) s2 = s1.cumsum() Observ\u00e1 que estamos usando random del m\u00f3dulo numpy, no de random. La funci\u00f3n np.random.randint(-1,2,120) genera un array de longitud 120 con valores -1, 0, 1 (no incluye extremo derecho del rango de valores). Podemos ver el gr\u00e1fico sencillamente: s2.plot() O usar una media m\u00f3vil (rolling mean) para suavizar los datos: w = 5 # ancho en minutos de la ventana s3 = s2.rolling(w).mean() s3.plot() Pod\u00e9s ver ambas curvas en un mismo gr\u00e1fico para ver m\u00e1s claramente el efecto del suavizado: df_series_23 = pd.DataFrame([s2, s3]).T # armo un dataframe con ambas series df_series_23.plot() Fijate que los datos de la curva suavizada empiezan m\u00e1s tarde, porque al principio no hay datos sobre los cuales hacer promedio. El par\u00e1metro min_periods = 1 del m\u00e9todo rolling te permite controlar esto. Probalo.","title":"Caminatas al azar"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#ejemplo-12-personas-caminando-8-horas","text":"En el siguiente ejemplo creamos un \u00edndice que contenga un elemento por minuto a partir del comienzo de la clase y durante 8 horas. Armamos tambi\u00e9n una lista de nombres. horas = 8 idx = pd.date_range('20200923 14:00', periods = horas*60, freq = 'min') nombres = ['Pedro', 'Santiago', 'Juan', 'Andr\u00e9s','Bartolom\u00e9','Tiago','Isca','Tadeo','Mateo','Felipe','Sim\u00f3n','Tom\u00e1s'] Luego usamos el m\u00f3dulo random de numpy para generar pasos para cada persona a cada minuto. Los acumulamos con cumsum y los acomodamos en un DataFrame, usando el \u00edndice generado antes y poni\u00e9ndoles nombres adecuados a cada columna: df_walks = pd.DataFrame(np.random.randint(-1,2,[horas*60,12]).cumsum(axis=0), index = idx, columns = nombres) df_walks.plot() Ahora suavizamos los datos, usando min_periods para no perder los datos de los extremos. w = 45 df_walk_suav = df_walks.rolling(w, min_periods = 1).mean() # datos suavizados nsuav = ['S_' + n for n in nombres] df_walk_suav.columns = nsuav # cambio el nombre de las columnas # para los datos suavizados df_walk_suav.plot()","title":"Ejemplo: 12 personas caminando 8 horas"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#guardando-datos","text":"Guardar una serie o un DataFrame en el disco es algo realmente sencillo. Prob\u00e1, por ejemplo, el efecto del comando df_walk_suav.to_csv('caminata_apostolica.csv') .","title":"Guardando datos"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#incorporando-el-arbolado-lineal","text":"","title":"Incorporando el Arbolado lineal"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#ejercicio-87-lectura-y-seleccion","text":"Vamos a trabajar ahora con el archivo 'arbolado-publico-lineal-2017-2018.csv' . Descargalo y guardalo en tu directorio '../Data/'. Levantalo y arm\u00e1 un DataFrame df_lineal que tenga solamente las siguiente columnas: cols_sel = ['nombre_cientifico', 'ancho_acera', 'diametro_altura_pecho', 'altura_arbol'] Imprim\u00ed las diez especies m\u00e1s frecuentes con sus respectivas cantidades. Trabajaremos con las siguientes especies seleccionadas: especies_seleccionadas = ['Tilia x moltkei', 'Jacaranda mimosifolia', 'Tipuana tipu'] Una forma de seleccionarlas es la siguiente: df_lineal_seleccion = df_lineal[df_lineal['nombre_cientifico'].isin(especies_seleccionadas)]","title":"Ejercicio 8.7: Lectura y selecci\u00f3n"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#ejercicio-88-boxplots","text":"El siguiente comando realiza un boxplot de los di\u00e1metros de los \u00e1rboles agrupados por especie. df_lineal_seleccion.boxplot('diametro_altura_pecho', by = 'nombre_cientifico') Realiz\u00e1 un gr\u00e1fico similar pero de los altos en lugar de los di\u00e1metros de los \u00e1rboles.","title":"Ejercicio 8.8: Boxplots"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#ejemplo-de-pairplot","text":"Otro gr\u00e1fico interesante que resume muy bien la informaci\u00f3n es el pairplot de seaborn que es una grilla cuadrada de subplots. Prob\u00e1 el siguiente c\u00f3digo: sns.pairplot(data = df_lineal_seleccion[cols_sel], hue = 'nombre_cientifico') El gr\u00e1fico va a tener una fila (y columna) por cada variable num\u00e9rica en el DataFrame pasado como data . En la diagonal del g\u0155afico, va a haber kdeplots (kernel density estimation plots, una versi\u00f3n suavizada de los histogramas) y fuera de la diagonal scatterplots combinando todos los pares de variables (cada combinaci\u00f3n aparece dos veces, una sobre y otra debajo de la diagonal). El hue selecciona la variable categ\u00f3rica a usar para distinguir subgrupos y asociarles colores. En la diagonal de este ejemplo (y en los scatterplots tambi\u00e9n) se ve por ejemplo que las Tipas suelen ser m\u00e1s anchas y m\u00e1s altas que los Tilos y los Jacarand\u00e1s. Pregunta: \u00bfPor qu\u00e9 el ancho_acera no tiene lugar en el gr\u00e1fico? Te recomendamos pegarle una mirada a esta p\u00e1gina donde vas a poder ver un poco m\u00e1s sobre el potencial de seaborn.","title":"Ejemplo de pairplot"},{"location":"08_Fechas_Carpetas_y_Pandas/05_Pandas/#ejercicio-89-comparando-especies-en-parques-y-en-veredas","text":"Al comienzo de la materia estuvimos trabajando con el dataset de \u00e1rboles en parques. Ahora estuvimos analizando otro dataset: el de \u00e1rboles en veredas. Ahora queremos estudiar si hay diferencias entre los ejemplares de una misma especie seg\u00fan si crecen en un sitio o en otro. Queremos hacer un boxplot del di\u00e1metro a la altura del pecho para las Tipas (su nombre cient\u00edfico es tipuana tipu ), que crecen en ambos tipos de ambiente. Para eso tendremos que juntar datos de dos bases de datos diferentes. Nos vamos en meter en un l\u00edo. El GCBA usa en un dataset 'altura_tot', 'diametro' y 'nombre_cie' para las alturas, di\u00e1metros y nombres cient\u00edficos de los ejemplares, y en el otro dataset usa 'altura_arbol', 'diametro_altura_pecho' y 'nombre_cientifico' para los mismos datos. Es m\u00e1s, los nombres cient\u00edficos var\u00edan de un dataset al otro. 'Tipuana Tipu' se transforma en 'Tipuana tipu' y 'Jacarand\u00e1 mimosifolia' en 'Jacaranda mimosifolia'. Obviamente son cambios menores pero suficientes para desalentar al usuarie desprevenide. En este ejercicio te proponemos los siguientes pasos para comparar los di\u00e1metros a la altura del pecho de las tipas en ambos tipos de entornos. Guard\u00e1 este trabajo en un archivo arbolado_parques_veredas.py . Abr\u00ed ambos datasets a los que llamaremos df_parques y df_veredas. Para cada dataset armate otro seleccionando solamente las filas correspondientes a las tipas (llamalos df_tipas_parques y df_tipas_veredas, respectivamente) y las columnas correspondientes al diametro a la altura del pecho y alturas. Hacelo como copias (usando .copy() como hicimos m\u00e1s arriba) para poder trabajar en estos nuevos dataframes sin modificar los dataframes grandes originales. Renombr\u00e1 las columnas que muestran la altura y el di\u00e1metro a la altura del pecho para que se llamen igual en ambos dataframes, para ello explor\u00e1 el comando rename . Agregale a cada dataframe (df_tipas_parques y df_tipas_veredas) una columna llamada 'ambiente' que en un caso valga siempre 'parque' y en el otro caso 'vereda'. Junt\u00e1 ambos datasets con el comando df_tipas = pd.concat([df_tipas_veredas, df_tipas_parques]) . De esta forma tenemos en un mismo dataframe la informaci\u00f3n de las tipas distinguidas por ambiente. Cre\u00e1 un boxplot para los di\u00e1metros a la altura del pecho de la tipas distinguiendo los ambientes ( boxplot('diametro_altura_pecho',by = 'ambiente') ). Repet\u00ed para alturas. \u00bfQu\u00e9 tendr\u00edas que cambiar para repetir el an\u00e1lisis para otras especies? \u00bfConvendr\u00eda definir una funci\u00f3n? Contenidos | Anterior (4 Ordenar archivos en Python) | Pr\u00f3ximo (6 Series temporales)","title":"Ejercicio 8.9: Comparando especies en parques y en veredas"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/","text":"Contenidos | Anterior (5 Introducci\u00f3n a Pandas) | Pr\u00f3ximo (7 Cierre de la clase) 8.6 Series temporales Para esta Secci\u00f3n contamos con el valioso aporte de Octavio Bruzzone . Octavio da dos cursos de posgrado excelentes sobre Series Temporales en Python. Uno se enfoca en los an\u00e1lisis en el dominio del tiempo y el otro en el dominio de las frecuencias. Generosamente nos comparti\u00f3 algunas ideas para este trabajo pr\u00e1ctico. Esta secci\u00f3n tiene un breve video introductorio sobre los datos y lo que hay que hacer en este TP. An\u00e1lisis y visualizaci\u00f3n de series temporales. En este pr\u00e1ctico vamos a visualizar y analizar datos de mareas en el R\u00edo de la Plata. Tiene una primera parte que esperamos que todes hagan y una segunda parte, m\u00e1s larga y compleja, optativa. Trabaj\u00e1 en el archivo mareas_fft.py . Para comenzar, copiate el archivo con datos de mareas en los puertos de San Fernando y Buenos Aires a tu carpeta Data Lectura de archivos temporales import pandas as pd df = pd.read_csv('../Data/OBS_SHN_SF-BA.csv') Observ\u00e1 los datos: >>> df.head() Time H_SF H_BA 0 2011-01-01 00:00:00 NaN 92.0 1 2011-01-01 01:00:00 NaN 110.0 2 2011-01-01 02:00:00 NaN 124.0 3 2011-01-01 03:00:00 NaN 132.0 4 2011-01-01 04:00:00 NaN 136.0 >>> df.index RangeIndex(start=0, stop=35064, step=1) Este archivo tiene alturas del agua en el puerto de San Fernando (columna H_SF ) y en el puerto de Buenos Aires (columna H_BA ) medidas en cent\u00edmetros. Tiene un dato por hora (columna Time ) durante cuatro a\u00f1os. En los primeros registros se observa algo muy frecuente con este tipo de archivos: tiene muchos datos faltantes. El \u00edndice de un dataframe nos da informaci\u00f3n de su estructura. En este caso, est\u00e1 representando el n\u00famero de l\u00ednea del archivo que le\u00edmos. Pero un \u00edndice puede aportarnos m\u00e1s informaci\u00f3n relevante para nuestro problema, por lo que la propuesta es que el \u00edndice deber\u00eda ser el instante en le que se tom\u00f3 cada muestra ('Time'). Para esto tenemos que decirle a la funci\u00f3n read_csv dos cosas: * por un lado que use la columna 'Time' como \u00edndice (index_col = ['Time']) y * por el otro que la interprete como un timestamp (parse_dates = True). df = pd.read_csv('../Data/OBS_SHN_SF-BA.csv', index_col=['Time'], parse_dates=True) Observ\u00e1 la diferencia: >>> df.head() H_SF H_BA Time 2011-01-01 00:00:00 NaN 92.0 2011-01-01 01:00:00 NaN 110.0 2011-01-01 02:00:00 NaN 124.0 2011-01-01 03:00:00 NaN 132.0 2011-01-01 04:00:00 NaN 136.0 >>> df.index DatetimeIndex(['2011-01-01 00:00:00', '2011-01-01 01:00:00', ... '2014-12-31 22:00:00', '2014-12-31 23:00:00'], dtype='datetime64[ns]', name='Time', length=35064, freq=None) Que el \u00edndice sea temporal nos da una versatilidad genial para trabajar con estos datos. Prob\u00e1 por ejemplo los siguientes comandos: >>> df['1-18-2014 9:00':'1-18-2014 18:00'] H_SF H_BA Time 2014-01-18 09:00:00 85.0 67.0 2014-01-18 10:00:00 79.0 60.0 2014-01-18 11:00:00 73.0 49.0 2014-01-18 12:00:00 65.0 43.0 2014-01-18 13:00:00 59.0 36.0 2014-01-18 14:00:00 53.0 29.0 2014-01-18 15:00:00 48.0 22.0 2014-01-18 16:00:00 42.0 18.0 2014-01-18 17:00:00 36.0 33.0 2014-01-18 18:00:00 40.0 67.0 Prob\u00e1 tambi\u00e9n df['2-19-2014'] (observ\u00e1 que el formato de fechas que se usa es el de EEUU), y df['12-25-2014':] . Ondas de marea en el R\u00edo de la Plata Grafiquemos estos \u00faltimos datos: df['12-25-2014':].plot() Ac\u00e1 se ven tres fen\u00f3menos interesantes: * Hay 14 picos en 7 d\u00edas, esto corresponde a la frecuencia semidiurna de las mareas. Cada poco m\u00e1s de 12hs tenemos un ciclo con pleamar y bajamar. Dos ciclos por d\u00eda. * Por otra parte, se ve que las mareas en San Fernando est\u00e1n retrasadas respecto a las de Buenos Aires. Esto se debe a que las ondas de marea vienen del oc\u00e9ano atl\u00e1ntico y se propagan por el estuario del r\u00edo de la Plata, pasando primero por Buenos Aires y llegando luego, con retraso, a San Fernando. En ciertas condiciones esta onda de mareas puede llegar a la ciudad de Rosario, aunque se va atenuando en su viaje desde el atl\u00e1ntico. Finalmente, hay una marcada diferencia entre la altura registrada en San Fernando y la de Buenos Aires. Esto se debe a que las dos escalas, a partir de las que se registran los datos, tienen ceros que no est\u00e1n nivelados. En este pr\u00e1ctico nos proponemos estudiar la propagaci\u00f3n de esta onda de marea que es generada por la atracci\u00f3n gravitacional que ejercen la luna y el sol sobre el agua. Vamos a usar una transformada de Fourier que nos permite estudiar las frecuencias predominantes en la serie de alturas. Las mareas se ver\u00e1n claramente porque estos efectos astron\u00f3micos son regulares y tienen frecuencias invariantes. Vientos y ondas de tormenta en el R\u00edo de la Plata Si miramos un gr\u00e1fico un poco m\u00e1s extendido en el tiempo vamos a ver que las alturas no solo fluct\u00faan con las mareas semidiurnas sino que la componente meteorol\u00f3gica (vientos principalmente, que generan ondas de tormenta ) modifica las alturas de manera muy considerable. El siguiente comando genera un gr\u00e1fico entre el 15 de octubre de 2014 y el 15 de diciembre del mismo a\u00f1o. df['10-15-2014':'12-15-2014'].plot() En ese gr\u00e1fico se puede observar c\u00f3mo una sudestada a principios de noviembre elev\u00f3 el nivel del estuario m\u00e1s de un metro durante casi tres d\u00edas. Las dos fotos que siguen son justamente de esa sudestada. Fueron tomadas el primero de noviembre por Gustavo Castaing. As\u00ed como el viento del sudeste empuja el agua del mar hacia adentro del estuario y genera crecidas, los vientos del norte o el oeste tambi\u00e9n impulsan desplazamientos del agua del estuario, en este caso generando bajantes. En las siguientes dos fotos puede verse una bajante capturada por Juan Pablo Mart\u00ednez Bigozzi el 19 de junio del 2019. La transformada de Fourier no resultar\u00e1 muy \u00fatil para ver estas ondas de tormenta . Como carecen de regularidad, no aparecer\u00e1n claramente en el espectro de frecuencias. Ejercicio 8.10: Trabajemos con una copia de este fragmento: dh = df['12-25-2014':].copy() Podemos desplazar (shift en ingl\u00e9s) una Serie de Pandas usando el m\u00e9todo ds.shift(pasos) . Adem\u00e1s, podemos subir o bajar su gr\u00e1fico sumando una constante a todas las mediciones ds + cte . Finalmente podemos unir dos series en un DataFrame de manera muy simple, para poder graficarlas juntas. Si concatenamos estas operaciones obtenemos algo as\u00ed: delta_t = 0 # tiempo que tarda la marea entre ambos puertos delta_h = 0 # diferencia de los ceros de escala entre ambos puertos pd.DataFrame([dh['H_SF'].shift(delta_t) - delta_h, dh['H_BA']]).T.plot() Busc\u00e1 los valores de delta_t (es un n\u00famero entero, son pasos) y delta_h (puede tener decimales, es un float) que hacen que los dos gr\u00e1ficos se vean lo m\u00e1s similares posible. Guard\u00e1 tu c\u00f3digo en el archivo mareas_a_mano.py para entregar. Correlaci\u00f3n con desplazamientos El siguiente c\u00f3digo calcula y grafica el coeficiente de correlaci\u00f3n r de Pearson entre la serie de alturas en Buenos Aires y la de San Fernando desplazada temporalmente. import numpy as np import pandas as pd from scipy.stats import pearsonr import matplotlib.pyplot as plt # Levanto las dos series df=pd.read_csv('../Data/OBS_SHN_SF-BA.csv',index_col=['Time'],parse_dates=True) # Me quedo con un fregmento dh=df['10-01-2014':].copy() # Selecciono los intervalos que voy a usar para desplazar SF shifts = np.arange(-12,13) # Genero un vector donde guardar los coeficientes de correlacion para cada deslpazamiento corrs = np.zeros(shifts.shape) for i, sh in enumerate(shifts): #guardo el coeficiente de correlaci\u00f3n r entre de SF desplazada con BA original. corrs[i] = pearsonr(dh['H_SF'].shift(sh)[12:-12],dh['H_BA'][12:-12])[0] # ploteo los resultados plt.plot(shifts, corrs) Ejercicio 8.11: Interpolaci\u00f3n Este ejemplo muestra una manera de interplolar la serie de manera de poder usar desplazamientos menores a una hora. # Cada cuarto de hora df=pd.read_csv('../Data/OBS_SHN_SF-BA.csv',index_col=['Time'],parse_dates=True) dh =df['10-01-2014':].copy() #ultimo trimestre freq_horaria = 4 # 4 para 15min, 60 para 1min cant_horas = 24 N = cant_horas * freq_horaria #resampleo cada tantos minutos dh = dh.resample(f'{int(60/freq_horaria)}T').mean() #rellenos los NaNs suavemente dh =dh.interpolate(method='quadratic') # genero vector de desplazamientos (enteros) ishifts = np.arange(-N,N+1) # y su desplamiento horario asociado shifts=ishifts/freq_horaria # finalmente calculo las correlaciones correspondientes corrs = np.zeros(shifts.shape) for i, sh in enumerate(ishifts): corrs[i] = pearsonr(dh['H_SF'].shift(sh)[N:-N],dh['H_BA'][N:-N])[0] # y grafico plt.plot(shifts, corrs) El comando np.argmax(corrs) se puede usar para devolver la coordenada de la m\u00e1xima correlaci\u00f3n. Esa posici\u00f3n del vector shifts indicar\u00e1 a cu\u00e1ntas horas corresponde ese desplazamiento. Si lo corremos con esta interpolaci\u00f3n cada 15 minutos propuesta en el c\u00f3digo, obtendremos que la onda tarda una hora en llegar a San Fernando. Usando una interpolaci\u00f3n m\u00e1s fina, \u00bfpod\u00e9s estimar el desfazaje en minutos? A nosotros nos dio 57 minutos. Parte optativa En lo que sigue vamos a usar herramientas matem\u00e1ticas para hacer un an\u00e1lisis similar al que hicimos reci\u00e9n de manera artesanal . Para una onda sinusoidal, el desplazamiento horizontal corresponde a una diferencia de fase y el desplazamiento vertical es simplemente una constante aditiva. Vamos a descomponer la serie de alturas observadas del agua por medio de la transformada de Fourier. Las ondas de marea se mueven lentamente y tardan cierto tiempo en llegar de un puerto a otro. En lo que sigue vamos a ver c\u00f3mo calcular el tiempo que le toma a esta onda en desplazarse de Buenos Aires hasta San Fernando. Lo que sigue es optativo . An\u00e1lisis por medio de transformadas de Fourier La transformada de Fourier descompone una se\u00f1al en una suma de senos y cosenos (sinusoides) con diferentes frecuencias y amplitudes. Esta animaci\u00f3n ilustra gr\u00e1ficamente el proceso de la transformada de Fourier. La transformada da, para cada frecuencia, un n\u00famero complejo a + bi que puede pensarse como un vector (a,b) en el plano. La parte real va a multiplicar un coseno con la frecuencia indicada y la parte imaginaria un seno con la misma frecuencia. La magnitud (o amplitud, o potencia) de la se\u00f1al en esa frecuencia se corresponde con el largo del vector (a, b) . La fase (o desplazamiento del m\u00e1ximo respecto del origen de las coordenadas), se corresponde con \u00e1ngulo que forma este vector (a, b) con el semieje de los reales positivos. Aqu\u00ed, la variable theta (\u03b8) representa el desplazamiento de fase de la curva azul (respecto a la roja que tiene desplazamiento nulo). Esta fase suele medirse en radianes, correspondiendo 2*\u03c0 a un ciclo completo de desfasaje. Vamos a aplicar estas herramientas al an\u00e1lisis de la propagaci\u00f3n de la onda de marea por el estuario del plata. Preparaci\u00f3n de m\u00f3dulos y datos Vamos a usar los siguientes m\u00f3dulos: from scipy import signal # para procesar se\u00f1ales import numpy as np import matplotlib.pyplot as plt Seleccionemos las dos series como vectores de numpy (con el m\u00e9todo to_numpy() ). inicio = '2014-01' fin = '2014-06' alturas_sf = df[inicio:fin]['H_SF'].to_numpy() alturas_ba = df[inicio:fin]['H_BA'].to_numpy() Primero definamos una funci\u00f3n que calcule la transformada de Fourier para datos horarios y considerando como unidad de frecuencia los d\u00edas (descartamos la mitad de los coeficientes de la transformada porque los datos son reales y no complejos). Pod\u00e9s tomarla como una caja negra por ahora... def calcular_fft(y, freq_sampleo = 24.0): '''y debe ser un vector con n\u00fameros reales representando datos de una serie temporal. freq_sampleo est\u00e1 seteado para considerar 24 datos por unidad. Devuelve dos vectores, uno de frecuencias y otro con la transformada propiamente. La transformada contiene los valores complejos que se corresponden con respectivas frecuencias.''' N = len(y) freq = np.fft.fftfreq(N, d = 1/freq_sampleo)[:N//2] tran = (np.fft.fft(y)/N)[:N//2] return freq, tran Para poder analizar una onda por medio de su transformada de Fourier, es necesario que la onda sea peri\u00f3dica. Puede pasar que no sea el caso y que una onda tenga tendencia lineal, en ese caso podr\u00edamos usar la funci\u00f3n scipy.signal.detrend() . En nuestro caso supondremos que la marea media se mantuvo estable a lo largo del per\u00edodo de estudio, as\u00ed que no tenemos que hacerle este procesamiento intermedio. Espectro de potencia y de \u00e1ngulos para San Fernando Primero calculamos la transformada de las alturas de San Fernando. freq_sf, fft_sf = calcular_fft(alturas_sf) Si quisi\u00e9ramos graficar freq_sf contra fft_sf no podr\u00edamos ver mucho ya que fft_sf contiene n\u00fameros complejos. La potencia (o amplitud) para cada frecuencia se calcula como el m\u00f3dulo del n\u00famero complejo correspondiente (para la frecuencia freq_sf[i] y la potencia es abs(fft_sf[i]) ). Al graficar esto podemos ver la amplitud de los sinusoides para cada frecuencia. Este gr\u00e1fico se llama el espectro de potencias de la onda original. plt.plot(freq_sf, np.abs(fft_sf)) plt.xlabel(\"Frecuencia\") plt.ylabel(\"Potencia (energ\u00eda)\") plt.show() A simple vista se observan dos picos, uno en frecuencia 0 (constante relacionada con el cero de escala) y otro pico cercano a la frecuencia 2 (frecuencia semidiurna) que est\u00e1 relacionado con la onda de mareas. El pico en la primera posici\u00f3n efectivamente se corresponde con la frecuencia 0 y su amplitud es: >>> freq_sf[0] 0.0 >>> np.abs(fft_sf[0]) 111.83 A partir de esto podemos decir que las alturas del r\u00edo en San Fernando durante este per\u00edodo oscilan alrededor de los 111.8 cm de altura. Para analizar precisamente el pico semidiurno podemos usar find_peaks que provee scipy.signal para evitar hacerlo a ojo. Vamos a pedir aquellos picos que tengan al menos cierta diferencia con su entorno (prominencia), un buen valor para esto es el 8. Pod\u00e9s probar otros valores y observar el resultado. >>> print(signal.find_peaks(np.abs(fft_sf), prominence = 8)) (array([350]), {'prominences': array([11.4554514]), 'left_bases': array([307]), 'right_bases': array([2109])}) Esta respuesta nos indica que hay un pico con la prominencia solicitada (al menos 8), que tiene un magnitud de 11.45 y que corresponde a la posici\u00f3n 350 del vector. >>> freq_sf[350] 1.93 La frecuencia relacionada con esa posici\u00f3n es cercana a dos, como ya hab\u00edamos observado en el gr\u00e1fico (dos ciclos por d\u00eda). Podemos distinguir los picos agregando un punto rojo y mirando m\u00e1s de cerca el \u00e1rea de inter\u00e9s: plt.plot(freq_sf, np.abs(fft_sf)) plt.xlabel(\"Frecuencia\") plt.ylabel(\"Potencia (energ\u00eda)\") plt.xlim(0,4) plt.ylim(0,20) # me quedo solo con el \u00faltimo pico pico_sf = signal.find_peaks(np.abs(fft_sf), prominence = 8)[0][-1] # es el pico a analizar, el de la onda de mareas # marco ese pico con un circulito rojo plt.scatter(freq_sf[pico_sf], np.abs(fft_sf)[pico_sf], facecolor = 'r') plt.show() Estos gr\u00e1ficos permiten interpretar que si descomponemos la curva de alturas en San Fernando como suma de sinusoidales, el sinusoide con frecuencia 1.93 tiene una magnitud considerablemente llamativa. No es casualidad que este sea un punto distinguido: se trata de la frecuencia de las mareas lunares. Ahora viene la parte un poco m\u00e1s sut\u00edl: el an\u00e1lisis de las fases . Si conocemos la fase de estas componentes en dos puertos distintos, podremos estimar el tiempo que tarda en desplazarse la marea de uno a otro. Para calcular la fase (entre -\u03c0 y \u03c0) de dicha componente (la que ubicamos en la posici\u00f3n 350) en el puerto de San Fernando, podemos simplemente usar np.angle() y pasarle el n\u00famero complejo en cuesti\u00f3n: >>> ang_sf = np.angle(fft_sf)[pico_sf] >>> print(ang_sf) 1.4849 Obtenemos un valor cercano a pi/2. Recordemos que 2 pi corresponde a un desfasaje de un ciclo completo de la curva. Como nuestra curva de estudio tiene una frecuencia diaria ligeramente inferior a 2 (freq_sf[350]~1.93), 2 pi corresponde a 24/1.93 horas ~ 12.44 horas. Por lo tanto la fase obtenida con angSF[350] corresponde a un retardo de >>> ang_sf * 24 / (2 * np.pi * freq_sf[350]) 2.93 Es decir, este sinusoide est\u00e1 desfasado poco menos de 3hs respecto al seno neutro . Espectro de potencia y de \u00e1ngulos para Buenos Aires Repitamos velozmente el procedimiento para el puerto de Buenos Aires y analicemos las diferencias. freq_ba, fft_ba = calcular_fft(alturas_ba) plt.plot(freq_ba, np.abs(fft_ba)) plt.xlabel(\"Frecuencia\") plt.ylabel(\"Potencia (energ\u00eda)\") plt.xlim(0,4) plt.ylim(0,20) # me quedo solo con el \u00faltimo pico pico_ba = signal.find_peaks(np.abs(fft_ba), prominence = 8)[0][-1] #se grafican los picos como circulitos rojos plt.scatter(freq_ba[pico_ba], np.abs(fft_ba)[pico_ba], facecolor='r') plt.title(\"Espectro de Potencias Bs.As.\") plt.show() Si buscamos la constante alrededor de la que oscilan las mareas seg\u00fan el nivel del puerto de Buenos Aires obtenemos: >>> np.abs(fft_ba[0]) 88.21 Con este resultado es sencillo obtener una estimaci\u00f3n para la diferencia de alturas de los ceros de escala entre ambos puertos. Pregunta 1: \u00bfCu\u00e1l es la diferencia de altura media entre los puertos obtenida de esta forma? Pregunta 2: \u00bfDe qu\u00e9 otra forma se puede estimar el valor medio de un puerto? \u00bfCu\u00e1nto da la diferencia con este otro m\u00e9todo? Por otra parte, si observamos que el espectro de potencia vemos que los picos en ambos puertos son s\u00famamente similares. >>> print(signal.find_peaks(np.abs(fft_ba), prominence=8)) (array([350]), {'prominences': array([12.67228046]), 'left_bases': array([279]), 'right_bases': array([1000])}) Las mareas de Buenos Aires tiene una componente de m\u00e1xima amplitud en la frecuencia 1.93 (misma que San Fernando) y con una magnitud de 12.67 (bastante similar a la magnitud correspondiente en San Fernando). Resta estudiar la fase de la curva de los datos de df_ba en esta frecuencia para poder determinar con precisi\u00f3n la diferencia de fase entre ambos puertos para ondas de marea. Primero calculamos el \u00e1ngulo de la componente correspondiente y luego lo convertimos en horas usando el factor ang2h : >>> ang_ba = np.angle(fft_ba)[pico_ba] >>> print(ang_ba) 1.96 >>> freq = freq_ba[pico_ba] >>> ang2h = 24 / (2*np.pi*freq) >>> ang_ba * ang2h 3.8786004708135566 Por lo tanto, el retardo de la onda de mareas puede calcularse usando (ang_ba - ang_sf) * ang2h Ejercicio 8.12: Desfasajes En la Pregunta 1 estimaste el desfasaje vertical entre los ceros de escala de los puertos analizados. Ahora ten\u00e9s que estimar el desfasaje temporal de las ondas de marea entre ambos puertos. \u00bfA cu\u00e1ntos minutos corresponde aproximadamente el tiempo que tarda la onda de mareas en llegar del puerto de Buenos Aires al de San Fernando? Us\u00e1 estos datos para volver a hacer el gr\u00e1fico del Ejercicio 8.10 (vas a tener que redondear a horas enteras el delay temporal). Un poco m\u00e1s avanzados: Ejercicio 8.13: Otros puertos Usando el archivo con datos del Puerto de Z\u00e1rate , estim\u00e1 el tiempo (expresado en horas y minutos) que le toma a la onda de marea llegar de Buenos Aires a Z\u00e1rate. Obviamente la onda llega atenuada a Z\u00e1rate. \u00bfC\u00f3mo se refleja esta atenuaci\u00f3n en la transformada? \u00bfPod\u00e9s cuantificar esta atenuaci\u00f3n? Guard\u00e1 lo que hayas hecho hasta ac\u00e1 en el archivo mareas_fft.py para entregar. Ejercicio 8.14: Otros per\u00edodos El primer an\u00e1lisis se realiz\u00f3 con el primer semestre del 2014 ya que no tiene ni datos faltantes ni outliers. Este ejercicio es una invitaci\u00f3n a explorar estos problemas tan frecuentes. \u00bfSe puede comparar Z\u00e1rate con San Fernando usando todos los datso de Z\u00e1rate? \u00bfC\u00f3mo se comporta San Fernando en esas fechas? \u00bfSe pueden usar las series completas de BA y SF para calcular el desfasaje de la onda de mareas? \u00bfQu\u00e9 son las alturas negativas? \u00bfTienen sentido? La siguiente funci\u00f3n completa datos faltantes y corrige peque\u00f1os problemas en los \u00edndices. Es un poco brutal tratar as\u00ed un DataFrame: es conveniente mirar los datos antes de completar faltantes. Lo dejamos como puntero a diferentes m\u00e9todos muy \u00fatiles para la limpieza de series. def reparar(df): df = df.interpolate() df = df.resample('H').mean() df = df.fillna(method = 'ffill') return df Contenidos | Anterior (5 Introducci\u00f3n a Pandas) | Pr\u00f3ximo (7 Cierre de la clase)","title":"06 Series Temporales"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#86-series-temporales","text":"Para esta Secci\u00f3n contamos con el valioso aporte de Octavio Bruzzone . Octavio da dos cursos de posgrado excelentes sobre Series Temporales en Python. Uno se enfoca en los an\u00e1lisis en el dominio del tiempo y el otro en el dominio de las frecuencias. Generosamente nos comparti\u00f3 algunas ideas para este trabajo pr\u00e1ctico. Esta secci\u00f3n tiene un breve video introductorio sobre los datos y lo que hay que hacer en este TP.","title":"8.6 Series temporales"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#analisis-y-visualizacion-de-series-temporales","text":"En este pr\u00e1ctico vamos a visualizar y analizar datos de mareas en el R\u00edo de la Plata. Tiene una primera parte que esperamos que todes hagan y una segunda parte, m\u00e1s larga y compleja, optativa. Trabaj\u00e1 en el archivo mareas_fft.py . Para comenzar, copiate el archivo con datos de mareas en los puertos de San Fernando y Buenos Aires a tu carpeta Data","title":"An\u00e1lisis y visualizaci\u00f3n de series temporales."},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#lectura-de-archivos-temporales","text":"import pandas as pd df = pd.read_csv('../Data/OBS_SHN_SF-BA.csv') Observ\u00e1 los datos: >>> df.head() Time H_SF H_BA 0 2011-01-01 00:00:00 NaN 92.0 1 2011-01-01 01:00:00 NaN 110.0 2 2011-01-01 02:00:00 NaN 124.0 3 2011-01-01 03:00:00 NaN 132.0 4 2011-01-01 04:00:00 NaN 136.0 >>> df.index RangeIndex(start=0, stop=35064, step=1) Este archivo tiene alturas del agua en el puerto de San Fernando (columna H_SF ) y en el puerto de Buenos Aires (columna H_BA ) medidas en cent\u00edmetros. Tiene un dato por hora (columna Time ) durante cuatro a\u00f1os. En los primeros registros se observa algo muy frecuente con este tipo de archivos: tiene muchos datos faltantes. El \u00edndice de un dataframe nos da informaci\u00f3n de su estructura. En este caso, est\u00e1 representando el n\u00famero de l\u00ednea del archivo que le\u00edmos. Pero un \u00edndice puede aportarnos m\u00e1s informaci\u00f3n relevante para nuestro problema, por lo que la propuesta es que el \u00edndice deber\u00eda ser el instante en le que se tom\u00f3 cada muestra ('Time'). Para esto tenemos que decirle a la funci\u00f3n read_csv dos cosas: * por un lado que use la columna 'Time' como \u00edndice (index_col = ['Time']) y * por el otro que la interprete como un timestamp (parse_dates = True). df = pd.read_csv('../Data/OBS_SHN_SF-BA.csv', index_col=['Time'], parse_dates=True) Observ\u00e1 la diferencia: >>> df.head() H_SF H_BA Time 2011-01-01 00:00:00 NaN 92.0 2011-01-01 01:00:00 NaN 110.0 2011-01-01 02:00:00 NaN 124.0 2011-01-01 03:00:00 NaN 132.0 2011-01-01 04:00:00 NaN 136.0 >>> df.index DatetimeIndex(['2011-01-01 00:00:00', '2011-01-01 01:00:00', ... '2014-12-31 22:00:00', '2014-12-31 23:00:00'], dtype='datetime64[ns]', name='Time', length=35064, freq=None) Que el \u00edndice sea temporal nos da una versatilidad genial para trabajar con estos datos. Prob\u00e1 por ejemplo los siguientes comandos: >>> df['1-18-2014 9:00':'1-18-2014 18:00'] H_SF H_BA Time 2014-01-18 09:00:00 85.0 67.0 2014-01-18 10:00:00 79.0 60.0 2014-01-18 11:00:00 73.0 49.0 2014-01-18 12:00:00 65.0 43.0 2014-01-18 13:00:00 59.0 36.0 2014-01-18 14:00:00 53.0 29.0 2014-01-18 15:00:00 48.0 22.0 2014-01-18 16:00:00 42.0 18.0 2014-01-18 17:00:00 36.0 33.0 2014-01-18 18:00:00 40.0 67.0 Prob\u00e1 tambi\u00e9n df['2-19-2014'] (observ\u00e1 que el formato de fechas que se usa es el de EEUU), y df['12-25-2014':] .","title":"Lectura de archivos temporales"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#ondas-de-marea-en-el-rio-de-la-plata","text":"Grafiquemos estos \u00faltimos datos: df['12-25-2014':].plot() Ac\u00e1 se ven tres fen\u00f3menos interesantes: * Hay 14 picos en 7 d\u00edas, esto corresponde a la frecuencia semidiurna de las mareas. Cada poco m\u00e1s de 12hs tenemos un ciclo con pleamar y bajamar. Dos ciclos por d\u00eda. * Por otra parte, se ve que las mareas en San Fernando est\u00e1n retrasadas respecto a las de Buenos Aires. Esto se debe a que las ondas de marea vienen del oc\u00e9ano atl\u00e1ntico y se propagan por el estuario del r\u00edo de la Plata, pasando primero por Buenos Aires y llegando luego, con retraso, a San Fernando. En ciertas condiciones esta onda de mareas puede llegar a la ciudad de Rosario, aunque se va atenuando en su viaje desde el atl\u00e1ntico. Finalmente, hay una marcada diferencia entre la altura registrada en San Fernando y la de Buenos Aires. Esto se debe a que las dos escalas, a partir de las que se registran los datos, tienen ceros que no est\u00e1n nivelados. En este pr\u00e1ctico nos proponemos estudiar la propagaci\u00f3n de esta onda de marea que es generada por la atracci\u00f3n gravitacional que ejercen la luna y el sol sobre el agua. Vamos a usar una transformada de Fourier que nos permite estudiar las frecuencias predominantes en la serie de alturas. Las mareas se ver\u00e1n claramente porque estos efectos astron\u00f3micos son regulares y tienen frecuencias invariantes.","title":"Ondas de marea en el R\u00edo de la Plata"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#vientos-y-ondas-de-tormenta-en-el-rio-de-la-plata","text":"Si miramos un gr\u00e1fico un poco m\u00e1s extendido en el tiempo vamos a ver que las alturas no solo fluct\u00faan con las mareas semidiurnas sino que la componente meteorol\u00f3gica (vientos principalmente, que generan ondas de tormenta ) modifica las alturas de manera muy considerable. El siguiente comando genera un gr\u00e1fico entre el 15 de octubre de 2014 y el 15 de diciembre del mismo a\u00f1o. df['10-15-2014':'12-15-2014'].plot() En ese gr\u00e1fico se puede observar c\u00f3mo una sudestada a principios de noviembre elev\u00f3 el nivel del estuario m\u00e1s de un metro durante casi tres d\u00edas. Las dos fotos que siguen son justamente de esa sudestada. Fueron tomadas el primero de noviembre por Gustavo Castaing. As\u00ed como el viento del sudeste empuja el agua del mar hacia adentro del estuario y genera crecidas, los vientos del norte o el oeste tambi\u00e9n impulsan desplazamientos del agua del estuario, en este caso generando bajantes. En las siguientes dos fotos puede verse una bajante capturada por Juan Pablo Mart\u00ednez Bigozzi el 19 de junio del 2019. La transformada de Fourier no resultar\u00e1 muy \u00fatil para ver estas ondas de tormenta . Como carecen de regularidad, no aparecer\u00e1n claramente en el espectro de frecuencias.","title":"Vientos y ondas de tormenta en el R\u00edo de la Plata"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#ejercicio-810","text":"Trabajemos con una copia de este fragmento: dh = df['12-25-2014':].copy() Podemos desplazar (shift en ingl\u00e9s) una Serie de Pandas usando el m\u00e9todo ds.shift(pasos) . Adem\u00e1s, podemos subir o bajar su gr\u00e1fico sumando una constante a todas las mediciones ds + cte . Finalmente podemos unir dos series en un DataFrame de manera muy simple, para poder graficarlas juntas. Si concatenamos estas operaciones obtenemos algo as\u00ed: delta_t = 0 # tiempo que tarda la marea entre ambos puertos delta_h = 0 # diferencia de los ceros de escala entre ambos puertos pd.DataFrame([dh['H_SF'].shift(delta_t) - delta_h, dh['H_BA']]).T.plot() Busc\u00e1 los valores de delta_t (es un n\u00famero entero, son pasos) y delta_h (puede tener decimales, es un float) que hacen que los dos gr\u00e1ficos se vean lo m\u00e1s similares posible. Guard\u00e1 tu c\u00f3digo en el archivo mareas_a_mano.py para entregar.","title":"Ejercicio 8.10:"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#correlacion-con-desplazamientos","text":"El siguiente c\u00f3digo calcula y grafica el coeficiente de correlaci\u00f3n r de Pearson entre la serie de alturas en Buenos Aires y la de San Fernando desplazada temporalmente. import numpy as np import pandas as pd from scipy.stats import pearsonr import matplotlib.pyplot as plt # Levanto las dos series df=pd.read_csv('../Data/OBS_SHN_SF-BA.csv',index_col=['Time'],parse_dates=True) # Me quedo con un fregmento dh=df['10-01-2014':].copy() # Selecciono los intervalos que voy a usar para desplazar SF shifts = np.arange(-12,13) # Genero un vector donde guardar los coeficientes de correlacion para cada deslpazamiento corrs = np.zeros(shifts.shape) for i, sh in enumerate(shifts): #guardo el coeficiente de correlaci\u00f3n r entre de SF desplazada con BA original. corrs[i] = pearsonr(dh['H_SF'].shift(sh)[12:-12],dh['H_BA'][12:-12])[0] # ploteo los resultados plt.plot(shifts, corrs)","title":"Correlaci\u00f3n con desplazamientos"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#ejercicio-811-interpolacion","text":"Este ejemplo muestra una manera de interplolar la serie de manera de poder usar desplazamientos menores a una hora. # Cada cuarto de hora df=pd.read_csv('../Data/OBS_SHN_SF-BA.csv',index_col=['Time'],parse_dates=True) dh =df['10-01-2014':].copy() #ultimo trimestre freq_horaria = 4 # 4 para 15min, 60 para 1min cant_horas = 24 N = cant_horas * freq_horaria #resampleo cada tantos minutos dh = dh.resample(f'{int(60/freq_horaria)}T').mean() #rellenos los NaNs suavemente dh =dh.interpolate(method='quadratic') # genero vector de desplazamientos (enteros) ishifts = np.arange(-N,N+1) # y su desplamiento horario asociado shifts=ishifts/freq_horaria # finalmente calculo las correlaciones correspondientes corrs = np.zeros(shifts.shape) for i, sh in enumerate(ishifts): corrs[i] = pearsonr(dh['H_SF'].shift(sh)[N:-N],dh['H_BA'][N:-N])[0] # y grafico plt.plot(shifts, corrs) El comando np.argmax(corrs) se puede usar para devolver la coordenada de la m\u00e1xima correlaci\u00f3n. Esa posici\u00f3n del vector shifts indicar\u00e1 a cu\u00e1ntas horas corresponde ese desplazamiento. Si lo corremos con esta interpolaci\u00f3n cada 15 minutos propuesta en el c\u00f3digo, obtendremos que la onda tarda una hora en llegar a San Fernando. Usando una interpolaci\u00f3n m\u00e1s fina, \u00bfpod\u00e9s estimar el desfazaje en minutos? A nosotros nos dio 57 minutos.","title":"Ejercicio 8.11: Interpolaci\u00f3n"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#parte-optativa","text":"En lo que sigue vamos a usar herramientas matem\u00e1ticas para hacer un an\u00e1lisis similar al que hicimos reci\u00e9n de manera artesanal . Para una onda sinusoidal, el desplazamiento horizontal corresponde a una diferencia de fase y el desplazamiento vertical es simplemente una constante aditiva. Vamos a descomponer la serie de alturas observadas del agua por medio de la transformada de Fourier. Las ondas de marea se mueven lentamente y tardan cierto tiempo en llegar de un puerto a otro. En lo que sigue vamos a ver c\u00f3mo calcular el tiempo que le toma a esta onda en desplazarse de Buenos Aires hasta San Fernando. Lo que sigue es optativo .","title":"Parte optativa"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#analisis-por-medio-de-transformadas-de-fourier","text":"La transformada de Fourier descompone una se\u00f1al en una suma de senos y cosenos (sinusoides) con diferentes frecuencias y amplitudes. Esta animaci\u00f3n ilustra gr\u00e1ficamente el proceso de la transformada de Fourier. La transformada da, para cada frecuencia, un n\u00famero complejo a + bi que puede pensarse como un vector (a,b) en el plano. La parte real va a multiplicar un coseno con la frecuencia indicada y la parte imaginaria un seno con la misma frecuencia. La magnitud (o amplitud, o potencia) de la se\u00f1al en esa frecuencia se corresponde con el largo del vector (a, b) . La fase (o desplazamiento del m\u00e1ximo respecto del origen de las coordenadas), se corresponde con \u00e1ngulo que forma este vector (a, b) con el semieje de los reales positivos. Aqu\u00ed, la variable theta (\u03b8) representa el desplazamiento de fase de la curva azul (respecto a la roja que tiene desplazamiento nulo). Esta fase suele medirse en radianes, correspondiendo 2*\u03c0 a un ciclo completo de desfasaje. Vamos a aplicar estas herramientas al an\u00e1lisis de la propagaci\u00f3n de la onda de marea por el estuario del plata.","title":"An\u00e1lisis por medio de transformadas de Fourier"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#preparacion-de-modulos-y-datos","text":"Vamos a usar los siguientes m\u00f3dulos: from scipy import signal # para procesar se\u00f1ales import numpy as np import matplotlib.pyplot as plt Seleccionemos las dos series como vectores de numpy (con el m\u00e9todo to_numpy() ). inicio = '2014-01' fin = '2014-06' alturas_sf = df[inicio:fin]['H_SF'].to_numpy() alturas_ba = df[inicio:fin]['H_BA'].to_numpy() Primero definamos una funci\u00f3n que calcule la transformada de Fourier para datos horarios y considerando como unidad de frecuencia los d\u00edas (descartamos la mitad de los coeficientes de la transformada porque los datos son reales y no complejos). Pod\u00e9s tomarla como una caja negra por ahora... def calcular_fft(y, freq_sampleo = 24.0): '''y debe ser un vector con n\u00fameros reales representando datos de una serie temporal. freq_sampleo est\u00e1 seteado para considerar 24 datos por unidad. Devuelve dos vectores, uno de frecuencias y otro con la transformada propiamente. La transformada contiene los valores complejos que se corresponden con respectivas frecuencias.''' N = len(y) freq = np.fft.fftfreq(N, d = 1/freq_sampleo)[:N//2] tran = (np.fft.fft(y)/N)[:N//2] return freq, tran Para poder analizar una onda por medio de su transformada de Fourier, es necesario que la onda sea peri\u00f3dica. Puede pasar que no sea el caso y que una onda tenga tendencia lineal, en ese caso podr\u00edamos usar la funci\u00f3n scipy.signal.detrend() . En nuestro caso supondremos que la marea media se mantuvo estable a lo largo del per\u00edodo de estudio, as\u00ed que no tenemos que hacerle este procesamiento intermedio.","title":"Preparaci\u00f3n de m\u00f3dulos y datos"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#espectro-de-potencia-y-de-angulos-para-san-fernando","text":"Primero calculamos la transformada de las alturas de San Fernando. freq_sf, fft_sf = calcular_fft(alturas_sf) Si quisi\u00e9ramos graficar freq_sf contra fft_sf no podr\u00edamos ver mucho ya que fft_sf contiene n\u00fameros complejos. La potencia (o amplitud) para cada frecuencia se calcula como el m\u00f3dulo del n\u00famero complejo correspondiente (para la frecuencia freq_sf[i] y la potencia es abs(fft_sf[i]) ). Al graficar esto podemos ver la amplitud de los sinusoides para cada frecuencia. Este gr\u00e1fico se llama el espectro de potencias de la onda original. plt.plot(freq_sf, np.abs(fft_sf)) plt.xlabel(\"Frecuencia\") plt.ylabel(\"Potencia (energ\u00eda)\") plt.show() A simple vista se observan dos picos, uno en frecuencia 0 (constante relacionada con el cero de escala) y otro pico cercano a la frecuencia 2 (frecuencia semidiurna) que est\u00e1 relacionado con la onda de mareas. El pico en la primera posici\u00f3n efectivamente se corresponde con la frecuencia 0 y su amplitud es: >>> freq_sf[0] 0.0 >>> np.abs(fft_sf[0]) 111.83 A partir de esto podemos decir que las alturas del r\u00edo en San Fernando durante este per\u00edodo oscilan alrededor de los 111.8 cm de altura. Para analizar precisamente el pico semidiurno podemos usar find_peaks que provee scipy.signal para evitar hacerlo a ojo. Vamos a pedir aquellos picos que tengan al menos cierta diferencia con su entorno (prominencia), un buen valor para esto es el 8. Pod\u00e9s probar otros valores y observar el resultado. >>> print(signal.find_peaks(np.abs(fft_sf), prominence = 8)) (array([350]), {'prominences': array([11.4554514]), 'left_bases': array([307]), 'right_bases': array([2109])}) Esta respuesta nos indica que hay un pico con la prominencia solicitada (al menos 8), que tiene un magnitud de 11.45 y que corresponde a la posici\u00f3n 350 del vector. >>> freq_sf[350] 1.93 La frecuencia relacionada con esa posici\u00f3n es cercana a dos, como ya hab\u00edamos observado en el gr\u00e1fico (dos ciclos por d\u00eda). Podemos distinguir los picos agregando un punto rojo y mirando m\u00e1s de cerca el \u00e1rea de inter\u00e9s: plt.plot(freq_sf, np.abs(fft_sf)) plt.xlabel(\"Frecuencia\") plt.ylabel(\"Potencia (energ\u00eda)\") plt.xlim(0,4) plt.ylim(0,20) # me quedo solo con el \u00faltimo pico pico_sf = signal.find_peaks(np.abs(fft_sf), prominence = 8)[0][-1] # es el pico a analizar, el de la onda de mareas # marco ese pico con un circulito rojo plt.scatter(freq_sf[pico_sf], np.abs(fft_sf)[pico_sf], facecolor = 'r') plt.show() Estos gr\u00e1ficos permiten interpretar que si descomponemos la curva de alturas en San Fernando como suma de sinusoidales, el sinusoide con frecuencia 1.93 tiene una magnitud considerablemente llamativa. No es casualidad que este sea un punto distinguido: se trata de la frecuencia de las mareas lunares. Ahora viene la parte un poco m\u00e1s sut\u00edl: el an\u00e1lisis de las fases . Si conocemos la fase de estas componentes en dos puertos distintos, podremos estimar el tiempo que tarda en desplazarse la marea de uno a otro. Para calcular la fase (entre -\u03c0 y \u03c0) de dicha componente (la que ubicamos en la posici\u00f3n 350) en el puerto de San Fernando, podemos simplemente usar np.angle() y pasarle el n\u00famero complejo en cuesti\u00f3n: >>> ang_sf = np.angle(fft_sf)[pico_sf] >>> print(ang_sf) 1.4849 Obtenemos un valor cercano a pi/2. Recordemos que 2 pi corresponde a un desfasaje de un ciclo completo de la curva. Como nuestra curva de estudio tiene una frecuencia diaria ligeramente inferior a 2 (freq_sf[350]~1.93), 2 pi corresponde a 24/1.93 horas ~ 12.44 horas. Por lo tanto la fase obtenida con angSF[350] corresponde a un retardo de >>> ang_sf * 24 / (2 * np.pi * freq_sf[350]) 2.93 Es decir, este sinusoide est\u00e1 desfasado poco menos de 3hs respecto al seno neutro .","title":"Espectro de potencia y de \u00e1ngulos para San Fernando"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#espectro-de-potencia-y-de-angulos-para-buenos-aires","text":"Repitamos velozmente el procedimiento para el puerto de Buenos Aires y analicemos las diferencias. freq_ba, fft_ba = calcular_fft(alturas_ba) plt.plot(freq_ba, np.abs(fft_ba)) plt.xlabel(\"Frecuencia\") plt.ylabel(\"Potencia (energ\u00eda)\") plt.xlim(0,4) plt.ylim(0,20) # me quedo solo con el \u00faltimo pico pico_ba = signal.find_peaks(np.abs(fft_ba), prominence = 8)[0][-1] #se grafican los picos como circulitos rojos plt.scatter(freq_ba[pico_ba], np.abs(fft_ba)[pico_ba], facecolor='r') plt.title(\"Espectro de Potencias Bs.As.\") plt.show() Si buscamos la constante alrededor de la que oscilan las mareas seg\u00fan el nivel del puerto de Buenos Aires obtenemos: >>> np.abs(fft_ba[0]) 88.21 Con este resultado es sencillo obtener una estimaci\u00f3n para la diferencia de alturas de los ceros de escala entre ambos puertos. Pregunta 1: \u00bfCu\u00e1l es la diferencia de altura media entre los puertos obtenida de esta forma? Pregunta 2: \u00bfDe qu\u00e9 otra forma se puede estimar el valor medio de un puerto? \u00bfCu\u00e1nto da la diferencia con este otro m\u00e9todo? Por otra parte, si observamos que el espectro de potencia vemos que los picos en ambos puertos son s\u00famamente similares. >>> print(signal.find_peaks(np.abs(fft_ba), prominence=8)) (array([350]), {'prominences': array([12.67228046]), 'left_bases': array([279]), 'right_bases': array([1000])}) Las mareas de Buenos Aires tiene una componente de m\u00e1xima amplitud en la frecuencia 1.93 (misma que San Fernando) y con una magnitud de 12.67 (bastante similar a la magnitud correspondiente en San Fernando). Resta estudiar la fase de la curva de los datos de df_ba en esta frecuencia para poder determinar con precisi\u00f3n la diferencia de fase entre ambos puertos para ondas de marea. Primero calculamos el \u00e1ngulo de la componente correspondiente y luego lo convertimos en horas usando el factor ang2h : >>> ang_ba = np.angle(fft_ba)[pico_ba] >>> print(ang_ba) 1.96 >>> freq = freq_ba[pico_ba] >>> ang2h = 24 / (2*np.pi*freq) >>> ang_ba * ang2h 3.8786004708135566 Por lo tanto, el retardo de la onda de mareas puede calcularse usando (ang_ba - ang_sf) * ang2h","title":"Espectro de potencia y de \u00e1ngulos para Buenos Aires"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#ejercicio-812-desfasajes","text":"En la Pregunta 1 estimaste el desfasaje vertical entre los ceros de escala de los puertos analizados. Ahora ten\u00e9s que estimar el desfasaje temporal de las ondas de marea entre ambos puertos. \u00bfA cu\u00e1ntos minutos corresponde aproximadamente el tiempo que tarda la onda de mareas en llegar del puerto de Buenos Aires al de San Fernando? Us\u00e1 estos datos para volver a hacer el gr\u00e1fico del Ejercicio 8.10 (vas a tener que redondear a horas enteras el delay temporal).","title":"Ejercicio 8.12: Desfasajes"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#un-poco-mas-avanzados","text":"","title":"Un poco m\u00e1s avanzados:"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#ejercicio-813-otros-puertos","text":"Usando el archivo con datos del Puerto de Z\u00e1rate , estim\u00e1 el tiempo (expresado en horas y minutos) que le toma a la onda de marea llegar de Buenos Aires a Z\u00e1rate. Obviamente la onda llega atenuada a Z\u00e1rate. \u00bfC\u00f3mo se refleja esta atenuaci\u00f3n en la transformada? \u00bfPod\u00e9s cuantificar esta atenuaci\u00f3n? Guard\u00e1 lo que hayas hecho hasta ac\u00e1 en el archivo mareas_fft.py para entregar.","title":"Ejercicio 8.13: Otros puertos"},{"location":"08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/#ejercicio-814-otros-periodos","text":"El primer an\u00e1lisis se realiz\u00f3 con el primer semestre del 2014 ya que no tiene ni datos faltantes ni outliers. Este ejercicio es una invitaci\u00f3n a explorar estos problemas tan frecuentes. \u00bfSe puede comparar Z\u00e1rate con San Fernando usando todos los datso de Z\u00e1rate? \u00bfC\u00f3mo se comporta San Fernando en esas fechas? \u00bfSe pueden usar las series completas de BA y SF para calcular el desfasaje de la onda de mareas? \u00bfQu\u00e9 son las alturas negativas? \u00bfTienen sentido? La siguiente funci\u00f3n completa datos faltantes y corrige peque\u00f1os problemas en los \u00edndices. Es un poco brutal tratar as\u00ed un DataFrame: es conveniente mirar los datos antes de completar faltantes. Lo dejamos como puntero a diferentes m\u00e9todos muy \u00fatiles para la limpieza de series. def reparar(df): df = df.interpolate() df = df.resample('H').mean() df = df.fillna(method = 'ffill') return df Contenidos | Anterior (5 Introducci\u00f3n a Pandas) | Pr\u00f3ximo (7 Cierre de la clase)","title":"Ejercicio 8.14: Otros per\u00edodos"},{"location":"08_Fechas_Carpetas_y_Pandas/07_Cierre/","text":"Contenidos | Anterior (6 Series temporales) 8.7 Cierre de la clase Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: El archivo vida.py del Ejercicio 8.1 . El archivo listar_imgs.py del Ejercicio 8.5 . El archivo arbolado_parques_veredas.py del Ejercicio 8.9 . El archivo mareas_a_mano.py del Ejercicio 8.10 . Te proponemos adem\u00e1s dos optativos: 1. El archivo ordenar_imgs.py del Ejercicio 8.6 . 2. El archivo mareas_fft.py del Ejercicio 8.13 . Que completes este formulario usando tu direcci\u00f3n de mail como identificaci\u00f3n. Al terminar vas a obtener un link para enviarnos tus ejercicios. La correcci\u00f3n de pares de esta semana ser\u00e1 con el archivo arbolado_parques_veredas.py del Ejercicio 8.9 . \u00a1Gracias! Contenidos | Anterior (6 Series temporales)","title":"07 Cierre"},{"location":"08_Fechas_Carpetas_y_Pandas/07_Cierre/#87-cierre-de-la-clase","text":"Para cerrar esta clase te pedimos dos cosas: * Que recopiles las soluciones de los siguientes ejercicios: El archivo vida.py del Ejercicio 8.1 . El archivo listar_imgs.py del Ejercicio 8.5 . El archivo arbolado_parques_veredas.py del Ejercicio 8.9 . El archivo mareas_a_mano.py del Ejercicio 8.10 . Te proponemos adem\u00e1s dos optativos: 1. El archivo ordenar_imgs.py del Ejercicio 8.6 . 2. El archivo mareas_fft.py del Ejercicio 8.13 . Que completes este formulario usando tu direcci\u00f3n de mail como identificaci\u00f3n. Al terminar vas a obtener un link para enviarnos tus ejercicios. La correcci\u00f3n de pares de esta semana ser\u00e1 con el archivo arbolado_parques_veredas.py del Ejercicio 8.9 . \u00a1Gracias! Contenidos | Anterior (6 Series temporales)","title":"8.7 Cierre de la clase"},{"location":"09_Clases_y_Objetos/00_Resumen/","text":"Contenidos | Anterior (8 Fechas, Carpetas y Pandas) | Pr\u00f3ximo (10 Generadores e iteradores) 9. Clases y objetos En esta clase vamos a meternos con la programaci\u00f3n orientada a objetos . Vamos a ver los conceptos de clases y objetos. Hasta ahora los programas que escribimos usaron s\u00f3lo tipos de datos nativos de Python, con la instrucci\u00f3n class vamos a definir nuevas clases. Vamos a ir m\u00e1s all\u00e1 y a hablar del concepto de herencia, una herramienta com\u00fanmente usada para escribir programas extensibles. Por \u00faltimo, vamos a referirnos a algunos m\u00e9todos especiales de los objetos de Python. En los ejercicios vamos a ver los conceptos de pilas y colas. En particular, la pila de llamadas nos prepara el camino para poder estudiar en un par de clases el concepto de recursi\u00f3n. Cerramos esta clase con un ejercicio optativo que involucra conceptos de teledetecci\u00f3n y de aprendizaje autom\u00e1tico. El ejercicio para la revisi\u00f3n de pares de esta semana es de programaci\u00f3n orientada a objetos (modelar una torre de control). 9.1 Introducci\u00f3n 9.2 Clases 9.3 Herencia 9.4 M\u00e9todos especiales 9.5 Objetos, pilas y colas 9.6 Teledetecci\u00f3n 9.7 Cierre de la clase Contenidos | Anterior (8 Fechas, Carpetas y Pandas) | Pr\u00f3ximo (10 Generadores e iteradores)","title":"00 Resumen"},{"location":"09_Clases_y_Objetos/00_Resumen/#9-clases-y-objetos","text":"En esta clase vamos a meternos con la programaci\u00f3n orientada a objetos . Vamos a ver los conceptos de clases y objetos. Hasta ahora los programas que escribimos usaron s\u00f3lo tipos de datos nativos de Python, con la instrucci\u00f3n class vamos a definir nuevas clases. Vamos a ir m\u00e1s all\u00e1 y a hablar del concepto de herencia, una herramienta com\u00fanmente usada para escribir programas extensibles. Por \u00faltimo, vamos a referirnos a algunos m\u00e9todos especiales de los objetos de Python. En los ejercicios vamos a ver los conceptos de pilas y colas. En particular, la pila de llamadas nos prepara el camino para poder estudiar en un par de clases el concepto de recursi\u00f3n. Cerramos esta clase con un ejercicio optativo que involucra conceptos de teledetecci\u00f3n y de aprendizaje autom\u00e1tico. El ejercicio para la revisi\u00f3n de pares de esta semana es de programaci\u00f3n orientada a objetos (modelar una torre de control). 9.1 Introducci\u00f3n 9.2 Clases 9.3 Herencia 9.4 M\u00e9todos especiales 9.5 Objetos, pilas y colas 9.6 Teledetecci\u00f3n 9.7 Cierre de la clase Contenidos | Anterior (8 Fechas, Carpetas y Pandas) | Pr\u00f3ximo (10 Generadores e iteradores)","title":"9. Clases y objetos"},{"location":"09_Clases_y_Objetos/01_Intro/","text":"Contenidos | Pr\u00f3ximo (2 Clases) 9.1 Introducci\u00f3n En este video damos una breve introducci\u00f3n a los temas de la clase. Luego, en cada secci\u00f3n vas a encontrar tambi\u00e9n un video corto con mayor nivel de detalle sobre los temas de la secci\u00f3n. \u00a1Que disfrutes la clase! Contenidos | Pr\u00f3ximo (2 Clases)","title":"01 Intro"},{"location":"09_Clases_y_Objetos/01_Intro/#91-introduccion","text":"En este video damos una breve introducci\u00f3n a los temas de la clase. Luego, en cada secci\u00f3n vas a encontrar tambi\u00e9n un video corto con mayor nivel de detalle sobre los temas de la secci\u00f3n. \u00a1Que disfrutes la clase! Contenidos | Pr\u00f3ximo (2 Clases)","title":"9.1 Introducci\u00f3n"},{"location":"09_Clases_y_Objetos/02_Clases/","text":"Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Herencia) 9.2 Clases Esta secci\u00f3n tiene un video donde introducimos las clases, damos algunos ejemplos y tambi\u00e9n introducimos el tema de la Secci\u00f3n 9.4 . En este video, y en el que veremos m\u00e1s adelante sobre herencia, usamos el c\u00f3digo de este archivo . La programaci\u00f3n orientada a objetos requiere un peque\u00f1o pero importante cambio en la forma de pensar la programaci\u00f3n tradicional. Dej\u00e1 decantar los conceptos nuevos mientras le\u00e9s esta secci\u00f3n. En esta secci\u00f3n veremos el concepto de clase, c\u00f3mo crear nuevos tipos de objetos, su utilidad, y las ventajas de esa forma de organizar los programas. Programaci\u00f3n orientada a objetos (POO) La programaci\u00f3n orientada a objetos es una forma de organizar el c\u00f3digo. As\u00ed como un algoritmo suele estar asociado a una estructura de datos particular, la programaci\u00f3n orientada a objetos \"empaqueta\" los datos junto con los m\u00e9todos usados para tratarlos. Cada uno de esos objetos consiste en Datos (atributos de los objetos). Comportamiento (m\u00e9todos de los objetos: son funciones que act\u00faan sobre los atributos del objeto). Ya usaste objetos durante el curso infinidad de veces. Por ejemplo, al manipular una lista. >>> nums = [1, 2, 3] >>> nums.append(4) # Esto es un m\u00e9todo de la lista >>> nums.insert(1,10) # Otro m\u00e9todo >>> nums [1, 10, 2, 3, 4] # Estos son los datos modificados por los m\u00e9todos >>> Miremos un poco m\u00e1s en detalle este fragmento de c\u00f3digo. Sabemos que nums es una variable de tipo lista. Equivalentemente, podemos decir que nums es una instancia de la clase list . Cada variable de tipo lista es una instancia de la misma clase. Al hablar de 'instancia' nos referimos a un 'objeto': un objeto es una instancia de una clase. Un objeto de tipo lista tiene atributos (datos) y m\u00e9todos. Los m\u00e9todos, como append() o insert() , se definen cuando se define la clase, pero se usan para manipular los datos de un objeto concreto ( nums en este caso). La instrucci\u00f3n class Para definir un tipo nuevo de objeto, us\u00e1 la instrucci\u00f3n class . class Jugador: def __init__(self, x, y): self.x = x self.y = y self.salud = 100 def mover(self, dx, dy): self.x += dx self.y += dy def lastimar(self, pts): self.salud -= pts Un objeto de tipo Jugador tiene como atributos x , y y salud . Sus m\u00e9todos son mover() y lastimar() . Puede decirse que una clase es la definici\u00f3n formal de las relaciones entre los datos y los m\u00e9todos que los manipulan. Un objeto es una instancia particular de la clase a la cual pertenece, con datos propios pero los mismos m\u00e9todos que los dem\u00e1s objetos de esa clase. Este concepto te va a quedar m\u00e1s claro cuando lo veas funcionar y lo uses. Instancias Los programas manipulan instancias individuales de las clases. Cada instancia es un objeto, y es en cada objeto que uno puede manipular los datos y llamar a sus m\u00e9todos. Pod\u00e9s crear un objeto mediante un llamado a la clase como si fuera una funci\u00f3n. >>> a = Jugador(2, 3) # Clase Jugador definida antes >>> b = Jugador(10, 20) >>> a y b son instancias de Jugador definida m\u00e1s arriba. Es decir, a y b son objetos de la clase Jugador . Importante: La instrucci\u00f3n class es solamente la definici\u00f3n de una clase, no hace nada por s\u00ed misma. Es similar a la definici\u00f3n de una funci\u00f3n. Datos de una instancia Cada instancia tiene sus propios datos locales. Ac\u00e1 pedimos ver el atributo x de cada instancia: >>> a.x 2 >>> b.x 10 Estos datos locales se inicializan, para cada instancia, durante la ejecuci\u00f3n del m\u00e9todo __init__() de la clase. class Jugador: def __init__(self, x, y): # Todo dato guardado en `self` es propio de esa instancia self.x = x self.y = y self.salud = 100 No hay restricciones en la cantidad o el tipo de atributos que puede tener una clase. M\u00e9todos de una instancia. Los m\u00e9todos de una instancia son los m\u00e9todos y las funciones que act\u00faan sobre los datos almacenados en esa instancia. class Jugador: ... # `mover` es un m\u00e9todo def mover(self, dx, dy): self.x += dx self.y += dy Siempre se recibe la instancia misma como primer argumento: \"self\" significa \"mismo\" como en \"mi mismo\" \u00f3 \"en s\u00ed misma\". Es como decir \"yo\". >>> a.mover(1, 2) # `self` refiere a `a` # `dx` refiere a `1` # `dy` refiere a `2` def mover(self, dx, dy): ... Por convenci\u00f3n siempre llamamos self a la instancia actual, y \u00e9sta es siempre pasada como primer argumento a todos los m\u00e9todos. En realidad el nombre real de la variable no importa, pero es una convenci\u00f3n en Python llamar al primer argumento self . Podr\u00edamos usar mismo , por ejemplo, en lugar de self y todo va a funcionar igual, pero no respeta las convenciones de la comunidad: class Jugador: ... # `mover` es un m\u00e9todo def mover(mismo, dx, dy): mismo.x += dx mismo.y += dy Visibilidad en clases (Scoping) Las clases no definen ni limitan (como los m\u00f3dulos) un entorno de visibilidad. class Jugador: ... def mover(self, dx, dy): self.x += dx self.y += dy def izquierda(self, dist): mover(-dist, 0) # NO! Refiere a una funci\u00f3n global `mover`. self.mover(-dist, 0) # S\u00ed. Llama al m\u00e9todo `mover` definido antes. Si necesit\u00e1s referirte a un dato o un m\u00e9todo de una clase ten\u00e9s que hacer una referencia expl\u00edcita (agregando el self ), sino te est\u00e1s refiriendo a otra cosa como en el ejemplo anterior. Ejercicios Vamos a comenzar esta serie de ejercicios modificando c\u00f3digo que escribiste antes del parcial. En particular retomaremos el c\u00f3digo del Ejercicio 7.5 . Te dejamos ac\u00e1 una versi\u00f3n funcionando que pod\u00e9s mirar y/o usar. Tiene cosas interesantes, aunque tengas la tuya funcionando si quer\u00e9s pegale una mirada. Ejercicio 9.1: Objetos como estructura de datos. Durante las primeras clases trabajamos con datos en forma de tuplas y diccionarios. Un lote con cajones de frutas, por ejemplo, estaba representado por una tupla, como \u00e9sta: s = ('Pera', 100, 490.10) o por un diccionario, de esta otra forma: s = { 'nombre' : 'Pera', 'cajones' : 100, 'precio' : 490.10 } Incluso escribiste funciones para manipular datos almacenados de ese modo: def costo(registro): return registro['cajones'] * registro['precio'] Otra forma de representar los datos con los que est\u00e1s trabajando es definir una clase. Cre\u00e1 un archivo llamado lote.py y adentro defin\u00ed una clase llamada Lote que represente un lote de cajones de una misma fruta. Definila de modo que cada instancia de la clase Lote (es decir, cada objeto lote) tenga los atributos nombre , cajones , y precio . \u00c9ste es un ejemplo del comportamiento buscado: >>> import lote >>> a = lote.Lote('Pera', 100, 490.10) >>> a.nombre 'Pera' >>> a.cajones 100 >>> a.precio 490.1 >>> Vamos a crear m\u00e1s objetos de tipo Lote para manipularlos. Por ejemplo: >>> b = lote.Lote('Manzana', 50, 122.34) >>> c = lote.Lote('Naranja', 75, 91.75) >>> b.cajones * b.precio 6117.0 >>> c.cajones * c.precio 6881.25 >>> lotes = [a, b, c] >>> lotes [<lote.Lote object at 0x37d0b0>, <lote.Lote object at 0x37d110>, <lote.Lote object at 0x37d050>] >>> for c in lotes: print(f'{c.nombre:>10s} {c.cajones:>10d} {c.precio:>10.2f}') ... mir\u00e1 el resultado ... >>> Fijate que la clase Lote funciona como una \"f\u00e1brica\" para crear objetos que son instancias de esa clase. Vos la llam\u00e1s como si fuera una funci\u00f3n y te crea una nueva instancia de s\u00ed misma. M\u00e1s a\u00fan, cada instancia es \u00fanica y tiene sus propios datos que son independientes de las dem\u00e1s instancias de la misma clase. Una instancia definida por una clase puede tener cierta similitud con un diccionario, pero usa una sintaxis algo diferente. Por ejemplo, en lugar de escribir c['nombre'] \u00f3 c['precio'] en objetos escrib\u00eds c.nombre o c.precio . Ejercicio 9.2: Agreg\u00e1 algunos m\u00e9todos Al definir una clase pod\u00e9s agregar funciones a los objetos que defin\u00eds. Las funciones espec\u00edficas de objetos se llaman m\u00e9todos y operan sobre los datos guardados en cada instancia. Agreg\u00e1 los m\u00e9todos costo() y vender() a tu objeto Lote . Deber\u00edan dar este comportamiento: >>> import lote >>> s = lote.Lote('Pera', 100, 490.10) >>> s.costo() 49010.0 >>> s.cajones 100 >>> s.vender(25) >>> s.cajones 75 >>> s.costo() 36757.5 >>> Ejercicio 9.3: Lista de instancias Segu\u00ed estos pasos para crear una lista de las instancias de Lote (una lista de objetos Lote ) a partir de una lista de diccionarios. Luego calcul\u00e1 el precio total de todas esas instancias. >>> import fileparse >>> with open('../Data/camion.csv') as lineas: ... camion_dicts = fileparse.parse_csv(lineas, select = ['nombre', 'cajones', 'precio'], types = [str, int, float]) ... >>> camion = [ lote.Lote(d['nombre'], d['cajones'], d['precio']) for d in camion_dicts] >>> camion [<lote.Lote object at 0x10c9e2128>, <lote.Lote object at 0x10c9e2048>, <lote.Lote object at 0x10c9e2080>, <lote.Lote object at 0x10c9e25f8>, <lote.Lote object at 0x10c9e2630>, <lote.Lote object at 0x10ca6f748>, <lote.Lote object at 0x10ca6f7b8>] >>> sum([c.costo() for c in camion]) 47671.15 >>> Ejercicio 9.4: Us\u00e1 tu clase Modific\u00e1 la funci\u00f3n leer_camion() en el programa informe.py de modo que lea un archivo con el contenido de un camion y devuelva una lista de instancias de Lote como mostramos reci\u00e9n en el Ejercicio 9.3 . Cuando hayas hecho esto, cambi\u00e1 un poco el c\u00f3digo en informe.py y en costo_camion.py de modo que funcionen con objetos Lote (instancias de la clase Lote ) en lugar de diccionarios. Ayuda: No deber\u00edan ser cambios importantes. Las referencias a diccionarios ahora tienen que hacer referencia a objetos ( c['cajones'] cambia a c.cajones ). Hecho esto, deber\u00edas poder ejecutar tus funciones como antes: >>> import costo_camion >>> costo_camion.costo_camion('../Data/camion.csv') 47671.15 >>> import informe >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv') Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 $32.2 8.02 Naranja 50 $91.1 15.18 Caqui 150 $103.44 2.02 Mandarina 200 $51.23 29.66 Durazno 95 $40.37 33.11 Mandarina 50 $65.1 15.79 Naranja 100 $70.44 35.84 Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Herencia)","title":"02 Clases"},{"location":"09_Clases_y_Objetos/02_Clases/#92-clases","text":"Esta secci\u00f3n tiene un video donde introducimos las clases, damos algunos ejemplos y tambi\u00e9n introducimos el tema de la Secci\u00f3n 9.4 . En este video, y en el que veremos m\u00e1s adelante sobre herencia, usamos el c\u00f3digo de este archivo . La programaci\u00f3n orientada a objetos requiere un peque\u00f1o pero importante cambio en la forma de pensar la programaci\u00f3n tradicional. Dej\u00e1 decantar los conceptos nuevos mientras le\u00e9s esta secci\u00f3n. En esta secci\u00f3n veremos el concepto de clase, c\u00f3mo crear nuevos tipos de objetos, su utilidad, y las ventajas de esa forma de organizar los programas.","title":"9.2 Clases"},{"location":"09_Clases_y_Objetos/02_Clases/#programacion-orientada-a-objetos-poo","text":"La programaci\u00f3n orientada a objetos es una forma de organizar el c\u00f3digo. As\u00ed como un algoritmo suele estar asociado a una estructura de datos particular, la programaci\u00f3n orientada a objetos \"empaqueta\" los datos junto con los m\u00e9todos usados para tratarlos. Cada uno de esos objetos consiste en Datos (atributos de los objetos). Comportamiento (m\u00e9todos de los objetos: son funciones que act\u00faan sobre los atributos del objeto). Ya usaste objetos durante el curso infinidad de veces. Por ejemplo, al manipular una lista. >>> nums = [1, 2, 3] >>> nums.append(4) # Esto es un m\u00e9todo de la lista >>> nums.insert(1,10) # Otro m\u00e9todo >>> nums [1, 10, 2, 3, 4] # Estos son los datos modificados por los m\u00e9todos >>> Miremos un poco m\u00e1s en detalle este fragmento de c\u00f3digo. Sabemos que nums es una variable de tipo lista. Equivalentemente, podemos decir que nums es una instancia de la clase list . Cada variable de tipo lista es una instancia de la misma clase. Al hablar de 'instancia' nos referimos a un 'objeto': un objeto es una instancia de una clase. Un objeto de tipo lista tiene atributos (datos) y m\u00e9todos. Los m\u00e9todos, como append() o insert() , se definen cuando se define la clase, pero se usan para manipular los datos de un objeto concreto ( nums en este caso).","title":"Programaci\u00f3n orientada a objetos (POO)"},{"location":"09_Clases_y_Objetos/02_Clases/#la-instruccion-class","text":"Para definir un tipo nuevo de objeto, us\u00e1 la instrucci\u00f3n class . class Jugador: def __init__(self, x, y): self.x = x self.y = y self.salud = 100 def mover(self, dx, dy): self.x += dx self.y += dy def lastimar(self, pts): self.salud -= pts Un objeto de tipo Jugador tiene como atributos x , y y salud . Sus m\u00e9todos son mover() y lastimar() . Puede decirse que una clase es la definici\u00f3n formal de las relaciones entre los datos y los m\u00e9todos que los manipulan. Un objeto es una instancia particular de la clase a la cual pertenece, con datos propios pero los mismos m\u00e9todos que los dem\u00e1s objetos de esa clase. Este concepto te va a quedar m\u00e1s claro cuando lo veas funcionar y lo uses.","title":"La instrucci\u00f3n class"},{"location":"09_Clases_y_Objetos/02_Clases/#instancias","text":"Los programas manipulan instancias individuales de las clases. Cada instancia es un objeto, y es en cada objeto que uno puede manipular los datos y llamar a sus m\u00e9todos. Pod\u00e9s crear un objeto mediante un llamado a la clase como si fuera una funci\u00f3n. >>> a = Jugador(2, 3) # Clase Jugador definida antes >>> b = Jugador(10, 20) >>> a y b son instancias de Jugador definida m\u00e1s arriba. Es decir, a y b son objetos de la clase Jugador . Importante: La instrucci\u00f3n class es solamente la definici\u00f3n de una clase, no hace nada por s\u00ed misma. Es similar a la definici\u00f3n de una funci\u00f3n.","title":"Instancias"},{"location":"09_Clases_y_Objetos/02_Clases/#datos-de-una-instancia","text":"Cada instancia tiene sus propios datos locales. Ac\u00e1 pedimos ver el atributo x de cada instancia: >>> a.x 2 >>> b.x 10 Estos datos locales se inicializan, para cada instancia, durante la ejecuci\u00f3n del m\u00e9todo __init__() de la clase. class Jugador: def __init__(self, x, y): # Todo dato guardado en `self` es propio de esa instancia self.x = x self.y = y self.salud = 100 No hay restricciones en la cantidad o el tipo de atributos que puede tener una clase.","title":"Datos de una instancia"},{"location":"09_Clases_y_Objetos/02_Clases/#metodos-de-una-instancia","text":"Los m\u00e9todos de una instancia son los m\u00e9todos y las funciones que act\u00faan sobre los datos almacenados en esa instancia. class Jugador: ... # `mover` es un m\u00e9todo def mover(self, dx, dy): self.x += dx self.y += dy Siempre se recibe la instancia misma como primer argumento: \"self\" significa \"mismo\" como en \"mi mismo\" \u00f3 \"en s\u00ed misma\". Es como decir \"yo\". >>> a.mover(1, 2) # `self` refiere a `a` # `dx` refiere a `1` # `dy` refiere a `2` def mover(self, dx, dy): ... Por convenci\u00f3n siempre llamamos self a la instancia actual, y \u00e9sta es siempre pasada como primer argumento a todos los m\u00e9todos. En realidad el nombre real de la variable no importa, pero es una convenci\u00f3n en Python llamar al primer argumento self . Podr\u00edamos usar mismo , por ejemplo, en lugar de self y todo va a funcionar igual, pero no respeta las convenciones de la comunidad: class Jugador: ... # `mover` es un m\u00e9todo def mover(mismo, dx, dy): mismo.x += dx mismo.y += dy","title":"M\u00e9todos de una instancia."},{"location":"09_Clases_y_Objetos/02_Clases/#visibilidad-en-clases-scoping","text":"Las clases no definen ni limitan (como los m\u00f3dulos) un entorno de visibilidad. class Jugador: ... def mover(self, dx, dy): self.x += dx self.y += dy def izquierda(self, dist): mover(-dist, 0) # NO! Refiere a una funci\u00f3n global `mover`. self.mover(-dist, 0) # S\u00ed. Llama al m\u00e9todo `mover` definido antes. Si necesit\u00e1s referirte a un dato o un m\u00e9todo de una clase ten\u00e9s que hacer una referencia expl\u00edcita (agregando el self ), sino te est\u00e1s refiriendo a otra cosa como en el ejemplo anterior.","title":"Visibilidad en clases (Scoping)"},{"location":"09_Clases_y_Objetos/02_Clases/#ejercicios","text":"Vamos a comenzar esta serie de ejercicios modificando c\u00f3digo que escribiste antes del parcial. En particular retomaremos el c\u00f3digo del Ejercicio 7.5 . Te dejamos ac\u00e1 una versi\u00f3n funcionando que pod\u00e9s mirar y/o usar. Tiene cosas interesantes, aunque tengas la tuya funcionando si quer\u00e9s pegale una mirada.","title":"Ejercicios"},{"location":"09_Clases_y_Objetos/02_Clases/#ejercicio-91-objetos-como-estructura-de-datos","text":"Durante las primeras clases trabajamos con datos en forma de tuplas y diccionarios. Un lote con cajones de frutas, por ejemplo, estaba representado por una tupla, como \u00e9sta: s = ('Pera', 100, 490.10) o por un diccionario, de esta otra forma: s = { 'nombre' : 'Pera', 'cajones' : 100, 'precio' : 490.10 } Incluso escribiste funciones para manipular datos almacenados de ese modo: def costo(registro): return registro['cajones'] * registro['precio'] Otra forma de representar los datos con los que est\u00e1s trabajando es definir una clase. Cre\u00e1 un archivo llamado lote.py y adentro defin\u00ed una clase llamada Lote que represente un lote de cajones de una misma fruta. Definila de modo que cada instancia de la clase Lote (es decir, cada objeto lote) tenga los atributos nombre , cajones , y precio . \u00c9ste es un ejemplo del comportamiento buscado: >>> import lote >>> a = lote.Lote('Pera', 100, 490.10) >>> a.nombre 'Pera' >>> a.cajones 100 >>> a.precio 490.1 >>> Vamos a crear m\u00e1s objetos de tipo Lote para manipularlos. Por ejemplo: >>> b = lote.Lote('Manzana', 50, 122.34) >>> c = lote.Lote('Naranja', 75, 91.75) >>> b.cajones * b.precio 6117.0 >>> c.cajones * c.precio 6881.25 >>> lotes = [a, b, c] >>> lotes [<lote.Lote object at 0x37d0b0>, <lote.Lote object at 0x37d110>, <lote.Lote object at 0x37d050>] >>> for c in lotes: print(f'{c.nombre:>10s} {c.cajones:>10d} {c.precio:>10.2f}') ... mir\u00e1 el resultado ... >>> Fijate que la clase Lote funciona como una \"f\u00e1brica\" para crear objetos que son instancias de esa clase. Vos la llam\u00e1s como si fuera una funci\u00f3n y te crea una nueva instancia de s\u00ed misma. M\u00e1s a\u00fan, cada instancia es \u00fanica y tiene sus propios datos que son independientes de las dem\u00e1s instancias de la misma clase. Una instancia definida por una clase puede tener cierta similitud con un diccionario, pero usa una sintaxis algo diferente. Por ejemplo, en lugar de escribir c['nombre'] \u00f3 c['precio'] en objetos escrib\u00eds c.nombre o c.precio .","title":"Ejercicio 9.1: Objetos como estructura de datos."},{"location":"09_Clases_y_Objetos/02_Clases/#ejercicio-92-agrega-algunos-metodos","text":"Al definir una clase pod\u00e9s agregar funciones a los objetos que defin\u00eds. Las funciones espec\u00edficas de objetos se llaman m\u00e9todos y operan sobre los datos guardados en cada instancia. Agreg\u00e1 los m\u00e9todos costo() y vender() a tu objeto Lote . Deber\u00edan dar este comportamiento: >>> import lote >>> s = lote.Lote('Pera', 100, 490.10) >>> s.costo() 49010.0 >>> s.cajones 100 >>> s.vender(25) >>> s.cajones 75 >>> s.costo() 36757.5 >>>","title":"Ejercicio 9.2: Agreg\u00e1 algunos m\u00e9todos"},{"location":"09_Clases_y_Objetos/02_Clases/#ejercicio-93-lista-de-instancias","text":"Segu\u00ed estos pasos para crear una lista de las instancias de Lote (una lista de objetos Lote ) a partir de una lista de diccionarios. Luego calcul\u00e1 el precio total de todas esas instancias. >>> import fileparse >>> with open('../Data/camion.csv') as lineas: ... camion_dicts = fileparse.parse_csv(lineas, select = ['nombre', 'cajones', 'precio'], types = [str, int, float]) ... >>> camion = [ lote.Lote(d['nombre'], d['cajones'], d['precio']) for d in camion_dicts] >>> camion [<lote.Lote object at 0x10c9e2128>, <lote.Lote object at 0x10c9e2048>, <lote.Lote object at 0x10c9e2080>, <lote.Lote object at 0x10c9e25f8>, <lote.Lote object at 0x10c9e2630>, <lote.Lote object at 0x10ca6f748>, <lote.Lote object at 0x10ca6f7b8>] >>> sum([c.costo() for c in camion]) 47671.15 >>>","title":"Ejercicio 9.3: Lista de instancias"},{"location":"09_Clases_y_Objetos/02_Clases/#ejercicio-94-usa-tu-clase","text":"Modific\u00e1 la funci\u00f3n leer_camion() en el programa informe.py de modo que lea un archivo con el contenido de un camion y devuelva una lista de instancias de Lote como mostramos reci\u00e9n en el Ejercicio 9.3 . Cuando hayas hecho esto, cambi\u00e1 un poco el c\u00f3digo en informe.py y en costo_camion.py de modo que funcionen con objetos Lote (instancias de la clase Lote ) en lugar de diccionarios. Ayuda: No deber\u00edan ser cambios importantes. Las referencias a diccionarios ahora tienen que hacer referencia a objetos ( c['cajones'] cambia a c.cajones ). Hecho esto, deber\u00edas poder ejecutar tus funciones como antes: >>> import costo_camion >>> costo_camion.costo_camion('../Data/camion.csv') 47671.15 >>> import informe >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv') Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 $32.2 8.02 Naranja 50 $91.1 15.18 Caqui 150 $103.44 2.02 Mandarina 200 $51.23 29.66 Durazno 95 $40.37 33.11 Mandarina 50 $65.1 15.79 Naranja 100 $70.44 35.84 Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Herencia)","title":"Ejercicio 9.4: Us\u00e1 tu clase"},{"location":"09_Clases_y_Objetos/03_Herencia/","text":"Contenidos | Anterior (2 Clases) | Pr\u00f3ximo (4 M\u00e9todos especiales) 9.3 Herencia Esta secci\u00f3n tiene un video donde introducimos el tema de herencia. La herencia entre clases es una herramienta muy usada para escribir programas extensibles. Exploraremos esta idea a continuaci\u00f3n. Introducci\u00f3n Se usa herencia para crear objetos m\u00e1s especializados a partir de objetos existentes. class Padre: ... class Hijo(Padre): ... Se dice que Hijo es una clase derivada o subclase. La clase Padre es conocida como la clase base, o superclase. La expresi\u00f3n class Hijo(Padre): significa que estamos creando una clase llamada Hijo que es derivada de la clase Padre . Extensiones Al usar herencia pod\u00e9s tomar una clase existente y ... Agregarle m\u00e9todos Redifinir m\u00e9todos existentes Agregar nuevos atributos Pod\u00e9s verlo como una forma de extender de tu codigo existente. Darle nuevos comportamientos, abarcar un abanico m\u00e1s amplio de posibilidades \u00f3 aumentar su compatibilidad. Ejemplo Supon\u00e9 que part\u00eds de la siguiente clase: class Lote: def __init__(self, nombre, cajones, precio): self.nombre = nombre self.cajones = cajones self.precio = precio def costo(self): return self.cajones * self.precio def vender(self, ncajones): self.cajones -= ncajones Pod\u00e9s modificar lo que necesites mediante herencia. Agregar un m\u00e9todo nuevo class MiLote(Lote): def rematar(self): self.vender(self.cajones) Se puede usar as\u00ed: >>> c = MiLote('Pera', 100, 490.1) >>> c.vender(25) >>> c.cajones 75 >>> c.rematar() >>> c.cajones 0 >>> Esta clase hered\u00f3 los atributos y m\u00e9todos de Lote y la extend\u00edo con un nuevo m\u00e9todo ( rematar() ). Redefinir un m\u00e9todo existente class MiLote(Lote): def costo(self): return 1.25 * self.cajones * self.precio Un ejemplo de uso: >>> c = MiLote('Pera', 100, 490.1) >>> c.costo() 61262.5 >>> El m\u00e9todo nuevo simplemente reemplaza al definido en la clase base. Los dem\u00e1s m\u00e9todos y atributos no son afectados. \u00bfNo es buen\u00edsimo? Utilizar un m\u00e9todo prevalente Hay veces en que una clase extiende el m\u00e9todo de la superclase a la que pertenece, pero necesita ejecutar el m\u00e9todo original como parte de la redefinici\u00f3n del m\u00e9todo nuevo. Para referirte a la superclase, us\u00e1 super() : class Lote: ... def costo(self): return self.cajones * self.precio ... class MiLote(Lote): def costo(self): # Fijate c\u00f3mo usamos `super` costo_orig = super().costo() return 1.25 * costo_orig Us\u00e1 super() para llamar al m\u00e9todo de la clase base (del la cual \u00e9sta es heredera). El m\u00e9todo __init__ y herencia. Al crear cada instancia se ejecuta __init__ . Ah\u00ed reside el c\u00f3digo importante para la creaci\u00f3n de una instancia nueva. Si redefin\u00eds __init__ siempre inclu\u00ed un llamado al m\u00e9todo __init__ de la clase base para inicializarla tambi\u00e9n. class Lote: def __init__(self, nombre, cajones, precio): self.nombre = nombre self.cajones = cajones self.precio = precio ... class MiLote(Lote): def __init__(self, nombre, cajones, precio, factor): # Fijate como es el llamado a `super().__init__()` super().__init__(nombre, cajones, precio) self.factor = factor def costo(self): return self.factor * super().costo() Es necesario llamar al m\u00e9todo __init__() en la clase base. Es una forma de ejecutar la versi\u00f3n previa del m\u00e9todo que estamos redefiniendo, como mostramos reci\u00e9n. Usos de herencia Uno de los usos de definir una clase como heredera de otra es organizar jer\u00e1rquicamente objetos que est\u00e1n relacionados. Un ejemplo: Las figuras geom\u00e9tricas pueden tener ciertos m\u00e9todos y atributos que luego son refinados en casos concretos como c\u00edrculos o rect\u00e1ngulos. class FiguraGeom: ... class Circulo(FiguraGeom): ... class Rectangulo(FiguraGeom): ... Imaginate por ejemplo su uso en una jerarqu\u00eda l\u00f3gica, o taxon\u00f3mica, en la que las clases tienen una relaci\u00f3n natural tal que hace intuitivo derivar una de otra. Una aplicaci\u00f3n m\u00e1s com\u00fan, y tal vez m\u00e1s pr\u00e1ctica, consiste en escribir c\u00f3digo que es reutilizable y/o extensible. Podr\u00edamos definir una clase base para una interfaz de transferencia de datos y permitir que cada fabricante de equipo de adquisici\u00f3n de datos implemente los detalles de comunicaci\u00f3n con cada interfaz en particular. class Procesador_de_datos(TCPHandler): def procesar_pedido(self): ... # Procesamiento de datos La clase base contiene c\u00f3digo de administraci\u00f3n no espec\u00edfico. Cada clase hereda ese c\u00f3digo y modifica las partes necesarias. Relaci\u00f3n \"isinstance\" La herencia establece una relaci\u00f3n de clases. class FiguraGeom: ... class Circulo(FiguraGeom): Preguntamos si un objeto es una instancia de cierta clase: >>> f = Circulo(4.0) >>> isinstance(f, FiguraGeom) True >>> Importante: Idealmente, todo c\u00f3digo que funcione con instancias de una clase base deber\u00eda tambi\u00e9n funcionar con instancias de las clases derivadas de ella. La clase base object Si una clase no tiene superclase, a veces se escribe object como clase base. class Figura_geom(object): ... object es la superclase de todo objeto en Python. Herencia m\u00faltiple. Pod\u00e9s heredar de varias clases simult\u00e1neamente si los especific\u00e1s en la definici\u00f3n de clase. class Madre: ... class Padre: ... class Hijo(Madre, Padre): ... La clase Hijo hereda caracter\u00edsticas de ambos padres. Algunos detalles son un poco delicados y no vamos a usar esa forma de heredar clases en este curso, aunque vas a encontrar un poco m\u00e1s de informaci\u00f3n en la pr\u00f3xima secci\u00f3n. Ejercicios El concepto de herencia es especialmente \u00fatil cuando est\u00e1s escribiendo c\u00f3digo que va a ser extendido o adaptado, ya sea en bibliotecas o grandes sistemas configurables, pero tambi\u00e9n en peque\u00f1os paquetes de procesamiento de datos que pueden adquirir datos de diversas fuentes. Como ya dijimos antes, uno puede escribir las relaciones y comportamientos fundamentales y dejar los detalles de implementaci\u00f3n de cada interfaz para cuando sean necesarios. Para verlo mejor volvamos a la funci\u00f3n imprimir_informe() del Ejercicio 6.4 , que figura en el programa informe.py . Ten\u00eda m\u00e1s o menos este aspecto: def imprimir_informe(data_informe): ''' Imprime una tabla prolija desde una lista de tuplas con (nombre, cajones, precio, cambio) ''' headers = ('Nombre','Cajones','Precio','Cambio') print('%10s %10s %10s %10s' % headers) print(('-'*10 + ' ')*len(headers)) for row in data_informe: print('%10s %10d %10.2f %10.2f' % row) Al ejecutar tu programa informe la salida es algo parecido a esto: >>> import informe >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv') Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 $32.2 8.02 Naranja 50 $91.1 15.18 Caqui 150 $103.44 2.02 Mandarina 200 $51.23 29.66 Durazno 95 $40.37 33.11 Mandarina 50 $65.1 15.79 Naranja 100 $70.44 35.84 A continuaci\u00f3n vamos a trabajar con herencias relacionadas con este c\u00f3digo. Ejercicio 9.5: Un problema de extensibilidad Imagin\u00e1 que necesit\u00e1s que la funci\u00f3n imprimir_informe() pueda exportar el informe en una variedad de formatos: texto plano, HTML, CSV \u00f3 XML. Podr\u00edas escribir una funci\u00f3n enorme que resuelva todos los casos, pero resultar\u00eda en c\u00f3digo repetido, y dif\u00edcil de mantener. Esta es una oportunidad perfecta para usar herencia de objetos. Vamos a enfocarnos en los pasos necesarios para crear una tabla. Al principio de la tabla tenemos los encabezados de las columnas. Despu\u00e9s de eso, los datos de la tabla ordenados en una fila por \u00edtem. Pongamos cada uno de esos pasos en una clase distinta. Cre\u00e1 un archivo llamado formato_tabla.py y defin\u00ed la siguiente clase: # formato_tabla.py class FormatoTabla: def encabezado(self, headers): ''' Crea el encabezado de la tabla. ''' raise NotImplementedError() def fila(self, rowdata): ''' Crea una \u00fanica fila de datos de la tabla. ''' raise NotImplementedError() Por ahora la clase no hace nada, pero sirve como una especie de especificaci\u00f3n de dise\u00f1o para otras clases que vamos a definir. Una clase como \u00e9sta es a menudo llamada \"clase base abstracta\". Ahora es necesario modificar la funci\u00f3n imprimir_informe() para que acepte como fuente de datos un objeto FormatoTabla e invoque los m\u00e9todos de este objeto para producir la tabla de salida. Algo as\u00ed: # informe.py import formato_tabla ... def imprimir_informe(data_informe, formateador): ''' Imprime una tabla prolija desde una lista de tuplas con (nombre, cajones, precio, diferencia) ''' formateador.encabezado(['Nombre', 'Cantidad', 'Precio', 'Cambio']) for nombre, cajones, precio, cambio in data_informe: rowdata = [ nombre, str(cajones), f'{precio:0.2f}', f'{cambio:0.2f}' ] formateador.fila(rowdata) Como agregaste un argumento a imprimir_informe() , hay que modificar tambi\u00e9n informe_camion() . Cambialo para que cree un objeto formateador de este modo: # informe.py import formato_tabla ... def informe_camion(archivo_camion, archivo_precios): ''' Crea un informe a partir de un archivo de cami\u00f3n y otro de precios de venta. ''' # Leer archivos con datos camion = leer_camion(archivo_camion) precios = leer_precios(archivo_precios) # Crear los datos para el informe data_informe = hacer_informe(camion, precios) # Imprimir el informe formateador = formato_tabla.FormatoTabla() imprimir_informe(data_informe, formateador) Ejecut\u00e1 este c\u00f3digo: >>> ================================ RESTART ================================ >>> import informe >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv') ... crashes ... Deber\u00eda dar inmediatamente una excepci\u00f3n de tipo NotImplementedError . No es nada maravilloso, pero es exactamente lo que esper\u00e1bamos que sucediera, \u00bfno? Sigamos... Ejercicio 9.6: Usemos herencia para cambiar la salida La clase FormatoTabla que definiste en la primera parte es s\u00f3lo la base de un sistema extensible. \u00c9ste es el momento de extenderla. Defin\u00ed una clase FormatoTablaTXT como sigue: # formato_tabla.py ... class FormatoTablaTXT(FormatoTabla): ''' Generar una tabla en formato TXT ''' def encabezado(self, headers): for h in headers: print(f'{h:>10s}', end=' ') print() print(('-'*10 + ' ')*len(headers)) def fila(self, data_fila): for d in data_fila: print(f'{d:>10s}', end=' ') print() Modific\u00e1 la funci\u00f3n informe_camion() y probala: # informe.py ... def informe_camion(archivo_camion, archivo_precios): ''' Crea un informe por camion a partir de archivos camion y precio. ''' # Leer archivos con datos camion = leer_camion(archivo_camion) precios = leer_precios(archivo_precios) # Obtener los datos para un informe data_informe = hacer_informe(camion, precios) # Imprimir formateador = formato_tabla.FormatoTablaTXT() imprimir_informe(data_informe, formateador) Este c\u00f3digo deber\u00eda dar la misma salida que antes: >>> ========================REINICIAR INTERPRETE======================== >>> import informe >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv') Nombre Cantidad Precio Cambio ---------- ---------- ---------- ---------- Lima 100 32.20 8.02 Naranja 50 91.10 15.18 Caqui 150 103.44 2.02 Mandarina 200 51.23 29.66 Durazno 95 40.37 33.11 Mandarina 50 65.10 15.79 Naranja 100 70.44 35.84 >>> Ahora probemos otras variantes. Defin\u00ed, para empezar, una nueva clase llamada FormatoTablaCSV que genere la salida en formato CSV: # formato_tabla.py ... class FormatoTablaCSV(FormatoTabla): ''' Generar una tabla en formato CSV ''' def encabezado(self, headers): print(','.join(headers)) def fila(self, data_fila): print(','.join(data_fila)) Modific\u00e1 tu programa informe.py de este modo: def informe_camion(archivo_camion, archivo_precios): ''' Crea un informe por camion a partir de archivos camion y precio. ''' # Leer archivos con datos camion = leer_camion(archivo_camion) precios = leer_precios(archivo_precios) # Obtener los datos para un informe data_informe = hacer_informe(camion, precios) # Imprimir formateador = formato_tabla.FormatoTablaCSV() imprimir_informe(data_informe, formateador) Ahora la salida deber\u00eda tener este aspecto: >>> ========================REINICIAR INTERPRETE======================== >>> import informe >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv') Nombre,Cantidad,Precio,Cambio Lima,100,32.20,8.02 Naranja,50,91.10,15.18 Caqui,150,103.44,2.02 Mandarina,200,51.23,29.66 Durazno,95,40.37,33.11 Mandarina,50,65.10,15.79 Naranja,100,70.44,35.84 Usando las mismas ideas cre\u00e1 la clase FormatoTablaHTML que produzca un tabla de la siguiente forma: <tr><th>Nombre</th><th>Cajones</th><th>Precio</th><th>Cambio</th></tr> <tr><td>Lima</td><td>100</td><td>32.20</td><td>8.02</td></tr> <tr><td>Naranja</td><td>50</td><td>91.10</td><td>15.18</td></tr> <tr><td>Caqui</td><td>150</td><td>103.44</td><td>2.02</td></tr> <tr><td>Mandarina</td><td>200</td><td>51.23</td><td>29.66</td></tr> <tr><td>Durazno</td><td>95</td><td>40.37</td><td>33.11</td></tr> <tr><td>Mandarina</td><td>50</td><td>65.10</td><td>15.79</td></tr> <tr><td>Naranja</td><td>100</td><td>70.44</td><td>35.84</td></tr> Para testear tu c\u00f3digo, modific\u00e1 el programa principal de modo que use un objeto de la clase FormatoTablaHTML en lugar de uno de la clase FormatoTablaCSV para darle formato a la tabla de salida. Fijate lo f\u00e1cil que es cambiar el comportamiento de un programa cuando ten\u00e9s objetos que son compatibles entre s\u00ed. Ejercicio 9.7: Polimorfismo en acci\u00f3n Una de las grandes ventajas de la programaci\u00f3n orientada a objetos es que pod\u00e9s cambiar un objeto por otro compatible y tu programa va a funcionar sin necesidad de adaptar el c\u00f3digo que usa esos objetos. Si escribiste un programa dise\u00f1ado para usar un objeto de la clase FormatoTabla , va a funcionar sin importar qu\u00e9 objeto de esa clase uses. A este comportamiento particular se lo llama polimorfismo. Est\u00e1 relacionado con la capacidad de usar la misma interfaz con diferentes objetos de la misma clase, haciendo que el programa como un todo se porte distinto. Ahora bien, un potencial problema es c\u00f3mo dise\u00f1ar tu programa de manera que el usuarie final pueda elegir el formato. Usar los nombres de las clases de formateadores no resultar\u00eda c\u00f3modo. Una soluci\u00f3n posible es considerar un condicional: def informe_camion(archivo_camion, archivo_precios, fmt = 'txt'): ''' Crea un informe con la carga de un cami\u00f3n a partir de archivos camion y precio. El formato predeterminado de la salida es txt Alternativas: csv o html ''' # Leer archivos con datos camion = leer_camion(archivo_camion) precios = leer_precios(archivo_precios) # Obtener los datos para un informe data_informe = hacer_informe(camion, precios) # Elige formato if fmt == 'txt': formateador = formato_tabla.FormatoTablaTXT() elif fmt == 'csv': formateador = formato_tabla.FormatoTablaCSV() elif fmt == 'html': formateador = formato_tabla.FormatoTablaHTML() else: raise RuntimeError(f'Unknown format {fmt}') imprimir_informe(data_informe, formateador) En este c\u00f3digo, el usuarie especifica un nombre simplificado como txt o csv para elegir el formato. Pero banc\u00e1. \u00bfEs una buena idea poner un gran bloque if en la funci\u00f3n informe_camion() ? \u00bfO quiz\u00e1s ser\u00eda mejor ponerla directamente en una funci\u00f3n de prop\u00f3sito general en otro lado? En el archivo formato_tabla.py , agreg\u00e1 la funci\u00f3n crear_formateador(nombre) que permita crear un objeto formateador dado un tipo de salida como txt , csv , o html . Modific\u00e1 informe_camion() para que se vea as\u00ed: def informe_camion(archivo_camion, archivo_precios, fmt = 'txt'): ''' Crea un informe con la carga de un cami\u00f3n a partir de archivos camion y precio. El formato predeterminado de la salida es .txt Alternativas: .csv o .html ''' # Lee archivos de datos camion = leer_camion(archivo_camion) precios = leer_precios(archivo_precios) # Crea la data del informe data_informe = hacer_informe(camion, precios) # Imprime el informe formateador = formato_tabla.crear_formateador(fmt) imprimir_informe(data_informe, formateador) Acordate de testear todas las ramas posibles del c\u00f3digo para asegurarte de que est\u00e1 funcionando. Llamalo y pedile crear salidas en todos los formatos (pod\u00e9s ver el HTML con tu browser). Ejercicio 9.8: Volvamos a armar todo Modific\u00e1 tu programa informe.py de modo que la funci\u00f3n informe_camion() acepte un par\u00e1metro opcional que especifique el formato de salida deseado. Por ejemplo: >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv', fmt = 'txt') Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 32.20 8.02 Naranja 50 91.10 15.18 Caqui 150 103.44 2.02 Mandarina 200 51.23 29.66 Durazno 95 40.37 33.11 Mandarina 50 65.10 15.79 Naranja 100 70.44 35.84 >>> Modific\u00e1 el programa principal y us\u00e1 sys.argv() para poder definir un formato particular directamente desde la l\u00ednea de comandos. En el siguiente ejemplo se ve un caso de uso. Idealmente, ese par\u00e1metro deber\u00eda ser opcional y, si no se lo pas\u00e1s, deber\u00eda andar como antes. bash $ python3 informe.py ../Data/camion.csv ../Data/precios.csv csv Nombre,Cajones,Precio,Cambio Lima,100,32.20,8.02 Naranja,50,91.10,15.18 Caqui,150,103.44,2.02 Mandarina,200,51.23,29.66 Durazno,95,40.37,33.11 Mandarina,50,65.10,15.79 Naranja,100,70.44,35.84 Esta versi\u00f3n de informe.py preparala para entregarla. Discusi\u00f3n El caso que vimos es un ejemplo de uno de los usos m\u00e1s comunes de herencia en programaci\u00f3n orientada a objetos: escribir programas extensibles. Un sistema puede definir una interfaz mediante una superclase base, y pedirte que escribas tus propias implementaciones derivadas de esa clase. Si escrib\u00eds los m\u00e9todos espec\u00edficos para tu caso particular pod\u00e9s adaptar la funci\u00f3n de un sistema general para resolver tu problema. Otro concepto, un poco m\u00e1s interesante, es el de crear tus propias abstracciones. En los ejercicios de esta parte definimos nuestra propia clase para crear variaciones en el formato de un informe. Tal vez est\u00e9s pensando \"\u00a1Deber\u00eda usar una biblioteca para crear formatos ya escrita por otre!\". Bueno, no. Est\u00e1 bueno que puedas tanto crear tu propia clase como usar una biblioteca ya escrita. El hecho de usar tu propia clase te da flexibilidad. Siempre que tu programa adhiera a la interfaz de objetos definida por tu clase, pod\u00e9s cambiar la implementaci\u00f3n interna en los objetos que escribas para que funcionen del modo que elijas. Pod\u00e9s escribir todo el c\u00f3digo vos o usar bibliotecas ya escritas, no importa. Cuando encuentres algo mejor, cambi\u00e1s tu implementaci\u00f3n para que llame al nuevo c\u00f3digo. Si la interfaz que hiciste est\u00e1 bien escrita, no vas a necesitar modificar el programa que usa las diferentes implementaciones. Simplemente funcionan si cumplen los contratos de la interfaz. Es algo muy \u00fatil y es uno de los motivos por los que usar herencia puede resolverte los problemas de extensibilidad y diversidad a futuro. Dicho esto, es cierto que dise\u00f1ar un programa en el paradigma orientado a objetos puede resultar algo muy dif\u00edcil. Si vas a encarar proyectos grandes con esta herramienta, consult\u00e1 libros sobre patrones de dise\u00f1o en POO. De todos modos, haber entendido lo que acabamos de hacer te permite llegar bastante lejos. Contenidos | Anterior (2 Clases) | Pr\u00f3ximo (4 M\u00e9todos especiales)","title":"03 Herencia"},{"location":"09_Clases_y_Objetos/03_Herencia/#93-herencia","text":"Esta secci\u00f3n tiene un video donde introducimos el tema de herencia. La herencia entre clases es una herramienta muy usada para escribir programas extensibles. Exploraremos esta idea a continuaci\u00f3n.","title":"9.3 Herencia"},{"location":"09_Clases_y_Objetos/03_Herencia/#introduccion","text":"Se usa herencia para crear objetos m\u00e1s especializados a partir de objetos existentes. class Padre: ... class Hijo(Padre): ... Se dice que Hijo es una clase derivada o subclase. La clase Padre es conocida como la clase base, o superclase. La expresi\u00f3n class Hijo(Padre): significa que estamos creando una clase llamada Hijo que es derivada de la clase Padre .","title":"Introducci\u00f3n"},{"location":"09_Clases_y_Objetos/03_Herencia/#extensiones","text":"Al usar herencia pod\u00e9s tomar una clase existente y ... Agregarle m\u00e9todos Redifinir m\u00e9todos existentes Agregar nuevos atributos Pod\u00e9s verlo como una forma de extender de tu codigo existente. Darle nuevos comportamientos, abarcar un abanico m\u00e1s amplio de posibilidades \u00f3 aumentar su compatibilidad.","title":"Extensiones"},{"location":"09_Clases_y_Objetos/03_Herencia/#ejemplo","text":"Supon\u00e9 que part\u00eds de la siguiente clase: class Lote: def __init__(self, nombre, cajones, precio): self.nombre = nombre self.cajones = cajones self.precio = precio def costo(self): return self.cajones * self.precio def vender(self, ncajones): self.cajones -= ncajones Pod\u00e9s modificar lo que necesites mediante herencia.","title":"Ejemplo"},{"location":"09_Clases_y_Objetos/03_Herencia/#agregar-un-metodo-nuevo","text":"class MiLote(Lote): def rematar(self): self.vender(self.cajones) Se puede usar as\u00ed: >>> c = MiLote('Pera', 100, 490.1) >>> c.vender(25) >>> c.cajones 75 >>> c.rematar() >>> c.cajones 0 >>> Esta clase hered\u00f3 los atributos y m\u00e9todos de Lote y la extend\u00edo con un nuevo m\u00e9todo ( rematar() ).","title":"Agregar un m\u00e9todo nuevo"},{"location":"09_Clases_y_Objetos/03_Herencia/#redefinir-un-metodo-existente","text":"class MiLote(Lote): def costo(self): return 1.25 * self.cajones * self.precio Un ejemplo de uso: >>> c = MiLote('Pera', 100, 490.1) >>> c.costo() 61262.5 >>> El m\u00e9todo nuevo simplemente reemplaza al definido en la clase base. Los dem\u00e1s m\u00e9todos y atributos no son afectados. \u00bfNo es buen\u00edsimo?","title":"Redefinir un m\u00e9todo existente"},{"location":"09_Clases_y_Objetos/03_Herencia/#utilizar-un-metodo-prevalente","text":"Hay veces en que una clase extiende el m\u00e9todo de la superclase a la que pertenece, pero necesita ejecutar el m\u00e9todo original como parte de la redefinici\u00f3n del m\u00e9todo nuevo. Para referirte a la superclase, us\u00e1 super() : class Lote: ... def costo(self): return self.cajones * self.precio ... class MiLote(Lote): def costo(self): # Fijate c\u00f3mo usamos `super` costo_orig = super().costo() return 1.25 * costo_orig Us\u00e1 super() para llamar al m\u00e9todo de la clase base (del la cual \u00e9sta es heredera).","title":"Utilizar un m\u00e9todo prevalente"},{"location":"09_Clases_y_Objetos/03_Herencia/#el-metodo-__init__-y-herencia","text":"Al crear cada instancia se ejecuta __init__ . Ah\u00ed reside el c\u00f3digo importante para la creaci\u00f3n de una instancia nueva. Si redefin\u00eds __init__ siempre inclu\u00ed un llamado al m\u00e9todo __init__ de la clase base para inicializarla tambi\u00e9n. class Lote: def __init__(self, nombre, cajones, precio): self.nombre = nombre self.cajones = cajones self.precio = precio ... class MiLote(Lote): def __init__(self, nombre, cajones, precio, factor): # Fijate como es el llamado a `super().__init__()` super().__init__(nombre, cajones, precio) self.factor = factor def costo(self): return self.factor * super().costo() Es necesario llamar al m\u00e9todo __init__() en la clase base. Es una forma de ejecutar la versi\u00f3n previa del m\u00e9todo que estamos redefiniendo, como mostramos reci\u00e9n.","title":"El m\u00e9todo __init__ y herencia."},{"location":"09_Clases_y_Objetos/03_Herencia/#usos-de-herencia","text":"Uno de los usos de definir una clase como heredera de otra es organizar jer\u00e1rquicamente objetos que est\u00e1n relacionados. Un ejemplo: Las figuras geom\u00e9tricas pueden tener ciertos m\u00e9todos y atributos que luego son refinados en casos concretos como c\u00edrculos o rect\u00e1ngulos. class FiguraGeom: ... class Circulo(FiguraGeom): ... class Rectangulo(FiguraGeom): ... Imaginate por ejemplo su uso en una jerarqu\u00eda l\u00f3gica, o taxon\u00f3mica, en la que las clases tienen una relaci\u00f3n natural tal que hace intuitivo derivar una de otra. Una aplicaci\u00f3n m\u00e1s com\u00fan, y tal vez m\u00e1s pr\u00e1ctica, consiste en escribir c\u00f3digo que es reutilizable y/o extensible. Podr\u00edamos definir una clase base para una interfaz de transferencia de datos y permitir que cada fabricante de equipo de adquisici\u00f3n de datos implemente los detalles de comunicaci\u00f3n con cada interfaz en particular. class Procesador_de_datos(TCPHandler): def procesar_pedido(self): ... # Procesamiento de datos La clase base contiene c\u00f3digo de administraci\u00f3n no espec\u00edfico. Cada clase hereda ese c\u00f3digo y modifica las partes necesarias.","title":"Usos de herencia"},{"location":"09_Clases_y_Objetos/03_Herencia/#relacion-isinstance","text":"La herencia establece una relaci\u00f3n de clases. class FiguraGeom: ... class Circulo(FiguraGeom): Preguntamos si un objeto es una instancia de cierta clase: >>> f = Circulo(4.0) >>> isinstance(f, FiguraGeom) True >>> Importante: Idealmente, todo c\u00f3digo que funcione con instancias de una clase base deber\u00eda tambi\u00e9n funcionar con instancias de las clases derivadas de ella.","title":"Relaci\u00f3n \"isinstance\""},{"location":"09_Clases_y_Objetos/03_Herencia/#la-clase-base-object","text":"Si una clase no tiene superclase, a veces se escribe object como clase base. class Figura_geom(object): ... object es la superclase de todo objeto en Python.","title":"La clase base object"},{"location":"09_Clases_y_Objetos/03_Herencia/#herencia-multiple","text":"Pod\u00e9s heredar de varias clases simult\u00e1neamente si los especific\u00e1s en la definici\u00f3n de clase. class Madre: ... class Padre: ... class Hijo(Madre, Padre): ... La clase Hijo hereda caracter\u00edsticas de ambos padres. Algunos detalles son un poco delicados y no vamos a usar esa forma de heredar clases en este curso, aunque vas a encontrar un poco m\u00e1s de informaci\u00f3n en la pr\u00f3xima secci\u00f3n.","title":"Herencia m\u00faltiple."},{"location":"09_Clases_y_Objetos/03_Herencia/#ejercicios","text":"El concepto de herencia es especialmente \u00fatil cuando est\u00e1s escribiendo c\u00f3digo que va a ser extendido o adaptado, ya sea en bibliotecas o grandes sistemas configurables, pero tambi\u00e9n en peque\u00f1os paquetes de procesamiento de datos que pueden adquirir datos de diversas fuentes. Como ya dijimos antes, uno puede escribir las relaciones y comportamientos fundamentales y dejar los detalles de implementaci\u00f3n de cada interfaz para cuando sean necesarios. Para verlo mejor volvamos a la funci\u00f3n imprimir_informe() del Ejercicio 6.4 , que figura en el programa informe.py . Ten\u00eda m\u00e1s o menos este aspecto: def imprimir_informe(data_informe): ''' Imprime una tabla prolija desde una lista de tuplas con (nombre, cajones, precio, cambio) ''' headers = ('Nombre','Cajones','Precio','Cambio') print('%10s %10s %10s %10s' % headers) print(('-'*10 + ' ')*len(headers)) for row in data_informe: print('%10s %10d %10.2f %10.2f' % row) Al ejecutar tu programa informe la salida es algo parecido a esto: >>> import informe >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv') Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 $32.2 8.02 Naranja 50 $91.1 15.18 Caqui 150 $103.44 2.02 Mandarina 200 $51.23 29.66 Durazno 95 $40.37 33.11 Mandarina 50 $65.1 15.79 Naranja 100 $70.44 35.84 A continuaci\u00f3n vamos a trabajar con herencias relacionadas con este c\u00f3digo.","title":"Ejercicios"},{"location":"09_Clases_y_Objetos/03_Herencia/#ejercicio-95-un-problema-de-extensibilidad","text":"Imagin\u00e1 que necesit\u00e1s que la funci\u00f3n imprimir_informe() pueda exportar el informe en una variedad de formatos: texto plano, HTML, CSV \u00f3 XML. Podr\u00edas escribir una funci\u00f3n enorme que resuelva todos los casos, pero resultar\u00eda en c\u00f3digo repetido, y dif\u00edcil de mantener. Esta es una oportunidad perfecta para usar herencia de objetos. Vamos a enfocarnos en los pasos necesarios para crear una tabla. Al principio de la tabla tenemos los encabezados de las columnas. Despu\u00e9s de eso, los datos de la tabla ordenados en una fila por \u00edtem. Pongamos cada uno de esos pasos en una clase distinta. Cre\u00e1 un archivo llamado formato_tabla.py y defin\u00ed la siguiente clase: # formato_tabla.py class FormatoTabla: def encabezado(self, headers): ''' Crea el encabezado de la tabla. ''' raise NotImplementedError() def fila(self, rowdata): ''' Crea una \u00fanica fila de datos de la tabla. ''' raise NotImplementedError() Por ahora la clase no hace nada, pero sirve como una especie de especificaci\u00f3n de dise\u00f1o para otras clases que vamos a definir. Una clase como \u00e9sta es a menudo llamada \"clase base abstracta\". Ahora es necesario modificar la funci\u00f3n imprimir_informe() para que acepte como fuente de datos un objeto FormatoTabla e invoque los m\u00e9todos de este objeto para producir la tabla de salida. Algo as\u00ed: # informe.py import formato_tabla ... def imprimir_informe(data_informe, formateador): ''' Imprime una tabla prolija desde una lista de tuplas con (nombre, cajones, precio, diferencia) ''' formateador.encabezado(['Nombre', 'Cantidad', 'Precio', 'Cambio']) for nombre, cajones, precio, cambio in data_informe: rowdata = [ nombre, str(cajones), f'{precio:0.2f}', f'{cambio:0.2f}' ] formateador.fila(rowdata) Como agregaste un argumento a imprimir_informe() , hay que modificar tambi\u00e9n informe_camion() . Cambialo para que cree un objeto formateador de este modo: # informe.py import formato_tabla ... def informe_camion(archivo_camion, archivo_precios): ''' Crea un informe a partir de un archivo de cami\u00f3n y otro de precios de venta. ''' # Leer archivos con datos camion = leer_camion(archivo_camion) precios = leer_precios(archivo_precios) # Crear los datos para el informe data_informe = hacer_informe(camion, precios) # Imprimir el informe formateador = formato_tabla.FormatoTabla() imprimir_informe(data_informe, formateador) Ejecut\u00e1 este c\u00f3digo: >>> ================================ RESTART ================================ >>> import informe >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv') ... crashes ... Deber\u00eda dar inmediatamente una excepci\u00f3n de tipo NotImplementedError . No es nada maravilloso, pero es exactamente lo que esper\u00e1bamos que sucediera, \u00bfno? Sigamos...","title":"Ejercicio 9.5: Un problema de extensibilidad"},{"location":"09_Clases_y_Objetos/03_Herencia/#ejercicio-96-usemos-herencia-para-cambiar-la-salida","text":"La clase FormatoTabla que definiste en la primera parte es s\u00f3lo la base de un sistema extensible. \u00c9ste es el momento de extenderla. Defin\u00ed una clase FormatoTablaTXT como sigue: # formato_tabla.py ... class FormatoTablaTXT(FormatoTabla): ''' Generar una tabla en formato TXT ''' def encabezado(self, headers): for h in headers: print(f'{h:>10s}', end=' ') print() print(('-'*10 + ' ')*len(headers)) def fila(self, data_fila): for d in data_fila: print(f'{d:>10s}', end=' ') print() Modific\u00e1 la funci\u00f3n informe_camion() y probala: # informe.py ... def informe_camion(archivo_camion, archivo_precios): ''' Crea un informe por camion a partir de archivos camion y precio. ''' # Leer archivos con datos camion = leer_camion(archivo_camion) precios = leer_precios(archivo_precios) # Obtener los datos para un informe data_informe = hacer_informe(camion, precios) # Imprimir formateador = formato_tabla.FormatoTablaTXT() imprimir_informe(data_informe, formateador) Este c\u00f3digo deber\u00eda dar la misma salida que antes: >>> ========================REINICIAR INTERPRETE======================== >>> import informe >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv') Nombre Cantidad Precio Cambio ---------- ---------- ---------- ---------- Lima 100 32.20 8.02 Naranja 50 91.10 15.18 Caqui 150 103.44 2.02 Mandarina 200 51.23 29.66 Durazno 95 40.37 33.11 Mandarina 50 65.10 15.79 Naranja 100 70.44 35.84 >>> Ahora probemos otras variantes. Defin\u00ed, para empezar, una nueva clase llamada FormatoTablaCSV que genere la salida en formato CSV: # formato_tabla.py ... class FormatoTablaCSV(FormatoTabla): ''' Generar una tabla en formato CSV ''' def encabezado(self, headers): print(','.join(headers)) def fila(self, data_fila): print(','.join(data_fila)) Modific\u00e1 tu programa informe.py de este modo: def informe_camion(archivo_camion, archivo_precios): ''' Crea un informe por camion a partir de archivos camion y precio. ''' # Leer archivos con datos camion = leer_camion(archivo_camion) precios = leer_precios(archivo_precios) # Obtener los datos para un informe data_informe = hacer_informe(camion, precios) # Imprimir formateador = formato_tabla.FormatoTablaCSV() imprimir_informe(data_informe, formateador) Ahora la salida deber\u00eda tener este aspecto: >>> ========================REINICIAR INTERPRETE======================== >>> import informe >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv') Nombre,Cantidad,Precio,Cambio Lima,100,32.20,8.02 Naranja,50,91.10,15.18 Caqui,150,103.44,2.02 Mandarina,200,51.23,29.66 Durazno,95,40.37,33.11 Mandarina,50,65.10,15.79 Naranja,100,70.44,35.84 Usando las mismas ideas cre\u00e1 la clase FormatoTablaHTML que produzca un tabla de la siguiente forma: <tr><th>Nombre</th><th>Cajones</th><th>Precio</th><th>Cambio</th></tr> <tr><td>Lima</td><td>100</td><td>32.20</td><td>8.02</td></tr> <tr><td>Naranja</td><td>50</td><td>91.10</td><td>15.18</td></tr> <tr><td>Caqui</td><td>150</td><td>103.44</td><td>2.02</td></tr> <tr><td>Mandarina</td><td>200</td><td>51.23</td><td>29.66</td></tr> <tr><td>Durazno</td><td>95</td><td>40.37</td><td>33.11</td></tr> <tr><td>Mandarina</td><td>50</td><td>65.10</td><td>15.79</td></tr> <tr><td>Naranja</td><td>100</td><td>70.44</td><td>35.84</td></tr> Para testear tu c\u00f3digo, modific\u00e1 el programa principal de modo que use un objeto de la clase FormatoTablaHTML en lugar de uno de la clase FormatoTablaCSV para darle formato a la tabla de salida. Fijate lo f\u00e1cil que es cambiar el comportamiento de un programa cuando ten\u00e9s objetos que son compatibles entre s\u00ed.","title":"Ejercicio 9.6: Usemos herencia para cambiar la salida"},{"location":"09_Clases_y_Objetos/03_Herencia/#ejercicio-97-polimorfismo-en-accion","text":"Una de las grandes ventajas de la programaci\u00f3n orientada a objetos es que pod\u00e9s cambiar un objeto por otro compatible y tu programa va a funcionar sin necesidad de adaptar el c\u00f3digo que usa esos objetos. Si escribiste un programa dise\u00f1ado para usar un objeto de la clase FormatoTabla , va a funcionar sin importar qu\u00e9 objeto de esa clase uses. A este comportamiento particular se lo llama polimorfismo. Est\u00e1 relacionado con la capacidad de usar la misma interfaz con diferentes objetos de la misma clase, haciendo que el programa como un todo se porte distinto. Ahora bien, un potencial problema es c\u00f3mo dise\u00f1ar tu programa de manera que el usuarie final pueda elegir el formato. Usar los nombres de las clases de formateadores no resultar\u00eda c\u00f3modo. Una soluci\u00f3n posible es considerar un condicional: def informe_camion(archivo_camion, archivo_precios, fmt = 'txt'): ''' Crea un informe con la carga de un cami\u00f3n a partir de archivos camion y precio. El formato predeterminado de la salida es txt Alternativas: csv o html ''' # Leer archivos con datos camion = leer_camion(archivo_camion) precios = leer_precios(archivo_precios) # Obtener los datos para un informe data_informe = hacer_informe(camion, precios) # Elige formato if fmt == 'txt': formateador = formato_tabla.FormatoTablaTXT() elif fmt == 'csv': formateador = formato_tabla.FormatoTablaCSV() elif fmt == 'html': formateador = formato_tabla.FormatoTablaHTML() else: raise RuntimeError(f'Unknown format {fmt}') imprimir_informe(data_informe, formateador) En este c\u00f3digo, el usuarie especifica un nombre simplificado como txt o csv para elegir el formato. Pero banc\u00e1. \u00bfEs una buena idea poner un gran bloque if en la funci\u00f3n informe_camion() ? \u00bfO quiz\u00e1s ser\u00eda mejor ponerla directamente en una funci\u00f3n de prop\u00f3sito general en otro lado? En el archivo formato_tabla.py , agreg\u00e1 la funci\u00f3n crear_formateador(nombre) que permita crear un objeto formateador dado un tipo de salida como txt , csv , o html . Modific\u00e1 informe_camion() para que se vea as\u00ed: def informe_camion(archivo_camion, archivo_precios, fmt = 'txt'): ''' Crea un informe con la carga de un cami\u00f3n a partir de archivos camion y precio. El formato predeterminado de la salida es .txt Alternativas: .csv o .html ''' # Lee archivos de datos camion = leer_camion(archivo_camion) precios = leer_precios(archivo_precios) # Crea la data del informe data_informe = hacer_informe(camion, precios) # Imprime el informe formateador = formato_tabla.crear_formateador(fmt) imprimir_informe(data_informe, formateador) Acordate de testear todas las ramas posibles del c\u00f3digo para asegurarte de que est\u00e1 funcionando. Llamalo y pedile crear salidas en todos los formatos (pod\u00e9s ver el HTML con tu browser).","title":"Ejercicio 9.7: Polimorfismo en acci\u00f3n"},{"location":"09_Clases_y_Objetos/03_Herencia/#ejercicio-98-volvamos-a-armar-todo","text":"Modific\u00e1 tu programa informe.py de modo que la funci\u00f3n informe_camion() acepte un par\u00e1metro opcional que especifique el formato de salida deseado. Por ejemplo: >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv', fmt = 'txt') Nombre Cajones Precio Cambio ---------- ---------- ---------- ---------- Lima 100 32.20 8.02 Naranja 50 91.10 15.18 Caqui 150 103.44 2.02 Mandarina 200 51.23 29.66 Durazno 95 40.37 33.11 Mandarina 50 65.10 15.79 Naranja 100 70.44 35.84 >>> Modific\u00e1 el programa principal y us\u00e1 sys.argv() para poder definir un formato particular directamente desde la l\u00ednea de comandos. En el siguiente ejemplo se ve un caso de uso. Idealmente, ese par\u00e1metro deber\u00eda ser opcional y, si no se lo pas\u00e1s, deber\u00eda andar como antes. bash $ python3 informe.py ../Data/camion.csv ../Data/precios.csv csv Nombre,Cajones,Precio,Cambio Lima,100,32.20,8.02 Naranja,50,91.10,15.18 Caqui,150,103.44,2.02 Mandarina,200,51.23,29.66 Durazno,95,40.37,33.11 Mandarina,50,65.10,15.79 Naranja,100,70.44,35.84 Esta versi\u00f3n de informe.py preparala para entregarla.","title":"Ejercicio 9.8: Volvamos a armar todo"},{"location":"09_Clases_y_Objetos/03_Herencia/#discusion","text":"El caso que vimos es un ejemplo de uno de los usos m\u00e1s comunes de herencia en programaci\u00f3n orientada a objetos: escribir programas extensibles. Un sistema puede definir una interfaz mediante una superclase base, y pedirte que escribas tus propias implementaciones derivadas de esa clase. Si escrib\u00eds los m\u00e9todos espec\u00edficos para tu caso particular pod\u00e9s adaptar la funci\u00f3n de un sistema general para resolver tu problema. Otro concepto, un poco m\u00e1s interesante, es el de crear tus propias abstracciones. En los ejercicios de esta parte definimos nuestra propia clase para crear variaciones en el formato de un informe. Tal vez est\u00e9s pensando \"\u00a1Deber\u00eda usar una biblioteca para crear formatos ya escrita por otre!\". Bueno, no. Est\u00e1 bueno que puedas tanto crear tu propia clase como usar una biblioteca ya escrita. El hecho de usar tu propia clase te da flexibilidad. Siempre que tu programa adhiera a la interfaz de objetos definida por tu clase, pod\u00e9s cambiar la implementaci\u00f3n interna en los objetos que escribas para que funcionen del modo que elijas. Pod\u00e9s escribir todo el c\u00f3digo vos o usar bibliotecas ya escritas, no importa. Cuando encuentres algo mejor, cambi\u00e1s tu implementaci\u00f3n para que llame al nuevo c\u00f3digo. Si la interfaz que hiciste est\u00e1 bien escrita, no vas a necesitar modificar el programa que usa las diferentes implementaciones. Simplemente funcionan si cumplen los contratos de la interfaz. Es algo muy \u00fatil y es uno de los motivos por los que usar herencia puede resolverte los problemas de extensibilidad y diversidad a futuro. Dicho esto, es cierto que dise\u00f1ar un programa en el paradigma orientado a objetos puede resultar algo muy dif\u00edcil. Si vas a encarar proyectos grandes con esta herramienta, consult\u00e1 libros sobre patrones de dise\u00f1o en POO. De todos modos, haber entendido lo que acabamos de hacer te permite llegar bastante lejos. Contenidos | Anterior (2 Clases) | Pr\u00f3ximo (4 M\u00e9todos especiales)","title":"Discusi\u00f3n"},{"location":"09_Clases_y_Objetos/04_M%C3%A9todos_Especiales/","text":"Contenidos | Anterior (3 Herencia) | Pr\u00f3ximo (5 Objetos, pilas y colas) 9.4 M\u00e9todos especiales El tema de esta secci\u00f3n lo tratamos junto con la introducci\u00f3n a clases, en el video de la Secci\u00f3n 9.2 . Podemos modificar muchos comportamientos de Python definiendo lo que se conoce como \"m\u00e9todos especiales\". Ac\u00e1 vamos a ver c\u00f3mo usar estos m\u00e9todos y a discutir brevemente otras herramientas relacionadas. Introducci\u00f3n Una clase puede tener definidos m\u00e9todos especiales. Estos m\u00e9todos tienen un significado particular para el int\u00e9rprete de Python. Sus nombres empiezan y terminan en __ (doble gui\u00f3n bajo). Por ejemplo __init__ . class Lote(object): def __init__(self): ... def __repr__(self): ... Hay decenas de m\u00e9todos especiales pero s\u00f3lo vamos a tratar algunos ejemplos espec\u00edficos ac\u00e1. M\u00e9todos especiales para convertir a strings Los objetos tienen dos representaciones de tipo cadena. >>> from datetime import date >>> d = date(2020, 12, 21) >>> print(d) 2020-12-21 >>> d datetime.date(2020, 12, 21) >>> La funci\u00f3n str() se usa para crear una representaci\u00f3n agradable de ver: >>> str(d) '2020-12-21' >>> Pero para crear una representaci\u00f3n m\u00e1s informativa para programadores, se usa la funci\u00f3n repr() . >>> repr(d) 'datetime.date(2020, 12, 21)' >>> Las funciones str() y repr() llaman a m\u00e9todos especiales de la clase para generar la cadena de caracteres que se va a mostrar. class Date(object): def __init__(self, year, month, day): self.year = year self.month = month self.day = day # Con `str()` def __str__(self): return f'{self.year}-{self.month}-{self.day}' # Con `repr()` def __repr__(self): return f'Date({self.year},{self.month},{self.day})' Nota: Hay una convenci\u00f3n para __repr__() que indica que debe devolver un string que, cuando sea pasado a eval() vuelva a crear el objeto subayacente. Analiz\u00e1 el ejemplo de datetime.date(2020, 12, 21) . Si no es posible crear un string que haga eso, la convenci\u00f3n es generar una representaci\u00f3n que sea f\u00e1cil de interpretar para una persona. class Punto(): def __init__(self, x, y): self.x = x self.y = y def __str__(self): return f'({self.x}, {self.y})' # Used with `repr()` def __repr__(self): return f'Punto({self.x}, {self.y})' M\u00e9todos matem\u00e1ticos especiales Las operaciones matem\u00e1ticas sobre los objetos involucran llamados a los siguientes m\u00e9todos. a + b a.__add__(b) a - b a.__sub__(b) a * b a.__mul__(b) a / b a.__truediv__(b) a // b a.__floordiv__(b) a % b a.__mod__(b) a << b a.__lshift__(b) a >> b a.__rshift__(b) a & b a.__and__(b) a | b a.__or__(b) a ^ b a.__xor__(b) a ** b a.__pow__(b) -a a.__neg__() ~a a.__invert__() abs(a) a.__abs__() As\u00ed, al definir un m\u00e9todo __add__(b) en la clase Punto , por ejemplo, nos permitir\u00e1 sumar dos instancias de esta clase usando el operador + . class Punto(): ... ... def __add__(self, b): return Punto(self.x + b.x, self.y + b.y) Como en el siguiente ejemplo: >>> a = Punto(1,2) >>> b = Punto(3,4) >>> repr(a + b) 'Punto(4, 6)' M\u00e9todos especiales para acceder a elementos Los siguientes m\u00e9todos se usan para implementar contenedores: len(x) x.__len__() x[a] x.__getitem__(a) x[a] = v x.__setitem__(a,v) del x[a] x.__delitem__(a) Los pod\u00e9s implementar en tus clases. class Secuencia: def __len__(self): ... def __getitem__(self,a): ... def __setitem__(self,a,v): ... def __delitem__(self,a): ... Invocar m\u00e9todos El proceso de invocar un m\u00e9todo puede dividirse en dos partes: B\u00fasqueda: Se usa el operator . Llamado: Se usan () >>> m = Lote('Pera', 100, 490.10) >>> c = m.costo # B\u00fasqueda >>> c <bound method Lote.costo of <Lote object at 0x590d0>> >>> c() # Llamado 49010.0 >>> Nota : la respuesta al pedido de representaci\u00f3n de c es algo as\u00ed como >* M\u00e9todos ligados Un m\u00e9todo que a\u00fan no ha sido llamado por el operador de llamado a funciones () se conoce como m\u00e9todo ligado y opera dentro de la instancia en la que fue originado. >>> m = Lote('Pera', 100, 490.10) >>> m <Lote object at 0x590d0> >>> c = m.costo >>> c <bound method Lote.costo of <Lote object at 0x590d0>> >>> c() 49010.0 >>> Estos m\u00e9todos ligados pueden ser el origen de errores por desprolijidad, que no son nada obvios. Por ejemplo: >>> m = Lote('Pera', 100, 490.10) >>> print('Costo : %0.2f' % m.costo) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: float argument required >>> O una fuente de comportamiento extra\u00f1o que es dif\u00edcil de debuggear. f = open(filename, 'w') ... f.close # EPA! No hicimos nada. `f` sigue abierto. En ambos casos, el error est\u00e1 causado por omitir los par\u00e9ntesis en el (intento de) llamado a la funci\u00f3n. En estos casos deber\u00eda haber sido: m.costo() o f.close() . Sin los par\u00e9ntesis, no estamos llamando a la funci\u00f3n sino refiri\u00e9ndonos al m\u00e9todo. Acceso a atributos Existe una forma alternativa de acceder, manipular, y administrar los atributos de un objeto. getattr(obj, 'name') # Equivale a obj.name setattr(obj, 'name', value) # Equivale a obj.name = value delattr(obj, 'name') # Equivale a del obj.name hasattr(obj, 'name') # Mira si la propiedad existe Ejemplo: if hasattr(obj, 'x'): x = getattr(obj, 'x'): else: x = None Nota : si getattr() no encuentra el atributo buscado ( x en este ejemplo), devuelve el argumento opcional arg ( None en este caso) x = getattr(obj, 'x', None) Ejercicios Ejercicio 9.9: Mejor salida para objetos Modific\u00e1 el objeto Lote que definiste en lote.py (del Ejercicio 9.1 ) de modo que el m\u00e9todo __repr__() genere una salida m\u00e1s agradable. Por ejemplo queremos un comportamiento como \u00e9ste: >>> peras = Lote('Pera', 100, 490.1) >>> peras Lote('Pera', 100, 490.1) >>> Fijate lo que ocurre cuando le\u00e9s un cami\u00f3n de frutas y mir\u00e1s la salida resultante despu\u00e9s de hacer estos cambios. Un ejemplo: >>> import informe >>> camion = informe.leer_camion('../Data/camion.csv') >>> camion ... fijate cu\u00e1l es la salida ... >>> Guard\u00e1 el archivo lote.py para entregar. Ejercicio 9.10: Ejemplo de getattr() getattr() es un mecanismo alternativo de leer atributos. Puede usarse para escribir c\u00f3digo sumamente vers\u00e1til. Prob\u00e1 este ejemplo, para empezar: >>> import lote >>> c = lote.Lote('Peras', 100, 490.1) >>> columnas = ['nombre', 'cajones'] >>> for colname in columnas: print(colname, '=', getattr(c, colname)) nombre = Peras cajones = 100 >>> Queremos que observes algo interesante: los datos de salida est\u00e1n completamente especificados por los nombres de los atributos listados en la variable columnas . Estamos usando el contenido de una variable ('nombre' y 'cajones') como nombres de otras variables, o de atributos de un objeto. No es usual. Si te dan ganas, en el archivo formato_tabla.py us\u00e1 esta idea pero extendela, y cre\u00e1 una funci\u00f3n imprimir_tabla() que imprima una tabla mostrando, de una lista de objetos de tipo arbitrario, una lista de atributos especificados por le usuarie. Tal como antes hicimos con la funci\u00f3n imprimir_informe() del Ejercicio 6.4 imprimir_tabla() tambi\u00e9n deber\u00eda aceptar cualquier instancia de la clase FormatoTabla para definir el formato de la salida. La idea es que funcione m\u00e1s o menos as\u00ed: >>> import informe >>> camion = informe.leer_camion('../Data/camion.csv') >>> from formato_tabla import crear_formateador, imprimir_tabla >>> formateador = crear_formateador('txt') >>> imprimir_tabla(camion, ['nombre','cajones'], formateador) nombre cajones ---------- ---------- Lima 100 Naranja 50 Caqui 150 Mandarina 200 Durazno 95 Mandarina 50 Naranja 100 >>> imprimir_tabla(camion, ['nombre','cajones','precio'], formateador) nombre cajones precio ---------- ---------- ---------- Lima 100 32.2 Naranja 50 91.1 Caqui 150 103.44 Mandarina 200 51.23 Durazno 95 40.37 Mandarina 50 65.1 Naranja 100 70.44 >>> Contenidos | Anterior (3 Herencia) | Pr\u00f3ximo (5 Objetos, pilas y colas)","title":"04 M\u00e9todos Especiales"},{"location":"09_Clases_y_Objetos/04_M%C3%A9todos_Especiales/#94-metodos-especiales","text":"El tema de esta secci\u00f3n lo tratamos junto con la introducci\u00f3n a clases, en el video de la Secci\u00f3n 9.2 . Podemos modificar muchos comportamientos de Python definiendo lo que se conoce como \"m\u00e9todos especiales\". Ac\u00e1 vamos a ver c\u00f3mo usar estos m\u00e9todos y a discutir brevemente otras herramientas relacionadas.","title":"9.4 M\u00e9todos especiales"},{"location":"09_Clases_y_Objetos/04_M%C3%A9todos_Especiales/#introduccion","text":"Una clase puede tener definidos m\u00e9todos especiales. Estos m\u00e9todos tienen un significado particular para el int\u00e9rprete de Python. Sus nombres empiezan y terminan en __ (doble gui\u00f3n bajo). Por ejemplo __init__ . class Lote(object): def __init__(self): ... def __repr__(self): ... Hay decenas de m\u00e9todos especiales pero s\u00f3lo vamos a tratar algunos ejemplos espec\u00edficos ac\u00e1.","title":"Introducci\u00f3n"},{"location":"09_Clases_y_Objetos/04_M%C3%A9todos_Especiales/#metodos-especiales-para-convertir-a-strings","text":"Los objetos tienen dos representaciones de tipo cadena. >>> from datetime import date >>> d = date(2020, 12, 21) >>> print(d) 2020-12-21 >>> d datetime.date(2020, 12, 21) >>> La funci\u00f3n str() se usa para crear una representaci\u00f3n agradable de ver: >>> str(d) '2020-12-21' >>> Pero para crear una representaci\u00f3n m\u00e1s informativa para programadores, se usa la funci\u00f3n repr() . >>> repr(d) 'datetime.date(2020, 12, 21)' >>> Las funciones str() y repr() llaman a m\u00e9todos especiales de la clase para generar la cadena de caracteres que se va a mostrar. class Date(object): def __init__(self, year, month, day): self.year = year self.month = month self.day = day # Con `str()` def __str__(self): return f'{self.year}-{self.month}-{self.day}' # Con `repr()` def __repr__(self): return f'Date({self.year},{self.month},{self.day})' Nota: Hay una convenci\u00f3n para __repr__() que indica que debe devolver un string que, cuando sea pasado a eval() vuelva a crear el objeto subayacente. Analiz\u00e1 el ejemplo de datetime.date(2020, 12, 21) . Si no es posible crear un string que haga eso, la convenci\u00f3n es generar una representaci\u00f3n que sea f\u00e1cil de interpretar para una persona. class Punto(): def __init__(self, x, y): self.x = x self.y = y def __str__(self): return f'({self.x}, {self.y})' # Used with `repr()` def __repr__(self): return f'Punto({self.x}, {self.y})'","title":"M\u00e9todos especiales para convertir a strings"},{"location":"09_Clases_y_Objetos/04_M%C3%A9todos_Especiales/#metodos-matematicos-especiales","text":"Las operaciones matem\u00e1ticas sobre los objetos involucran llamados a los siguientes m\u00e9todos. a + b a.__add__(b) a - b a.__sub__(b) a * b a.__mul__(b) a / b a.__truediv__(b) a // b a.__floordiv__(b) a % b a.__mod__(b) a << b a.__lshift__(b) a >> b a.__rshift__(b) a & b a.__and__(b) a | b a.__or__(b) a ^ b a.__xor__(b) a ** b a.__pow__(b) -a a.__neg__() ~a a.__invert__() abs(a) a.__abs__() As\u00ed, al definir un m\u00e9todo __add__(b) en la clase Punto , por ejemplo, nos permitir\u00e1 sumar dos instancias de esta clase usando el operador + . class Punto(): ... ... def __add__(self, b): return Punto(self.x + b.x, self.y + b.y) Como en el siguiente ejemplo: >>> a = Punto(1,2) >>> b = Punto(3,4) >>> repr(a + b) 'Punto(4, 6)'","title":"M\u00e9todos matem\u00e1ticos especiales"},{"location":"09_Clases_y_Objetos/04_M%C3%A9todos_Especiales/#metodos-especiales-para-acceder-a-elementos","text":"Los siguientes m\u00e9todos se usan para implementar contenedores: len(x) x.__len__() x[a] x.__getitem__(a) x[a] = v x.__setitem__(a,v) del x[a] x.__delitem__(a) Los pod\u00e9s implementar en tus clases. class Secuencia: def __len__(self): ... def __getitem__(self,a): ... def __setitem__(self,a,v): ... def __delitem__(self,a): ...","title":"M\u00e9todos especiales para acceder a elementos"},{"location":"09_Clases_y_Objetos/04_M%C3%A9todos_Especiales/#invocar-metodos","text":"El proceso de invocar un m\u00e9todo puede dividirse en dos partes: B\u00fasqueda: Se usa el operator . Llamado: Se usan () >>> m = Lote('Pera', 100, 490.10) >>> c = m.costo # B\u00fasqueda >>> c <bound method Lote.costo of <Lote object at 0x590d0>> >>> c() # Llamado 49010.0 >>> Nota : la respuesta al pedido de representaci\u00f3n de c es algo as\u00ed como >*","title":"Invocar m\u00e9todos"},{"location":"09_Clases_y_Objetos/04_M%C3%A9todos_Especiales/#metodos-ligados","text":"Un m\u00e9todo que a\u00fan no ha sido llamado por el operador de llamado a funciones () se conoce como m\u00e9todo ligado y opera dentro de la instancia en la que fue originado. >>> m = Lote('Pera', 100, 490.10) >>> m <Lote object at 0x590d0> >>> c = m.costo >>> c <bound method Lote.costo of <Lote object at 0x590d0>> >>> c() 49010.0 >>> Estos m\u00e9todos ligados pueden ser el origen de errores por desprolijidad, que no son nada obvios. Por ejemplo: >>> m = Lote('Pera', 100, 490.10) >>> print('Costo : %0.2f' % m.costo) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: float argument required >>> O una fuente de comportamiento extra\u00f1o que es dif\u00edcil de debuggear. f = open(filename, 'w') ... f.close # EPA! No hicimos nada. `f` sigue abierto. En ambos casos, el error est\u00e1 causado por omitir los par\u00e9ntesis en el (intento de) llamado a la funci\u00f3n. En estos casos deber\u00eda haber sido: m.costo() o f.close() . Sin los par\u00e9ntesis, no estamos llamando a la funci\u00f3n sino refiri\u00e9ndonos al m\u00e9todo.","title":"M\u00e9todos ligados"},{"location":"09_Clases_y_Objetos/04_M%C3%A9todos_Especiales/#acceso-a-atributos","text":"Existe una forma alternativa de acceder, manipular, y administrar los atributos de un objeto. getattr(obj, 'name') # Equivale a obj.name setattr(obj, 'name', value) # Equivale a obj.name = value delattr(obj, 'name') # Equivale a del obj.name hasattr(obj, 'name') # Mira si la propiedad existe Ejemplo: if hasattr(obj, 'x'): x = getattr(obj, 'x'): else: x = None Nota : si getattr() no encuentra el atributo buscado ( x en este ejemplo), devuelve el argumento opcional arg ( None en este caso) x = getattr(obj, 'x', None)","title":"Acceso a atributos"},{"location":"09_Clases_y_Objetos/04_M%C3%A9todos_Especiales/#ejercicios","text":"","title":"Ejercicios"},{"location":"09_Clases_y_Objetos/04_M%C3%A9todos_Especiales/#ejercicio-99-mejor-salida-para-objetos","text":"Modific\u00e1 el objeto Lote que definiste en lote.py (del Ejercicio 9.1 ) de modo que el m\u00e9todo __repr__() genere una salida m\u00e1s agradable. Por ejemplo queremos un comportamiento como \u00e9ste: >>> peras = Lote('Pera', 100, 490.1) >>> peras Lote('Pera', 100, 490.1) >>> Fijate lo que ocurre cuando le\u00e9s un cami\u00f3n de frutas y mir\u00e1s la salida resultante despu\u00e9s de hacer estos cambios. Un ejemplo: >>> import informe >>> camion = informe.leer_camion('../Data/camion.csv') >>> camion ... fijate cu\u00e1l es la salida ... >>> Guard\u00e1 el archivo lote.py para entregar.","title":"Ejercicio 9.9: Mejor salida para objetos"},{"location":"09_Clases_y_Objetos/04_M%C3%A9todos_Especiales/#ejercicio-910-ejemplo-de-getattr","text":"getattr() es un mecanismo alternativo de leer atributos. Puede usarse para escribir c\u00f3digo sumamente vers\u00e1til. Prob\u00e1 este ejemplo, para empezar: >>> import lote >>> c = lote.Lote('Peras', 100, 490.1) >>> columnas = ['nombre', 'cajones'] >>> for colname in columnas: print(colname, '=', getattr(c, colname)) nombre = Peras cajones = 100 >>> Queremos que observes algo interesante: los datos de salida est\u00e1n completamente especificados por los nombres de los atributos listados en la variable columnas . Estamos usando el contenido de una variable ('nombre' y 'cajones') como nombres de otras variables, o de atributos de un objeto. No es usual. Si te dan ganas, en el archivo formato_tabla.py us\u00e1 esta idea pero extendela, y cre\u00e1 una funci\u00f3n imprimir_tabla() que imprima una tabla mostrando, de una lista de objetos de tipo arbitrario, una lista de atributos especificados por le usuarie. Tal como antes hicimos con la funci\u00f3n imprimir_informe() del Ejercicio 6.4 imprimir_tabla() tambi\u00e9n deber\u00eda aceptar cualquier instancia de la clase FormatoTabla para definir el formato de la salida. La idea es que funcione m\u00e1s o menos as\u00ed: >>> import informe >>> camion = informe.leer_camion('../Data/camion.csv') >>> from formato_tabla import crear_formateador, imprimir_tabla >>> formateador = crear_formateador('txt') >>> imprimir_tabla(camion, ['nombre','cajones'], formateador) nombre cajones ---------- ---------- Lima 100 Naranja 50 Caqui 150 Mandarina 200 Durazno 95 Mandarina 50 Naranja 100 >>> imprimir_tabla(camion, ['nombre','cajones','precio'], formateador) nombre cajones precio ---------- ---------- ---------- Lima 100 32.2 Naranja 50 91.1 Caqui 150 103.44 Mandarina 200 51.23 Durazno 95 40.37 Mandarina 50 65.1 Naranja 100 70.44 >>> Contenidos | Anterior (3 Herencia) | Pr\u00f3ximo (5 Objetos, pilas y colas)","title":"Ejercicio 9.10: Ejemplo de getattr()"},{"location":"09_Clases_y_Objetos/05_Pilas_Colas/","text":"Contenidos | Anterior (4 M\u00e9todos especiales) | Pr\u00f3ximo (6 Teledetecci\u00f3n) 9.5 Objetos, pilas y colas Esta secci\u00f3n tiene un video donde trabajamos con colas. En este video trabajamos con los archivos que figuran en esta carpeta comprimida . En esta secci\u00f3n tendr\u00e1s que resolver algunos ejercicios definiendo clases y objetos. Un ejercicio geom\u00e9trico Cre\u00e1 una clase llamada Rectangulo que va a estar definido por dos puntos. Para esos dos puntos, us\u00e1 la clase Punto de la Secci\u00f3n anterior. El rect\u00e1ngulo es paralelo a los ejes, los puntos representan dos esquinas opuestas cualesquiera. La clase debe tener un m\u00e9todo constructor para crear el rect\u00e1ngulo a partir de dos puntos y los siguientes m\u00e9todos: * base() que d\u00e9 la medida de la base del rect\u00e1ngulo. * altura() que d\u00e9 la medida de la altura del rect\u00e1ngulo. * area() que d\u00e9 la medida del \u00e1rea del rect\u00e1ngulo. * Cre\u00e1 m\u00e9todos especiales __str__ y __repr__ . * desplazar(desplazamiento) que dado un desplazamiento (de tipo Punto) desplace el rect\u00e1ngulo en ambas coordenadas usando el m\u00e9todo add de la clase Punto. * rotar() que rote el rect\u00e1ngulo sobre su esquina inferior derecha 90 grados a la derecha. Prob\u00e1 tu c\u00f3digo: >>> ul = Punto(0,2) >>> lr = Punto(1,0) >>> ll = Punto(0,0) >>> ur = Punto(1,2) >>> rect1 = Rectangulo(ul,lr) >>> rect2 = Rectangulo(ll,ur) >>> rect1.base() 1 >>> rect1.base() 1 >>> rect2.altura() 2 >>> rect2.altura() 2 >>> rect1.rotar() >>> rect2.rotar() >>> rect1.base() 2 >>> rect2.base() 2 >>> rect1.altura() 1 >>> rect2.altura() 1 Ejercicio 9.11: Canguros buenos y canguros malos Este ejercicio est\u00e1 relacionado con un error muy com\u00fan en Python. Escrib\u00ed una definici\u00f3n de una clase Canguro que tenga: Un m\u00e9todo __init__ que recibe un nombre para el canguro y una lista (par\u00e1metro opcional) e inicializa un atributo llamado contenido_marsupio con la lista que le pases como par\u00e1metro o como lista vac\u00eda si no le pas\u00e1s nada. Un m\u00e9todo llamado meter_en_marsupio que, dado un objeto cualquiera, lo agregue a la lista contenido_marsupio . Un m\u00e9todo __str__ que devuelve una representaci\u00f3n como cadena del objeto Canguro indicando su nombre y los contenidos de su marsupio. Prob\u00e1 tu c\u00f3digo creando dos objetos, madre_canguro y cangurito y guard\u00e1 en el marsupio de la madre algunos objetos y al propio cangurito. Luego, mir\u00e1 el ejemplo canguro_malo.py copiado a continuaci\u00f3n. Este ejemplo intenta resolver el problema anterior, pero tiene un bug. Analizalo y corregilo. Entreg\u00e1 como respuesta un archivo canguros_buenos.py conteniendo, perimero la clase definida por vos y luego una correcci\u00f3n de la clase definida en el ejemplo, junto con un comentario indicando d\u00f3nde estaba el error y en qu\u00e9 const\u00eda. # canguro_malo.py \"\"\"Este c\u00f3digo continene un bug importante y dificil de ver \"\"\" class Canguro: \"\"\"Un Canguro es un marsupial.\"\"\" def __init__(self, nombre, contenido=[]): \"\"\"Inicializar los contenidos del marsupio. nombre: string contenido: contenido inicial del marsupio, lista. \"\"\" self.nombre = nombre self.contenido_marsupio = contenido def __str__(self): \"\"\"devuelve una representaci\u00f3n como cadena de este Canguro. \"\"\" t = [ self.nombre + ' tiene en su marsupio:' ] for obj in self.contenido_marsupio: s = ' ' + object.__str__(obj) t.append(s) return '\\n'.join(t) def meter_en_marsupio(self, item): \"\"\"Agrega un nuevo item al marsupio. item: objecto a ser agregado \"\"\" self.contenido_marsupio.append(item) #%% madre_canguro = Canguro('Madre') cangurito = Canguro('gurito') madre_canguro.meter_en_marsupio('billetera') madre_canguro.meter_en_marsupio('llaves del auto') madre_canguro.meter_en_marsupio(cangurito) print(madre_canguro) # Al ejecutar este c\u00f3digo todo parece funcionar correctamente. # Para ver el problema, imprim\u00ed el contenido de cangurito. Ojo: al corregir el bug no modifiques la firma del constructor __init__ del objeto: asegurate que siga aceptando los mismos par\u00e1metros (obligatorios y opcionales) que antes. Colas Una cola es una estructura de datos. Se caracteriza por contener una secuencia de elementos y dos operaciones: encolar y desencolar. La primera, encolar, agrega un elemento al final de la secuencia que contiene la cola. Desencolar, por su parte, devuelve el primer elemento de la secuencia y lo elimina de la misma. Las colas tambi\u00e9n se llaman estructuras FIFO (del ingl\u00e9s First In First Out), debido a que el primer elemento en entrar a la cola ser\u00e1 tambi\u00e9n el primero en salir. El nombre cola se le da por su analog\u00eda con las colas que hacemos (o hac\u00edamos cuando pod\u00edamos salir de casa) para entrar al cine, por ejemplo. Esta es una posible implementaci\u00f3n de la clase Cola : class Cola: '''Representa a una cola, con operaciones de encolar y desencolar. El primero en ser encolado es tambien el primero en ser desencolado. ''' def __init__(self): '''Crea una cola vacia.''' self.items = [] def encolar(self, x): '''Encola el elemento x.''' self.items.append(x) def desencolar(self): '''Elimina el primer elemento de la cola y devuelve su valor. Si la cola esta vacia, levanta ValueError.''' if self.esta_vacia(): raise ValueError('La cola esta vacia') return self.items.pop(0) def esta_vacia(self): '''Devuelve True si la cola esta vacia, False si no.''' return len(self.items) == 0 Ejercicio 9.12: Torre de Control Usando un par de objetos de la clase Cola, escrib\u00ed una nueva clase llamada TorreDeControl que modele el trabajo de una torre de control de un aeropuerto con una pista de aterrizaje. Los aviones que est\u00e1n esperando para aterrizar tienen prioridad sobre los que est\u00e1n esperando para despegar. La clase debe funcionar conforme al siguiente ejemplo: >>> torre = TorreDeControl() >>> torre.nuevo_arribo('AR156') >>> torre.nueva_partida('KLM1267') >>> torre.nuevo_arribo('AR32') >>> torre.ver_estado() Vuelos esperando para aterrizar: AR156, AR32 Vuelos esperando para despegar: KLM1267 >>> torre.asignar_pista() El vuelo AR156 aterriz\u00f3 con \u00e9xito. >>> torre.asignar_pista() El vuelo AR32 aterriz\u00f3 con \u00e9xito. >>> torre.asignar_pista() El vuelo KLM1267 despeg\u00f3 con \u00e9xito. >>> torre.asignar_pista() No hay vuelos en espera. Guard\u00e1 tu soluci\u00f3n (conteniendo tambi\u00e9n la definici\u00f3n de la clase Cola ) en torre_control.py para entregar al final de la clase. Pilas Una pila ( stack en ingl\u00e9s) es una estructura de datos. Se trata de una lista ordenada que permite almacenar y recuperar datos, con un modo de acceso de tipo LIFO (del ingl\u00e9s Last In, First Out, \u00ab\u00faltimo en entrar, primero en salir\u00bb). Funcionan de manera opuesta que las colas que mencionamos antes. Las pilas y colas son estructuras de datos que se aplican en multitud de contextos debido a su simplicidad y capacidad de modelar diferentes procesos. La operaciones (m\u00e9todos) elementales de las pilas son apilar (coloca un objeto en la pila) y desapilar (retira el \u00faltimo elemento apilado). En ingl\u00e9s se llaman push y pop y son an\u00e1logos al encolar y el desencolar de la colas. En cada momento solamente se tiene acceso a la parte superior de la pila, es decir, al \u00faltimo objeto apilado. La operaci\u00f3n desapilar justamente permite la obtenci\u00f3n de este elemento, que es retirado de la pila. La pila de llamadas (en ingl\u00e9s call stack ) de un lenguaje (por ejemplo Python), es una pila manejada por el int\u00e9rprete que almacena la informaci\u00f3n sobre las subrutinas activas en cada instante. Tambi\u00e9n se la conoce como pila de ejecuci\u00f3n o pila de control y se usa para llevar registro de las funciones que se fueron llamando y el de las variables definidas en cada contexto. Por ejemplo, si definimos las siguientes funciones: def f(): x = 50 a = 20 print(\"En f, x vale\", x) def g(): x = 10 b = 45 print(\"En g, antes de llamar a f, x vale\", x) f() print(\"En g, despu\u00e9s de llamar a f, x vale\", x) la ejecuci\u00f3n de g() resulta en: >>> g() En g, antes de llamar a f, x vale 10 En f, x vale 50 En g, despu\u00e9s de llamar a f, x vale 10. Para poder volver a recuperar el valor 10 para x en g() luego de llamar a f() se manej\u00f3 adecuadamente la pila de llamadas. Podemos pensar que en la ejecuci\u00f3n de g() , justo antes de llamar a f() hab\u00eda un estado que podr\u00eda ser resumido en estado = {funci\u00f3n: 'g', pr\u00f3xima_l\u00ednea_a_ejecutar: 4, variables: {x: 10, b: 45}} . Luego se ejecuta la cuarta l\u00ednea de c\u00f3digo. El int\u00e9rprete incrementa pr\u00f3xima_l\u00ednea_a_ejecutar y, antes de llamar a f() , apila el estado en la pila de llamadas. Al llamar a f() , el nuevo estado pasa a ser estado = {funci\u00f3n: 'f', pr\u00f3xima_l\u00ednea_a_ejecutar: 1, variables = {}} . El int\u00e9reprete ejecuta las tres l\u00edneas de c\u00f3digo de f , incrementando la variable pr\u00f3xima_l\u00ednea_a_ejecutar en cada paso, y agregando x:50 y luego a:20 el estado de las variables. Por lo tanto, termina la ejecuci\u00f3n de f en el estado = {funci\u00f3n: 'f', pr\u00f3xima_l\u00ednea_a_ejecutar: 4, variables = {x: 50, a: 20}} . Como ya no hay m\u00e1s c\u00f3digo que ejecutar de f() el int\u00e9rprete desapila un estado y contin\u00faa con la ejecuci\u00f3n usando estado = {funci\u00f3n: 'g', pr\u00f3xima_l\u00ednea_a_ejecutar: 5, variables: {x: 10, b: 45}} , y por lo tanto imprime: En g, despu\u00e9s de llamar a f, x vale 10. Estos conceptos son importantes para la clase pr\u00f3xima donde estudiaremos funciones que se llaman a s\u00ed mismas recursivamente . Si no fuera por la pila de llamadas, los valores de las variables de las diferentes instancias de una funci\u00f3n recursiva correr\u00edan el riesgo de mezclarse y confundirse. Ejercicio 9.13: implementar el TAD pila Implement\u00e1 en una clase Pila el TAD descripto anteriormente con los m\u00e9todos apilar() , desapilar() y esta_vacia() . Usala para reproducir el siguiente c\u00f3digo: def mostrar_x_del_estado(estado): print(f\"Ejecutando {estado['funci\u00f3n']}(), x vale {estado['variables']['x']}\") pila_de_llamadas = Pila() #la ejecuci\u00f3n est\u00e1 en la l\u00ednea 3 de g(). El estado tiene x=10. estado = {'funci\u00f3n': 'g', 'pr\u00f3xima_l\u00ednea_a_ejecutar': 3, 'variables': {'x': 10, 'b': 45}} mostrar_x_del_estado(estado) #sigo ejecutando, toca llamar a f(): incremento y apilo el estado. estado['pr\u00f3xima_l\u00ednea_a_ejecutar'] = 5 pila_de_llamadas.apilar(estado) #llamo a f y ejecuto primeras l\u00edneas estado = {'funci\u00f3n': 'f', 'pr\u00f3xima_l\u00ednea_a_ejecutar': 3, 'variables': {'x': 50, 'a': 20}} mostrar_x_del_estado(estado) #termina ejecuci\u00f3n de f: se desapila el estado: estado = pila_de_llamadas.desapilar() mostrar_x_del_estado(estado) Su ejecuci\u00f3n deber\u00eda dar: Ejecutando g(), x vale 10 Ejecutando f(), x vale 50 Ejecutando g(), x vale 10 Contenidos | Anterior (4 M\u00e9todos especiales) | Pr\u00f3ximo (6 Teledetecci\u00f3n)","title":"05 Pilas Colas"},{"location":"09_Clases_y_Objetos/05_Pilas_Colas/#95-objetos-pilas-y-colas","text":"Esta secci\u00f3n tiene un video donde trabajamos con colas. En este video trabajamos con los archivos que figuran en esta carpeta comprimida . En esta secci\u00f3n tendr\u00e1s que resolver algunos ejercicios definiendo clases y objetos.","title":"9.5 Objetos, pilas y colas"},{"location":"09_Clases_y_Objetos/05_Pilas_Colas/#un-ejercicio-geometrico","text":"Cre\u00e1 una clase llamada Rectangulo que va a estar definido por dos puntos. Para esos dos puntos, us\u00e1 la clase Punto de la Secci\u00f3n anterior. El rect\u00e1ngulo es paralelo a los ejes, los puntos representan dos esquinas opuestas cualesquiera. La clase debe tener un m\u00e9todo constructor para crear el rect\u00e1ngulo a partir de dos puntos y los siguientes m\u00e9todos: * base() que d\u00e9 la medida de la base del rect\u00e1ngulo. * altura() que d\u00e9 la medida de la altura del rect\u00e1ngulo. * area() que d\u00e9 la medida del \u00e1rea del rect\u00e1ngulo. * Cre\u00e1 m\u00e9todos especiales __str__ y __repr__ . * desplazar(desplazamiento) que dado un desplazamiento (de tipo Punto) desplace el rect\u00e1ngulo en ambas coordenadas usando el m\u00e9todo add de la clase Punto. * rotar() que rote el rect\u00e1ngulo sobre su esquina inferior derecha 90 grados a la derecha. Prob\u00e1 tu c\u00f3digo: >>> ul = Punto(0,2) >>> lr = Punto(1,0) >>> ll = Punto(0,0) >>> ur = Punto(1,2) >>> rect1 = Rectangulo(ul,lr) >>> rect2 = Rectangulo(ll,ur) >>> rect1.base() 1 >>> rect1.base() 1 >>> rect2.altura() 2 >>> rect2.altura() 2 >>> rect1.rotar() >>> rect2.rotar() >>> rect1.base() 2 >>> rect2.base() 2 >>> rect1.altura() 1 >>> rect2.altura() 1","title":"Un ejercicio geom\u00e9trico"},{"location":"09_Clases_y_Objetos/05_Pilas_Colas/#ejercicio-911-canguros-buenos-y-canguros-malos","text":"Este ejercicio est\u00e1 relacionado con un error muy com\u00fan en Python. Escrib\u00ed una definici\u00f3n de una clase Canguro que tenga: Un m\u00e9todo __init__ que recibe un nombre para el canguro y una lista (par\u00e1metro opcional) e inicializa un atributo llamado contenido_marsupio con la lista que le pases como par\u00e1metro o como lista vac\u00eda si no le pas\u00e1s nada. Un m\u00e9todo llamado meter_en_marsupio que, dado un objeto cualquiera, lo agregue a la lista contenido_marsupio . Un m\u00e9todo __str__ que devuelve una representaci\u00f3n como cadena del objeto Canguro indicando su nombre y los contenidos de su marsupio. Prob\u00e1 tu c\u00f3digo creando dos objetos, madre_canguro y cangurito y guard\u00e1 en el marsupio de la madre algunos objetos y al propio cangurito. Luego, mir\u00e1 el ejemplo canguro_malo.py copiado a continuaci\u00f3n. Este ejemplo intenta resolver el problema anterior, pero tiene un bug. Analizalo y corregilo. Entreg\u00e1 como respuesta un archivo canguros_buenos.py conteniendo, perimero la clase definida por vos y luego una correcci\u00f3n de la clase definida en el ejemplo, junto con un comentario indicando d\u00f3nde estaba el error y en qu\u00e9 const\u00eda. # canguro_malo.py \"\"\"Este c\u00f3digo continene un bug importante y dificil de ver \"\"\" class Canguro: \"\"\"Un Canguro es un marsupial.\"\"\" def __init__(self, nombre, contenido=[]): \"\"\"Inicializar los contenidos del marsupio. nombre: string contenido: contenido inicial del marsupio, lista. \"\"\" self.nombre = nombre self.contenido_marsupio = contenido def __str__(self): \"\"\"devuelve una representaci\u00f3n como cadena de este Canguro. \"\"\" t = [ self.nombre + ' tiene en su marsupio:' ] for obj in self.contenido_marsupio: s = ' ' + object.__str__(obj) t.append(s) return '\\n'.join(t) def meter_en_marsupio(self, item): \"\"\"Agrega un nuevo item al marsupio. item: objecto a ser agregado \"\"\" self.contenido_marsupio.append(item) #%% madre_canguro = Canguro('Madre') cangurito = Canguro('gurito') madre_canguro.meter_en_marsupio('billetera') madre_canguro.meter_en_marsupio('llaves del auto') madre_canguro.meter_en_marsupio(cangurito) print(madre_canguro) # Al ejecutar este c\u00f3digo todo parece funcionar correctamente. # Para ver el problema, imprim\u00ed el contenido de cangurito. Ojo: al corregir el bug no modifiques la firma del constructor __init__ del objeto: asegurate que siga aceptando los mismos par\u00e1metros (obligatorios y opcionales) que antes.","title":"Ejercicio 9.11: Canguros buenos y canguros malos"},{"location":"09_Clases_y_Objetos/05_Pilas_Colas/#colas","text":"Una cola es una estructura de datos. Se caracteriza por contener una secuencia de elementos y dos operaciones: encolar y desencolar. La primera, encolar, agrega un elemento al final de la secuencia que contiene la cola. Desencolar, por su parte, devuelve el primer elemento de la secuencia y lo elimina de la misma. Las colas tambi\u00e9n se llaman estructuras FIFO (del ingl\u00e9s First In First Out), debido a que el primer elemento en entrar a la cola ser\u00e1 tambi\u00e9n el primero en salir. El nombre cola se le da por su analog\u00eda con las colas que hacemos (o hac\u00edamos cuando pod\u00edamos salir de casa) para entrar al cine, por ejemplo. Esta es una posible implementaci\u00f3n de la clase Cola : class Cola: '''Representa a una cola, con operaciones de encolar y desencolar. El primero en ser encolado es tambien el primero en ser desencolado. ''' def __init__(self): '''Crea una cola vacia.''' self.items = [] def encolar(self, x): '''Encola el elemento x.''' self.items.append(x) def desencolar(self): '''Elimina el primer elemento de la cola y devuelve su valor. Si la cola esta vacia, levanta ValueError.''' if self.esta_vacia(): raise ValueError('La cola esta vacia') return self.items.pop(0) def esta_vacia(self): '''Devuelve True si la cola esta vacia, False si no.''' return len(self.items) == 0","title":"Colas"},{"location":"09_Clases_y_Objetos/05_Pilas_Colas/#ejercicio-912-torre-de-control","text":"Usando un par de objetos de la clase Cola, escrib\u00ed una nueva clase llamada TorreDeControl que modele el trabajo de una torre de control de un aeropuerto con una pista de aterrizaje. Los aviones que est\u00e1n esperando para aterrizar tienen prioridad sobre los que est\u00e1n esperando para despegar. La clase debe funcionar conforme al siguiente ejemplo: >>> torre = TorreDeControl() >>> torre.nuevo_arribo('AR156') >>> torre.nueva_partida('KLM1267') >>> torre.nuevo_arribo('AR32') >>> torre.ver_estado() Vuelos esperando para aterrizar: AR156, AR32 Vuelos esperando para despegar: KLM1267 >>> torre.asignar_pista() El vuelo AR156 aterriz\u00f3 con \u00e9xito. >>> torre.asignar_pista() El vuelo AR32 aterriz\u00f3 con \u00e9xito. >>> torre.asignar_pista() El vuelo KLM1267 despeg\u00f3 con \u00e9xito. >>> torre.asignar_pista() No hay vuelos en espera. Guard\u00e1 tu soluci\u00f3n (conteniendo tambi\u00e9n la definici\u00f3n de la clase Cola ) en torre_control.py para entregar al final de la clase.","title":"Ejercicio 9.12: Torre de Control"},{"location":"09_Clases_y_Objetos/05_Pilas_Colas/#pilas","text":"Una pila ( stack en ingl\u00e9s) es una estructura de datos. Se trata de una lista ordenada que permite almacenar y recuperar datos, con un modo de acceso de tipo LIFO (del ingl\u00e9s Last In, First Out, \u00ab\u00faltimo en entrar, primero en salir\u00bb). Funcionan de manera opuesta que las colas que mencionamos antes. Las pilas y colas son estructuras de datos que se aplican en multitud de contextos debido a su simplicidad y capacidad de modelar diferentes procesos. La operaciones (m\u00e9todos) elementales de las pilas son apilar (coloca un objeto en la pila) y desapilar (retira el \u00faltimo elemento apilado). En ingl\u00e9s se llaman push y pop y son an\u00e1logos al encolar y el desencolar de la colas. En cada momento solamente se tiene acceso a la parte superior de la pila, es decir, al \u00faltimo objeto apilado. La operaci\u00f3n desapilar justamente permite la obtenci\u00f3n de este elemento, que es retirado de la pila. La pila de llamadas (en ingl\u00e9s call stack ) de un lenguaje (por ejemplo Python), es una pila manejada por el int\u00e9rprete que almacena la informaci\u00f3n sobre las subrutinas activas en cada instante. Tambi\u00e9n se la conoce como pila de ejecuci\u00f3n o pila de control y se usa para llevar registro de las funciones que se fueron llamando y el de las variables definidas en cada contexto. Por ejemplo, si definimos las siguientes funciones: def f(): x = 50 a = 20 print(\"En f, x vale\", x) def g(): x = 10 b = 45 print(\"En g, antes de llamar a f, x vale\", x) f() print(\"En g, despu\u00e9s de llamar a f, x vale\", x) la ejecuci\u00f3n de g() resulta en: >>> g() En g, antes de llamar a f, x vale 10 En f, x vale 50 En g, despu\u00e9s de llamar a f, x vale 10. Para poder volver a recuperar el valor 10 para x en g() luego de llamar a f() se manej\u00f3 adecuadamente la pila de llamadas. Podemos pensar que en la ejecuci\u00f3n de g() , justo antes de llamar a f() hab\u00eda un estado que podr\u00eda ser resumido en estado = {funci\u00f3n: 'g', pr\u00f3xima_l\u00ednea_a_ejecutar: 4, variables: {x: 10, b: 45}} . Luego se ejecuta la cuarta l\u00ednea de c\u00f3digo. El int\u00e9rprete incrementa pr\u00f3xima_l\u00ednea_a_ejecutar y, antes de llamar a f() , apila el estado en la pila de llamadas. Al llamar a f() , el nuevo estado pasa a ser estado = {funci\u00f3n: 'f', pr\u00f3xima_l\u00ednea_a_ejecutar: 1, variables = {}} . El int\u00e9reprete ejecuta las tres l\u00edneas de c\u00f3digo de f , incrementando la variable pr\u00f3xima_l\u00ednea_a_ejecutar en cada paso, y agregando x:50 y luego a:20 el estado de las variables. Por lo tanto, termina la ejecuci\u00f3n de f en el estado = {funci\u00f3n: 'f', pr\u00f3xima_l\u00ednea_a_ejecutar: 4, variables = {x: 50, a: 20}} . Como ya no hay m\u00e1s c\u00f3digo que ejecutar de f() el int\u00e9rprete desapila un estado y contin\u00faa con la ejecuci\u00f3n usando estado = {funci\u00f3n: 'g', pr\u00f3xima_l\u00ednea_a_ejecutar: 5, variables: {x: 10, b: 45}} , y por lo tanto imprime: En g, despu\u00e9s de llamar a f, x vale 10. Estos conceptos son importantes para la clase pr\u00f3xima donde estudiaremos funciones que se llaman a s\u00ed mismas recursivamente . Si no fuera por la pila de llamadas, los valores de las variables de las diferentes instancias de una funci\u00f3n recursiva correr\u00edan el riesgo de mezclarse y confundirse.","title":"Pilas"},{"location":"09_Clases_y_Objetos/05_Pilas_Colas/#ejercicio-913-implementar-el-tad-pila","text":"Implement\u00e1 en una clase Pila el TAD descripto anteriormente con los m\u00e9todos apilar() , desapilar() y esta_vacia() . Usala para reproducir el siguiente c\u00f3digo: def mostrar_x_del_estado(estado): print(f\"Ejecutando {estado['funci\u00f3n']}(), x vale {estado['variables']['x']}\") pila_de_llamadas = Pila() #la ejecuci\u00f3n est\u00e1 en la l\u00ednea 3 de g(). El estado tiene x=10. estado = {'funci\u00f3n': 'g', 'pr\u00f3xima_l\u00ednea_a_ejecutar': 3, 'variables': {'x': 10, 'b': 45}} mostrar_x_del_estado(estado) #sigo ejecutando, toca llamar a f(): incremento y apilo el estado. estado['pr\u00f3xima_l\u00ednea_a_ejecutar'] = 5 pila_de_llamadas.apilar(estado) #llamo a f y ejecuto primeras l\u00edneas estado = {'funci\u00f3n': 'f', 'pr\u00f3xima_l\u00ednea_a_ejecutar': 3, 'variables': {'x': 50, 'a': 20}} mostrar_x_del_estado(estado) #termina ejecuci\u00f3n de f: se desapila el estado: estado = pila_de_llamadas.desapilar() mostrar_x_del_estado(estado) Su ejecuci\u00f3n deber\u00eda dar: Ejecutando g(), x vale 10 Ejecutando f(), x vale 50 Ejecutando g(), x vale 10 Contenidos | Anterior (4 M\u00e9todos especiales) | Pr\u00f3ximo (6 Teledetecci\u00f3n)","title":"Ejercicio 9.13: implementar el TAD pila"},{"location":"09_Clases_y_Objetos/06_Teledeteccion/","text":"Contenidos | Anterior (5 Objetos, pilas y colas) | Pr\u00f3ximo (7 Cierre de la clase) 9.6 Teledetecci\u00f3n En este video introducimos el tema de esta secci\u00f3n. En este ejercicio vamos a trabajar con una imagen satelital obtenida por sensores a bordo del sat\u00e9lite Landsat8. Es un ejercicio optativo para entregar. Si quer\u00e9s, hacelo y guardalo en el archivo NDVI.py . Ejercicio 9.14: Optativo de teledetecci\u00f3n Autora: Mariela Rajngewerc La imagen original fue bajada de la p\u00e1gina del earthexplorer . En esa p\u00e1gina se pueden bajar im\u00e1genes con distinto nivel de pre-procesamiento. Para este ejercicio bajamos una imagen de nivel de procesamiento 2, esto quiere decir que los valores de los pixeles representan la reflectancia en superficie en distintas longitudes de onda. Ac\u00e1 pueden encontrar el manual de estas imagenes donde les detallan la descripci\u00f3n tanto de los nombres de lor archivos como de los preprocesamiento que tienen realizados. Para este ejercicio hemos realizado un clip de cada una de las bandas originales de la imagen y ya multiplicamos a cada una de las bandas por el factor de escala indicado en el manual (0,0001). Las longitudes de onda y la resoluciones de cada banda de la im\u00e1gen se describen a continuaci\u00f3n: Banda Longitud de onda (nan\u00f3metros) Resoluci\u00f3n espacial (metros) Banda 1 - Aerosoles 430 - 450 30 Banda 2 - Azul 450 - 510 30 Banda 3 - Verde 530 - 590 30 Banda 4 - Rojo 640 - 670 30 Banda 5 - Infrarrojo cercano 850 - 880 30 Banda 6 - Infrarrojo medio 1 1570 - 1650 30 Banda 7 - Infrarrojo medio 2 2110 - 2290 30 Si desean abrir los datos de la imagen original en Python deber\u00e1n bajar algunas librer\u00edas espec\u00edficas para la manipulaci\u00f3n de datos satelitales, por ejemplo: gdal . Ac\u00e1 hay un tutorial de los primeros pasos. En la carpeta clip encontrar\u00e1n los datos que vamos a usar en los ejercicios. Cada banda del clip se encuentra en formato .npy Ejercicios: Ejercicio 9.15: Ver una banda a) Us\u00e1 numpy para levantar cada una de las bandas y plt.imshow(banda) para verla. \u00bfSe ve correctamente? Pod\u00e9s ajustar el rango de visualizaci\u00f3n de colores usando los par\u00e1metros vmin y vmax . Sugerencia : Con plt.hist(banda.flatten(),bins = 100) vas a ver un histograma de los valores en la matriz banda . Pod\u00e9s usarlo para guiarte en la b\u00fasqueda del rango que tiene sentido usar como vmin y vmax. b) Prob\u00e1 usando percentiles para fijar el rango. Algo como vmin = np.percentile(data.flatten(), q) vmax = np.percentile(data.flatten(), 100-q) c) Escrib\u00ed una funci\u00f3n crear_img_png(carpeta, banda) que, dada una carpeta y un n\u00famero de banda, muestre la imagen de dicha banda y la guarde en formato .png. Asegurate de incorporar un colorbar al lado de la im\u00e1gen. Ten\u00e9 en cuenta lo que hiciste en los puntos anteriores para que se vea adecuadamente. Ejercicio 9.16: Histogramas Escrib\u00ed ahora otra funci\u00f3n, llamada crear_hist_png(carpeta, banda, bins) que, dada una carpeta, un n\u00famero de banda y una cantidad de bins, muestre el histograma (con la cantidad de bins seleccionados) de los valores de dicha banda y la guarde en formato .png. Ejercicio 9.17: M\u00e1scaras binarias a) Us\u00e1 las funciones crear_img_png y crear_hist_png que hiciste en los puntos anteriores para generar las im\u00e1genes e histogramas de cada banda. b) \u00bfQu\u00e9 banda o bandas parecieran tener histogramas bimodales, mostrando diferentes tipos de pixels? Eleg\u00ed una de esas bandas y, observando el histograma, seleccion\u00e1 un umbral que te permita distinguir los dos tipos de p\u00edxels. Por ejemplo, pod\u00e9s crear una matriz del mismo tama\u00f1o de la banda donde a cada p\u00edxel le corresponda un 1 o un 0, 1 si est\u00e1 por arriba del umbral y 0 si no. Grafic\u00e1 la im\u00e1gen binaria as\u00ed obtenida. \u00bfA qu\u00e9 corresponden los dos tipos de p\u00edxeles que pudiste distinguir tan f\u00e1cilmente? Ejercicio 9.18: Clasificaci\u00f3n manual En este ejercicio vamos a trabajar con un \u00edndice: el \u00cdndice de Vegetaci\u00f3n de Diferencia Normalizada, tambi\u00e9n conocido como NDVI por sus siglas en ingl\u00e9s. Este \u00edndice, basado en la intensidad de la radiaci\u00f3n de dos bandas del espectro electromagn\u00e9tico que interact\u00faan particularmente con la vegetaci\u00f3n, aporta informaci\u00f3n sobre la cantidad, estado y desarrollo de la misma. Para calcular el NDVI se utilizan las bandas espectrales Roja e Infrarroja y el c\u00e1lculo se hace mediante la siguiente f\u00f3rmula: (INFRARROJO_CERCANO - ROJO) / (INFRARROJO_CERCANO + ROJO) a) Calcular el NDVI en una nueva matriz. b) Categoriz\u00e1 los valores obtenidos en cada p\u00edxel de acuerdo a clases que nos sean m\u00e1s \u00fatiles y f\u00e1ciles de interpretar. La tabla a continuaci\u00f3n muestra una propuesta de categor\u00edas que pod\u00e9s considerar: Valor de NDVI Nombre de la clase Identificador de Clase color < 0 No vegetada 0 black entre 0 y 0.1 \u00c1rea desnuda 1 y entre 0.1 y 0.25 Vegetaci\u00f3n baja 2 yellowgreen entre 0.25 y 0.4 Vegetaci\u00f3n moderada 3 g >0.4 Vegetaci\u00f3n densa 4 darkgreen Cre\u00e1 un np.array que le asigne a cada p\u00edxel el n\u00famero dado por el identificador de categor\u00eda correspondiente seg\u00fan la tabla. Llam\u00e1 clases_ndvi a la matriz as\u00ed obtenida. c) Gener\u00e1 un gr\u00e1fico con matplotlib mostrando las clases obtenidas. d) Crear un colorMap para lograr asignarle a cada clase el color sugerido en la tabla. Para esto pod\u00e9s usar la funci\u00f3n ListedColormap inclu\u00edda en matplotlib.colors y crear un colorMap (cmap). e) Ponele una leyenda que indique el nombre de cada clase con el color asignado, para eso te sugerimos usar la funci\u00f3n Patch que se encuentra en matplotlib.patches . Para que puedas orientarte, te mostramos a continuaci\u00f3n un ejemplo de resultado esperado: Si llegaste hasta ac\u00e1, no te olvides de guardar tu trabajo en el archivo NDVI.py y entregarlo. A continuaci\u00f3n, un ejercicio que usa herramientas un poco m\u00e1s avanzadas de aprendizaje autom\u00e1tico. Ejercicio 9.19: Clasificaci\u00f3n autom\u00e1tica En el ejercicio anterior definimos a mano los umbrales que distinguen las clases. Es posible hacer esto de forma autom\u00e1tica. Para eso se usan t\u00e9cnicas de clustering. El siguiente c\u00f3digo muestra un ejemplo con un clasificador muy sencillo: kmeans . Este clasificador est\u00e1 ya implementado en la biblioteca sklearn que es una biblioteca dedicada al aprendizaje autom\u00e1tico en python (probablemente la m\u00e1s usada para esto). # filtro datos ruidosos o que puedan traer problemas. # el NDVI debe estar entre -1 y 1. ndvi[ndvi > 1] = 1 ndvi[ndvi < -1] = -1 #importo el clasificador y defino una instancia para clasificar con dos etiquetas from sklearn.cluster import KMeans kmeans = KMeans(n_clusters = 2) #le saco la estructura bidimensional a la matriz NDVI y la llamo datos datos = ndvi.reshape(-1,1) #datos es un vector con un dato de NDVI por pixel. #entreno o ajusto el el clasificador con los datos (demora!) kmeans.fit(datos) #ajusta el modelo #usa el modelo ajustado para poner etiquetas etiquetas = kmeans.predict(ndvi.reshape(-1,1)) #visualizo los resultados recuperando la estructura bidimensional de la matriz plt.imshow(etiquetas.reshape(ndvi.shape)) Prob\u00e1 ajustando el n\u00famero de clusters ( n_clusters = 5 , por ejemplo) y corriendo nuevamente el modelo. Ponele colores diferentes a las diferentes clases obtenidas. Si tarda mucho pod\u00e9s trabajar con un pedazo de la im\u00e1gen. Por ejemplo si hac\u00e9s ndvi_clip = ndvi[1000:2000,2000:3000] te qued\u00e1s con un cuadradito que es un octavo de la imagen original y pod\u00e9s usarlo para probar cosas r\u00e1pido. Si te convencen los resultados pod\u00e9s correr tu algoritmo sobre la im\u00e1gen completa. Sugerencia: C\u00f3digo para colorbars Revisar este c\u00f3digo para el cmap: from matplotlib import colors # Creo colores cmap = colors.ListedColormap(['black', 'y', 'yellowgreen', 'green', 'darkgreen']) # Defino los limites de cada color limites = [0, 1, 2, 3, 4] norm = colors.BoundaryNorm(limites, cmap.N) # Genero el grafico con colores plt.imshow(clases_ndvi, cmap=cmap, norm=norm) Y \u00e9ste para las leyendas: import matplotlib.patches as mpatches # Genero leyenda y grafico con leyenda texts = ['Sin vegetacion', 'Area desnuda', 'Vegetacion baja', 'Vegetacion moderada', 'Vegetacion densa'] patches = [mpatches.Patch(color=cmap(i), label=\"{:s}\".format(texts[i]) ) for i in range(len(texts))] plt.legend(handles=patches, bbox_to_anchor=(0.2,1.3), loc='center', ncol=1 ) plt.imshow(clases_ndvi, cmap=cmap, norm=norm) plt.show() Contenidos | Anterior (5 Objetos, pilas y colas) | Pr\u00f3ximo (7 Cierre de la clase)","title":"06 Teledeteccion"},{"location":"09_Clases_y_Objetos/06_Teledeteccion/#96-teledeteccion","text":"En este video introducimos el tema de esta secci\u00f3n. En este ejercicio vamos a trabajar con una imagen satelital obtenida por sensores a bordo del sat\u00e9lite Landsat8. Es un ejercicio optativo para entregar. Si quer\u00e9s, hacelo y guardalo en el archivo NDVI.py .","title":"9.6 Teledetecci\u00f3n"},{"location":"09_Clases_y_Objetos/06_Teledeteccion/#ejercicio-914-optativo-de-teledeteccion","text":"Autora: Mariela Rajngewerc La imagen original fue bajada de la p\u00e1gina del earthexplorer . En esa p\u00e1gina se pueden bajar im\u00e1genes con distinto nivel de pre-procesamiento. Para este ejercicio bajamos una imagen de nivel de procesamiento 2, esto quiere decir que los valores de los pixeles representan la reflectancia en superficie en distintas longitudes de onda. Ac\u00e1 pueden encontrar el manual de estas imagenes donde les detallan la descripci\u00f3n tanto de los nombres de lor archivos como de los preprocesamiento que tienen realizados. Para este ejercicio hemos realizado un clip de cada una de las bandas originales de la imagen y ya multiplicamos a cada una de las bandas por el factor de escala indicado en el manual (0,0001). Las longitudes de onda y la resoluciones de cada banda de la im\u00e1gen se describen a continuaci\u00f3n: Banda Longitud de onda (nan\u00f3metros) Resoluci\u00f3n espacial (metros) Banda 1 - Aerosoles 430 - 450 30 Banda 2 - Azul 450 - 510 30 Banda 3 - Verde 530 - 590 30 Banda 4 - Rojo 640 - 670 30 Banda 5 - Infrarrojo cercano 850 - 880 30 Banda 6 - Infrarrojo medio 1 1570 - 1650 30 Banda 7 - Infrarrojo medio 2 2110 - 2290 30 Si desean abrir los datos de la imagen original en Python deber\u00e1n bajar algunas librer\u00edas espec\u00edficas para la manipulaci\u00f3n de datos satelitales, por ejemplo: gdal . Ac\u00e1 hay un tutorial de los primeros pasos. En la carpeta clip encontrar\u00e1n los datos que vamos a usar en los ejercicios. Cada banda del clip se encuentra en formato .npy","title":"Ejercicio 9.14: Optativo de teledetecci\u00f3n"},{"location":"09_Clases_y_Objetos/06_Teledeteccion/#ejercicios","text":"","title":"Ejercicios:"},{"location":"09_Clases_y_Objetos/06_Teledeteccion/#ejercicio-915-ver-una-banda","text":"a) Us\u00e1 numpy para levantar cada una de las bandas y plt.imshow(banda) para verla. \u00bfSe ve correctamente? Pod\u00e9s ajustar el rango de visualizaci\u00f3n de colores usando los par\u00e1metros vmin y vmax . Sugerencia : Con plt.hist(banda.flatten(),bins = 100) vas a ver un histograma de los valores en la matriz banda . Pod\u00e9s usarlo para guiarte en la b\u00fasqueda del rango que tiene sentido usar como vmin y vmax. b) Prob\u00e1 usando percentiles para fijar el rango. Algo como vmin = np.percentile(data.flatten(), q) vmax = np.percentile(data.flatten(), 100-q) c) Escrib\u00ed una funci\u00f3n crear_img_png(carpeta, banda) que, dada una carpeta y un n\u00famero de banda, muestre la imagen de dicha banda y la guarde en formato .png. Asegurate de incorporar un colorbar al lado de la im\u00e1gen. Ten\u00e9 en cuenta lo que hiciste en los puntos anteriores para que se vea adecuadamente.","title":"Ejercicio 9.15: Ver una banda"},{"location":"09_Clases_y_Objetos/06_Teledeteccion/#ejercicio-916-histogramas","text":"Escrib\u00ed ahora otra funci\u00f3n, llamada crear_hist_png(carpeta, banda, bins) que, dada una carpeta, un n\u00famero de banda y una cantidad de bins, muestre el histograma (con la cantidad de bins seleccionados) de los valores de dicha banda y la guarde en formato .png.","title":"Ejercicio 9.16: Histogramas"},{"location":"09_Clases_y_Objetos/06_Teledeteccion/#ejercicio-917-mascaras-binarias","text":"a) Us\u00e1 las funciones crear_img_png y crear_hist_png que hiciste en los puntos anteriores para generar las im\u00e1genes e histogramas de cada banda. b) \u00bfQu\u00e9 banda o bandas parecieran tener histogramas bimodales, mostrando diferentes tipos de pixels? Eleg\u00ed una de esas bandas y, observando el histograma, seleccion\u00e1 un umbral que te permita distinguir los dos tipos de p\u00edxels. Por ejemplo, pod\u00e9s crear una matriz del mismo tama\u00f1o de la banda donde a cada p\u00edxel le corresponda un 1 o un 0, 1 si est\u00e1 por arriba del umbral y 0 si no. Grafic\u00e1 la im\u00e1gen binaria as\u00ed obtenida. \u00bfA qu\u00e9 corresponden los dos tipos de p\u00edxeles que pudiste distinguir tan f\u00e1cilmente?","title":"Ejercicio 9.17: M\u00e1scaras binarias"},{"location":"09_Clases_y_Objetos/06_Teledeteccion/#ejercicio-918-clasificacion-manual","text":"En este ejercicio vamos a trabajar con un \u00edndice: el \u00cdndice de Vegetaci\u00f3n de Diferencia Normalizada, tambi\u00e9n conocido como NDVI por sus siglas en ingl\u00e9s. Este \u00edndice, basado en la intensidad de la radiaci\u00f3n de dos bandas del espectro electromagn\u00e9tico que interact\u00faan particularmente con la vegetaci\u00f3n, aporta informaci\u00f3n sobre la cantidad, estado y desarrollo de la misma. Para calcular el NDVI se utilizan las bandas espectrales Roja e Infrarroja y el c\u00e1lculo se hace mediante la siguiente f\u00f3rmula: (INFRARROJO_CERCANO - ROJO) / (INFRARROJO_CERCANO + ROJO) a) Calcular el NDVI en una nueva matriz. b) Categoriz\u00e1 los valores obtenidos en cada p\u00edxel de acuerdo a clases que nos sean m\u00e1s \u00fatiles y f\u00e1ciles de interpretar. La tabla a continuaci\u00f3n muestra una propuesta de categor\u00edas que pod\u00e9s considerar: Valor de NDVI Nombre de la clase Identificador de Clase color < 0 No vegetada 0 black entre 0 y 0.1 \u00c1rea desnuda 1 y entre 0.1 y 0.25 Vegetaci\u00f3n baja 2 yellowgreen entre 0.25 y 0.4 Vegetaci\u00f3n moderada 3 g >0.4 Vegetaci\u00f3n densa 4 darkgreen Cre\u00e1 un np.array que le asigne a cada p\u00edxel el n\u00famero dado por el identificador de categor\u00eda correspondiente seg\u00fan la tabla. Llam\u00e1 clases_ndvi a la matriz as\u00ed obtenida. c) Gener\u00e1 un gr\u00e1fico con matplotlib mostrando las clases obtenidas. d) Crear un colorMap para lograr asignarle a cada clase el color sugerido en la tabla. Para esto pod\u00e9s usar la funci\u00f3n ListedColormap inclu\u00edda en matplotlib.colors y crear un colorMap (cmap). e) Ponele una leyenda que indique el nombre de cada clase con el color asignado, para eso te sugerimos usar la funci\u00f3n Patch que se encuentra en matplotlib.patches . Para que puedas orientarte, te mostramos a continuaci\u00f3n un ejemplo de resultado esperado: Si llegaste hasta ac\u00e1, no te olvides de guardar tu trabajo en el archivo NDVI.py y entregarlo. A continuaci\u00f3n, un ejercicio que usa herramientas un poco m\u00e1s avanzadas de aprendizaje autom\u00e1tico.","title":"Ejercicio 9.18: Clasificaci\u00f3n manual"},{"location":"09_Clases_y_Objetos/06_Teledeteccion/#ejercicio-919-clasificacion-automatica","text":"En el ejercicio anterior definimos a mano los umbrales que distinguen las clases. Es posible hacer esto de forma autom\u00e1tica. Para eso se usan t\u00e9cnicas de clustering. El siguiente c\u00f3digo muestra un ejemplo con un clasificador muy sencillo: kmeans . Este clasificador est\u00e1 ya implementado en la biblioteca sklearn que es una biblioteca dedicada al aprendizaje autom\u00e1tico en python (probablemente la m\u00e1s usada para esto). # filtro datos ruidosos o que puedan traer problemas. # el NDVI debe estar entre -1 y 1. ndvi[ndvi > 1] = 1 ndvi[ndvi < -1] = -1 #importo el clasificador y defino una instancia para clasificar con dos etiquetas from sklearn.cluster import KMeans kmeans = KMeans(n_clusters = 2) #le saco la estructura bidimensional a la matriz NDVI y la llamo datos datos = ndvi.reshape(-1,1) #datos es un vector con un dato de NDVI por pixel. #entreno o ajusto el el clasificador con los datos (demora!) kmeans.fit(datos) #ajusta el modelo #usa el modelo ajustado para poner etiquetas etiquetas = kmeans.predict(ndvi.reshape(-1,1)) #visualizo los resultados recuperando la estructura bidimensional de la matriz plt.imshow(etiquetas.reshape(ndvi.shape)) Prob\u00e1 ajustando el n\u00famero de clusters ( n_clusters = 5 , por ejemplo) y corriendo nuevamente el modelo. Ponele colores diferentes a las diferentes clases obtenidas. Si tarda mucho pod\u00e9s trabajar con un pedazo de la im\u00e1gen. Por ejemplo si hac\u00e9s ndvi_clip = ndvi[1000:2000,2000:3000] te qued\u00e1s con un cuadradito que es un octavo de la imagen original y pod\u00e9s usarlo para probar cosas r\u00e1pido. Si te convencen los resultados pod\u00e9s correr tu algoritmo sobre la im\u00e1gen completa.","title":"Ejercicio 9.19: Clasificaci\u00f3n autom\u00e1tica"},{"location":"09_Clases_y_Objetos/06_Teledeteccion/#sugerencia-codigo-para-colorbars","text":"Revisar este c\u00f3digo para el cmap: from matplotlib import colors # Creo colores cmap = colors.ListedColormap(['black', 'y', 'yellowgreen', 'green', 'darkgreen']) # Defino los limites de cada color limites = [0, 1, 2, 3, 4] norm = colors.BoundaryNorm(limites, cmap.N) # Genero el grafico con colores plt.imshow(clases_ndvi, cmap=cmap, norm=norm) Y \u00e9ste para las leyendas: import matplotlib.patches as mpatches # Genero leyenda y grafico con leyenda texts = ['Sin vegetacion', 'Area desnuda', 'Vegetacion baja', 'Vegetacion moderada', 'Vegetacion densa'] patches = [mpatches.Patch(color=cmap(i), label=\"{:s}\".format(texts[i]) ) for i in range(len(texts))] plt.legend(handles=patches, bbox_to_anchor=(0.2,1.3), loc='center', ncol=1 ) plt.imshow(clases_ndvi, cmap=cmap, norm=norm) plt.show() Contenidos | Anterior (5 Objetos, pilas y colas) | Pr\u00f3ximo (7 Cierre de la clase)","title":"Sugerencia: C\u00f3digo para colorbars"},{"location":"09_Clases_y_Objetos/07_Cierre/","text":"Contenidos | Anterior (6 Teledetecci\u00f3n) 9.7 Cierre de la clase En esta clase vimos las ventajas de estructurar un programa con las ideas Programaci\u00f3n Orientada a Objetos. Vimos c\u00f3mo pod\u00e9s definir tus propias clases y te mostramos c\u00f3mo este paradigma puede aportar tanto a la organizaci\u00f3n de un programa \"est\u00e1tico\" como tambi\u00e9n para preparar programas para que sean f\u00e1cilmente extensibles. Una de las formas de extender el comportamiento de un programa es definir una interfase de interacci\u00f3n entre objetos de modo que un comportamiento nuevo pueda programarse sin tocar (casi) el c\u00f3digo preexistente. Otra forma muy interesante es definir clases base, abstractas, que van a ser implementadas luego, por herencia, en sus versiones definitivas. La experiencia te va a permitir decidir (quiz\u00e1s tard\u00edamente) cu\u00e1ndo es mas conveniente una arquitectura o la otra. En fin, para cerrar esta clase, entreg\u00e1: El archivo informe.py del Ejercicio 9.8 . El archivo lote.py del Ejercicio 9.9 . El archivo torre_control.py del Ejercicio 9.12 . El archivo canguros_buenos.py del Ejercicio 9.11 . El archivo NDVI.py del Ejercicio 9.14 (optativo). Adem\u00e1s te pedimos que completes este formulario usando tu direcci\u00f3n de mail como identificaci\u00f3n. Al terminar vas a obtener un link para enviarnos tus ejercicios. \u00a1Nos vemos! Contenidos | Anterior (6 Teledetecci\u00f3n)","title":"07 Cierre"},{"location":"09_Clases_y_Objetos/07_Cierre/#97-cierre-de-la-clase","text":"En esta clase vimos las ventajas de estructurar un programa con las ideas Programaci\u00f3n Orientada a Objetos. Vimos c\u00f3mo pod\u00e9s definir tus propias clases y te mostramos c\u00f3mo este paradigma puede aportar tanto a la organizaci\u00f3n de un programa \"est\u00e1tico\" como tambi\u00e9n para preparar programas para que sean f\u00e1cilmente extensibles. Una de las formas de extender el comportamiento de un programa es definir una interfase de interacci\u00f3n entre objetos de modo que un comportamiento nuevo pueda programarse sin tocar (casi) el c\u00f3digo preexistente. Otra forma muy interesante es definir clases base, abstractas, que van a ser implementadas luego, por herencia, en sus versiones definitivas. La experiencia te va a permitir decidir (quiz\u00e1s tard\u00edamente) cu\u00e1ndo es mas conveniente una arquitectura o la otra. En fin, para cerrar esta clase, entreg\u00e1: El archivo informe.py del Ejercicio 9.8 . El archivo lote.py del Ejercicio 9.9 . El archivo torre_control.py del Ejercicio 9.12 . El archivo canguros_buenos.py del Ejercicio 9.11 . El archivo NDVI.py del Ejercicio 9.14 (optativo). Adem\u00e1s te pedimos que completes este formulario usando tu direcci\u00f3n de mail como identificaci\u00f3n. Al terminar vas a obtener un link para enviarnos tus ejercicios. \u00a1Nos vemos! Contenidos | Anterior (6 Teledetecci\u00f3n)","title":"9.7 Cierre de la clase"},{"location":"10_Generadores_e_Iteradores/00_Resumen/","text":"Contenidos | Anterior (9 Clases y objetos) | Pr\u00f3ximo (11 Recursi\u00f3n y regresi\u00f3n) 10. Generadores e iteradores Programar es b\u00e1sicamente escribir condicionales, ciclos y asignaciones de variables. Aunque no de cualquier forma. Los ciclos, ya sean ciclos while o iteraciones for son una de las estructuras m\u00e1s ubicuas en cualquier lenguaje. Los programas hacen muchas iteraciones para procesar listas, leer archivos, buscar en bases de datos y dem\u00e1s. Una de las caracter\u00edsticas m\u00e1s poderosas de Python es la capacidad de redefinir la iteraci\u00f3n mediante las llamadas \"funciones generadoras\". En esta secci\u00f3n veremos de qu\u00e9 se trata esto. Hacia el final vas a escribir programas que procesan datos en tiempo real, a medida que son generados. Terminamos la clase con un ejercicio optativo que combina dos temas importantes: objetos y simulaciones. El ejercicio optativo propone simular en el espacio y tiempo la din\u00e1mica predador-presa utilizando para esto programaci\u00f3n orientada a objetos. 10.1 Introducci\u00f3n 10.2 El protocolo de iteraci\u00f3n 10.3 Iteraci\u00f3n a medida 10.4 Productores, consumidores y ca\u00f1er\u00edas. 10.5 M\u00e1s sobre generadores 10.6 Predador Presa 10.7 Cierre de la clase Contenidos | Anterior (9 Clases y objetos) | Pr\u00f3ximo (11 Recursi\u00f3n y regresi\u00f3n)","title":"00 Resumen"},{"location":"10_Generadores_e_Iteradores/00_Resumen/#10-generadores-e-iteradores","text":"Programar es b\u00e1sicamente escribir condicionales, ciclos y asignaciones de variables. Aunque no de cualquier forma. Los ciclos, ya sean ciclos while o iteraciones for son una de las estructuras m\u00e1s ubicuas en cualquier lenguaje. Los programas hacen muchas iteraciones para procesar listas, leer archivos, buscar en bases de datos y dem\u00e1s. Una de las caracter\u00edsticas m\u00e1s poderosas de Python es la capacidad de redefinir la iteraci\u00f3n mediante las llamadas \"funciones generadoras\". En esta secci\u00f3n veremos de qu\u00e9 se trata esto. Hacia el final vas a escribir programas que procesan datos en tiempo real, a medida que son generados. Terminamos la clase con un ejercicio optativo que combina dos temas importantes: objetos y simulaciones. El ejercicio optativo propone simular en el espacio y tiempo la din\u00e1mica predador-presa utilizando para esto programaci\u00f3n orientada a objetos. 10.1 Introducci\u00f3n 10.2 El protocolo de iteraci\u00f3n 10.3 Iteraci\u00f3n a medida 10.4 Productores, consumidores y ca\u00f1er\u00edas. 10.5 M\u00e1s sobre generadores 10.6 Predador Presa 10.7 Cierre de la clase Contenidos | Anterior (9 Clases y objetos) | Pr\u00f3ximo (11 Recursi\u00f3n y regresi\u00f3n)","title":"10. Generadores e iteradores"},{"location":"10_Generadores_e_Iteradores/01_Intro/","text":"Contenidos | Pr\u00f3ximo (2 El protocolo de iteraci\u00f3n) 10.1 Introducci\u00f3n En este video damos una breve introducci\u00f3n a los temas de la clase. Luego, en cada secci\u00f3n vas a encontrar tambi\u00e9n un video corto con mayor nivel de detalle sobre los temas de la secci\u00f3n. \u00a1Que disfrutes la clase! Contenidos | Pr\u00f3ximo (2 El protocolo de iteraci\u00f3n)","title":"01 Intro"},{"location":"10_Generadores_e_Iteradores/01_Intro/#101-introduccion","text":"En este video damos una breve introducci\u00f3n a los temas de la clase. Luego, en cada secci\u00f3n vas a encontrar tambi\u00e9n un video corto con mayor nivel de detalle sobre los temas de la secci\u00f3n. \u00a1Que disfrutes la clase! Contenidos | Pr\u00f3ximo (2 El protocolo de iteraci\u00f3n)","title":"10.1 Introducci\u00f3n"},{"location":"10_Generadores_e_Iteradores/02_protocolo_Iteracion/","text":"Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Iteraci\u00f3n a medida) 10.2 El protocolo de iteraci\u00f3n En esta secci\u00f3n vemos lo que realmente sucede en Python durante una proceso de iteraci\u00f3n. Esta secci\u00f3n tiene un video introductorio. Iteraciones por doquier Podemos iterar sobre una gran diversidad de objetos. a = 'hola a todes' for c in a: # Iterar sobre las letras en a ... b = {'nombre': 'Elsa', 'password':'foo'} for k in b: # Iterar sobre las claves de diccionario ... c = [1, 2, 3, 4] for i in c: # Iterar sobre los items en una lista o tupla ... f = open('foo.txt') for x in f: # Iterar sobre las l\u00edneas de un archivo ASCII ... Podemos iterar sobre todos estos objetos porque cumplen con un protocolo que permite, justamente, iterar. Veamos algo sobre este protocolo: El protocolo de iteraci\u00f3n Analicemos la instrucci\u00f3n for . for x in obj: # instrucciones \u00bfC\u00f3mo funciona realmente \u00e9sto? Mediante un protocolo de iteraci\u00f3n que puede resumirse as\u00ed: _iter = obj.__iter__() # Buscar el objeto iterador while True: try: x = _iter.__next__() # Dame el siguiente item except StopIteration: # No hay m\u00e1s items break # instrucciones ... Todo objeto compatible con un ciclo for implementa, a bajo nivel, este protocolo de iteraci\u00f3n. Un ejemplo: Iteraci\u00f3n manual sobre una lista. >>> x = [1,2,3] >>> it = x.__iter__() >>> it <listiterator object at 0x590b0> >>> it.__next__() 1 >>> it.__next__() 2 >>> it.__next__() 3 >>> it.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in ? StopIteration >>> Fijate que al agotar los elementos, el traceback acusa una excepci\u00f3n de tipo StopIteration . Fijate tambi\u00e9n que en la tercera l\u00ednea, al preguntar por it , python responde . Iterable Es necesario que entiendas los mecanismos de iteradores si quer\u00e9s permitir iteraci\u00f3n sobre objetos que vos definas, es decir, hacerlos iterables . El siguiente ejemplo construye un contenedor iterable, simplemente basado en una lista: class Camion: def __init__(self): self.lotes = [] def __iter__(self): return self.lotes.__iter__() ... camion = Camion() for c in camion: ... Ejercicios Ejercicio 10.1: Iteradores, un ejemplo Constru\u00ed la siguiente lista: a = [1, 9, 4, 25, 16] Y ahora iter\u00e1 sobre esa lista a mano : Llam\u00e1 al m\u00e9todo __iter__() para obtener un objeto iterador y llama al m\u00e9todo __next__() para obtener sucesivamente cada uno de los elementos. >>> i = a.__iter__() >>> i <listiterator object at 0x64c10> >>> i.__next__() 1 >>> i.__next__() 9 >>> i.__next__() 4 >>> i.__next__() 25 >>> i.__next__() 16 >>> i.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> StopIteration >>> La funci\u00f3n nativa de Python next() es un \"atajo\" al m\u00e9todo __next__() de un iterador. Prob\u00e1 usarlo a mano sobre un archivo: >>> f = open('../Data/camion.csv') >>> f.__iter__() # Notar que esto apunta al m\u00e9todo... # ...que accede al archivo mismo. <_io.TextIOWrapper name='../Data/camion.csv' mode='r' encoding='UTF-8'> >>> next(f) 'nombre,cajones,precio\\n' >>> next(f) 'Lima,100,32.20\\n' >>> next(f) 'Naranja,50,91.10\\n' >>> Llam\u00e1 a next(f) hasta que llegues al final del archivo, y fijate qu\u00e9 sucede. Ejercicio 10.2: Iteraci\u00f3n sobre objetos Como dec\u00edamos, cuando definas tus propios objetos, es posible que quieras que se pueda iterar sobre ellos (especialmente si estos objetos son \"envoltorios\" (wrappers) para listas u otros iterables). Hagamos esto: en un nuevo archivo llamado camion.py , defin\u00ed la siguiente clase: # camion.py class Camion: def __init__(self, lotes): self.lotes = lotes def precio_total(self): return sum([l.costo() for l in self.lotes]) def contar_cajones(self): from collections import Counter cantidad_total = Counter() for l in self.lotes: cantidad_total[l.nombre] += l.cajones return cantidad_total La intenci\u00f3n es crear un envoltorio para una lista, y de paso agregarle algunos m\u00e9todos, como la propiedad de calcular el costo total del cami\u00f3n. Vamos a usar lo que hiciste en el Ejercicio 9.1 . Modific\u00e1 la funci\u00f3n leer_camion() en informe.py de modo que cree una instancia de Camion , como se muestra: # informe.py ... import fileparse from lote import Lote from camion import Camion def leer_camion(filename): ''' Lee un archivo con el contenido de un cami\u00f3n y lo devuelve como un objeto Camion. ''' with open(filename) as file: camiondicts = fileparse.parse_csv(file, select=['nombre','cajones','precio'], types=[str,int,float]) camion = [Lote(d['nombre'], d['cajones'], d['precio']) for d in camiondicts] return Camion(camion) ... Ahora intent\u00e1 correr el programa informe.py . No hay forma. informe.py intenta iterar sobre las instancias de Camion pero \u00e9stas no son iterables y el programa no funciona. >>> import informe >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv') ... muere ... La forma de arreglar este programa roto es modificar la clase Camion y hacerla iterable. class Camion: def __init__(self, lotes): self.lotes = lotes def __iter__(self): return self.lotes.__iter__() def precio_total(self): return sum([l.costo() for l in self.lotes]) def contar_cajones(self): from collections import Counter cantidad_total = Counter() for lote in self.lotes: cantidad_total[lote.nombre] += lote.cajones return cantidad_total Despu\u00e9s de haber hecho este cambio, tu informe.py deber\u00eda estar funcionando de nuevo. Guard\u00e1 esta versi\u00f3n de informe.py para entregar al final de la clase (en el pr\u00f3ximo ejercicio te pediremos tambi\u00e9n camion.py ). Y ya que est\u00e1s, cambi\u00e1 el programa costo_camion.py para que use objetos que sean instancias de la clase Camion , por ejemplo as\u00ed: # costo_camion.py import informe def costo_camion(filename): ''' Computa el precio total (cantidad * precio) de un archivo camion ''' camion = informe.leer_camion(filename) return camion.precio_total() ... Testealo, testealo, y testealo para asegurarte que funciona: >>> import costo_camion >>> costo_camion.costo_camion('../Data/camion.csv') 47671.15 >>> Ejercicio 10.3: Un iterador adecuado Cuando hagas clases que sean recipientes o contenedores de estructuras de datos vas a necesitar que hagan algo m\u00e1s que simplemente iterar. Prob\u00e1 modificar la clase Camion de modo que tenga algunos de los \"m\u00e9todos m\u00e1gicos\" que mencionamos en la Secci\u00f3n 9.4 . Aqu\u00ed hay algunos: class Camion: def __init__(self, lotes): self.lotes = lotes def __iter__(self): return self.lotes.__iter__() def __len__(self): return len(self.lotes) def __getitem__(self, index): return self.lotes[index] def __contains__(self, nombre): return any([lote.nombre == nombre for lote in self.lotes]) def precio_total(self): return sum([l.costo() for l in self.lotes]) def contar_cajones(self): from collections import Counter cantidad_total = Counter() for l in self.lotes: cantidad_total[l.nombre] += l.cajones return cantidad_total Por \u00faltimo, probemos esta nueva estructura: >>> import informe >>> camion = informe.leer_camion('../Data/camion.csv') >>> len(camion) 7 >>> camion[0] Lote('Lima', 100, 32.2) >>> camion[1] Lote('Naranja', 50, 91.1) >>> camion[0:3] [Lote('Lima', 100, 32.2), Lote('Naranja', 50, 91.1), Lote('Caqui', 150, 103.44)] >>> 'Naranja' in camion True >>> 'Manzana' in camion False >>> Guard\u00e1 tu versi\u00f3n de camion.py con estos cambios para entregar y para la revisi\u00f3n de pares. Un comentario importante sobre todo esto: Se considera de buen estilo Python al c\u00f3digo que comparte ciertas normas de interacci\u00f3n con el resto del mundo Python. Este concepto aplicado a objetos contenedores significa que \u00e9stos cumplen con las buenas costumbres de ser iterables, indexables y que admiten otras operaciones que naturalmente se espera a priori que vayan a cumplir, justamente por el simple hecho de ser objetos contenedores. Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Iteraci\u00f3n a medida)","title":"02 protocolo Iteracion"},{"location":"10_Generadores_e_Iteradores/02_protocolo_Iteracion/#102-el-protocolo-de-iteracion","text":"En esta secci\u00f3n vemos lo que realmente sucede en Python durante una proceso de iteraci\u00f3n. Esta secci\u00f3n tiene un video introductorio.","title":"10.2 El protocolo de iteraci\u00f3n"},{"location":"10_Generadores_e_Iteradores/02_protocolo_Iteracion/#iteraciones-por-doquier","text":"Podemos iterar sobre una gran diversidad de objetos. a = 'hola a todes' for c in a: # Iterar sobre las letras en a ... b = {'nombre': 'Elsa', 'password':'foo'} for k in b: # Iterar sobre las claves de diccionario ... c = [1, 2, 3, 4] for i in c: # Iterar sobre los items en una lista o tupla ... f = open('foo.txt') for x in f: # Iterar sobre las l\u00edneas de un archivo ASCII ... Podemos iterar sobre todos estos objetos porque cumplen con un protocolo que permite, justamente, iterar. Veamos algo sobre este protocolo:","title":"Iteraciones por doquier"},{"location":"10_Generadores_e_Iteradores/02_protocolo_Iteracion/#el-protocolo-de-iteracion","text":"Analicemos la instrucci\u00f3n for . for x in obj: # instrucciones \u00bfC\u00f3mo funciona realmente \u00e9sto? Mediante un protocolo de iteraci\u00f3n que puede resumirse as\u00ed: _iter = obj.__iter__() # Buscar el objeto iterador while True: try: x = _iter.__next__() # Dame el siguiente item except StopIteration: # No hay m\u00e1s items break # instrucciones ... Todo objeto compatible con un ciclo for implementa, a bajo nivel, este protocolo de iteraci\u00f3n. Un ejemplo: Iteraci\u00f3n manual sobre una lista. >>> x = [1,2,3] >>> it = x.__iter__() >>> it <listiterator object at 0x590b0> >>> it.__next__() 1 >>> it.__next__() 2 >>> it.__next__() 3 >>> it.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in ? StopIteration >>> Fijate que al agotar los elementos, el traceback acusa una excepci\u00f3n de tipo StopIteration . Fijate tambi\u00e9n que en la tercera l\u00ednea, al preguntar por it , python responde .","title":"El protocolo de iteraci\u00f3n"},{"location":"10_Generadores_e_Iteradores/02_protocolo_Iteracion/#iterable","text":"Es necesario que entiendas los mecanismos de iteradores si quer\u00e9s permitir iteraci\u00f3n sobre objetos que vos definas, es decir, hacerlos iterables . El siguiente ejemplo construye un contenedor iterable, simplemente basado en una lista: class Camion: def __init__(self): self.lotes = [] def __iter__(self): return self.lotes.__iter__() ... camion = Camion() for c in camion: ...","title":"Iterable"},{"location":"10_Generadores_e_Iteradores/02_protocolo_Iteracion/#ejercicios","text":"","title":"Ejercicios"},{"location":"10_Generadores_e_Iteradores/02_protocolo_Iteracion/#ejercicio-101-iteradores-un-ejemplo","text":"Constru\u00ed la siguiente lista: a = [1, 9, 4, 25, 16] Y ahora iter\u00e1 sobre esa lista a mano : Llam\u00e1 al m\u00e9todo __iter__() para obtener un objeto iterador y llama al m\u00e9todo __next__() para obtener sucesivamente cada uno de los elementos. >>> i = a.__iter__() >>> i <listiterator object at 0x64c10> >>> i.__next__() 1 >>> i.__next__() 9 >>> i.__next__() 4 >>> i.__next__() 25 >>> i.__next__() 16 >>> i.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> StopIteration >>> La funci\u00f3n nativa de Python next() es un \"atajo\" al m\u00e9todo __next__() de un iterador. Prob\u00e1 usarlo a mano sobre un archivo: >>> f = open('../Data/camion.csv') >>> f.__iter__() # Notar que esto apunta al m\u00e9todo... # ...que accede al archivo mismo. <_io.TextIOWrapper name='../Data/camion.csv' mode='r' encoding='UTF-8'> >>> next(f) 'nombre,cajones,precio\\n' >>> next(f) 'Lima,100,32.20\\n' >>> next(f) 'Naranja,50,91.10\\n' >>> Llam\u00e1 a next(f) hasta que llegues al final del archivo, y fijate qu\u00e9 sucede.","title":"Ejercicio 10.1: Iteradores, un ejemplo"},{"location":"10_Generadores_e_Iteradores/02_protocolo_Iteracion/#ejercicio-102-iteracion-sobre-objetos","text":"Como dec\u00edamos, cuando definas tus propios objetos, es posible que quieras que se pueda iterar sobre ellos (especialmente si estos objetos son \"envoltorios\" (wrappers) para listas u otros iterables). Hagamos esto: en un nuevo archivo llamado camion.py , defin\u00ed la siguiente clase: # camion.py class Camion: def __init__(self, lotes): self.lotes = lotes def precio_total(self): return sum([l.costo() for l in self.lotes]) def contar_cajones(self): from collections import Counter cantidad_total = Counter() for l in self.lotes: cantidad_total[l.nombre] += l.cajones return cantidad_total La intenci\u00f3n es crear un envoltorio para una lista, y de paso agregarle algunos m\u00e9todos, como la propiedad de calcular el costo total del cami\u00f3n. Vamos a usar lo que hiciste en el Ejercicio 9.1 . Modific\u00e1 la funci\u00f3n leer_camion() en informe.py de modo que cree una instancia de Camion , como se muestra: # informe.py ... import fileparse from lote import Lote from camion import Camion def leer_camion(filename): ''' Lee un archivo con el contenido de un cami\u00f3n y lo devuelve como un objeto Camion. ''' with open(filename) as file: camiondicts = fileparse.parse_csv(file, select=['nombre','cajones','precio'], types=[str,int,float]) camion = [Lote(d['nombre'], d['cajones'], d['precio']) for d in camiondicts] return Camion(camion) ... Ahora intent\u00e1 correr el programa informe.py . No hay forma. informe.py intenta iterar sobre las instancias de Camion pero \u00e9stas no son iterables y el programa no funciona. >>> import informe >>> informe.informe_camion('../Data/camion.csv', '../Data/precios.csv') ... muere ... La forma de arreglar este programa roto es modificar la clase Camion y hacerla iterable. class Camion: def __init__(self, lotes): self.lotes = lotes def __iter__(self): return self.lotes.__iter__() def precio_total(self): return sum([l.costo() for l in self.lotes]) def contar_cajones(self): from collections import Counter cantidad_total = Counter() for lote in self.lotes: cantidad_total[lote.nombre] += lote.cajones return cantidad_total Despu\u00e9s de haber hecho este cambio, tu informe.py deber\u00eda estar funcionando de nuevo. Guard\u00e1 esta versi\u00f3n de informe.py para entregar al final de la clase (en el pr\u00f3ximo ejercicio te pediremos tambi\u00e9n camion.py ). Y ya que est\u00e1s, cambi\u00e1 el programa costo_camion.py para que use objetos que sean instancias de la clase Camion , por ejemplo as\u00ed: # costo_camion.py import informe def costo_camion(filename): ''' Computa el precio total (cantidad * precio) de un archivo camion ''' camion = informe.leer_camion(filename) return camion.precio_total() ... Testealo, testealo, y testealo para asegurarte que funciona: >>> import costo_camion >>> costo_camion.costo_camion('../Data/camion.csv') 47671.15 >>>","title":"Ejercicio 10.2: Iteraci\u00f3n sobre objetos"},{"location":"10_Generadores_e_Iteradores/02_protocolo_Iteracion/#ejercicio-103-un-iterador-adecuado","text":"Cuando hagas clases que sean recipientes o contenedores de estructuras de datos vas a necesitar que hagan algo m\u00e1s que simplemente iterar. Prob\u00e1 modificar la clase Camion de modo que tenga algunos de los \"m\u00e9todos m\u00e1gicos\" que mencionamos en la Secci\u00f3n 9.4 . Aqu\u00ed hay algunos: class Camion: def __init__(self, lotes): self.lotes = lotes def __iter__(self): return self.lotes.__iter__() def __len__(self): return len(self.lotes) def __getitem__(self, index): return self.lotes[index] def __contains__(self, nombre): return any([lote.nombre == nombre for lote in self.lotes]) def precio_total(self): return sum([l.costo() for l in self.lotes]) def contar_cajones(self): from collections import Counter cantidad_total = Counter() for l in self.lotes: cantidad_total[l.nombre] += l.cajones return cantidad_total Por \u00faltimo, probemos esta nueva estructura: >>> import informe >>> camion = informe.leer_camion('../Data/camion.csv') >>> len(camion) 7 >>> camion[0] Lote('Lima', 100, 32.2) >>> camion[1] Lote('Naranja', 50, 91.1) >>> camion[0:3] [Lote('Lima', 100, 32.2), Lote('Naranja', 50, 91.1), Lote('Caqui', 150, 103.44)] >>> 'Naranja' in camion True >>> 'Manzana' in camion False >>> Guard\u00e1 tu versi\u00f3n de camion.py con estos cambios para entregar y para la revisi\u00f3n de pares. Un comentario importante sobre todo esto: Se considera de buen estilo Python al c\u00f3digo que comparte ciertas normas de interacci\u00f3n con el resto del mundo Python. Este concepto aplicado a objetos contenedores significa que \u00e9stos cumplen con las buenas costumbres de ser iterables, indexables y que admiten otras operaciones que naturalmente se espera a priori que vayan a cumplir, justamente por el simple hecho de ser objetos contenedores. Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Iteraci\u00f3n a medida)","title":"Ejercicio 10.3: Un iterador adecuado"},{"location":"10_Generadores_e_Iteradores/03_iteracion_a_medida/","text":"Contenidos | Anterior (2 El protocolo de iteraci\u00f3n) | Pr\u00f3ximo (4 Productores, consumidores y ca\u00f1er\u00edas.) 10.3 Iteraci\u00f3n a medida En esta secci\u00f3n introducimos el concepto de funci\u00f3n generadora. Estas funciones te permiten obtener el iterador que necesites. Un problema de iteraci\u00f3n Supon\u00e9 que quer\u00e9s crear una secuencia particular de iteraci\u00f3n: una cuenta regresiva, por decir algo. >>> for x in regresiva(10): ... print(x, end=' ') ... 10 9 8 7 6 5 4 3 2 1 >>> Existe una forma f\u00e1cil de hacer esto. Generadores Un generador es una funci\u00f3n que define un patr\u00f3n de iteraci\u00f3n. def regresiva(n): while n > 0: yield n n -= 1 Nota: \"yield\" se traduce como \"rendir\" \u00f3 \"entregar\". Por ejemplo: >>> for x in regresiva(10): ... print(x, end=' ') ... 10 9 8 7 6 5 4 3 2 1 >>> Un generador es cualquier funci\u00f3n que usa el commando yield . El comportamiento de los generadores es algo diferente al del resto de las funciones. Al llamar a un generador cre\u00e1s un objeto generador, pero su funci\u00f3n no se ejecuta de inmediato. def regresiva(n): # Agreguemos este print para ver qu\u00e9 pasa... print('Cuenta regresiva desde', n) while n > 0: yield n n -= 1 >>> x = regresiva(10) # No se ejecuta ning\u00fan PRINT ! >>> x # sin embargo x es un objeto generador <generator object at 0x58490> >>> La funci\u00f3n s\u00f3lo se ejecuta ante un llamado al m\u00e9todo __next__() >>> x = regresiva(10) >>> x <generator object at 0x58490> >>> x.__next__() Cuenta regresiva desde 10 10 >>> Lo que hace yield es notable: produce un valor, y luego suspende la ejecuci\u00f3n de la funci\u00f3n. La ejecuci\u00f3n contin\u00faa al volver a llamar a __next__() . >>> x.__next__() 9 >>> x.__next__() 8 Cuando finalmente se llega al final de la funci\u00f3n, la iteraci\u00f3n da un error. >>> x.__next__() 1 >>> x.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in ? StopIteration >>> Observaci\u00f3n: Una funci\u00f3n generadora implementa el mismo protocolo de bajo nivel que los for usan sobre listas, tuplas, diccionarios, archivos, etc. \u00a1Por eso es tan sencillo usar los generadores para iterar! Ejercicios Ejercicio 10.4: Un generador simple Si te encontr\u00e1s con la necesidad de obtener una iteraci\u00f3n particular, pens\u00e1 en usar funciones generadoras. Son f\u00e1ciles de escribir: simplemente hac\u00e9 una funci\u00f3n que implemente la l\u00f3gica de iteraci\u00f3n deseada y use yield para entregar valores. Por ejemplo, prob\u00e1 este generador que busca un archivo y entrega las l\u00edneas que incluyen cierto substring. >>> def filematch(filename, substr): with open(filename, 'r') as f: for line in f: if substr in line: yield line >>> for line in open('../Data/camion.csv'): print(line, end='') nombre,cajones,precio Lima,100,32.2 Naranja,50,91.1 Caqui,150,103.44 Mandarina,200,51.23 Durazno,95,40.37 Mandarina,50,65.1 Naranja,100,70.44 >>> for line in filematch('../Data/camion.csv', 'Naranja'): print(line, end='') Naranja,50,91.1 Naranja,100,70.44 >>> Esta idea es muy interesante: pod\u00e9s armar una funci\u00f3n que encapsule todo el procesamiento de datos y despu\u00e9s recorrerla con un ciclo for para que te entregue los datos uno a uno. El pr\u00f3ximo ejemplo es de un caso a\u00fan m\u00e1s especial. Ejercicio 10.5: Monitoreo de datos en tiempo real. Ac\u00e1 hay un breve video sobre este ejercicio. Un generador puede ser una forma interesante de vigilar datos a medida que son producidos. En esta secci\u00f3n vamos a probar esa idea. Para empezar, hac\u00e9 lo siguiente. Vas a necesitar dos archivos que est\u00e1n en tu carpeta de ejercicios, dentro de Data : sim_mercado.py y mcentral.csv . Por favor primero borralos y bajate de nuevo estos dos archivos porque los modificamos ligeramente. Guard\u00e1 el archivo mcentral.csv en la carpeta Data y el archivo sim_mercado.py en la carpeta de la clase 10. El programa sim_mercado.py es un generador de datos de precios que toma como referencia a mcentral.csv . Al ejecutarlo, el programa escribe datos (con una componente aleatoria) en un archivo llamado mercadolog.csv cont\u00ednuamente hasta que es detenido. Se ejecuta indefinidamente: una vez que inicies su ejecuci\u00f3n pod\u00e9s dejarlo correr y olvidarte de \u00e9l. Abr\u00ed una consola del sistema operativo nueva y ejecut\u00e1 el programa. Si est\u00e1s en Windows, dale un doble click al \u00edcono de sim_mercado.py , \u00f3 desde unix: bash % python3 sim_mercado.py Despu\u00e9s, olvidate de \u00e9l. Dej\u00e1lo ah\u00ed, corriendo. Usando otra consola, mir\u00e1 el contenido de Data/mercadolog.csv . Vas a ver que cada tanto se agrega una nueva l\u00ednea al archivo. Ahora que el programa generador de datos est\u00e1 en ejecuci\u00f3n, escribamos un programa que abra el archivo, vaya al final, y espere nuevos datos. Para esto cre\u00e1 un programa llamado vigilante.py (es uno de los ejercicios a entregar) que contenga el siguiente c\u00f3digo. # vigilante.py import os import time f = open('../Data/mercadolog.csv') f.seek(0, os.SEEK_END) # Mover el \u00edndice 0 posiciones desde el EOF while True: line = f.readline() if line == '': time.sleep(0.5) # Esperar un rato y continue # vuelve al comienzo del while fields = line.split(',') nombre = fields[0].strip('\"') precio = float(fields[1]) volumen = int(fields[2]) if volumen > 1000: print(f'{nombre:>10s} {precio:>10.2f} {volumen:>10d}') Nota: EOF = End Of File (fin de archivo) Cuando ejecutes el programa vas a ver un indicador de precios en el mercado en tiempo real, con indicaci\u00f3n de qu\u00e9 producto se trata, cu\u00e1l es su precio, y cu\u00e1l es el volumen de la operaci\u00f3n (en cantidad de cajones). Observaci\u00f3n: La forma en que usamos el m\u00e9todo readline() en este ejemplo es un poco rara, no es la forma en que se suele usar (dentro de un ciclo for para recorrer el contenido de un archivo). En este caso la estamos usando para mirar constantemente el fin de archivo para obtener los \u00faltimos datos que se hayan agregado ( readline() devuelve \u00f3 bien el \u00faltimo dato o bien una cadena vac\u00eda). Ejercicio 10.6: Uso de un generador para producir datos Si analiz\u00e1s un poco el c\u00f3digo del Ejercicio 10.5 vas a notar que la primera parte del programa \"produce\" datos (los obtiene del archivo) y la segunda los procesa y los imprime, es decir \"consume\" datos. Una caracter\u00edstica importante de las funciones generadoras es que pod\u00e9s mover todo el c\u00f3digo a una funci\u00f3n reutilizable. Probalo vos. Modific\u00e1 el c\u00f3digo del Ejercicio 10.5 de modo que la lectura del archivo est\u00e9 resuelta por una \u00fanica funci\u00f3n generadora vigilar() a la que se le pasa un nombre de archivo como par\u00e1metro. Hacelo de modo que el siguiente c\u00f3digo funcione: >>> for line in vigilar('../Data/mercadolog.csv'): print(line) # Ac\u00e1 deber\u00edas ver las l\u00edneas impresas sin formato de tabla # Algo similar a esto \"Berenjena\", 49.33, 624 \"Naranja\", 15.88, 1040 \"Cebolla\", 66.32, 720 \"Durazno\", 149.02, 768 \"Pomelo\", 48.24, 981 \"Lechuga\", 32.57, 819 \"Repollo\", 6.69, 777 \"Lima\", 1272.49, 208 \"TomCherry\", 514.05, 208 Modific\u00e1 el programa vigilante.py para que termine con un bloque as\u00ed: if __name__ == '__main__': for line in vigilar('../Data/mercadolog.csv'): fields = line.split(',') nombre = fields[0].strip('\"') precio = float(fields[1]) volumen = int(fields[2]) if volumen > 1000: print(f'{nombre:>10s} {precio:>10.2f} {volumen:>10d}') Gurad\u00e1 esta versi\u00f3n de vigilante.py para entregar al final de la clase. Ejercicio 10.7: Cambios de precio de un cami\u00f3n Modific\u00e1 el programa vigilante.py para que s\u00f3lo informe las l\u00edneas que tienen precios de lotes inclu\u00eddos en un cami\u00f3n, e ignore el resto de los productos. Por ejemplo: if __name__ == '__main__': import informe camion = informe.leer_camion ('../Data/camion.csv') for line in vigilar('../Data/mercadolog.csv'): fields = line.split(',') nombre = fields[0].strip('\"') precio = float(fields[1]) volumen = int(fields[2]) if nombre in camion: print(f'{nombre:>10s} {precio:>10.2f} {volumen:>10d}') Observaci\u00f3n: para que esto funcione, tu clase Camion tiene que haber implementado el operador in . Control\u00e1 que tu soluci\u00f3n al ejercicio Ejercicio 10.3 implemente el operador __contains__() . Discusi\u00f3n Lo que acaba de suceder es algo con mucho potencial: moviste tu patr\u00f3n de iteraci\u00f3n (el que toma las \u00faltimas l\u00edneas de un archivo) y lo pusiste en su propia funci\u00f3n. La funci\u00f3n vigilar() ahora es una funci\u00f3n de uso amplio, que pod\u00e9s usar en cualquier programa. Por ejemplo, la podr\u00edas usar para mirar el log (historial) de un servidor \u00f3 de un debugger, o de otras fuentes continuas de datos. \u00bfNo est\u00e1 bueno? Contenidos | Anterior (2 El protocolo de iteraci\u00f3n) | Pr\u00f3ximo (4 Productores, consumidores y ca\u00f1er\u00edas.)","title":"03 iteracion a medida"},{"location":"10_Generadores_e_Iteradores/03_iteracion_a_medida/#103-iteracion-a-medida","text":"En esta secci\u00f3n introducimos el concepto de funci\u00f3n generadora. Estas funciones te permiten obtener el iterador que necesites.","title":"10.3 Iteraci\u00f3n a medida"},{"location":"10_Generadores_e_Iteradores/03_iteracion_a_medida/#un-problema-de-iteracion","text":"Supon\u00e9 que quer\u00e9s crear una secuencia particular de iteraci\u00f3n: una cuenta regresiva, por decir algo. >>> for x in regresiva(10): ... print(x, end=' ') ... 10 9 8 7 6 5 4 3 2 1 >>> Existe una forma f\u00e1cil de hacer esto.","title":"Un problema de iteraci\u00f3n"},{"location":"10_Generadores_e_Iteradores/03_iteracion_a_medida/#generadores","text":"Un generador es una funci\u00f3n que define un patr\u00f3n de iteraci\u00f3n. def regresiva(n): while n > 0: yield n n -= 1 Nota: \"yield\" se traduce como \"rendir\" \u00f3 \"entregar\". Por ejemplo: >>> for x in regresiva(10): ... print(x, end=' ') ... 10 9 8 7 6 5 4 3 2 1 >>> Un generador es cualquier funci\u00f3n que usa el commando yield . El comportamiento de los generadores es algo diferente al del resto de las funciones. Al llamar a un generador cre\u00e1s un objeto generador, pero su funci\u00f3n no se ejecuta de inmediato. def regresiva(n): # Agreguemos este print para ver qu\u00e9 pasa... print('Cuenta regresiva desde', n) while n > 0: yield n n -= 1 >>> x = regresiva(10) # No se ejecuta ning\u00fan PRINT ! >>> x # sin embargo x es un objeto generador <generator object at 0x58490> >>> La funci\u00f3n s\u00f3lo se ejecuta ante un llamado al m\u00e9todo __next__() >>> x = regresiva(10) >>> x <generator object at 0x58490> >>> x.__next__() Cuenta regresiva desde 10 10 >>> Lo que hace yield es notable: produce un valor, y luego suspende la ejecuci\u00f3n de la funci\u00f3n. La ejecuci\u00f3n contin\u00faa al volver a llamar a __next__() . >>> x.__next__() 9 >>> x.__next__() 8 Cuando finalmente se llega al final de la funci\u00f3n, la iteraci\u00f3n da un error. >>> x.__next__() 1 >>> x.__next__() Traceback (most recent call last): File \"<stdin>\", line 1, in ? StopIteration >>> Observaci\u00f3n: Una funci\u00f3n generadora implementa el mismo protocolo de bajo nivel que los for usan sobre listas, tuplas, diccionarios, archivos, etc. \u00a1Por eso es tan sencillo usar los generadores para iterar!","title":"Generadores"},{"location":"10_Generadores_e_Iteradores/03_iteracion_a_medida/#ejercicios","text":"","title":"Ejercicios"},{"location":"10_Generadores_e_Iteradores/03_iteracion_a_medida/#ejercicio-104-un-generador-simple","text":"Si te encontr\u00e1s con la necesidad de obtener una iteraci\u00f3n particular, pens\u00e1 en usar funciones generadoras. Son f\u00e1ciles de escribir: simplemente hac\u00e9 una funci\u00f3n que implemente la l\u00f3gica de iteraci\u00f3n deseada y use yield para entregar valores. Por ejemplo, prob\u00e1 este generador que busca un archivo y entrega las l\u00edneas que incluyen cierto substring. >>> def filematch(filename, substr): with open(filename, 'r') as f: for line in f: if substr in line: yield line >>> for line in open('../Data/camion.csv'): print(line, end='') nombre,cajones,precio Lima,100,32.2 Naranja,50,91.1 Caqui,150,103.44 Mandarina,200,51.23 Durazno,95,40.37 Mandarina,50,65.1 Naranja,100,70.44 >>> for line in filematch('../Data/camion.csv', 'Naranja'): print(line, end='') Naranja,50,91.1 Naranja,100,70.44 >>> Esta idea es muy interesante: pod\u00e9s armar una funci\u00f3n que encapsule todo el procesamiento de datos y despu\u00e9s recorrerla con un ciclo for para que te entregue los datos uno a uno. El pr\u00f3ximo ejemplo es de un caso a\u00fan m\u00e1s especial.","title":"Ejercicio 10.4: Un generador simple"},{"location":"10_Generadores_e_Iteradores/03_iteracion_a_medida/#ejercicio-105-monitoreo-de-datos-en-tiempo-real","text":"Ac\u00e1 hay un breve video sobre este ejercicio. Un generador puede ser una forma interesante de vigilar datos a medida que son producidos. En esta secci\u00f3n vamos a probar esa idea. Para empezar, hac\u00e9 lo siguiente. Vas a necesitar dos archivos que est\u00e1n en tu carpeta de ejercicios, dentro de Data : sim_mercado.py y mcentral.csv . Por favor primero borralos y bajate de nuevo estos dos archivos porque los modificamos ligeramente. Guard\u00e1 el archivo mcentral.csv en la carpeta Data y el archivo sim_mercado.py en la carpeta de la clase 10. El programa sim_mercado.py es un generador de datos de precios que toma como referencia a mcentral.csv . Al ejecutarlo, el programa escribe datos (con una componente aleatoria) en un archivo llamado mercadolog.csv cont\u00ednuamente hasta que es detenido. Se ejecuta indefinidamente: una vez que inicies su ejecuci\u00f3n pod\u00e9s dejarlo correr y olvidarte de \u00e9l. Abr\u00ed una consola del sistema operativo nueva y ejecut\u00e1 el programa. Si est\u00e1s en Windows, dale un doble click al \u00edcono de sim_mercado.py , \u00f3 desde unix: bash % python3 sim_mercado.py Despu\u00e9s, olvidate de \u00e9l. Dej\u00e1lo ah\u00ed, corriendo. Usando otra consola, mir\u00e1 el contenido de Data/mercadolog.csv . Vas a ver que cada tanto se agrega una nueva l\u00ednea al archivo. Ahora que el programa generador de datos est\u00e1 en ejecuci\u00f3n, escribamos un programa que abra el archivo, vaya al final, y espere nuevos datos. Para esto cre\u00e1 un programa llamado vigilante.py (es uno de los ejercicios a entregar) que contenga el siguiente c\u00f3digo. # vigilante.py import os import time f = open('../Data/mercadolog.csv') f.seek(0, os.SEEK_END) # Mover el \u00edndice 0 posiciones desde el EOF while True: line = f.readline() if line == '': time.sleep(0.5) # Esperar un rato y continue # vuelve al comienzo del while fields = line.split(',') nombre = fields[0].strip('\"') precio = float(fields[1]) volumen = int(fields[2]) if volumen > 1000: print(f'{nombre:>10s} {precio:>10.2f} {volumen:>10d}') Nota: EOF = End Of File (fin de archivo) Cuando ejecutes el programa vas a ver un indicador de precios en el mercado en tiempo real, con indicaci\u00f3n de qu\u00e9 producto se trata, cu\u00e1l es su precio, y cu\u00e1l es el volumen de la operaci\u00f3n (en cantidad de cajones). Observaci\u00f3n: La forma en que usamos el m\u00e9todo readline() en este ejemplo es un poco rara, no es la forma en que se suele usar (dentro de un ciclo for para recorrer el contenido de un archivo). En este caso la estamos usando para mirar constantemente el fin de archivo para obtener los \u00faltimos datos que se hayan agregado ( readline() devuelve \u00f3 bien el \u00faltimo dato o bien una cadena vac\u00eda).","title":"Ejercicio 10.5: Monitoreo de datos en tiempo real."},{"location":"10_Generadores_e_Iteradores/03_iteracion_a_medida/#ejercicio-106-uso-de-un-generador-para-producir-datos","text":"Si analiz\u00e1s un poco el c\u00f3digo del Ejercicio 10.5 vas a notar que la primera parte del programa \"produce\" datos (los obtiene del archivo) y la segunda los procesa y los imprime, es decir \"consume\" datos. Una caracter\u00edstica importante de las funciones generadoras es que pod\u00e9s mover todo el c\u00f3digo a una funci\u00f3n reutilizable. Probalo vos. Modific\u00e1 el c\u00f3digo del Ejercicio 10.5 de modo que la lectura del archivo est\u00e9 resuelta por una \u00fanica funci\u00f3n generadora vigilar() a la que se le pasa un nombre de archivo como par\u00e1metro. Hacelo de modo que el siguiente c\u00f3digo funcione: >>> for line in vigilar('../Data/mercadolog.csv'): print(line) # Ac\u00e1 deber\u00edas ver las l\u00edneas impresas sin formato de tabla # Algo similar a esto \"Berenjena\", 49.33, 624 \"Naranja\", 15.88, 1040 \"Cebolla\", 66.32, 720 \"Durazno\", 149.02, 768 \"Pomelo\", 48.24, 981 \"Lechuga\", 32.57, 819 \"Repollo\", 6.69, 777 \"Lima\", 1272.49, 208 \"TomCherry\", 514.05, 208 Modific\u00e1 el programa vigilante.py para que termine con un bloque as\u00ed: if __name__ == '__main__': for line in vigilar('../Data/mercadolog.csv'): fields = line.split(',') nombre = fields[0].strip('\"') precio = float(fields[1]) volumen = int(fields[2]) if volumen > 1000: print(f'{nombre:>10s} {precio:>10.2f} {volumen:>10d}') Gurad\u00e1 esta versi\u00f3n de vigilante.py para entregar al final de la clase.","title":"Ejercicio 10.6: Uso de un generador para producir datos"},{"location":"10_Generadores_e_Iteradores/03_iteracion_a_medida/#ejercicio-107-cambios-de-precio-de-un-camion","text":"Modific\u00e1 el programa vigilante.py para que s\u00f3lo informe las l\u00edneas que tienen precios de lotes inclu\u00eddos en un cami\u00f3n, e ignore el resto de los productos. Por ejemplo: if __name__ == '__main__': import informe camion = informe.leer_camion ('../Data/camion.csv') for line in vigilar('../Data/mercadolog.csv'): fields = line.split(',') nombre = fields[0].strip('\"') precio = float(fields[1]) volumen = int(fields[2]) if nombre in camion: print(f'{nombre:>10s} {precio:>10.2f} {volumen:>10d}') Observaci\u00f3n: para que esto funcione, tu clase Camion tiene que haber implementado el operador in . Control\u00e1 que tu soluci\u00f3n al ejercicio Ejercicio 10.3 implemente el operador __contains__() .","title":"Ejercicio 10.7: Cambios de precio de un cami\u00f3n"},{"location":"10_Generadores_e_Iteradores/03_iteracion_a_medida/#discusion","text":"Lo que acaba de suceder es algo con mucho potencial: moviste tu patr\u00f3n de iteraci\u00f3n (el que toma las \u00faltimas l\u00edneas de un archivo) y lo pusiste en su propia funci\u00f3n. La funci\u00f3n vigilar() ahora es una funci\u00f3n de uso amplio, que pod\u00e9s usar en cualquier programa. Por ejemplo, la podr\u00edas usar para mirar el log (historial) de un servidor \u00f3 de un debugger, o de otras fuentes continuas de datos. \u00bfNo est\u00e1 bueno? Contenidos | Anterior (2 El protocolo de iteraci\u00f3n) | Pr\u00f3ximo (4 Productores, consumidores y ca\u00f1er\u00edas.)","title":"Discusi\u00f3n"},{"location":"10_Generadores_e_Iteradores/04_Producers_consumers/","text":"Contenidos | Anterior (3 Iteraci\u00f3n a medida) | Pr\u00f3ximo (5 M\u00e1s sobre generadores) 10.4 Productores, consumidores y ca\u00f1er\u00edas. Para esta secci\u00f3n hay un video introductorio . Los generadores son una herramienta muy \u00fatil para configurar pipelines (ca\u00f1er\u00edas). Este concepto requiere una breve aclaraci\u00f3n : Un pipeline tradicional en computaci\u00f3n consta de una serie de programas y archivos asociados que constituyen una estructura de procesamiento de datos, donde cada programa se ejecuta independientemente de los dem\u00e1s, pero juntos resultan en un flujo conveniente de datos a trav\u00e9s de los archivos asociados desde un \"productor\" (una c\u00e1mara, un sensor, un lector de c\u00f3digo de barras) hasta un \"consumidor\" (un graficador, un interruptor el\u00e9ctrico, un log de una p\u00e1gina web). Construiste un peque\u00f1o pipeline en la secci\u00f3n anterior, usando vigilante.py . En esta secci\u00f3n hablaremos de c\u00f3mo implementar estas estructuras de productores y consumidores de datos con generadores en Python. Sistemas productor-consumidor El concepto de generadores est\u00e1 \u00edntimamente asociado a problemas de tipo productor-consumidor en sus varias formas. Fijate esta estructura, que es t\u00edpica de muchos programas: # Productor def vigilar(f): ... while True: ... yield linea # Produce/obtiene valores para \"linea\" ... # Consumidor for linea in vigilar(f): # Consume l\u00edneas del `yield` ... Los yield generan los datos que los for consumen. Pipelines con generadores Pod\u00e9s usar esta caracter\u00edstica de los generadores para constru\u00edr pipelines que procesen tus datos, un concepto que es muy usado en Unix (pipes) pero en Windows se usa menos. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor Los pipelines de procesamiento de datos tienen un productor al comienzo, una cadena de etapas de procesamiento y un consumidor al final. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def productor(): ... yield item ... El productor es en general un generador, aunque tambien podr\u00eda ser una lista o cualquier otra secuencia iterable. El yield alimenta al pipeline de datos. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def consumidor(s): for item in s: ... El consumidor es un ciclo for . Obtiene los elementos item y los usa para algo. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def procesamiento(s): for item in s: ... yield itemnuevo ... Las etapas intermedias de procesamiento simult\u00e1neamente consumen y producen datos, pueden alterar el flujo de datos, eliminar o modificar datos seg\u00fan su funci\u00f3n. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def productor(): ... yield item # yield devuelve un item que ser\u00e1 recibido por `procesamiento` ... def procesamiento(s): for item in s: # item viene del `productor` ... yield newitem # este yield devuelve un nuevo item ... def consumidor(s): for item in s: # item viene de `procesamiento` ... Vamos a constru\u00edr un pipeline con la siguiente arquitectura: a = productor() b = procesamiento(a) c = consumidor(b) Como te dar\u00e1s cuenta, los datos van pasando de una funci\u00f3n a la siguiente. Ejercicios Para este ejercicio, necesit\u00e1s que el programa sim_mercado.py a\u00fan est\u00e9 corriendo. Vas a usar la funci\u00f3n vigilar() que escribiste en el Ejercicio 10.7 Ejercicio 10.8: Configuremos un pipeline simple Escrib\u00ed la siguiente funci\u00f3n y veamos como funciona un pipeline. >>> def filematch(lines, substr): for line in lines: if substr in line: yield line >>> Esta funci\u00f3n es casi id\u00e9ntica al primer ejemplo de generador en el ejercicio anterior, salvo que ya no abre un archivo sino que opera directamente de una secuencia de l\u00edneas que recibe como argumento. Ahora prob\u00e1 lo siguiente: >>> lines = vigilar('../Data/mercadolog.csv') >>> naranjas = filematch(lines, 'Naranja') >>> for line in naranjas: print(line) ... esper\u00e1 que aparezca la salida ... Puede pasar que tarde unos segundos en darte una salida, pero vas a ver informaci\u00f3n sobre naranjas tan pronto como sean a\u00f1adidas al archivo por el primer generador. Ejercicio 10.9: Un pipeline m\u00e1s en serio Llevemos esta idea un poco m\u00e1s lejos. Probemos esto: >>> from vigilante import vigilar >>> import csv >>> lineas = vigilar('../Data/mercadolog.csv') >>> filas = csv.reader(lineas) >>> for fila in filas: print(fila) ... ['Rabanito', ' 249.37', ' 357'] ['Batata', ' 15.75', ' 1040'] ['Rabanito', ' 211.31', ' 324'] ['Zuccini', ' 83.12', ' 612'] ... \u00a1Interesante! La salida de la funci\u00f3n vigilar() fu\u00e9 usada como entrada a la funci\u00f3n csv.reader() (que hab\u00edamos usado para leer un archivo del disco) y el resultado es una secuencia de filas \"parseadas\", separadas por las comas. Ejercicio 10.10: Un pipeline m\u00e1s largo Veamos si podemos constru\u00edr un pipeline m\u00e1s largo basado en la misma idea. Cre\u00e1 un archivo nuevo llamado ticker.py , te lo vamos a pedir al final de la clase. Comenz\u00e1 creando una funci\u00f3n que lea un archivo CSV como hiciste antes: # ticker.py from vigilante import vigilar import csv def parsear_datos(lines): rows = csv.reader(lines) return rows if __name__ == '__main__': lines = vigilar('../Data/mercadolog.csv') rows = parsear_datos(lines) for row in rows: print(row) Escrib\u00ed una funci\u00f3n nueva que elija algunas columnas espec\u00edficas: # ticker.py ... def elegir_columnas(rows, indices): for row in rows: yield [row[index] for index in indices] ... def parsear_datos(lines): rows = csv.reader(lines) rows = elegir_columnas(rows, [0, 2]) return rows Probalo de nuevo. La salida ahora deber\u00eda estar restringida a esto: ['Br\u00f3coli', ' 388'] ['Ajo', ' 120'] ['Caqui', ' 108'] ['Mandarina', ' 1170'] ... Escrib\u00ed funciones generadoras que conviertan el tipo de datos a diccionarios: # ticker.py ... def cambiar_tipo(rows, types): for row in rows: yield [func(val) for func, val in zip(types, row)] def hace_dicts(rows, headers): for row in rows: yield dict(zip(headers, row)) def parsear_datos(lines): rows = csv.reader(lines) rows = elegir_columnas(rows, [0, 1, 2]) rows = cambiar_tipo(rows, [str, float, int]) rows = hace_dicts(rows, ['nombre', 'precio', 'volumen']) return rows ... Correlo de nuevo. Ahora la salida deber\u00eda ser una serie de diccionarios: {'nombre': 'Frutilla', 'precio': 276.81, 'volumen': 249.0} {'nombre': 'Morr\u00f3n', 'precio': 2988.42, 'volumen': 702.0} {'nombre': 'Morr\u00f3n', 'precio': 3108.63, 'volumen': 498.0} {'nombre': 'Naranja', 'precio': 11.5, 'volumen': 870.0} ... Ejercicio 10.11: Filtremos los datos Para seguir agregando procesamiento a nuestro pipeline, escrib\u00ed un filtro de datos: # ticker.py ... def filtrar_datos(filas, nombres): for fila in filas: if fila['nombre'] in nombres: yield fila Esto se usa para dejar pasar \u00fanicamente aquellos lotes incluidos en el cami\u00f3n. Probalo. import informe camion = informe.leer_camion('../Data/camion.csv') filas = parsear_datos(vigilar('../Data/mercadolog.csv')) filas = filtrar_datos(filas, camion) for fila in filas: print(fila) Ejercicio 10.12: El pipeline ensamblado En el programa ticker.py (esta versi\u00f3n te vamos a pedir que la entregues) escrib\u00ed una funci\u00f3n ticker(camion_file, log_file, fmt) que cree un indicador en tiempo real para un cami\u00f3n, archivo log, y formato de tabla de salida particulares. Fijate: >>> from ticker import ticker >>> ticker('../Data/camion.csv', '../Data/mercadolog.csv', 'txt') Nombre Precio Volumen ---------- ---------- ---------- Caqui 796.73 96 Mandarina 12.12 1120 Lima 2659.37 222 Naranja 11.70 1040 Durazno 281.76 704 ... >>> ticker('../Data/camion.csv', '../Data/mercadolog.csv', 'csv') Nombre,Precio,Volumen Mandarina,14.19,1140 Naranja,9.37,1150 Durazno,280.56,872 Lima,2624.94,232 ... Discusi\u00f3n \u00bfQu\u00e9 aprendimos hoy? Si cre\u00e1s varias funciones generadoras y las pon\u00e9s \"en serie\" (una recibe los datos de la anterior) pod\u00e9s crear pipelines que controlen el flujo de datos: los procesen, modifiquen o filtren entre el primer generador y el \u00faltimo consumidor. Adem\u00e1s viste lo f\u00e1cil que es cambiar el comportamiento del programa cuando ten\u00e9s interfases bien definidas. Por supuesto, pod\u00e9s empaquetar un conjunto de etapas de procesamiento en una funci\u00f3n sola, si tiene sentido hacerlo. Contenidos | Anterior (3 Iteraci\u00f3n a medida) | Pr\u00f3ximo (5 M\u00e1s sobre generadores)","title":"04 Producers consumers"},{"location":"10_Generadores_e_Iteradores/04_Producers_consumers/#104-productores-consumidores-y-canerias","text":"Para esta secci\u00f3n hay un video introductorio . Los generadores son una herramienta muy \u00fatil para configurar pipelines (ca\u00f1er\u00edas). Este concepto requiere una breve aclaraci\u00f3n : Un pipeline tradicional en computaci\u00f3n consta de una serie de programas y archivos asociados que constituyen una estructura de procesamiento de datos, donde cada programa se ejecuta independientemente de los dem\u00e1s, pero juntos resultan en un flujo conveniente de datos a trav\u00e9s de los archivos asociados desde un \"productor\" (una c\u00e1mara, un sensor, un lector de c\u00f3digo de barras) hasta un \"consumidor\" (un graficador, un interruptor el\u00e9ctrico, un log de una p\u00e1gina web). Construiste un peque\u00f1o pipeline en la secci\u00f3n anterior, usando vigilante.py . En esta secci\u00f3n hablaremos de c\u00f3mo implementar estas estructuras de productores y consumidores de datos con generadores en Python.","title":"10.4 Productores, consumidores y ca\u00f1er\u00edas."},{"location":"10_Generadores_e_Iteradores/04_Producers_consumers/#sistemas-productor-consumidor","text":"El concepto de generadores est\u00e1 \u00edntimamente asociado a problemas de tipo productor-consumidor en sus varias formas. Fijate esta estructura, que es t\u00edpica de muchos programas: # Productor def vigilar(f): ... while True: ... yield linea # Produce/obtiene valores para \"linea\" ... # Consumidor for linea in vigilar(f): # Consume l\u00edneas del `yield` ... Los yield generan los datos que los for consumen.","title":"Sistemas productor-consumidor"},{"location":"10_Generadores_e_Iteradores/04_Producers_consumers/#pipelines-con-generadores","text":"Pod\u00e9s usar esta caracter\u00edstica de los generadores para constru\u00edr pipelines que procesen tus datos, un concepto que es muy usado en Unix (pipes) pero en Windows se usa menos. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor Los pipelines de procesamiento de datos tienen un productor al comienzo, una cadena de etapas de procesamiento y un consumidor al final. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def productor(): ... yield item ... El productor es en general un generador, aunque tambien podr\u00eda ser una lista o cualquier otra secuencia iterable. El yield alimenta al pipeline de datos. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def consumidor(s): for item in s: ... El consumidor es un ciclo for . Obtiene los elementos item y los usa para algo. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def procesamiento(s): for item in s: ... yield itemnuevo ... Las etapas intermedias de procesamiento simult\u00e1neamente consumen y producen datos, pueden alterar el flujo de datos, eliminar o modificar datos seg\u00fan su funci\u00f3n. productor \u2192 procesamiento \u2192 procesamiento \u2192 consumidor def productor(): ... yield item # yield devuelve un item que ser\u00e1 recibido por `procesamiento` ... def procesamiento(s): for item in s: # item viene del `productor` ... yield newitem # este yield devuelve un nuevo item ... def consumidor(s): for item in s: # item viene de `procesamiento` ... Vamos a constru\u00edr un pipeline con la siguiente arquitectura: a = productor() b = procesamiento(a) c = consumidor(b) Como te dar\u00e1s cuenta, los datos van pasando de una funci\u00f3n a la siguiente.","title":"Pipelines con generadores"},{"location":"10_Generadores_e_Iteradores/04_Producers_consumers/#ejercicios","text":"Para este ejercicio, necesit\u00e1s que el programa sim_mercado.py a\u00fan est\u00e9 corriendo. Vas a usar la funci\u00f3n vigilar() que escribiste en el Ejercicio 10.7","title":"Ejercicios"},{"location":"10_Generadores_e_Iteradores/04_Producers_consumers/#ejercicio-108-configuremos-un-pipeline-simple","text":"Escrib\u00ed la siguiente funci\u00f3n y veamos como funciona un pipeline. >>> def filematch(lines, substr): for line in lines: if substr in line: yield line >>> Esta funci\u00f3n es casi id\u00e9ntica al primer ejemplo de generador en el ejercicio anterior, salvo que ya no abre un archivo sino que opera directamente de una secuencia de l\u00edneas que recibe como argumento. Ahora prob\u00e1 lo siguiente: >>> lines = vigilar('../Data/mercadolog.csv') >>> naranjas = filematch(lines, 'Naranja') >>> for line in naranjas: print(line) ... esper\u00e1 que aparezca la salida ... Puede pasar que tarde unos segundos en darte una salida, pero vas a ver informaci\u00f3n sobre naranjas tan pronto como sean a\u00f1adidas al archivo por el primer generador.","title":"Ejercicio 10.8: Configuremos un pipeline simple"},{"location":"10_Generadores_e_Iteradores/04_Producers_consumers/#ejercicio-109-un-pipeline-mas-en-serio","text":"Llevemos esta idea un poco m\u00e1s lejos. Probemos esto: >>> from vigilante import vigilar >>> import csv >>> lineas = vigilar('../Data/mercadolog.csv') >>> filas = csv.reader(lineas) >>> for fila in filas: print(fila) ... ['Rabanito', ' 249.37', ' 357'] ['Batata', ' 15.75', ' 1040'] ['Rabanito', ' 211.31', ' 324'] ['Zuccini', ' 83.12', ' 612'] ... \u00a1Interesante! La salida de la funci\u00f3n vigilar() fu\u00e9 usada como entrada a la funci\u00f3n csv.reader() (que hab\u00edamos usado para leer un archivo del disco) y el resultado es una secuencia de filas \"parseadas\", separadas por las comas.","title":"Ejercicio 10.9: Un pipeline m\u00e1s en serio"},{"location":"10_Generadores_e_Iteradores/04_Producers_consumers/#ejercicio-1010-un-pipeline-mas-largo","text":"Veamos si podemos constru\u00edr un pipeline m\u00e1s largo basado en la misma idea. Cre\u00e1 un archivo nuevo llamado ticker.py , te lo vamos a pedir al final de la clase. Comenz\u00e1 creando una funci\u00f3n que lea un archivo CSV como hiciste antes: # ticker.py from vigilante import vigilar import csv def parsear_datos(lines): rows = csv.reader(lines) return rows if __name__ == '__main__': lines = vigilar('../Data/mercadolog.csv') rows = parsear_datos(lines) for row in rows: print(row) Escrib\u00ed una funci\u00f3n nueva que elija algunas columnas espec\u00edficas: # ticker.py ... def elegir_columnas(rows, indices): for row in rows: yield [row[index] for index in indices] ... def parsear_datos(lines): rows = csv.reader(lines) rows = elegir_columnas(rows, [0, 2]) return rows Probalo de nuevo. La salida ahora deber\u00eda estar restringida a esto: ['Br\u00f3coli', ' 388'] ['Ajo', ' 120'] ['Caqui', ' 108'] ['Mandarina', ' 1170'] ... Escrib\u00ed funciones generadoras que conviertan el tipo de datos a diccionarios: # ticker.py ... def cambiar_tipo(rows, types): for row in rows: yield [func(val) for func, val in zip(types, row)] def hace_dicts(rows, headers): for row in rows: yield dict(zip(headers, row)) def parsear_datos(lines): rows = csv.reader(lines) rows = elegir_columnas(rows, [0, 1, 2]) rows = cambiar_tipo(rows, [str, float, int]) rows = hace_dicts(rows, ['nombre', 'precio', 'volumen']) return rows ... Correlo de nuevo. Ahora la salida deber\u00eda ser una serie de diccionarios: {'nombre': 'Frutilla', 'precio': 276.81, 'volumen': 249.0} {'nombre': 'Morr\u00f3n', 'precio': 2988.42, 'volumen': 702.0} {'nombre': 'Morr\u00f3n', 'precio': 3108.63, 'volumen': 498.0} {'nombre': 'Naranja', 'precio': 11.5, 'volumen': 870.0} ...","title":"Ejercicio 10.10: Un pipeline m\u00e1s largo"},{"location":"10_Generadores_e_Iteradores/04_Producers_consumers/#ejercicio-1011-filtremos-los-datos","text":"Para seguir agregando procesamiento a nuestro pipeline, escrib\u00ed un filtro de datos: # ticker.py ... def filtrar_datos(filas, nombres): for fila in filas: if fila['nombre'] in nombres: yield fila Esto se usa para dejar pasar \u00fanicamente aquellos lotes incluidos en el cami\u00f3n. Probalo. import informe camion = informe.leer_camion('../Data/camion.csv') filas = parsear_datos(vigilar('../Data/mercadolog.csv')) filas = filtrar_datos(filas, camion) for fila in filas: print(fila)","title":"Ejercicio 10.11: Filtremos los datos"},{"location":"10_Generadores_e_Iteradores/04_Producers_consumers/#ejercicio-1012-el-pipeline-ensamblado","text":"En el programa ticker.py (esta versi\u00f3n te vamos a pedir que la entregues) escrib\u00ed una funci\u00f3n ticker(camion_file, log_file, fmt) que cree un indicador en tiempo real para un cami\u00f3n, archivo log, y formato de tabla de salida particulares. Fijate: >>> from ticker import ticker >>> ticker('../Data/camion.csv', '../Data/mercadolog.csv', 'txt') Nombre Precio Volumen ---------- ---------- ---------- Caqui 796.73 96 Mandarina 12.12 1120 Lima 2659.37 222 Naranja 11.70 1040 Durazno 281.76 704 ... >>> ticker('../Data/camion.csv', '../Data/mercadolog.csv', 'csv') Nombre,Precio,Volumen Mandarina,14.19,1140 Naranja,9.37,1150 Durazno,280.56,872 Lima,2624.94,232 ...","title":"Ejercicio 10.12: El pipeline ensamblado"},{"location":"10_Generadores_e_Iteradores/04_Producers_consumers/#discusion","text":"\u00bfQu\u00e9 aprendimos hoy? Si cre\u00e1s varias funciones generadoras y las pon\u00e9s \"en serie\" (una recibe los datos de la anterior) pod\u00e9s crear pipelines que controlen el flujo de datos: los procesen, modifiquen o filtren entre el primer generador y el \u00faltimo consumidor. Adem\u00e1s viste lo f\u00e1cil que es cambiar el comportamiento del programa cuando ten\u00e9s interfases bien definidas. Por supuesto, pod\u00e9s empaquetar un conjunto de etapas de procesamiento en una funci\u00f3n sola, si tiene sentido hacerlo. Contenidos | Anterior (3 Iteraci\u00f3n a medida) | Pr\u00f3ximo (5 M\u00e1s sobre generadores)","title":"Discusi\u00f3n"},{"location":"10_Generadores_e_Iteradores/05_Mas_generadores/","text":"Contenidos | Anterior (4 Productores, consumidores y ca\u00f1er\u00edas.) | Pr\u00f3ximo (6 Predador Presa) 10.5 M\u00e1s sobre generadores Esta secci\u00f3n introduce algunos temas adicionales relacionados con generadores, entre ellas: expresiones generadoras y el m\u00f3dulo itertools Expresiones generadoras Una expresi\u00f3n generadora es una lista por comprensi\u00f3n en su \"versi\u00f3n generadora\", que devuelve un elemento por vez. >>> a = [1,2,3,4] >>> b = (2*x for x in a) >>> b <generator object at 0x58760> >>> for i in b: ... print(i, end=' ') ... 2 4 6 8 >>> \u00bfCuales son las diferencias entre expresiones generadoras y comprensi\u00f3n de listas? Bueno, las expresiones generadoras ... No construyen una lista Son construidas para ser iteradas Una vez consumidas, no pueden ser reutilizadas. La sintaxis general es: (<expresi\u00f3n> for i in s if <condici\u00f3n>) Que puede leerse como .... el valor es <expresi\u00f3n> para cada elemento i perteneciente a s siempre y cuando <condici\u00f3n> se cumpla. Las pod\u00e9s usar como argumento de una funci\u00f3n. sum(x*x for x in a) Las pod\u00e9s usar en lugar de cualquier iterable. >>> a = [1,2,3,4] >>> b = (x*x for x in a) >>> c = (-x for x in b) >>> for i in c: ... print(i, end=' ') ... -1 -4 -9 -16 >>> El uso principal de las expresiones generadoras es en c\u00f3digo que realiza un c\u00f3mputo con una serie de elementos pero s\u00f3lo necesita cada elemento una \u00fanica vez. Ejemplo: quitar todas las l\u00edneas de un programa que sean comentarios: f = open('unarchivo.txt') lines = (line for line in f if not line.startswith('#')) for line in lines: ... f.close() Al usar generadores, tu c\u00f3digo ejecuta m\u00e1s r\u00e1pido y usa menos memoria. Se portan como un filtro en el flujo de datos por un pipeline. Motivos para usar generadores Muchos problemas se expresan mejor en t\u00e9rminos de iteraci\u00f3n. Recorrer una colecci\u00f3n de items para hacer alg\u00fan c\u00f3mputo (buscar, reemplazar, modificar, etc.). Los pipelines de procesamiento resuelven un amplio abanico de problemas. Son m\u00e1s eficientes en el uso de memoria. S\u00f3lo produc\u00eds valores cuando los necesit\u00e1s. Varias ventajas sobre construir una larga lista. Pueden operar sobre datos en pipelines. Un generador facilita la reutilizaci\u00f3n de c\u00f3digo. Separa la propia iteraci\u00f3n del c\u00f3digo que utiliza sus resultados. Pod\u00e9s construir tu propio conjunto de herramientas de iteraci\u00f3n y ensamblarlas como necesites en cada caso. El m\u00f3dulo itertools El m\u00f3dulo itertools es una biblioteca con varias funciones \u00fatiles para construir generadores e iteradores. itertools.chain(s1,s2) itertools.count(n) itertools.cycle(s) itertools.dropwhile(predicate, s) itertools.groupby(s) itertools.ifilter(predicate, s) itertools.imap(function, s1, ... sN) itertools.repeat(s, n) itertools.tee(s, ncopies) itertools.izip(s1, ... , sN) Todas estas funciones procesan datos iterativamente, e implementan distintos tipos de patrones de iteraci\u00f3n. Si quer\u00e9s profundizar m\u00e1s en estos conceptos, te recomendamos el curso que escribi\u00f3 Beazley hace unos a\u00f1os sobre Generadores e iteradores . Ejercicios En ejercicios anteriores escribiste c\u00f3digo que vigilaba un archivo log esperando l\u00edneas nuevas escritas al final y las presentaba como una secuencia de filas. Este ejercicio continua aquel, de modo que vas a necesitar que sim_mercado.py est\u00e9 ejecut\u00e1ndose. Acordate de pararlo cuando termines... agrega una l\u00ednea por segundo y eventualmente te va a llenar tu disco r\u00edgido. Ejercicio 10.13: Expresiones generadoras Fijate este ejemplo de una expresi\u00f3n generadora: >>> nums = [1, 2, 3, 4, 5] >>> cuadrados = (x*x for x in nums) >>> cuadrados <generator object <genexpr> at 0x109207e60> >>> for n in cuadrados: ... print(n) ... 1 4 9 16 25 A diferencia de una definici\u00f3n por comprensi\u00f3n de listas, una expresi\u00f3n generadora s\u00f3lo puede recorrerse una vez. Si intent\u00e1s recorrerla de nuevo con otro for , no obten\u00e9s nada. >>> for n in squares: ... print(n) ... >>> Ejercicio 10.14: Expresiones generadoras como argumentos en funciones. A veces es \u00fatil (y muy claro al leerlo) si pas\u00e1s una expresi\u00f3n generadora como argumento de una funci\u00f3n. A primera vista parece un poco raro, pero prob\u00e1 esto: >>> nums = [1,2,3,4,5] >>> sum([x*x for x in nums]) # una lista por comprensi\u00f3n 55 >>> sum(x*x for x in nums) # una expresi\u00f3n generadora 55 >>> En ese ejemplo, la segunda versi\u00f3n (que usa un generador) requerir\u00eda mucha menos memoria que si construyera toda la lista simult\u00e1neamente (si la lista fuera grande). En tu archivo camion.py hiciste algunos c\u00e1lculos usando comprensi\u00f3n de listas. Reemplaz\u00e1 esas expresiones por expresiones generadoras (pod\u00e9s entregar esta nueva versi\u00f3n del archivo o la anterior al final de la clase). Ejercicio 10.15: C\u00f3digo simple Las expresiones generadoras son a menudo un buen reemplazo para peque\u00f1as funciones generadoras. Por ejemplo, en lugar de escribir una funci\u00f3n como esta: def filtrar_datos(filas, nombres): for fila in filas: if fila['nombre'] in nombres: yield fila La podr\u00edas reemplazar con una expresi\u00f3n as\u00ed: filas = (fila for fila in filas if fila['nombre'] in nombres) Modific\u00e1 tu programa ticker.py para que use expresiones generadoras en lugar de funciones generadoras. Al final de la clase pod\u00e9s entregar el ticker.py anterior o este nuevo (\u00a1mejor el nuevo!). Ejercicio 10.16: Volviendo a ordenar im\u00e1genes Te proponemos aqu\u00ed que retomes el Ejercicio 8.5 que ten\u00e9s guardado en el archivo listar_imgs.py . Us\u00e1 los datos que te proporciona os.walk y una expresi\u00f3n generadora para filtrar las im\u00e1genes png (con sus directorios correspondientes). Este filtro deber\u00eda generar pares (directorio, archivo.png) M\u00e1s a\u00fan, opcionalmente dise\u00f1\u00e1 un generador que, dada la secuencia filtrada (directorios y archivos png), genere ternas consistentes de: ('viejo_dir/viejo_nombre', 'nuevo_dir/nuevo_nombre', fecha_a_setear) de manera que pueda ser f\u00e1cilmente usada por una funci\u00f3n para completar las tareas del Ejercicio 8.6 . Contenidos | Anterior (4 Productores, consumidores y ca\u00f1er\u00edas.) | Pr\u00f3ximo (6 Predador Presa)","title":"05 Mas generadores"},{"location":"10_Generadores_e_Iteradores/05_Mas_generadores/#105-mas-sobre-generadores","text":"Esta secci\u00f3n introduce algunos temas adicionales relacionados con generadores, entre ellas: expresiones generadoras y el m\u00f3dulo itertools","title":"10.5 M\u00e1s sobre generadores"},{"location":"10_Generadores_e_Iteradores/05_Mas_generadores/#expresiones-generadoras","text":"Una expresi\u00f3n generadora es una lista por comprensi\u00f3n en su \"versi\u00f3n generadora\", que devuelve un elemento por vez. >>> a = [1,2,3,4] >>> b = (2*x for x in a) >>> b <generator object at 0x58760> >>> for i in b: ... print(i, end=' ') ... 2 4 6 8 >>> \u00bfCuales son las diferencias entre expresiones generadoras y comprensi\u00f3n de listas? Bueno, las expresiones generadoras ... No construyen una lista Son construidas para ser iteradas Una vez consumidas, no pueden ser reutilizadas. La sintaxis general es: (<expresi\u00f3n> for i in s if <condici\u00f3n>) Que puede leerse como .... el valor es <expresi\u00f3n> para cada elemento i perteneciente a s siempre y cuando <condici\u00f3n> se cumpla. Las pod\u00e9s usar como argumento de una funci\u00f3n. sum(x*x for x in a) Las pod\u00e9s usar en lugar de cualquier iterable. >>> a = [1,2,3,4] >>> b = (x*x for x in a) >>> c = (-x for x in b) >>> for i in c: ... print(i, end=' ') ... -1 -4 -9 -16 >>> El uso principal de las expresiones generadoras es en c\u00f3digo que realiza un c\u00f3mputo con una serie de elementos pero s\u00f3lo necesita cada elemento una \u00fanica vez. Ejemplo: quitar todas las l\u00edneas de un programa que sean comentarios: f = open('unarchivo.txt') lines = (line for line in f if not line.startswith('#')) for line in lines: ... f.close() Al usar generadores, tu c\u00f3digo ejecuta m\u00e1s r\u00e1pido y usa menos memoria. Se portan como un filtro en el flujo de datos por un pipeline.","title":"Expresiones generadoras"},{"location":"10_Generadores_e_Iteradores/05_Mas_generadores/#motivos-para-usar-generadores","text":"Muchos problemas se expresan mejor en t\u00e9rminos de iteraci\u00f3n. Recorrer una colecci\u00f3n de items para hacer alg\u00fan c\u00f3mputo (buscar, reemplazar, modificar, etc.). Los pipelines de procesamiento resuelven un amplio abanico de problemas. Son m\u00e1s eficientes en el uso de memoria. S\u00f3lo produc\u00eds valores cuando los necesit\u00e1s. Varias ventajas sobre construir una larga lista. Pueden operar sobre datos en pipelines. Un generador facilita la reutilizaci\u00f3n de c\u00f3digo. Separa la propia iteraci\u00f3n del c\u00f3digo que utiliza sus resultados. Pod\u00e9s construir tu propio conjunto de herramientas de iteraci\u00f3n y ensamblarlas como necesites en cada caso.","title":"Motivos para usar generadores"},{"location":"10_Generadores_e_Iteradores/05_Mas_generadores/#el-modulo-itertools","text":"El m\u00f3dulo itertools es una biblioteca con varias funciones \u00fatiles para construir generadores e iteradores. itertools.chain(s1,s2) itertools.count(n) itertools.cycle(s) itertools.dropwhile(predicate, s) itertools.groupby(s) itertools.ifilter(predicate, s) itertools.imap(function, s1, ... sN) itertools.repeat(s, n) itertools.tee(s, ncopies) itertools.izip(s1, ... , sN) Todas estas funciones procesan datos iterativamente, e implementan distintos tipos de patrones de iteraci\u00f3n. Si quer\u00e9s profundizar m\u00e1s en estos conceptos, te recomendamos el curso que escribi\u00f3 Beazley hace unos a\u00f1os sobre Generadores e iteradores .","title":"El m\u00f3dulo itertools"},{"location":"10_Generadores_e_Iteradores/05_Mas_generadores/#ejercicios","text":"En ejercicios anteriores escribiste c\u00f3digo que vigilaba un archivo log esperando l\u00edneas nuevas escritas al final y las presentaba como una secuencia de filas. Este ejercicio continua aquel, de modo que vas a necesitar que sim_mercado.py est\u00e9 ejecut\u00e1ndose. Acordate de pararlo cuando termines... agrega una l\u00ednea por segundo y eventualmente te va a llenar tu disco r\u00edgido.","title":"Ejercicios"},{"location":"10_Generadores_e_Iteradores/05_Mas_generadores/#ejercicio-1013-expresiones-generadoras","text":"Fijate este ejemplo de una expresi\u00f3n generadora: >>> nums = [1, 2, 3, 4, 5] >>> cuadrados = (x*x for x in nums) >>> cuadrados <generator object <genexpr> at 0x109207e60> >>> for n in cuadrados: ... print(n) ... 1 4 9 16 25 A diferencia de una definici\u00f3n por comprensi\u00f3n de listas, una expresi\u00f3n generadora s\u00f3lo puede recorrerse una vez. Si intent\u00e1s recorrerla de nuevo con otro for , no obten\u00e9s nada. >>> for n in squares: ... print(n) ... >>>","title":"Ejercicio 10.13: Expresiones generadoras"},{"location":"10_Generadores_e_Iteradores/05_Mas_generadores/#ejercicio-1014-expresiones-generadoras-como-argumentos-en-funciones","text":"A veces es \u00fatil (y muy claro al leerlo) si pas\u00e1s una expresi\u00f3n generadora como argumento de una funci\u00f3n. A primera vista parece un poco raro, pero prob\u00e1 esto: >>> nums = [1,2,3,4,5] >>> sum([x*x for x in nums]) # una lista por comprensi\u00f3n 55 >>> sum(x*x for x in nums) # una expresi\u00f3n generadora 55 >>> En ese ejemplo, la segunda versi\u00f3n (que usa un generador) requerir\u00eda mucha menos memoria que si construyera toda la lista simult\u00e1neamente (si la lista fuera grande). En tu archivo camion.py hiciste algunos c\u00e1lculos usando comprensi\u00f3n de listas. Reemplaz\u00e1 esas expresiones por expresiones generadoras (pod\u00e9s entregar esta nueva versi\u00f3n del archivo o la anterior al final de la clase).","title":"Ejercicio 10.14: Expresiones generadoras como argumentos en funciones."},{"location":"10_Generadores_e_Iteradores/05_Mas_generadores/#ejercicio-1015-codigo-simple","text":"Las expresiones generadoras son a menudo un buen reemplazo para peque\u00f1as funciones generadoras. Por ejemplo, en lugar de escribir una funci\u00f3n como esta: def filtrar_datos(filas, nombres): for fila in filas: if fila['nombre'] in nombres: yield fila La podr\u00edas reemplazar con una expresi\u00f3n as\u00ed: filas = (fila for fila in filas if fila['nombre'] in nombres) Modific\u00e1 tu programa ticker.py para que use expresiones generadoras en lugar de funciones generadoras. Al final de la clase pod\u00e9s entregar el ticker.py anterior o este nuevo (\u00a1mejor el nuevo!).","title":"Ejercicio 10.15: C\u00f3digo simple"},{"location":"10_Generadores_e_Iteradores/05_Mas_generadores/#ejercicio-1016-volviendo-a-ordenar-imagenes","text":"Te proponemos aqu\u00ed que retomes el Ejercicio 8.5 que ten\u00e9s guardado en el archivo listar_imgs.py . Us\u00e1 los datos que te proporciona os.walk y una expresi\u00f3n generadora para filtrar las im\u00e1genes png (con sus directorios correspondientes). Este filtro deber\u00eda generar pares (directorio, archivo.png) M\u00e1s a\u00fan, opcionalmente dise\u00f1\u00e1 un generador que, dada la secuencia filtrada (directorios y archivos png), genere ternas consistentes de: ('viejo_dir/viejo_nombre', 'nuevo_dir/nuevo_nombre', fecha_a_setear) de manera que pueda ser f\u00e1cilmente usada por una funci\u00f3n para completar las tareas del Ejercicio 8.6 . Contenidos | Anterior (4 Productores, consumidores y ca\u00f1er\u00edas.) | Pr\u00f3ximo (6 Predador Presa)","title":"Ejercicio 10.16: Volviendo a ordenar im\u00e1genes"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/","text":"Contenidos | Anterior (5 M\u00e1s sobre generadores) | Pr\u00f3ximo (7 Cierre de la clase) 10.6 Predador Presa En este video introducimos el tema de esta secci\u00f3n. Los modelos de depredaci\u00f3n y competencia forman parte de la bater\u00eda de herramientas cl\u00e1sicas del ec\u00f3logo. Vito Volterra en Italia y Alfred Lotka en Estados Unidos fueron los precursores en este tema y crearon modelos que, con diversas modificaciones y mejoras, seguimos usando hoy en d\u00eda. El modelo de Volterra para depredaci\u00f3n comienza suponiendo la existencia de dos poblaciones de animales, una de las cuales (el depredador) se alimenta de la otra (la presa). Se supone que las dos poblaciones est\u00e1n formadas por individuos id\u00e9nticos, mezclados en el espacio. La gran mayor\u00eda de los modelos usualmente estudiados tienen solamente en cuenta la din\u00e1mica temporal, desatendiendo la din\u00e1mica espacial. Con la excusa de implementar una versi\u00f3n espacio-temporal de este modelo, proponemos un ejercicio guiado que usa fuertemente programaci\u00f3n orientada a objetos. Lo que sigue es un ejercicio optativo. Como dec\u00edamos, el ejercicio est\u00e1 muy guiado y toda la estructura del modelo est\u00e1 basada en objetos. La idea es recrear un mundo que imaginaremos como un valle rodeado de monta\u00f1as en el que existen depredadores (que llamaremos Leones) y presas (que llamaremos Ant\u00edlopes). Este valle ser\u00e1 bidimensional, y lo representaremos por medio de una grilla rectangular que llamaremos tablero. El modelo inicial con el que trabajaremos tiene definidas 4 etapas que determinan un ciclo: Etapa de movimiento : en esta etapa cada animal se desplaza a alguna posici\u00f3n vecina desocupada (si es que existe, sino permanece en el lugar). La decisi\u00f3n de a cu\u00e1l desplazarse ser\u00e1 responsabilidad del animal, que, sabiendo las disponibles, elegir\u00e1 una al azar. Etapa de alimentaci\u00f3n : en esta etapa los animales se alimentan. Los ant\u00edlopes comer\u00e1n pasto en su lugar, mientras que los leones buscar\u00e1n un ant\u00edlope en las posiciones vecinas y, de existir, se lo comer\u00e1n. Esta acci\u00f3n de un le\u00f3n se ver\u00e1 reflejada en el tablero con su desplazamiento a la posici\u00f3n del ant\u00edlope, el cual ya no ser\u00e1 m\u00e1s parte de nuestro mundo. Etapa de reproducci\u00f3n : cada animal buscar\u00e1 en sus posiciones vecinas alguien de su misma especie. Si lo encuentra y adem\u00e1s hay una posici\u00f3n vac\u00eda en el tablero se incluir\u00e1 un nuevo animal (de la misma especie) en el tablero. Nuevamente la elecci\u00f3n de la pareja y del lugar del nuevo animal ser\u00e1n aleatorias. Este modelo inicial no prevee el atributo sexo, ni un l\u00edmite entre la cantidad reproducciones en las que puede participar un animal por etapa. Cierre de ciclo : en la \u00faltima etapa de un ciclo todos los animales \"envejecen\" en 1 unidad, aquellos que se reprodujeron y siguen en edad reproductiva vuelven a ser f\u00e9rtiles. Si alguno alcanz\u00f3 la edad m\u00e1xima de su especie se considera que ya puede retir\u00e1rselo del mundo (es decir, se muere). Sucede lo mismo si, al pasar una etapa, alcanza el l\u00edmite de etapas sin alimentarse, en cuyo caso muere de hambre. Clases del modelo inicial: El modelo inicial te lo pod\u00e9s bajar de ac\u00e1 . Ya tiene definidas la clase Animal de la que heredan dos nuevas clases: Le\u00f3n y Ant\u00edlope . Tambi\u00e9n tiene definida una clase Tablero . Todas estas clases se integran en una clase Mundo . Vamos a ver una por una estas clases y te indicaremos algunos m\u00e9todos faltantes que tendr\u00e1s que implementar vos y otros que te proponemos mejorar. Animales Esta clase est\u00e1 definida en el archivo animal.py . La clase Animal ser\u00e1 una clase abstracta, de la cual heredar\u00e1n la clase Le\u00f3n y la clase Ant\u00edlope. Los m\u00e9todos y atributos comunes que representen a un animal deber\u00e1n estar en esta clase. Constructor El constructor no recibe par\u00e1metros, s\u00f3lo instancia los atributos iniciales. En esta documentaci\u00f3n se instancian algunos. def __init__(self): super(Animal, self).__init__() self.edad = 0 self.energia = self.energia_maxima # cantidad de ciclos que aguanta sin alimentarse Consultas A continuaci\u00f3n se muestran los m\u00e9todos para obtener informaci\u00f3n del animal. Es importante notar que un animal en s\u00ed, no es ni Le\u00f3n ni Ant\u00edlope, por eso ambas preguntas devuelven False . Estos m\u00e9todos definen a su vez el comportamiento, no siendo unicamente una observaci\u00f3n de las variables, sino que definen que un animal est\u00e1 vivo \u00fanicamente si no alcanz\u00f3 la edad m\u00e1xima y adem\u00e1s no pas\u00f3 el l\u00edmite de tiempo que puede estar sin alimentarse. Lo mismo sucede con tiene_hambre que podr\u00eda modificarse para que un animal que ya se aliment\u00f3 no necesite alimentarse instant\u00e1neamente. Se pueden agregar m\u00e9todos como puede_tener_cria y cualquier otra consulta que sea pertinente para un animal. def en_vida(self): return (self.edad <= self.edad_maxima) and self.energia > 0 def tiene_hambre(self): \"\"\"Ac\u00e1 se puede poner comportamiento para que no tenga hambre todo el tiempo deber\u00eda depender de la diferencia entre su nivel de energ\u00eda y su energ\u00eda m\u00e1xima\"\"\" return True def es_leon(self): return False def es_antilope(self): return False Modificadores A continuaci\u00f3n presentamos algunos m\u00e9todos modificadores del objeto. def pasar_un_ciclo(self): self.energia -= 1 # consume energ\u00eda self.edad += 1 # envejece if self.edad >= 2 and self.reproducciones_pendientes > 0: self.es_reproductore = True #se puede reproducir def tener_cria(self): \"\"\"Ac\u00e1 se puede poner comportamiento que sucede al tener cria y que evita que tengas m\u00e1s de una cria por ciclo, \u00bfquizas tener_cria consume m\u00e1s energ\u00eda que un ciclo com\u00fan?\"\"\" pass def alimentarse(self, animales_vecinos = None): self.energia = self.energia_maxima return None def reproducirse(self, vecinos, lugares_libres): pos = None if vecinos: pareja = random.choice(vecinos) if lugares_libres: self.tener_cria() pareja.tener_cria() pos = random.choice(lugares_libres) return pos def moverse(self, lugares_libres): pos = None if lugares_libres: pos = random.choice(lugares_libres) return pos Le\u00f3n Al heredar de Animal , la clase Leon es peque\u00f1a: class Leon(Animal): Todas los m\u00e9todos y atributos definidos all\u00ed est\u00e1n disponibles. Se hace un override del metodo es_leon para aclarar que en este caso S\u00cd es un le\u00f3n. Y como el le\u00f3n es carn\u00edvoro, tambi\u00e9n se extiende el m\u00e9todo alimentarse que s\u00f3lo sucede cuando puede comer. def __init__(self): super(Leon, self).__init__() self.autonomia = 3 self.edad_maxima = 5 def es_leon(self): return True def alimentarse(self, animales_vecinos): # Se alimenta si puede e indica la posici\u00f3n del animal que se pudo comer pos = None if self.tiene_hambre(): # no est\u00e1 lleno presas_cercanas = [ (pos,animal) for (pos, animal) in animales_vecinos if animal.es_antilope() ] if presas_cercanas: # y hay presas cerca super(Leon, self).alimentarse() (pos, animal) = random.choice(presas_cercanas) return pos Ejemplo: Un Le\u00f3n Prob\u00e1 las siguientes instrucciones: L = Leon() L.energia L.edad L.es_leon() L.es_antilope() L.pasar_un_ciclo() L.energia L.edad L.tiene_hambre() Ant\u00edlope La clase Antilope es m\u00e1s peque\u00f1a a\u00fan y unicamente indica que es un Ant\u00edlope. Ac\u00e1 se asume fuertemente que el ant\u00edlope come pasto y que pasto hay siempre. def __init__(self): self.autonomia = 8 self.edad_maxima = 8 super(Antilope, self).__init__() def es_antilope(self): return True Ejemplo: Un Le\u00f3n y dos Ant\u00edlopes Agreg\u00e1 ahora dos ant\u00edlopes: A1 = Antilope() A2 = Antilope() A1.energia A1.edad A1.es_antilope() Y hac\u00e9 que el Le\u00f3n, que ya tiene hambre, se coma alguno de los dos ant\u00edlopes (aleatoriamente): vecinos = [(1,A1),(2,A2)] pos = L.alimentarse(vecinos) if pos: print(f'El le\u00f3n se come al ant\u00edlope A{pos}') else: print(f'El le\u00f3n no come') Fijate que el m\u00e9todo alimentarse no mata al ant\u00edlope, solo devuelve su posici\u00f3n. Alguien m\u00e1s deber\u00e1 ocuparse de retirarlo del mundo. Si corr\u00e9s este c\u00f3digo varias veces, vas a ver que el Le\u00f3n obtiene energ\u00eda m\u00e1xima al comer, pero sigue comiendo. Implement\u00e1 adecuadamente el m\u00e9todo tiene_hambre() de la clase Animal de manera que solo tenga hambre cuando su energ\u00eda baje. Volv\u00e9 a probar el c\u00f3digo. El le\u00f3n deber\u00eda comer solo cuando pase al menos un ciclo desde la \u00faltima vez que comi\u00f3. Ejemplo: Un Le\u00f3n y una Leona Definamos ahora una leona M y hagamos que pasen unos ciclos hasta que sea reproductora. M = Leon() M.puede_reproducir() M.pasar_un_ciclo() M.puede_reproducir() Repet\u00ed hasta que L y M sean reproductores. Luego ponelos cerca. Digamos que M tiene como vecinos a los dos ant\u00edlopes y al le\u00f3n L de antes. Supongamos que las crias pueden ocupar algunos lugares libres en nuestro mundo (a\u00fan no definido): vecinos = [L] lugares_libres = [4,5,6,7,8] L.puede_reproducir() M.puede_reproducir() Est\u00e1n dadas las condiciones, que se reproduzcan: pos = M.reproducirse(vecinos, lugares_libres) print(f'nace un nuevo leoncito en la posici\u00f3n {pos}') M.puede_reproducir() M.pasar_un_ciclo() M.puede_reproducir() Vemos que el m\u00e9todo reproducirse nos devuelve una de las posiciones que le dijimos que estaban libres y que los leones no pueden volverse a reproducir en el mismo ciclo pero s\u00ed en el siguiente. Pasemos ahora a ver c\u00f3mo se estructura el tablero. El tablero Constructor La clase tablero tendr\u00e1 un \u00fanico constructor que recibir\u00e1 los atributos que dar\u00e1n lugar al tablero del tama\u00f1o deseado: def __init__(self, filas, columnas): super(Tablero, self).__init__() self.filas = filas self.columnas = columnas self.posiciones = {} self.n_posiciones_libres = self.filas * self.columnas Esta clase tendr\u00e1 4 atributos: el n\u00famero de filas, el de columnas, un diccionario donde se almacenar\u00e1 el contenido, y la cantidad de celdas vac\u00edas. El diccionario tendr\u00e1 unicamente las posiciones con alg\u00fan contenido. La cantidad de celdas vac\u00edas es un atributo que podr\u00eda calcularse a partir de los 3 primeros atributos, pero se decidi\u00f3 tenerlo precalculado por ser un valor que se usar\u00e1 mucho. Modificadores El tablero no tiene una gran complejidad, permite ser modificado de 2 maneras: ubicar un elemento en el tablero, y retirar un elemento del tablero. Se provee adem\u00e1s de la funcionalidad que combina estas cosas bajo el nombre de mover (cambia de lugar un elemento). def ubicar(self, pos, elem): if not self.ocupada(pos): self.n_posiciones_libres -= 1 self.posiciones[pos] = elem return pos in self.posiciones def retirar(self, pos): self.n_posiciones_libres += 1 return self.posiciones.pop(pos) def mover(self, p_origen, p_destino): self.ubicar(p_destino, self.retirar(p_origen)) Getters Adem\u00e1s la clase tablero provee m\u00e9todos para consultar sobre estado de posiciones y los valores que se encuentran en el tablero. def posicion(self, pos): #devuele qu\u00e9 hay en pos return self.posiciones[pos] def ocupada(self, pos): return pos in self.posiciones def libre(self, pos): return pos not in self.posiciones def elementos(self): return list(self.posiciones.values()) def hay_posiciones_libres(self): return self.n_posiciones_libres > 0 Modificadores complejos Una de las funcionalidades deseables para que se pueda usar un tablero, es la posibilidad de ubicar al azar un elemento en alg\u00fan lugar del mismo (que est\u00e9 libre). El tablero provee esa funcionalidad: def ubicar_en_posicion_vacia(self, elem): if not self.hay_posiciones_libres(): raise RuntimeError(\"Est\u00e1s intentado agregar algo al tablero y est\u00e1 lleno\") pos = choice(self.posiciones_libres()) self.ubicar(pos, elem) Consultas Tambi\u00e9n ofrece consultas m\u00e1s complejas: def posiciones_ocupadas(self): res = [] for f in range(self.filas): for c in range(self.columnas): if self.ocupada((f,c)): res.append((f,c)) return res def posiciones_libres(self): res = [] for f in range(self.filas): for c in range(self.columnas): if self.libre((f,c)): res.append((f,c)) return res def posiciones_vecinas_libre(self, pos): res = self.posiciones_vecinas(pos) res = [ p for p in res if self.libre(p)] return res def posiciones_vecinas_con_ocupantes(self, pos): res = self.posiciones_vecinas(pos) res = [ (p, self.posicion(p)) for p in res if self.ocupada(p)] return res Auxiliares El m\u00e9todo posiciones_vecinas es el que define la topolog\u00eda del terreno. En este caso, una celda tiene como vecinos a las 8 celdas con las que comparte un borde o un v\u00e9rtice (excepto en los bordes). Es posible modificar la din\u00e1mica del mundo modificando esta funci\u00f3n (por ejemplo, hacerlo cil\u00edndrico, esf\u00e9rico o toroidal). def posiciones_vecinas(self, pos): desp=[(-1, -1), (-1, 0), (-1, 1),(0, 1), (1, 1), (1, 0),(1, -1), (0, -1)] for i in range(len(desp)): f = (desp[i][0] + pos[0]) c = (desp[i][1] + pos[1]) desp[i] = (f, c) desp = [ (f,c) for f,c in desp if (0<=f and f<self.filas) and (0<=c and c<self.columnas) ] return desp Se pueden definir como adyacentes s\u00f3lo las que compartan un borde, o las que est\u00e9n a 2 celdas de distancia, incluso es posible definir que en el borde del tablero vuelva a empezar del otro lado (condiciones peri\u00f3dicas). El mundo El mundo ser\u00e1 el encargado de hacer un tablero que usar\u00e1 de soporte, llenarlo de animales y ordenarlos para que se comporten de cierta forma en cada etapa que se implemente. Constructor En el constructor se define el tama\u00f1o del mundo, la cantidad inicial de Leones y Ant\u00edlopes, tiene la opci\u00f3n de que imprima informaci\u00f3n de lo que va sucediendo con el par\u00e1metro debug . def __init__(self, columnas, filas, n_leones, n_antilopes, debug=False): super(Mundo, self).__init__() self.debug = debug self.ciclo = 0 self.tablero = Tablero(filas, columnas) self.llenar_mundo(n_leones, n_antilopes) El constructor delega la tarea de llenar el tablero al m\u00e9todo llenar_mundo : def llenar_mundo(self, n_leones, n_antilopes): for _ in range(n_leones): if self.tablero.hay_posiciones_libres(): print_debug(\"ubicando un leon\", self.debug) self.tablero.ubicar_en_posicion_vacia(Leon()) for _ in range(n_antilopes): if self.tablero.hay_posiciones_libres(): print_debug(\"ubicando un Antilope\", self.debug) self.tablero.ubicar_en_posicion_vacia(Antilope()) Modelado de la din\u00e1mica En la etapa de movimiento, para cada posici\u00f3n ocupada del tablero, se indican cuales son sus vecinos libres y se lo manda a moverse, en caso de que el animal responda con una posici\u00f3n, se lo mueve a la posici\u00f3n indicada. def etapa_movimiento(self): print_debug(f\"Iniciando Movimiento en ciclo {self.ciclo}\", self.debug) for p in self.tablero.posiciones_ocupadas(): animal = self.tablero.posicion(p) posiciones_libres = self.tablero.posiciones_vecinas_libre(p) nueva_posicion = animal.moverse(posiciones_libres) if nueva_posicion: self.tablero.mover(p, nueva_posicion) En la etapa de alimentaci\u00f3n, es similar a la anterior, salvo que se indican cuales son sus vecinos ocupados y se los manda a alimentarse, en caso de que el animal responda con una posici\u00f3n, se lo mueve a la posici\u00f3n indicada. def etapa_alimentacion(self): print_debug(f\"Iniciando Alimentaci\u00f3n en ciclo {self.ciclo}\", self.debug) for p in self.tablero.posiciones_ocupadas(): animal = self.tablero.posicion(p) animales_cercanos = self.tablero.posiciones_vecinas_con_ocupantes(p) desplazo = animal.alimentarse(animales_cercanos) if desplazo: self.tablero.ubicar(desplazo, self.tablero.retirar(p)) La etapa de reproducci\u00f3n no est\u00e1 implementada. M\u00e1s adelante te pediremos que la implementes. Se deben pasar los animales vecinos. En este punto se debe realizar una importante decisi\u00f3n de modelado. \u00bfQui\u00e9n es el encargado de que s\u00f3lo se apareen animales de la misma especie? \u00bfEl mundo?\u00bfO cada animal? En base a esto se deber\u00e1 quiz\u00e1s modificar c\u00f3digo existente. def etapa_reproduccion(self): print_debug(f\"Iniciando Reproducci\u00f3n en ciclo {self.ciclo}\", self.debug) pass Finalmente el m\u00e9todo que cierra un ciclo haciendo que todos los animales cumplan a\u00f1os, gasten energ\u00eda y retirando los que ya no est\u00e1n con vida. def cerrar_un_ciclo(self): print_debug(f\"Concluyendo ciclo {self.ciclo}\", self.debug) for p in self.tablero.posiciones_ocupadas(): animal = self.tablero.posicion(p) animal.pasar_un_ciclo() #envejecer, consumir alimento if not animal.en_vida(): self.tablero.retirar(p) self.ciclo += 1 Los 4 m\u00e9todos est\u00e1n para ser llamados todos juntos con: def pasar_un_ciclo(self): self.etapa_movimiento() self.etapa_alimentacion() self.etapa_reproduccion() self.cerrar_un_ciclo() Probando el modelo completo Una forma para probar el funcionamiento es tener el siguiente c\u00f3digo que corre el mundo varias veces con una pausa de tiempo para poder verlo. m = Mundo(12, 6, 5, 15, debug=True) import time for i in range(20): m.pasar_un_ciclo() time.sleep(2) print(i +1) print(m) Para empezar a explorar m\u00e1s en serio el modelo deber\u00edas completar los m\u00e9todos que est\u00e9n indicados con pass y otros detalles, seg\u00fan te indicamos en los siguientes ejercicios. Agreg\u00e1 adem\u00e1s cualquier m\u00e9todo que consideres necesario para obtener informaci\u00f3n, o modelar alg\u00fan comportamiento. Ejercicio 10.17: Etapa de reproducci\u00f3n Implement\u00e1 el m\u00e9todo etapa_reproduccion en la clase Mundo . Ejercicio 10.18: Acotando la reproducci\u00f3n Implement\u00e1 la l\u00f3gica necesaria para que los animales pueden reproducirse \u00fanicamente una vez por a\u00f1o (ya sean los que inician la reproducci\u00f3n o los que son compa\u00f1eres). Ejercicio 10.19: Alcanzando la madurez Implement\u00e1 la l\u00f3gica necesaria para que un animal s\u00f3lo puede reproducirse cuando ya tiene 2 a\u00f1os cumplidos. Si llegaste hasta ac\u00e1, por favor guard\u00e1 todo junto en un solo archivo simulacion.py y entregalo al finalizar la clase. Una vez realizado esto hay diversas opciones para usarlo y expandirlo. Extensiones del modelo A continuaci\u00f3n una lista no exhaustiva de las extensiones posibles al modelo, pod\u00e9s incorporar algunas, o todas: Ning\u00fan animal se alimenta m\u00e1s de una vez en una etapa. Modifi\u0107a el m\u00e9todo tiene_hambre() de la clase Animal para que no siempre tenga hambre. Si un animal se alimenta en una etapa, no necesita alimentarse m\u00e1s por un turno entero. Cuando un Le\u00f3n ataca un Ant\u00edlope, no siempre se lo come, a veces el Ant\u00edlope logra escapar. Modelar esto con 3 posibles escenarios: Existe una probabilidad p (fija), de que el Le\u00f3n tenga \u00e9xito (con el m\u00f3dulo random se puede hacer random.random() > p ) La probabilidad es variable dependiendo de la edad del Le\u00f3n, siendo muy baja cuando es cachorro, alta cuando es adulto, y baja de nuevo en su vejez. La probabilidad es variable dependiendo de la edad del Le\u00f3n, igual al anterior, y la edad del Ant\u00edlope, siendo la probabilidad de que escape muy baja cuando es cachorro, alta cuando es adulto, y baja de nuevo en su vejez. Una forma de calcular esto es: Se puede hacer uso de los vecinos para modificar esta probabilidad, entonces si los Ant\u00edlopes est\u00e1n en manada, que la probabilidad de comer del Le\u00f3n sea m\u00e1s baja a\u00fan. Extender la vecindad a un radio de 2 para todos los animales. Extender la vecindad para distinto radio dependiendo la especie. Que el Ant\u00edlope pueda visualizar Leones a cierta distancia (ej. radio 3), y desplazarse en otra direcci\u00f3n. Exploraciones Analizar distintos valores para la construcci\u00f3n del mundo a lo largo del tiempo. \u00bfEs posible encontrar un equilibrio entre la cantidad de leones y ant\u00edlopes? \u00bfQu\u00e9 sucede con la supervivencia si se modifican los atributos propios de la clase Le\u00f3n y Ant\u00edlope de manera de que tengan mayor (o menor) autonom\u00eda, o sean m\u00e1s longevos? \u00bfSe detectan ciclos de mayor\u00eda de una especie y despu\u00e9s de la otra?\u00bfHay dominaci\u00f3n? Contenidos | Anterior (5 M\u00e1s sobre generadores) | Pr\u00f3ximo (7 Cierre de la clase)","title":"06 PredadorPresa"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#106-predador-presa","text":"En este video introducimos el tema de esta secci\u00f3n. Los modelos de depredaci\u00f3n y competencia forman parte de la bater\u00eda de herramientas cl\u00e1sicas del ec\u00f3logo. Vito Volterra en Italia y Alfred Lotka en Estados Unidos fueron los precursores en este tema y crearon modelos que, con diversas modificaciones y mejoras, seguimos usando hoy en d\u00eda. El modelo de Volterra para depredaci\u00f3n comienza suponiendo la existencia de dos poblaciones de animales, una de las cuales (el depredador) se alimenta de la otra (la presa). Se supone que las dos poblaciones est\u00e1n formadas por individuos id\u00e9nticos, mezclados en el espacio. La gran mayor\u00eda de los modelos usualmente estudiados tienen solamente en cuenta la din\u00e1mica temporal, desatendiendo la din\u00e1mica espacial. Con la excusa de implementar una versi\u00f3n espacio-temporal de este modelo, proponemos un ejercicio guiado que usa fuertemente programaci\u00f3n orientada a objetos. Lo que sigue es un ejercicio optativo. Como dec\u00edamos, el ejercicio est\u00e1 muy guiado y toda la estructura del modelo est\u00e1 basada en objetos. La idea es recrear un mundo que imaginaremos como un valle rodeado de monta\u00f1as en el que existen depredadores (que llamaremos Leones) y presas (que llamaremos Ant\u00edlopes). Este valle ser\u00e1 bidimensional, y lo representaremos por medio de una grilla rectangular que llamaremos tablero. El modelo inicial con el que trabajaremos tiene definidas 4 etapas que determinan un ciclo: Etapa de movimiento : en esta etapa cada animal se desplaza a alguna posici\u00f3n vecina desocupada (si es que existe, sino permanece en el lugar). La decisi\u00f3n de a cu\u00e1l desplazarse ser\u00e1 responsabilidad del animal, que, sabiendo las disponibles, elegir\u00e1 una al azar. Etapa de alimentaci\u00f3n : en esta etapa los animales se alimentan. Los ant\u00edlopes comer\u00e1n pasto en su lugar, mientras que los leones buscar\u00e1n un ant\u00edlope en las posiciones vecinas y, de existir, se lo comer\u00e1n. Esta acci\u00f3n de un le\u00f3n se ver\u00e1 reflejada en el tablero con su desplazamiento a la posici\u00f3n del ant\u00edlope, el cual ya no ser\u00e1 m\u00e1s parte de nuestro mundo. Etapa de reproducci\u00f3n : cada animal buscar\u00e1 en sus posiciones vecinas alguien de su misma especie. Si lo encuentra y adem\u00e1s hay una posici\u00f3n vac\u00eda en el tablero se incluir\u00e1 un nuevo animal (de la misma especie) en el tablero. Nuevamente la elecci\u00f3n de la pareja y del lugar del nuevo animal ser\u00e1n aleatorias. Este modelo inicial no prevee el atributo sexo, ni un l\u00edmite entre la cantidad reproducciones en las que puede participar un animal por etapa. Cierre de ciclo : en la \u00faltima etapa de un ciclo todos los animales \"envejecen\" en 1 unidad, aquellos que se reprodujeron y siguen en edad reproductiva vuelven a ser f\u00e9rtiles. Si alguno alcanz\u00f3 la edad m\u00e1xima de su especie se considera que ya puede retir\u00e1rselo del mundo (es decir, se muere). Sucede lo mismo si, al pasar una etapa, alcanza el l\u00edmite de etapas sin alimentarse, en cuyo caso muere de hambre.","title":"10.6 Predador Presa"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#clases-del-modelo-inicial","text":"El modelo inicial te lo pod\u00e9s bajar de ac\u00e1 . Ya tiene definidas la clase Animal de la que heredan dos nuevas clases: Le\u00f3n y Ant\u00edlope . Tambi\u00e9n tiene definida una clase Tablero . Todas estas clases se integran en una clase Mundo . Vamos a ver una por una estas clases y te indicaremos algunos m\u00e9todos faltantes que tendr\u00e1s que implementar vos y otros que te proponemos mejorar.","title":"Clases del modelo inicial:"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#animales","text":"Esta clase est\u00e1 definida en el archivo animal.py . La clase Animal ser\u00e1 una clase abstracta, de la cual heredar\u00e1n la clase Le\u00f3n y la clase Ant\u00edlope. Los m\u00e9todos y atributos comunes que representen a un animal deber\u00e1n estar en esta clase.","title":"Animales"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#constructor","text":"El constructor no recibe par\u00e1metros, s\u00f3lo instancia los atributos iniciales. En esta documentaci\u00f3n se instancian algunos. def __init__(self): super(Animal, self).__init__() self.edad = 0 self.energia = self.energia_maxima # cantidad de ciclos que aguanta sin alimentarse","title":"Constructor"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#consultas","text":"A continuaci\u00f3n se muestran los m\u00e9todos para obtener informaci\u00f3n del animal. Es importante notar que un animal en s\u00ed, no es ni Le\u00f3n ni Ant\u00edlope, por eso ambas preguntas devuelven False . Estos m\u00e9todos definen a su vez el comportamiento, no siendo unicamente una observaci\u00f3n de las variables, sino que definen que un animal est\u00e1 vivo \u00fanicamente si no alcanz\u00f3 la edad m\u00e1xima y adem\u00e1s no pas\u00f3 el l\u00edmite de tiempo que puede estar sin alimentarse. Lo mismo sucede con tiene_hambre que podr\u00eda modificarse para que un animal que ya se aliment\u00f3 no necesite alimentarse instant\u00e1neamente. Se pueden agregar m\u00e9todos como puede_tener_cria y cualquier otra consulta que sea pertinente para un animal. def en_vida(self): return (self.edad <= self.edad_maxima) and self.energia > 0 def tiene_hambre(self): \"\"\"Ac\u00e1 se puede poner comportamiento para que no tenga hambre todo el tiempo deber\u00eda depender de la diferencia entre su nivel de energ\u00eda y su energ\u00eda m\u00e1xima\"\"\" return True def es_leon(self): return False def es_antilope(self): return False","title":"Consultas"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#modificadores","text":"A continuaci\u00f3n presentamos algunos m\u00e9todos modificadores del objeto. def pasar_un_ciclo(self): self.energia -= 1 # consume energ\u00eda self.edad += 1 # envejece if self.edad >= 2 and self.reproducciones_pendientes > 0: self.es_reproductore = True #se puede reproducir def tener_cria(self): \"\"\"Ac\u00e1 se puede poner comportamiento que sucede al tener cria y que evita que tengas m\u00e1s de una cria por ciclo, \u00bfquizas tener_cria consume m\u00e1s energ\u00eda que un ciclo com\u00fan?\"\"\" pass def alimentarse(self, animales_vecinos = None): self.energia = self.energia_maxima return None def reproducirse(self, vecinos, lugares_libres): pos = None if vecinos: pareja = random.choice(vecinos) if lugares_libres: self.tener_cria() pareja.tener_cria() pos = random.choice(lugares_libres) return pos def moverse(self, lugares_libres): pos = None if lugares_libres: pos = random.choice(lugares_libres) return pos","title":"Modificadores"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#leon","text":"Al heredar de Animal , la clase Leon es peque\u00f1a: class Leon(Animal): Todas los m\u00e9todos y atributos definidos all\u00ed est\u00e1n disponibles. Se hace un override del metodo es_leon para aclarar que en este caso S\u00cd es un le\u00f3n. Y como el le\u00f3n es carn\u00edvoro, tambi\u00e9n se extiende el m\u00e9todo alimentarse que s\u00f3lo sucede cuando puede comer. def __init__(self): super(Leon, self).__init__() self.autonomia = 3 self.edad_maxima = 5 def es_leon(self): return True def alimentarse(self, animales_vecinos): # Se alimenta si puede e indica la posici\u00f3n del animal que se pudo comer pos = None if self.tiene_hambre(): # no est\u00e1 lleno presas_cercanas = [ (pos,animal) for (pos, animal) in animales_vecinos if animal.es_antilope() ] if presas_cercanas: # y hay presas cerca super(Leon, self).alimentarse() (pos, animal) = random.choice(presas_cercanas) return pos","title":"Le\u00f3n"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#ejemplo-un-leon","text":"Prob\u00e1 las siguientes instrucciones: L = Leon() L.energia L.edad L.es_leon() L.es_antilope() L.pasar_un_ciclo() L.energia L.edad L.tiene_hambre()","title":"Ejemplo: Un Le\u00f3n"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#antilope","text":"La clase Antilope es m\u00e1s peque\u00f1a a\u00fan y unicamente indica que es un Ant\u00edlope. Ac\u00e1 se asume fuertemente que el ant\u00edlope come pasto y que pasto hay siempre. def __init__(self): self.autonomia = 8 self.edad_maxima = 8 super(Antilope, self).__init__() def es_antilope(self): return True","title":"Ant\u00edlope"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#ejemplo-un-leon-y-dos-antilopes","text":"Agreg\u00e1 ahora dos ant\u00edlopes: A1 = Antilope() A2 = Antilope() A1.energia A1.edad A1.es_antilope() Y hac\u00e9 que el Le\u00f3n, que ya tiene hambre, se coma alguno de los dos ant\u00edlopes (aleatoriamente): vecinos = [(1,A1),(2,A2)] pos = L.alimentarse(vecinos) if pos: print(f'El le\u00f3n se come al ant\u00edlope A{pos}') else: print(f'El le\u00f3n no come') Fijate que el m\u00e9todo alimentarse no mata al ant\u00edlope, solo devuelve su posici\u00f3n. Alguien m\u00e1s deber\u00e1 ocuparse de retirarlo del mundo. Si corr\u00e9s este c\u00f3digo varias veces, vas a ver que el Le\u00f3n obtiene energ\u00eda m\u00e1xima al comer, pero sigue comiendo. Implement\u00e1 adecuadamente el m\u00e9todo tiene_hambre() de la clase Animal de manera que solo tenga hambre cuando su energ\u00eda baje. Volv\u00e9 a probar el c\u00f3digo. El le\u00f3n deber\u00eda comer solo cuando pase al menos un ciclo desde la \u00faltima vez que comi\u00f3.","title":"Ejemplo: Un Le\u00f3n y dos Ant\u00edlopes"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#ejemplo-un-leon-y-una-leona","text":"Definamos ahora una leona M y hagamos que pasen unos ciclos hasta que sea reproductora. M = Leon() M.puede_reproducir() M.pasar_un_ciclo() M.puede_reproducir() Repet\u00ed hasta que L y M sean reproductores. Luego ponelos cerca. Digamos que M tiene como vecinos a los dos ant\u00edlopes y al le\u00f3n L de antes. Supongamos que las crias pueden ocupar algunos lugares libres en nuestro mundo (a\u00fan no definido): vecinos = [L] lugares_libres = [4,5,6,7,8] L.puede_reproducir() M.puede_reproducir() Est\u00e1n dadas las condiciones, que se reproduzcan: pos = M.reproducirse(vecinos, lugares_libres) print(f'nace un nuevo leoncito en la posici\u00f3n {pos}') M.puede_reproducir() M.pasar_un_ciclo() M.puede_reproducir() Vemos que el m\u00e9todo reproducirse nos devuelve una de las posiciones que le dijimos que estaban libres y que los leones no pueden volverse a reproducir en el mismo ciclo pero s\u00ed en el siguiente. Pasemos ahora a ver c\u00f3mo se estructura el tablero.","title":"Ejemplo: Un Le\u00f3n y una Leona"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#el-tablero","text":"","title":"El tablero"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#constructor_1","text":"La clase tablero tendr\u00e1 un \u00fanico constructor que recibir\u00e1 los atributos que dar\u00e1n lugar al tablero del tama\u00f1o deseado: def __init__(self, filas, columnas): super(Tablero, self).__init__() self.filas = filas self.columnas = columnas self.posiciones = {} self.n_posiciones_libres = self.filas * self.columnas Esta clase tendr\u00e1 4 atributos: el n\u00famero de filas, el de columnas, un diccionario donde se almacenar\u00e1 el contenido, y la cantidad de celdas vac\u00edas. El diccionario tendr\u00e1 unicamente las posiciones con alg\u00fan contenido. La cantidad de celdas vac\u00edas es un atributo que podr\u00eda calcularse a partir de los 3 primeros atributos, pero se decidi\u00f3 tenerlo precalculado por ser un valor que se usar\u00e1 mucho.","title":"Constructor"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#modificadores_1","text":"El tablero no tiene una gran complejidad, permite ser modificado de 2 maneras: ubicar un elemento en el tablero, y retirar un elemento del tablero. Se provee adem\u00e1s de la funcionalidad que combina estas cosas bajo el nombre de mover (cambia de lugar un elemento). def ubicar(self, pos, elem): if not self.ocupada(pos): self.n_posiciones_libres -= 1 self.posiciones[pos] = elem return pos in self.posiciones def retirar(self, pos): self.n_posiciones_libres += 1 return self.posiciones.pop(pos) def mover(self, p_origen, p_destino): self.ubicar(p_destino, self.retirar(p_origen))","title":"Modificadores"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#getters","text":"Adem\u00e1s la clase tablero provee m\u00e9todos para consultar sobre estado de posiciones y los valores que se encuentran en el tablero. def posicion(self, pos): #devuele qu\u00e9 hay en pos return self.posiciones[pos] def ocupada(self, pos): return pos in self.posiciones def libre(self, pos): return pos not in self.posiciones def elementos(self): return list(self.posiciones.values()) def hay_posiciones_libres(self): return self.n_posiciones_libres > 0","title":"Getters"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#modificadores-complejos","text":"Una de las funcionalidades deseables para que se pueda usar un tablero, es la posibilidad de ubicar al azar un elemento en alg\u00fan lugar del mismo (que est\u00e9 libre). El tablero provee esa funcionalidad: def ubicar_en_posicion_vacia(self, elem): if not self.hay_posiciones_libres(): raise RuntimeError(\"Est\u00e1s intentado agregar algo al tablero y est\u00e1 lleno\") pos = choice(self.posiciones_libres()) self.ubicar(pos, elem)","title":"Modificadores complejos"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#consultas_1","text":"Tambi\u00e9n ofrece consultas m\u00e1s complejas: def posiciones_ocupadas(self): res = [] for f in range(self.filas): for c in range(self.columnas): if self.ocupada((f,c)): res.append((f,c)) return res def posiciones_libres(self): res = [] for f in range(self.filas): for c in range(self.columnas): if self.libre((f,c)): res.append((f,c)) return res def posiciones_vecinas_libre(self, pos): res = self.posiciones_vecinas(pos) res = [ p for p in res if self.libre(p)] return res def posiciones_vecinas_con_ocupantes(self, pos): res = self.posiciones_vecinas(pos) res = [ (p, self.posicion(p)) for p in res if self.ocupada(p)] return res","title":"Consultas"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#auxiliares","text":"El m\u00e9todo posiciones_vecinas es el que define la topolog\u00eda del terreno. En este caso, una celda tiene como vecinos a las 8 celdas con las que comparte un borde o un v\u00e9rtice (excepto en los bordes). Es posible modificar la din\u00e1mica del mundo modificando esta funci\u00f3n (por ejemplo, hacerlo cil\u00edndrico, esf\u00e9rico o toroidal). def posiciones_vecinas(self, pos): desp=[(-1, -1), (-1, 0), (-1, 1),(0, 1), (1, 1), (1, 0),(1, -1), (0, -1)] for i in range(len(desp)): f = (desp[i][0] + pos[0]) c = (desp[i][1] + pos[1]) desp[i] = (f, c) desp = [ (f,c) for f,c in desp if (0<=f and f<self.filas) and (0<=c and c<self.columnas) ] return desp Se pueden definir como adyacentes s\u00f3lo las que compartan un borde, o las que est\u00e9n a 2 celdas de distancia, incluso es posible definir que en el borde del tablero vuelva a empezar del otro lado (condiciones peri\u00f3dicas).","title":"Auxiliares"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#el-mundo","text":"El mundo ser\u00e1 el encargado de hacer un tablero que usar\u00e1 de soporte, llenarlo de animales y ordenarlos para que se comporten de cierta forma en cada etapa que se implemente.","title":"El mundo"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#constructor_2","text":"En el constructor se define el tama\u00f1o del mundo, la cantidad inicial de Leones y Ant\u00edlopes, tiene la opci\u00f3n de que imprima informaci\u00f3n de lo que va sucediendo con el par\u00e1metro debug . def __init__(self, columnas, filas, n_leones, n_antilopes, debug=False): super(Mundo, self).__init__() self.debug = debug self.ciclo = 0 self.tablero = Tablero(filas, columnas) self.llenar_mundo(n_leones, n_antilopes) El constructor delega la tarea de llenar el tablero al m\u00e9todo llenar_mundo : def llenar_mundo(self, n_leones, n_antilopes): for _ in range(n_leones): if self.tablero.hay_posiciones_libres(): print_debug(\"ubicando un leon\", self.debug) self.tablero.ubicar_en_posicion_vacia(Leon()) for _ in range(n_antilopes): if self.tablero.hay_posiciones_libres(): print_debug(\"ubicando un Antilope\", self.debug) self.tablero.ubicar_en_posicion_vacia(Antilope())","title":"Constructor"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#modelado-de-la-dinamica","text":"En la etapa de movimiento, para cada posici\u00f3n ocupada del tablero, se indican cuales son sus vecinos libres y se lo manda a moverse, en caso de que el animal responda con una posici\u00f3n, se lo mueve a la posici\u00f3n indicada. def etapa_movimiento(self): print_debug(f\"Iniciando Movimiento en ciclo {self.ciclo}\", self.debug) for p in self.tablero.posiciones_ocupadas(): animal = self.tablero.posicion(p) posiciones_libres = self.tablero.posiciones_vecinas_libre(p) nueva_posicion = animal.moverse(posiciones_libres) if nueva_posicion: self.tablero.mover(p, nueva_posicion) En la etapa de alimentaci\u00f3n, es similar a la anterior, salvo que se indican cuales son sus vecinos ocupados y se los manda a alimentarse, en caso de que el animal responda con una posici\u00f3n, se lo mueve a la posici\u00f3n indicada. def etapa_alimentacion(self): print_debug(f\"Iniciando Alimentaci\u00f3n en ciclo {self.ciclo}\", self.debug) for p in self.tablero.posiciones_ocupadas(): animal = self.tablero.posicion(p) animales_cercanos = self.tablero.posiciones_vecinas_con_ocupantes(p) desplazo = animal.alimentarse(animales_cercanos) if desplazo: self.tablero.ubicar(desplazo, self.tablero.retirar(p)) La etapa de reproducci\u00f3n no est\u00e1 implementada. M\u00e1s adelante te pediremos que la implementes. Se deben pasar los animales vecinos. En este punto se debe realizar una importante decisi\u00f3n de modelado. \u00bfQui\u00e9n es el encargado de que s\u00f3lo se apareen animales de la misma especie? \u00bfEl mundo?\u00bfO cada animal? En base a esto se deber\u00e1 quiz\u00e1s modificar c\u00f3digo existente. def etapa_reproduccion(self): print_debug(f\"Iniciando Reproducci\u00f3n en ciclo {self.ciclo}\", self.debug) pass Finalmente el m\u00e9todo que cierra un ciclo haciendo que todos los animales cumplan a\u00f1os, gasten energ\u00eda y retirando los que ya no est\u00e1n con vida. def cerrar_un_ciclo(self): print_debug(f\"Concluyendo ciclo {self.ciclo}\", self.debug) for p in self.tablero.posiciones_ocupadas(): animal = self.tablero.posicion(p) animal.pasar_un_ciclo() #envejecer, consumir alimento if not animal.en_vida(): self.tablero.retirar(p) self.ciclo += 1 Los 4 m\u00e9todos est\u00e1n para ser llamados todos juntos con: def pasar_un_ciclo(self): self.etapa_movimiento() self.etapa_alimentacion() self.etapa_reproduccion() self.cerrar_un_ciclo()","title":"Modelado de la din\u00e1mica"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#probando-el-modelo-completo","text":"Una forma para probar el funcionamiento es tener el siguiente c\u00f3digo que corre el mundo varias veces con una pausa de tiempo para poder verlo. m = Mundo(12, 6, 5, 15, debug=True) import time for i in range(20): m.pasar_un_ciclo() time.sleep(2) print(i +1) print(m) Para empezar a explorar m\u00e1s en serio el modelo deber\u00edas completar los m\u00e9todos que est\u00e9n indicados con pass y otros detalles, seg\u00fan te indicamos en los siguientes ejercicios. Agreg\u00e1 adem\u00e1s cualquier m\u00e9todo que consideres necesario para obtener informaci\u00f3n, o modelar alg\u00fan comportamiento.","title":"Probando el modelo completo"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#ejercicio-1017-etapa-de-reproduccion","text":"Implement\u00e1 el m\u00e9todo etapa_reproduccion en la clase Mundo .","title":"Ejercicio 10.17: Etapa de reproducci\u00f3n"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#ejercicio-1018-acotando-la-reproduccion","text":"Implement\u00e1 la l\u00f3gica necesaria para que los animales pueden reproducirse \u00fanicamente una vez por a\u00f1o (ya sean los que inician la reproducci\u00f3n o los que son compa\u00f1eres).","title":"Ejercicio 10.18: Acotando la reproducci\u00f3n"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#ejercicio-1019-alcanzando-la-madurez","text":"Implement\u00e1 la l\u00f3gica necesaria para que un animal s\u00f3lo puede reproducirse cuando ya tiene 2 a\u00f1os cumplidos. Si llegaste hasta ac\u00e1, por favor guard\u00e1 todo junto en un solo archivo simulacion.py y entregalo al finalizar la clase. Una vez realizado esto hay diversas opciones para usarlo y expandirlo.","title":"Ejercicio 10.19: Alcanzando la madurez"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#extensiones-del-modelo","text":"A continuaci\u00f3n una lista no exhaustiva de las extensiones posibles al modelo, pod\u00e9s incorporar algunas, o todas: Ning\u00fan animal se alimenta m\u00e1s de una vez en una etapa. Modifi\u0107a el m\u00e9todo tiene_hambre() de la clase Animal para que no siempre tenga hambre. Si un animal se alimenta en una etapa, no necesita alimentarse m\u00e1s por un turno entero. Cuando un Le\u00f3n ataca un Ant\u00edlope, no siempre se lo come, a veces el Ant\u00edlope logra escapar. Modelar esto con 3 posibles escenarios: Existe una probabilidad p (fija), de que el Le\u00f3n tenga \u00e9xito (con el m\u00f3dulo random se puede hacer random.random() > p ) La probabilidad es variable dependiendo de la edad del Le\u00f3n, siendo muy baja cuando es cachorro, alta cuando es adulto, y baja de nuevo en su vejez. La probabilidad es variable dependiendo de la edad del Le\u00f3n, igual al anterior, y la edad del Ant\u00edlope, siendo la probabilidad de que escape muy baja cuando es cachorro, alta cuando es adulto, y baja de nuevo en su vejez. Una forma de calcular esto es: Se puede hacer uso de los vecinos para modificar esta probabilidad, entonces si los Ant\u00edlopes est\u00e1n en manada, que la probabilidad de comer del Le\u00f3n sea m\u00e1s baja a\u00fan. Extender la vecindad a un radio de 2 para todos los animales. Extender la vecindad para distinto radio dependiendo la especie. Que el Ant\u00edlope pueda visualizar Leones a cierta distancia (ej. radio 3), y desplazarse en otra direcci\u00f3n.","title":"Extensiones del modelo"},{"location":"10_Generadores_e_Iteradores/06_PredadorPresa/#exploraciones","text":"Analizar distintos valores para la construcci\u00f3n del mundo a lo largo del tiempo. \u00bfEs posible encontrar un equilibrio entre la cantidad de leones y ant\u00edlopes? \u00bfQu\u00e9 sucede con la supervivencia si se modifican los atributos propios de la clase Le\u00f3n y Ant\u00edlope de manera de que tengan mayor (o menor) autonom\u00eda, o sean m\u00e1s longevos? \u00bfSe detectan ciclos de mayor\u00eda de una especie y despu\u00e9s de la otra?\u00bfHay dominaci\u00f3n? Contenidos | Anterior (5 M\u00e1s sobre generadores) | Pr\u00f3ximo (7 Cierre de la clase)","title":"Exploraciones"},{"location":"10_Generadores_e_Iteradores/07_Cierre/","text":"Contenidos | Anterior (6 Predador Presa) 10.7 Cierre de la clase En esta clase aprendiste sobre generadores e iteradores, dos conceptos muy interesantes de Python. Viste que el mecanismo de iteraci\u00f3n es una forma de dialogar con un objeto. Adem\u00e1s, aprendiste los m\u00e9todos que necesit\u00e1s implementar para que un objeto que creaste sea iterable. Discutimos tambi\u00e9n las ventajas de constru\u00edr un programa con estos conceptos. Los programas resultan mas vers\u00e1tiles, modulares, y ligeros. Como con el concepto de comprensi\u00f3n de listas, pod\u00e9s usar la sintaxis de comprensi\u00f3n para constru\u00edr un iterable: una expresi\u00f3n sobre la cual pod\u00e9s iterar sin necesidad de almacenar todos los elementos posibles en una lista ni escribir una funci\u00f3n para calcularlos. Por \u00faltimo, viste la ventaja de crear pipelines: estructuras de procesamiento de datos configurables en vuelo, altamente modulares. Aunque no la uses de inmediato, cuando te la apropies, esta arquitectura puede cambiarte (un poquito) la vida. Para cerrar esta clase, prepar\u00e1: El archivo informe.py del Ejercicio 10.2 . El archivo camion.py del Ejercicio 10.3 (o Ejercicio 10.14 ) que va a jugar en la revisi\u00f3n de pares. El archivo vigilante.py del Ejercicio 10.7 . El archivo ticker.py del Ejercicio 10.12 (o del Ejercicio 10.15 ). Y, opcionalmente, el archivo simulacion.py del Ejercicio 10.19 . Adem\u00e1s te pedimos que completes este formulario usando tu direcci\u00f3n de mail como identificaci\u00f3n. Al terminar vas a obtener un link para enviarnos tus ejercicios. \u00a1Nos vemos! Contenidos | Anterior (6 Predador Presa)","title":"07 Cierre"},{"location":"10_Generadores_e_Iteradores/07_Cierre/#107-cierre-de-la-clase","text":"En esta clase aprendiste sobre generadores e iteradores, dos conceptos muy interesantes de Python. Viste que el mecanismo de iteraci\u00f3n es una forma de dialogar con un objeto. Adem\u00e1s, aprendiste los m\u00e9todos que necesit\u00e1s implementar para que un objeto que creaste sea iterable. Discutimos tambi\u00e9n las ventajas de constru\u00edr un programa con estos conceptos. Los programas resultan mas vers\u00e1tiles, modulares, y ligeros. Como con el concepto de comprensi\u00f3n de listas, pod\u00e9s usar la sintaxis de comprensi\u00f3n para constru\u00edr un iterable: una expresi\u00f3n sobre la cual pod\u00e9s iterar sin necesidad de almacenar todos los elementos posibles en una lista ni escribir una funci\u00f3n para calcularlos. Por \u00faltimo, viste la ventaja de crear pipelines: estructuras de procesamiento de datos configurables en vuelo, altamente modulares. Aunque no la uses de inmediato, cuando te la apropies, esta arquitectura puede cambiarte (un poquito) la vida. Para cerrar esta clase, prepar\u00e1: El archivo informe.py del Ejercicio 10.2 . El archivo camion.py del Ejercicio 10.3 (o Ejercicio 10.14 ) que va a jugar en la revisi\u00f3n de pares. El archivo vigilante.py del Ejercicio 10.7 . El archivo ticker.py del Ejercicio 10.12 (o del Ejercicio 10.15 ). Y, opcionalmente, el archivo simulacion.py del Ejercicio 10.19 . Adem\u00e1s te pedimos que completes este formulario usando tu direcci\u00f3n de mail como identificaci\u00f3n. Al terminar vas a obtener un link para enviarnos tus ejercicios. \u00a1Nos vemos! Contenidos | Anterior (6 Predador Presa)","title":"10.7 Cierre de la clase"},{"location":"11_Recursion/00_Resumen/","text":"Contenidos | Anterior (10 Generadores e iteradores) | Pr\u00f3ximo (12 Ordenamiento) 11. Recursi\u00f3n y regresi\u00f3n En esta clase discutimos el concepto de recursi\u00f3n, proponemos algunas bases para el dise\u00f1o de algoritmos recursivos y elaboramos algunos ejemplos con ellos, algunos un tanto esot\u00e9ricos. En otro orden de cosas, en la \u00faltima secci\u00f3n damos un acercamiento pr\u00e1ctico a las t\u00e9cnicas de regresi\u00f3n lineal y dejamos la posibilidad de profundizar m\u00e1s en el tema con referencias y ejercicios optativos. 11.1 Introducci\u00f3n 11.2 Intro a la Recursi\u00f3n 11.3 Dise\u00f1o de algoritmos recursivos 11.4 Pr\u00e1ctica de Recursi\u00f3n 11.5 Regresi\u00f3n lineal 11.6 Cierre de la clase de Recursi\u00f3n y Regresi\u00f3n Contenidos | Anterior (10 Generadores e iteradores) | Pr\u00f3ximo (12 Ordenamiento)","title":"00 Resumen"},{"location":"11_Recursion/00_Resumen/#11-recursion-y-regresion","text":"En esta clase discutimos el concepto de recursi\u00f3n, proponemos algunas bases para el dise\u00f1o de algoritmos recursivos y elaboramos algunos ejemplos con ellos, algunos un tanto esot\u00e9ricos. En otro orden de cosas, en la \u00faltima secci\u00f3n damos un acercamiento pr\u00e1ctico a las t\u00e9cnicas de regresi\u00f3n lineal y dejamos la posibilidad de profundizar m\u00e1s en el tema con referencias y ejercicios optativos. 11.1 Introducci\u00f3n 11.2 Intro a la Recursi\u00f3n 11.3 Dise\u00f1o de algoritmos recursivos 11.4 Pr\u00e1ctica de Recursi\u00f3n 11.5 Regresi\u00f3n lineal 11.6 Cierre de la clase de Recursi\u00f3n y Regresi\u00f3n Contenidos | Anterior (10 Generadores e iteradores) | Pr\u00f3ximo (12 Ordenamiento)","title":"11. Recursi\u00f3n y regresi\u00f3n"},{"location":"11_Recursion/01_Introduccion/","text":"Contenidos | Pr\u00f3ximo (2 Intro a la Recursi\u00f3n) 11.1 Introducci\u00f3n En este video damos una breve introducci\u00f3n al concepto de recursi\u00f3n, que es el tema principal de esta clase. Luego en la pr\u00f3xima secci\u00f3n vas encontrar un video m\u00e1s largo donde vemos con mayor profundidad este tema, que est\u00e1 desarrollado por escrito a lo largo de dos secciones. Luego hay una secci\u00f3n solamente de ejercicios. Por \u00faltimo hay una secci\u00f3n de regresi\u00f3n lineal, que tiene una parte obligatoria y una parte optativa. En esa secci\u00f3n tambi\u00e9n hay un video que introduce el tema. \u00a1Que disfrutes la clase! Contenidos | Pr\u00f3ximo (2 Intro a la Recursi\u00f3n)","title":"01 Introduccion"},{"location":"11_Recursion/01_Introduccion/#111-introduccion","text":"En este video damos una breve introducci\u00f3n al concepto de recursi\u00f3n, que es el tema principal de esta clase. Luego en la pr\u00f3xima secci\u00f3n vas encontrar un video m\u00e1s largo donde vemos con mayor profundidad este tema, que est\u00e1 desarrollado por escrito a lo largo de dos secciones. Luego hay una secci\u00f3n solamente de ejercicios. Por \u00faltimo hay una secci\u00f3n de regresi\u00f3n lineal, que tiene una parte obligatoria y una parte optativa. En esa secci\u00f3n tambi\u00e9n hay un video que introduce el tema. \u00a1Que disfrutes la clase! Contenidos | Pr\u00f3ximo (2 Intro a la Recursi\u00f3n)","title":"11.1 Introducci\u00f3n"},{"location":"11_Recursion/02_Recursion/","text":"Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Dise\u00f1o de algoritmos recursivos) 11.2 Intro a la Recursi\u00f3n Para esta secci\u00f3n y las dos siguientes hay un video donde introducimos el tema de recursi\u00f3n y vemos algunos ejemplos. La recursi\u00f3n y c\u00f3mo puede ser que funcione Estamos acostumbrados a escribir funciones que llaman a otras funciones. Pero lo cierto es que nada impide que en Python (y en muchos otros lenguajes) una funci\u00f3n se llame a s\u00ed misma. Y lo m\u00e1s interesante es que esta propiedad, que se llama recursi\u00f3n , permite en muchos casos encontrar soluciones muy elegantes para determinados problemas. En materias de matem\u00e1tica se estudian los razonamientos por inducci\u00f3n para probar propiedades de n\u00fameros enteros y la recursi\u00f3n no es m\u00e1s que una generalizaci\u00f3n de la inducci\u00f3n a m\u00e1s estructuras: las listas, las cadenas de caracteres, las funciones, etc. A continuaci\u00f3n estudiaremos diversas situaciones en las cuales aparece la recursi\u00f3n, veremos c\u00f3mo es que esto puede funcionar, algunas situaciones en las que es conveniente utilizarla y otras situaciones en las que no. Una funci\u00f3n recursiva matem\u00e1tica Es muy com\u00fan tener definiciones inductivas de operaciones. Un caso paradigm\u00e1tico es la del factorial. Recordemos que el factorial de un n\u00famero entero positivo n es el producto de todos los n\u00fameros entre 1 y n. La definici\u00f3n usual, inductiva, es la siguiente: 1! = 1 n! = n * (n-1)! si n>1 Este tipo de definici\u00f3n se traduce naturalmente en una funci\u00f3n en Python: def factorial(n): \"\"\"Precondici\u00f3n: n entero positivo Devuelve: n!\"\"\" if n == 1: return 1 return n * factorial(n - 1) \u00c9sta es la ejecuci\u00f3n del factorial para n = 1 y para n = 3 . >>> factorial(1) 1 >>> factorial(3) 6 El sentido de la instrucci\u00f3n n * factorial(n - 1) es exactamente el mismo que el de la definici\u00f3n inductiva: para calcular el factorial de n se debe multiplicar n por el factorial de n-1 . Dos piezas fundamentales para garantizar el funcionamiento de este programa son: Que se defina un caso base (en este caso la indicaci\u00f3n no recursiva de c\u00f3mo calcular factorial(1) ). Que el argumento de la funci\u00f3n respete la precondici\u00f3n de que n debe ser un entero mayor o igual que 1. No es incre\u00edble que esto pueda funcionar adecuadamente en un lenguaje de programaci\u00f3n? Ejercicio 11.1: Para poder analizar qu\u00e9 sucede a cada paso de la ejecuci\u00f3n de la funci\u00f3n, utilizaremos una versi\u00f3n m\u00e1s detallada del mismo c\u00f3digo, en la que el resultado de cada paso se asigna a una variable. def factorial(n): if n == 1: r = 1 return r f = factorial(n-1) r = n * f return r Esta porci\u00f3n de c\u00f3digo funciona exactamente igual que la anterior, pero nos permite ponerles nombres a los resultados intermedios de cada operaci\u00f3n para poder estudiar qu\u00e9 sucede a cada paso. Analiz\u00e1 con tu debugger la ejecuci\u00f3n de factorial(3) . Algoritmos recursivos y algoritmos iterativos Llamaremos algoritmos recursivos a aquellos que realizan llamadas recursivas para llegar al resultado, y algoritmos iterativos a aquellos que llegan a un resultado a trav\u00e9s de una iteraci\u00f3n mediante un ciclo definido o indefinido. Todo algoritmo recursivo puede expresarse como iterativo y viceversa. Sin embargo, seg\u00fan las condiciones del problema a resolver podr\u00e1 ser preferible utilizar la soluci\u00f3n recursiva o la iterativa. Una posible implementaci\u00f3n iterativa de la funci\u00f3n factorial vista anteriormente ser\u00eda: def factorial(n): \"\"\"Precondici\u00f3n: n entero positivo Devuelve: n!\"\"\" fact = 1 for num in range(n, 1, -1): fact *= num return fact Se puede ver que en este caso no es necesario incluir un caso base, ya que el mismo ciclo incluye una condici\u00f3n de corte, pero que s\u00ed es necesario incluir un acumulador, que en el caso recursivo no era necesario. Por otro lado, si hici\u00e9ramos el seguimiento de esta funci\u00f3n, como se hizo para la versi\u00f3n recursiva, ver\u00edamos que la pila de ejecuci\u00f3n siempre tiene un \u00fanico marco, en el cual se van modificando los valores de num y fact . Es por esto que, en general, las versiones recursivas de los algoritmos utilizan m\u00e1s memoria (ya que la pila de ejecuci\u00f3n se guarda en memoria) pero suelen ser m\u00e1s elegantes. Un ejemplo de recursi\u00f3n elegante Consideremos ahora otro problema que puede ser resuelto de forma elegante mediante un algoritmo recursivo. La funci\u00f3n potencia(b, n) que vimos cuando hablamos de invariantes en la Secci\u00f3n 7.5 , realiza n iteraciones para poder obtener el valor de b^n . Sin embargo, es posible optimizarla teniendo en cuenta los siguientes hechos: b^n = b^(n/2) * b^(n/2) si n es par, y b^n = b^((n-1)/2) * b^((n-1)/2) * b si n es impar. Estas ecuaciones nos permiten dise\u00f1ar un algoritmo much\u00edsimo m\u00e1s eficiente. Esta situaci\u00f3n guarda cierta analog\u00eda con el problema de la b\u00fasqueda en una lista ordenada. La idea es, en un paso, reducir el tama\u00f1o del problema a la mitad. Antes de programar cualquier funci\u00f3n recursiva es necesario decidir cu\u00e1l ser\u00e1 el caso base y cu\u00e1l el paso recursivo . Para esta funci\u00f3n, tomaremos n=0 como el caso base (devolveremos 1 ). El paso recursivo tendr\u00e1 dos partes, correspondientes a los dos posibles grupos de valores de n . def potencia(b,n): \"\"\"Precondici\u00f3n: n >= 0 Devuelve: b^n.\"\"\" if n <= 0: # caso base return 1 if n % 2 == 0: # caso n par p = potencia(b, n // 2) return p * p else: # caso n impar p = potencia(b, (n - 1) // 2) return p * p * b El uso de la variable p en este caso no es optativo, ya que es una de las ventajas principales de esta implementaci\u00f3n: se aprovecha el resultado calculado en lugar de tener que calcularlo dos veces. Vemos que este c\u00f3digo funciona correctamente: >>> potencia(2, 10) 1024 >>> potencia(3, 3) 27 >>> potencia(5, 0) 1 El orden de las llamadas, haciendo un seguimiento simplificado de la funci\u00f3n ser\u00e1: potencia(2, 10) potencia(2, 5) potencia(2, 2) potencia(2, 1) potencia(2, 0) return 1 return 1 * 1 * 2 return 2 * 2 return 4 * 4 * 2 return 32 * 32 return 1024 Se puede ver, entonces, que para calcular 2^10 se realizaron 5 llamadas a potencia , mientras que en la implementaci\u00f3n m\u00e1s sencilla se realizaban 10 iteraciones. Y esta optimizaci\u00f3n ser\u00e1 cada vez m\u00e1s importante a medida que aumenta n : por ejemplo para n = 100 se realizar\u00e1n 8 llamadas recursivas, y para n = 1000 11 llamadas. Es posible transformar este algoritmo recursivo en un algoritmo iterativo. Para ello es necesario simular la pila de llamadas a funciones mediante una pila que almacene los valores que sean necesarios. En este caso, lo que apilaremos ser\u00e1 si el valor de n es par o no. def potencia(b, n): \"\"\"Precondici\u00f3n: n >= 0 Devuelve: b^n.\"\"\" pila = [] while n > 0: if n % 2 == 0: pila.append(True) n //= 2 else: pila.append(False) n = (n - 1) // 2 p = 1 while pila: es_par = pila.pop() if es_par: p *= p else: p *= p * b return p Como se puede ver, este c\u00f3digo es mucho m\u00e1s complejo que la versi\u00f3n recursiva. Esto se debe a que utilizando recursi\u00f3n el uso de la pila de llamadas a funciones oculta el proceso de apilado y desapilado y permite concentrarse en la parte importante del algoritmo. Un ejemplo de recursi\u00f3n poco eficiente Del ejemplo anterior se podr\u00eda deducir que siempre es mejor utilizar algoritmos recursivos; sin embargo --como dijimos antes-- cada situaci\u00f3n merece ser analizada por separado. Un ejemplo cl\u00e1sico en el cual la recursi\u00f3n tiene un resultado muy poco eficiente es el de los n\u00fameros de Fibonacci. La sucesi\u00f3n de Fibonacci est\u00e1 definida por la siguiente relaci\u00f3n: F(0) = 0 F(1) = 1 F(n) = F(n - 1) + F(n - 2) si n > 1 Los primeros n\u00fameros de esta sucesi\u00f3n son: 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 . La sucesi\u00f3n tiene numerosas aplicaciones en computaci\u00f3n y matem\u00e1tica y tambi\u00e9n aparece en configuraciones biol\u00f3gicas, como en las flores de girasoles, en la configuraci\u00f3n de los anan\u00e1s o las pi\u00f1as de las con\u00edferas, en la reproducci\u00f3n de conejos, etc. La siguiente imagen muestra su uso para aproximar una espiral \u00e1urea: Dada la definici\u00f3n recursiva de la sucesi\u00f3n, puede resultar muy tentador escribir una funci\u00f3n que calcule en valor de fib(n) de la siguiente forma: def fib(n): \"\"\"Precondici\u00f3n: n >= 0. Devuelve: el n\u00famero de Fibonacci n\u00famero n.\"\"\" if n == 0: res = 0 elif n == 1: res = 1 else: res = fib(n - 1) + fib(n - 2) return res Si bien esta implementaci\u00f3n es muy sencilla y elegante, tambi\u00e9n es extremadamente poco eficiente: para calcular fib(n - 1) es necesario calcular fib(n - 2) , que luego volver\u00e1 a ser calculado para obtener el valor fib(n) . Por ejemplo, una simple llamada a fib(5) , generar\u00eda recursivamente todas las llamadas ilustradas en el siguiente gr\u00e1fico. Puede verse que muchas de estas llamadas est\u00e1n repetidas, generando un total de 15 llamadas a la funci\u00f3n fib , s\u00f3lo para devolver el valor F(5) . En este caso, ser\u00e1 mucho m\u00e1s conveniente utilizar una versi\u00f3n iterativa, que vaya almacenando los valores de las dos variables anteriores a medida que los va calculando. def fib(n): \"\"\"Precondici\u00f3n: n >= 0. Devuelve: el n\u00famero de Fibonacci n\u00famero n.\"\"\" if n == 0 or n == 1: return n ant2 = 0 ant1 = 1 for i in range(2, n + 1): fibn = ant1 + ant2 ant2 = ant1 ant1 = fibn return fibn Vemos que el caso base es el mismo para ambos algoritmos, pero que en el caso iterativo se calcula el n\u00famero de Fibonacci de forma incremental, de modo que para obtener el valor de fib(n) se har\u00e1n n-1 iteraciones. En resumen : vimos que un algoritmo recursivo no es necesariamente mejor que uno iterativo, ni viceversa. En cada situaci\u00f3n es conveniente analizar cu\u00e1l algoritmo provee una soluci\u00f3n m\u00e1s clara y eficiente. Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Dise\u00f1o de algoritmos recursivos)","title":"02 Recursion"},{"location":"11_Recursion/02_Recursion/#112-intro-a-la-recursion","text":"Para esta secci\u00f3n y las dos siguientes hay un video donde introducimos el tema de recursi\u00f3n y vemos algunos ejemplos.","title":"11.2 Intro a la Recursi\u00f3n"},{"location":"11_Recursion/02_Recursion/#la-recursion-y-como-puede-ser-que-funcione","text":"Estamos acostumbrados a escribir funciones que llaman a otras funciones. Pero lo cierto es que nada impide que en Python (y en muchos otros lenguajes) una funci\u00f3n se llame a s\u00ed misma. Y lo m\u00e1s interesante es que esta propiedad, que se llama recursi\u00f3n , permite en muchos casos encontrar soluciones muy elegantes para determinados problemas. En materias de matem\u00e1tica se estudian los razonamientos por inducci\u00f3n para probar propiedades de n\u00fameros enteros y la recursi\u00f3n no es m\u00e1s que una generalizaci\u00f3n de la inducci\u00f3n a m\u00e1s estructuras: las listas, las cadenas de caracteres, las funciones, etc. A continuaci\u00f3n estudiaremos diversas situaciones en las cuales aparece la recursi\u00f3n, veremos c\u00f3mo es que esto puede funcionar, algunas situaciones en las que es conveniente utilizarla y otras situaciones en las que no.","title":"La recursi\u00f3n y c\u00f3mo puede ser que funcione"},{"location":"11_Recursion/02_Recursion/#una-funcion-recursiva-matematica","text":"Es muy com\u00fan tener definiciones inductivas de operaciones. Un caso paradigm\u00e1tico es la del factorial. Recordemos que el factorial de un n\u00famero entero positivo n es el producto de todos los n\u00fameros entre 1 y n. La definici\u00f3n usual, inductiva, es la siguiente: 1! = 1 n! = n * (n-1)! si n>1 Este tipo de definici\u00f3n se traduce naturalmente en una funci\u00f3n en Python: def factorial(n): \"\"\"Precondici\u00f3n: n entero positivo Devuelve: n!\"\"\" if n == 1: return 1 return n * factorial(n - 1) \u00c9sta es la ejecuci\u00f3n del factorial para n = 1 y para n = 3 . >>> factorial(1) 1 >>> factorial(3) 6 El sentido de la instrucci\u00f3n n * factorial(n - 1) es exactamente el mismo que el de la definici\u00f3n inductiva: para calcular el factorial de n se debe multiplicar n por el factorial de n-1 . Dos piezas fundamentales para garantizar el funcionamiento de este programa son: Que se defina un caso base (en este caso la indicaci\u00f3n no recursiva de c\u00f3mo calcular factorial(1) ). Que el argumento de la funci\u00f3n respete la precondici\u00f3n de que n debe ser un entero mayor o igual que 1. No es incre\u00edble que esto pueda funcionar adecuadamente en un lenguaje de programaci\u00f3n?","title":"Una funci\u00f3n recursiva matem\u00e1tica"},{"location":"11_Recursion/02_Recursion/#ejercicio-111","text":"Para poder analizar qu\u00e9 sucede a cada paso de la ejecuci\u00f3n de la funci\u00f3n, utilizaremos una versi\u00f3n m\u00e1s detallada del mismo c\u00f3digo, en la que el resultado de cada paso se asigna a una variable. def factorial(n): if n == 1: r = 1 return r f = factorial(n-1) r = n * f return r Esta porci\u00f3n de c\u00f3digo funciona exactamente igual que la anterior, pero nos permite ponerles nombres a los resultados intermedios de cada operaci\u00f3n para poder estudiar qu\u00e9 sucede a cada paso. Analiz\u00e1 con tu debugger la ejecuci\u00f3n de factorial(3) .","title":"Ejercicio 11.1:"},{"location":"11_Recursion/02_Recursion/#algoritmos-recursivos-y-algoritmos-iterativos","text":"Llamaremos algoritmos recursivos a aquellos que realizan llamadas recursivas para llegar al resultado, y algoritmos iterativos a aquellos que llegan a un resultado a trav\u00e9s de una iteraci\u00f3n mediante un ciclo definido o indefinido. Todo algoritmo recursivo puede expresarse como iterativo y viceversa. Sin embargo, seg\u00fan las condiciones del problema a resolver podr\u00e1 ser preferible utilizar la soluci\u00f3n recursiva o la iterativa. Una posible implementaci\u00f3n iterativa de la funci\u00f3n factorial vista anteriormente ser\u00eda: def factorial(n): \"\"\"Precondici\u00f3n: n entero positivo Devuelve: n!\"\"\" fact = 1 for num in range(n, 1, -1): fact *= num return fact Se puede ver que en este caso no es necesario incluir un caso base, ya que el mismo ciclo incluye una condici\u00f3n de corte, pero que s\u00ed es necesario incluir un acumulador, que en el caso recursivo no era necesario. Por otro lado, si hici\u00e9ramos el seguimiento de esta funci\u00f3n, como se hizo para la versi\u00f3n recursiva, ver\u00edamos que la pila de ejecuci\u00f3n siempre tiene un \u00fanico marco, en el cual se van modificando los valores de num y fact . Es por esto que, en general, las versiones recursivas de los algoritmos utilizan m\u00e1s memoria (ya que la pila de ejecuci\u00f3n se guarda en memoria) pero suelen ser m\u00e1s elegantes.","title":"Algoritmos recursivos y algoritmos iterativos"},{"location":"11_Recursion/02_Recursion/#un-ejemplo-de-recursion-elegante","text":"Consideremos ahora otro problema que puede ser resuelto de forma elegante mediante un algoritmo recursivo. La funci\u00f3n potencia(b, n) que vimos cuando hablamos de invariantes en la Secci\u00f3n 7.5 , realiza n iteraciones para poder obtener el valor de b^n . Sin embargo, es posible optimizarla teniendo en cuenta los siguientes hechos: b^n = b^(n/2) * b^(n/2) si n es par, y b^n = b^((n-1)/2) * b^((n-1)/2) * b si n es impar. Estas ecuaciones nos permiten dise\u00f1ar un algoritmo much\u00edsimo m\u00e1s eficiente. Esta situaci\u00f3n guarda cierta analog\u00eda con el problema de la b\u00fasqueda en una lista ordenada. La idea es, en un paso, reducir el tama\u00f1o del problema a la mitad. Antes de programar cualquier funci\u00f3n recursiva es necesario decidir cu\u00e1l ser\u00e1 el caso base y cu\u00e1l el paso recursivo . Para esta funci\u00f3n, tomaremos n=0 como el caso base (devolveremos 1 ). El paso recursivo tendr\u00e1 dos partes, correspondientes a los dos posibles grupos de valores de n . def potencia(b,n): \"\"\"Precondici\u00f3n: n >= 0 Devuelve: b^n.\"\"\" if n <= 0: # caso base return 1 if n % 2 == 0: # caso n par p = potencia(b, n // 2) return p * p else: # caso n impar p = potencia(b, (n - 1) // 2) return p * p * b El uso de la variable p en este caso no es optativo, ya que es una de las ventajas principales de esta implementaci\u00f3n: se aprovecha el resultado calculado en lugar de tener que calcularlo dos veces. Vemos que este c\u00f3digo funciona correctamente: >>> potencia(2, 10) 1024 >>> potencia(3, 3) 27 >>> potencia(5, 0) 1 El orden de las llamadas, haciendo un seguimiento simplificado de la funci\u00f3n ser\u00e1: potencia(2, 10) potencia(2, 5) potencia(2, 2) potencia(2, 1) potencia(2, 0) return 1 return 1 * 1 * 2 return 2 * 2 return 4 * 4 * 2 return 32 * 32 return 1024 Se puede ver, entonces, que para calcular 2^10 se realizaron 5 llamadas a potencia , mientras que en la implementaci\u00f3n m\u00e1s sencilla se realizaban 10 iteraciones. Y esta optimizaci\u00f3n ser\u00e1 cada vez m\u00e1s importante a medida que aumenta n : por ejemplo para n = 100 se realizar\u00e1n 8 llamadas recursivas, y para n = 1000 11 llamadas. Es posible transformar este algoritmo recursivo en un algoritmo iterativo. Para ello es necesario simular la pila de llamadas a funciones mediante una pila que almacene los valores que sean necesarios. En este caso, lo que apilaremos ser\u00e1 si el valor de n es par o no. def potencia(b, n): \"\"\"Precondici\u00f3n: n >= 0 Devuelve: b^n.\"\"\" pila = [] while n > 0: if n % 2 == 0: pila.append(True) n //= 2 else: pila.append(False) n = (n - 1) // 2 p = 1 while pila: es_par = pila.pop() if es_par: p *= p else: p *= p * b return p Como se puede ver, este c\u00f3digo es mucho m\u00e1s complejo que la versi\u00f3n recursiva. Esto se debe a que utilizando recursi\u00f3n el uso de la pila de llamadas a funciones oculta el proceso de apilado y desapilado y permite concentrarse en la parte importante del algoritmo.","title":"Un ejemplo de recursi\u00f3n elegante"},{"location":"11_Recursion/02_Recursion/#un-ejemplo-de-recursion-poco-eficiente","text":"Del ejemplo anterior se podr\u00eda deducir que siempre es mejor utilizar algoritmos recursivos; sin embargo --como dijimos antes-- cada situaci\u00f3n merece ser analizada por separado. Un ejemplo cl\u00e1sico en el cual la recursi\u00f3n tiene un resultado muy poco eficiente es el de los n\u00fameros de Fibonacci. La sucesi\u00f3n de Fibonacci est\u00e1 definida por la siguiente relaci\u00f3n: F(0) = 0 F(1) = 1 F(n) = F(n - 1) + F(n - 2) si n > 1 Los primeros n\u00fameros de esta sucesi\u00f3n son: 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 . La sucesi\u00f3n tiene numerosas aplicaciones en computaci\u00f3n y matem\u00e1tica y tambi\u00e9n aparece en configuraciones biol\u00f3gicas, como en las flores de girasoles, en la configuraci\u00f3n de los anan\u00e1s o las pi\u00f1as de las con\u00edferas, en la reproducci\u00f3n de conejos, etc. La siguiente imagen muestra su uso para aproximar una espiral \u00e1urea: Dada la definici\u00f3n recursiva de la sucesi\u00f3n, puede resultar muy tentador escribir una funci\u00f3n que calcule en valor de fib(n) de la siguiente forma: def fib(n): \"\"\"Precondici\u00f3n: n >= 0. Devuelve: el n\u00famero de Fibonacci n\u00famero n.\"\"\" if n == 0: res = 0 elif n == 1: res = 1 else: res = fib(n - 1) + fib(n - 2) return res Si bien esta implementaci\u00f3n es muy sencilla y elegante, tambi\u00e9n es extremadamente poco eficiente: para calcular fib(n - 1) es necesario calcular fib(n - 2) , que luego volver\u00e1 a ser calculado para obtener el valor fib(n) . Por ejemplo, una simple llamada a fib(5) , generar\u00eda recursivamente todas las llamadas ilustradas en el siguiente gr\u00e1fico. Puede verse que muchas de estas llamadas est\u00e1n repetidas, generando un total de 15 llamadas a la funci\u00f3n fib , s\u00f3lo para devolver el valor F(5) . En este caso, ser\u00e1 mucho m\u00e1s conveniente utilizar una versi\u00f3n iterativa, que vaya almacenando los valores de las dos variables anteriores a medida que los va calculando. def fib(n): \"\"\"Precondici\u00f3n: n >= 0. Devuelve: el n\u00famero de Fibonacci n\u00famero n.\"\"\" if n == 0 or n == 1: return n ant2 = 0 ant1 = 1 for i in range(2, n + 1): fibn = ant1 + ant2 ant2 = ant1 ant1 = fibn return fibn Vemos que el caso base es el mismo para ambos algoritmos, pero que en el caso iterativo se calcula el n\u00famero de Fibonacci de forma incremental, de modo que para obtener el valor de fib(n) se har\u00e1n n-1 iteraciones. En resumen : vimos que un algoritmo recursivo no es necesariamente mejor que uno iterativo, ni viceversa. En cada situaci\u00f3n es conveniente analizar cu\u00e1l algoritmo provee una soluci\u00f3n m\u00e1s clara y eficiente. Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Dise\u00f1o de algoritmos recursivos)","title":"Un ejemplo de recursi\u00f3n poco eficiente"},{"location":"11_Recursion/03_Diseno_Recursivo/","text":"Contenidos | Anterior (2 Intro a la Recursi\u00f3n) | Pr\u00f3ximo (4 Pr\u00e1ctica de Recursi\u00f3n) 11.3 Dise\u00f1o de algoritmos recursivos Hasta el momento vimos que hay muchas funciones matem\u00e1ticas que se definen o que pueden desarrollarse de forma recursiva, pero puede aplicarse recursividad a muchos problemas que no sean explicitamente recursivos. Dise\u00f1ar un algoritmo recursivo es un proceso sistematizable. En general, en el proceso para plantear un algoritmo recursivo, necesitamos resolver estos tres problemas: Caso base: Necesitamos definir uno o m\u00e1s casos base de acuerdo a nuestro problema. Como regla general tratamos de pensar como caso base a las condiciones sobre las cuales es m\u00e1s f\u00e1cil resolver nuestro problema. Por ejemplo, si estuvi\u00e9ramos trabajando sobre listas o cadenas probablemente sepamos la respuesta a nuestro problema en el caso de una secuencia vac\u00eda; si estuvi\u00e9ramos trabajando sobre conjuntos de elementos probablemente la respuesta sea evidente para los conjuntos de un solo elemento. Caso recursivo o caso general: Este es el caso que va a efectuar la llamada recursiva. La idea de este caso es reducir el problema a un problema m\u00e1s sencillo, del cual se har\u00e1 cargo la llamada recursiva, y luego poder ensamblar la soluci\u00f3n al problema original. Ampliaremos esto m\u00e1s adelante. Convergencia: Necesitamos que la reducci\u00f3n que se haga en el caso recursivo converja hacia los casos base, de modo que la recursi\u00f3n alguna vez termine. Esto es, si dijimos que el caso base se resolv\u00eda cuando ten\u00edamos una lista vac\u00eda, las operaciones del caso recursivo tienen que reducir reiteradamente la lista hasta que la misma quede vac\u00eda. Si podemos hacer estas tres cosas, tendremos un algoritmo recursivo para nuestro problema. Un primer dise\u00f1o recursivo Supongamos que queremos programar una funci\u00f3n sumar(lista) que determine en forma recursiva la suma de una secuencia lista de n\u00fameros. Como caso base debemos elegir un caso sencillo de verificar. El caso m\u00e1s sencillo de verificar es uno en el que ni siquiera necesitamos computar algo: Si la lista est\u00e1 vac\u00eda es evidente que la suma da cero. Nuestro caso base ser\u00e1 algo as\u00ed como: if len(lista) == 0: return 0 Queremos dise\u00f1ar un paso recursivo que realice una reducci\u00f3n de manera que dada cualquier lista, la aplicaci\u00f3n sucesiva de la reducci\u00f3n seleccionada converja al caso base. Hay muchas maneras de reducir una lista para lograr esto; para este caso vamos a proponer una muy sencilla: sacar el primer elemento. Si cada llamada recursiva saca el primer elemento, tarde o temprano covergeremos a una lista vac\u00eda. Nuestra llamada recursiva podr\u00eda ser algo as\u00ed como: sumar(lista[1:]) Lo m\u00e1s complejo ahora es pensar el caso general. Dijimos que \u00edbamos a retirar un elemento de la lista por vez y hacer una llamada recursiva. Olvid\u00e9monos por un momento de la recursividad e imaginemos que ya tenemos una funci\u00f3n sumar2 que sabe sumar los elementos de una lista y que lo hace bien. Intentemos resolver el problema inverso: si agregamos un elemento x al principio de la lista (obteniendo [x] + lista ), \u00bfpodemos calcular la suma de la nueva lista? \u00bfPodemos resolver el problema m\u00e1s grande con la soluci\u00f3n al problema m\u00e1s peque\u00f1o? La soluci\u00f3n es sencilla: La suma de la lista ampliada ser\u00e1 x m\u00e1s la suma de la lista original (que podemos calcular como sumar2(lista) ). Es decir, la soluci\u00f3n al problema este que planteamos ser\u00eda as\u00ed: def sumar(lista): \"\"\"Precondici\u00f3n: len(lista) >= 1. Devuelve: La suma de los elementos en la lista.\"\"\" return lista[0] + sumar2(lista[1:]) Podemos ver que si tuvi\u00e9ramos implementada sumar2 entonces sumar funcionar\u00eda bien. Volvamos ahora a recursividad: Si sabemos resolver el caso general en funci\u00f3n a la soluci\u00f3n del caso simplificado de la llamada recursiva, si existen casos base que corten la recursi\u00f3n y si adem\u00e1s la recursi\u00f3n converge hacia los casos base tenemos resuelto el problema completo. La funci\u00f3n que asumimos que funcionaba es la misma que acabamos de implementar. Cuando dise\u00f1amos una funci\u00f3n recursiva tenemos que dar este salto de f\u00e9 : asumir que la funci\u00f3n del paso recursivo ya funciona; nosotros lo que vamos a implementar es una funci\u00f3n que logra concatenar el resultado del subproblema y ensamblarlo con nuestro problema mayor. Si hacemos esto bien entonces todo funciona. Finalmente nuestra primera funci\u00f3n recursiva quedar\u00eda: def sumar(lista): \"\"\"Devuelve la suma de los elementos en la lista.\"\"\" res = 0 if len(lista) != 0: res = lista[0] + sumar(lista[1:]) return res Recursi\u00f3n de cola Dentro de los problemas recursivos no siempre es inmediato establecer c\u00f3mo se va a propagar la informaci\u00f3n entre las llamadas recursivas. Es decir, c\u00f3mo va a interactuar la soluci\u00f3n de el o los subproblemas en la soluci\u00f3n del problema general. En todos los ejemplos presentados hasta el momento la informaci\u00f3n del resultado se propag\u00f3 desde las hojas del \u00e1rbol de llamadas (los casos base) hacia las funciones invocantes (mediante la instrucci\u00f3n return ). Por ejemplo, para resolver el resultado de Fibonacci F(5) se utilizan \u00fanicamente los resultados computados por F(4) y F(3) , y no se recibe ning\u00fan dato adicional de la funci\u00f3n invocante (m\u00e1s all\u00e1 del par\u00e1metro n=5 ). Esto no siempre es as\u00ed, en algunos problemas s\u00ed se hace necesario propagar informaci\u00f3n \"hacia abajo\". Y en otros casos, si bien no es necesario, puede tener ventajas adicionales. Por ejemplo, podr\u00edamos reescribir la funci\u00f3n sumar() de esta forma: def sumar(lista, suma = 0): \"\"\"Devuelve la suma de los elementos en la lista.\"\"\" res = suma if len(lista) != 0: res = sumar(lista[1:], lista[0] + suma) return res Puede observarse que en esta implementaci\u00f3n en vez de esperar a que se resuelva el c\u00f3mputo de la parte recursiva para ensamblar la soluci\u00f3n e ir resolviendo los c\u00e1lculos parciales desde el final de la lista hacia el principio, le pasamos la soluci\u00f3n parcial a la llamada recursiva. Finalmente el caso base devuelve la suma de los c\u00e1lculos que se realizaron de principio a final y cada llamada recursiva devuelve este resultado. No profundizaremos m\u00e1s en el tema, pero la particularidad de que lo \u00faltimo que se realice en el caso general sea la llamada recursiva (sin realizar ninguna operaci\u00f3n adicional sobre el resultado de esta llamada) se conoce como recursividad de cola . La recursividad de cola es de inter\u00e9s porque implica muy poco esfuerzo reescribir una versi\u00f3n iterativa y no recursiva del algoritmo. Esto es inmediato: como lo \u00faltimo que se hace es la llamada recursiva entonces no hace falta seguir recordando el contexto de la llamada anterior cuando se hace la siguiente, entonces no es necesario utilizar la pila de ejecuci\u00f3n. El c\u00f3digo anterior puede reescribirse como def sumar(lista): \"\"\"Devuelve la suma de los elementos en la lista.\"\"\" suma = 0 while lista: lista, suma = lista[1:], lista[0] + suma return suma tan solo reemplazando la recursi\u00f3n por un bucle y actualizando las variables seg\u00fan los par\u00e1metros de la llamada recursiva. Modificaci\u00f3n de la firma La firma de una funci\u00f3n es su nombre, m\u00e1s los par\u00e1metros que recibe, m\u00e1s los valores que devuelve. Para invocar una funci\u00f3n cualquiera, es suficiente con saber c\u00f3mo es su firma, y no es necesario saber c\u00f3mo es la implementaci\u00f3n interna. Ahora bien, si cambiamos la lista de par\u00e1metros o el tipo de dato del valor de retorno de la funci\u00f3n, estamos cambiando su firma, y eso nos obliga a cambiar cualquier lugar del c\u00f3digo que contenga alguna llamada a la funci\u00f3n. En el ejemplo de sumar implementada con recursividad de cola nos vimos obligados a modificar la firma de la funci\u00f3n agregando el par\u00e1metro suma que no formaba parte del problema inicial. Pudimos hacerlo elegantemente utilizando un valor por omisi\u00f3n ( suma=0 ), pero la firma de todos modos qued\u00f3 confusa. Hay casos en los que no podemos salvar un cambio en la firma. Por ejemplo, supongamos que queremos dise\u00f1ar una funci\u00f3n recursiva que calcule el promedio de una secuencia de n\u00fameros. Como ya sabemos dise\u00f1ar funciones recursivas, intuimos que el caso base ser\u00e1 cuando la lista tenga un solo elemento y que la reduciremos sacando de a un elemento por vez. El cuerpo de nuestra funci\u00f3n ser\u00e1 algo as\u00ed: def promediar(lista): if len(lista) == 1: res = lista[0] else: res = promediar(lista[1:]) ??? return res Ahora bien, con esto no alcanza para resolver el problema. Para calcular un promedio necesitamos tanto calcular la suma como contar la cantidad de elementos. Entonces, una implementaci\u00f3n recursiva va a estar computando dos valores cuando el resultado del problema es evidentemente uno solo. Si bien puede elaborarse una soluci\u00f3n similar a la que ya ensayamos con sumar complicar\u00eda innecesariamente el c\u00f3digo. Es preferible modificar la firma de la funci\u00f3n. Implementemos el problema resolviendo primero la llamada recursiva (en una funci\u00f3n diferente que llamaremos promediar_aux() ) y luego ensamblando: def promediar_aux(lista): suma = lista[0] cantidad = 1 if len(lista) > 1: suma_resto, cantidad_resto = promediar_aux(lista[1:]) suma += suma_resto cantidad += cantidad_resto return suma, cantidad Puede verse que esta funci\u00f3n cumple con las reglas de dise\u00f1o de recursividad que describimos antes. Con lo que no cumple esta funci\u00f3n es con la firma natural de la funci\u00f3n promediar() que quer\u00edamos dise\u00f1ar, ya que promediar_aux() devuelve dos cosas y no una. Esto no invalida nuestra soluci\u00f3n, pero la misma est\u00e1 incompleta. Lo que debemos hacer es implementar una funci\u00f3n wrapper (envoltorio) que lo que haga es operar como cara visible para le usuarie de la funci\u00f3n que hace realmente el trabajo. A esta funci\u00f3n s\u00ed la vamos a llamar promediar , ya que va a cumplir con la firma deseada: def promediar(lista): \"\"\"Devuelve el promedio de los elementos de una lista de n\u00fameros.\"\"\" def promediar_aux(lista): suma = lista[0] cantidad = 1 if len(lista) > 1: suma_resto, cantidad_resto = promediar_aux(lista[1:]) suma += suma_resto cantidad += cantidad_resto return suma, cantidad suma, cantidad = promediar_aux(lista) return suma / cantidad Notar que si bien la funci\u00f3n visible promediar no es recursiva, s\u00ed lo es la funci\u00f3n promediar_aux que es la que realiza el trabajo, por lo que el conjunto se considera recursivo. Observ\u00e1 que estamos definiendo la funci\u00f3n promediar_aux dentro de la funci\u00f3n promediar de manera que no resulte visible desde afuera (no la pod\u00e9s llamar desde afuera: as\u00ed como hay variables locales , \u00e9sta es una funci\u00f3n local ). Adem\u00e1s de para adaptar la firma de la funci\u00f3n recursiva, las funciones wrapper se suelen utilizar para simplificar el c\u00f3digo de las funciones recursivas. Por ejemplo, si quisi\u00e9ramos hacer validaciones de los par\u00e1metros, no querr\u00edamos que las mismas se reiteraran en cada iteraci\u00f3n recursiva porque consumir\u00edan recursos innecesarios. Entonces las podemos resolver en la funci\u00f3n wrapper, antes de empezar la recursi\u00f3n. Por ejemplo, hace un rato implementamos la potencia en forma recursiva con la restricci\u00f3n n >= 0 . Pero dado que b^n = (1/b)^(-n) podemos aprovechar el c\u00f3digo implementado para resolver para cualquier n entero. Podr\u00edamos modificar el c\u00f3digo de potencia() para incluir este caso, pero se reiterar\u00eda la comprobaci\u00f3n en cada nivel de la recursi\u00f3n. Para este caso resulta m\u00e1s sencillo construir una funci\u00f3n wrapper e incluir ah\u00ed todo lo que consideremos necesario. Habiendo renombrado la funci\u00f3n original como _potencia , nuestro wrapper ser\u00eda: def potencia(b, n): \"\"\"Precondici\u00f3n: n es entero Devuelve: b^n.\"\"\" if n < 0: b = 1 / b n = -n return _potencia(b, n) Limitaciones Si creamos una funci\u00f3n sin caso base , obtendremos el equivalente recursivo de un bucle infinito. \u00c9ste es un bucle infinito y corre para siempre. i = 0 while i < 10: suma = suma + i El bucle recursivo infinito, sin embargo, termina agotando la memoria. Esto se debe a que cada llamada recursiva agrega un elemento a la pila de llamadas a funciones y la memoria de nuestras computadoras no es infinita. En particular, en Python, para evitar que la memoria se termine, la pila de ejecuci\u00f3n de funciones tiene un l\u00edmite. Es decir, que si se ejecuta un c\u00f3digo como el que sigue: def inutil(n): return inutil(n - 1) Se obtendr\u00e1 un resultado como el siguiente: >>> inutil(1) File \"<stdin>\", line 2, in inutil File \"<stdin>\", line 2, in inutil (...) File \"<stdin>\", line 2, in inutil RecursionError: maximum recursion depth exceeded El l\u00edmite por omisi\u00f3n es de 1000 llamadas recursivas. Es posible modificar el tama\u00f1o m\u00e1ximo de la pila de recursi\u00f3n mediante la instrucci\u00f3n sys.setrecursionlimit(n) . Sin embargo, si se est\u00e1 alcanzando este l\u00edmite suele ser una buena idea pensar si realmente el algoritmo recursivo es el que mejor resuelve el problema. Sab\u00edas que Existen algunos lenguajes funcionales , como Haskell, ML, o Scheme, en los cuales la recursi\u00f3n es la \u00fanica forma de realizar un ciclo. Es decir, no existen construcciones while ni for . Estos lenguajes cuentan con optimizaci\u00f3n de recursi\u00f3n de cola, una optimizaci\u00f3n para que cuando se identifique que la recursi\u00f3n es de cola, no se apile el estado de la funci\u00f3n innecesariamente, evitando el consumo adicional de memoria mencionado anteriormente. La ejecuci\u00f3n de todas las funciones con recursi\u00f3n de cola vistas en esta unidad podr\u00eda ser optimizada por el compilador o int\u00e9rprete del lenguaje. Resumen A medida que se realizan llamadas a funciones, el estado de cada funci\u00f3n se almacena en la pila de ejecuci\u00f3n . Esto permite que sea posible que una funci\u00f3n se llame a s\u00ed misma, pero que las variables dentro de la funci\u00f3n tomen distintos valores. La recursi\u00f3n es el proceso en el cual una funci\u00f3n se invoca a s\u00ed misma. Este proceso permite crear un nuevo tipo de ciclos. Siempre que se escribe una funci\u00f3n recursiva es importante considerar el caso base (el que detendr\u00e1 la recursi\u00f3n) y el caso recursivo (el que realizar\u00e1 la llamada recursiva). Una funci\u00f3n recursiva sin caso base es equivalente a un bucle infinito. Una funci\u00f3n no es mejor ni peor por ser recursiva. En cada situaci\u00f3n a resolver puede ser conveniente utilizar una soluci\u00f3n recursiva o una iterativa. Para elegir una o la otra ser\u00e1 necesario analizar las caracter\u00edsticas de elegancia y eficiencia. Al dise\u00f1ar funciones recursivas muchas veces puede ser \u00fatil implementar una funci\u00f3n wrapper , por ejemplo para adaptar la firma de la funci\u00f3n, validar par\u00e1metros, inicializar datos o manejar excepciones. Contenidos | Anterior (2 Intro a la Recursi\u00f3n) | Pr\u00f3ximo (4 Pr\u00e1ctica de Recursi\u00f3n)","title":"03 Diseno Recursivo"},{"location":"11_Recursion/03_Diseno_Recursivo/#113-diseno-de-algoritmos-recursivos","text":"Hasta el momento vimos que hay muchas funciones matem\u00e1ticas que se definen o que pueden desarrollarse de forma recursiva, pero puede aplicarse recursividad a muchos problemas que no sean explicitamente recursivos. Dise\u00f1ar un algoritmo recursivo es un proceso sistematizable. En general, en el proceso para plantear un algoritmo recursivo, necesitamos resolver estos tres problemas: Caso base: Necesitamos definir uno o m\u00e1s casos base de acuerdo a nuestro problema. Como regla general tratamos de pensar como caso base a las condiciones sobre las cuales es m\u00e1s f\u00e1cil resolver nuestro problema. Por ejemplo, si estuvi\u00e9ramos trabajando sobre listas o cadenas probablemente sepamos la respuesta a nuestro problema en el caso de una secuencia vac\u00eda; si estuvi\u00e9ramos trabajando sobre conjuntos de elementos probablemente la respuesta sea evidente para los conjuntos de un solo elemento. Caso recursivo o caso general: Este es el caso que va a efectuar la llamada recursiva. La idea de este caso es reducir el problema a un problema m\u00e1s sencillo, del cual se har\u00e1 cargo la llamada recursiva, y luego poder ensamblar la soluci\u00f3n al problema original. Ampliaremos esto m\u00e1s adelante. Convergencia: Necesitamos que la reducci\u00f3n que se haga en el caso recursivo converja hacia los casos base, de modo que la recursi\u00f3n alguna vez termine. Esto es, si dijimos que el caso base se resolv\u00eda cuando ten\u00edamos una lista vac\u00eda, las operaciones del caso recursivo tienen que reducir reiteradamente la lista hasta que la misma quede vac\u00eda. Si podemos hacer estas tres cosas, tendremos un algoritmo recursivo para nuestro problema.","title":"11.3 Dise\u00f1o de algoritmos recursivos"},{"location":"11_Recursion/03_Diseno_Recursivo/#un-primer-diseno-recursivo","text":"Supongamos que queremos programar una funci\u00f3n sumar(lista) que determine en forma recursiva la suma de una secuencia lista de n\u00fameros. Como caso base debemos elegir un caso sencillo de verificar. El caso m\u00e1s sencillo de verificar es uno en el que ni siquiera necesitamos computar algo: Si la lista est\u00e1 vac\u00eda es evidente que la suma da cero. Nuestro caso base ser\u00e1 algo as\u00ed como: if len(lista) == 0: return 0 Queremos dise\u00f1ar un paso recursivo que realice una reducci\u00f3n de manera que dada cualquier lista, la aplicaci\u00f3n sucesiva de la reducci\u00f3n seleccionada converja al caso base. Hay muchas maneras de reducir una lista para lograr esto; para este caso vamos a proponer una muy sencilla: sacar el primer elemento. Si cada llamada recursiva saca el primer elemento, tarde o temprano covergeremos a una lista vac\u00eda. Nuestra llamada recursiva podr\u00eda ser algo as\u00ed como: sumar(lista[1:]) Lo m\u00e1s complejo ahora es pensar el caso general. Dijimos que \u00edbamos a retirar un elemento de la lista por vez y hacer una llamada recursiva. Olvid\u00e9monos por un momento de la recursividad e imaginemos que ya tenemos una funci\u00f3n sumar2 que sabe sumar los elementos de una lista y que lo hace bien. Intentemos resolver el problema inverso: si agregamos un elemento x al principio de la lista (obteniendo [x] + lista ), \u00bfpodemos calcular la suma de la nueva lista? \u00bfPodemos resolver el problema m\u00e1s grande con la soluci\u00f3n al problema m\u00e1s peque\u00f1o? La soluci\u00f3n es sencilla: La suma de la lista ampliada ser\u00e1 x m\u00e1s la suma de la lista original (que podemos calcular como sumar2(lista) ). Es decir, la soluci\u00f3n al problema este que planteamos ser\u00eda as\u00ed: def sumar(lista): \"\"\"Precondici\u00f3n: len(lista) >= 1. Devuelve: La suma de los elementos en la lista.\"\"\" return lista[0] + sumar2(lista[1:]) Podemos ver que si tuvi\u00e9ramos implementada sumar2 entonces sumar funcionar\u00eda bien. Volvamos ahora a recursividad: Si sabemos resolver el caso general en funci\u00f3n a la soluci\u00f3n del caso simplificado de la llamada recursiva, si existen casos base que corten la recursi\u00f3n y si adem\u00e1s la recursi\u00f3n converge hacia los casos base tenemos resuelto el problema completo. La funci\u00f3n que asumimos que funcionaba es la misma que acabamos de implementar. Cuando dise\u00f1amos una funci\u00f3n recursiva tenemos que dar este salto de f\u00e9 : asumir que la funci\u00f3n del paso recursivo ya funciona; nosotros lo que vamos a implementar es una funci\u00f3n que logra concatenar el resultado del subproblema y ensamblarlo con nuestro problema mayor. Si hacemos esto bien entonces todo funciona. Finalmente nuestra primera funci\u00f3n recursiva quedar\u00eda: def sumar(lista): \"\"\"Devuelve la suma de los elementos en la lista.\"\"\" res = 0 if len(lista) != 0: res = lista[0] + sumar(lista[1:]) return res","title":"Un primer dise\u00f1o recursivo"},{"location":"11_Recursion/03_Diseno_Recursivo/#recursion-de-cola","text":"Dentro de los problemas recursivos no siempre es inmediato establecer c\u00f3mo se va a propagar la informaci\u00f3n entre las llamadas recursivas. Es decir, c\u00f3mo va a interactuar la soluci\u00f3n de el o los subproblemas en la soluci\u00f3n del problema general. En todos los ejemplos presentados hasta el momento la informaci\u00f3n del resultado se propag\u00f3 desde las hojas del \u00e1rbol de llamadas (los casos base) hacia las funciones invocantes (mediante la instrucci\u00f3n return ). Por ejemplo, para resolver el resultado de Fibonacci F(5) se utilizan \u00fanicamente los resultados computados por F(4) y F(3) , y no se recibe ning\u00fan dato adicional de la funci\u00f3n invocante (m\u00e1s all\u00e1 del par\u00e1metro n=5 ). Esto no siempre es as\u00ed, en algunos problemas s\u00ed se hace necesario propagar informaci\u00f3n \"hacia abajo\". Y en otros casos, si bien no es necesario, puede tener ventajas adicionales. Por ejemplo, podr\u00edamos reescribir la funci\u00f3n sumar() de esta forma: def sumar(lista, suma = 0): \"\"\"Devuelve la suma de los elementos en la lista.\"\"\" res = suma if len(lista) != 0: res = sumar(lista[1:], lista[0] + suma) return res Puede observarse que en esta implementaci\u00f3n en vez de esperar a que se resuelva el c\u00f3mputo de la parte recursiva para ensamblar la soluci\u00f3n e ir resolviendo los c\u00e1lculos parciales desde el final de la lista hacia el principio, le pasamos la soluci\u00f3n parcial a la llamada recursiva. Finalmente el caso base devuelve la suma de los c\u00e1lculos que se realizaron de principio a final y cada llamada recursiva devuelve este resultado. No profundizaremos m\u00e1s en el tema, pero la particularidad de que lo \u00faltimo que se realice en el caso general sea la llamada recursiva (sin realizar ninguna operaci\u00f3n adicional sobre el resultado de esta llamada) se conoce como recursividad de cola . La recursividad de cola es de inter\u00e9s porque implica muy poco esfuerzo reescribir una versi\u00f3n iterativa y no recursiva del algoritmo. Esto es inmediato: como lo \u00faltimo que se hace es la llamada recursiva entonces no hace falta seguir recordando el contexto de la llamada anterior cuando se hace la siguiente, entonces no es necesario utilizar la pila de ejecuci\u00f3n. El c\u00f3digo anterior puede reescribirse como def sumar(lista): \"\"\"Devuelve la suma de los elementos en la lista.\"\"\" suma = 0 while lista: lista, suma = lista[1:], lista[0] + suma return suma tan solo reemplazando la recursi\u00f3n por un bucle y actualizando las variables seg\u00fan los par\u00e1metros de la llamada recursiva.","title":"Recursi\u00f3n de cola"},{"location":"11_Recursion/03_Diseno_Recursivo/#modificacion-de-la-firma","text":"La firma de una funci\u00f3n es su nombre, m\u00e1s los par\u00e1metros que recibe, m\u00e1s los valores que devuelve. Para invocar una funci\u00f3n cualquiera, es suficiente con saber c\u00f3mo es su firma, y no es necesario saber c\u00f3mo es la implementaci\u00f3n interna. Ahora bien, si cambiamos la lista de par\u00e1metros o el tipo de dato del valor de retorno de la funci\u00f3n, estamos cambiando su firma, y eso nos obliga a cambiar cualquier lugar del c\u00f3digo que contenga alguna llamada a la funci\u00f3n. En el ejemplo de sumar implementada con recursividad de cola nos vimos obligados a modificar la firma de la funci\u00f3n agregando el par\u00e1metro suma que no formaba parte del problema inicial. Pudimos hacerlo elegantemente utilizando un valor por omisi\u00f3n ( suma=0 ), pero la firma de todos modos qued\u00f3 confusa. Hay casos en los que no podemos salvar un cambio en la firma. Por ejemplo, supongamos que queremos dise\u00f1ar una funci\u00f3n recursiva que calcule el promedio de una secuencia de n\u00fameros. Como ya sabemos dise\u00f1ar funciones recursivas, intuimos que el caso base ser\u00e1 cuando la lista tenga un solo elemento y que la reduciremos sacando de a un elemento por vez. El cuerpo de nuestra funci\u00f3n ser\u00e1 algo as\u00ed: def promediar(lista): if len(lista) == 1: res = lista[0] else: res = promediar(lista[1:]) ??? return res Ahora bien, con esto no alcanza para resolver el problema. Para calcular un promedio necesitamos tanto calcular la suma como contar la cantidad de elementos. Entonces, una implementaci\u00f3n recursiva va a estar computando dos valores cuando el resultado del problema es evidentemente uno solo. Si bien puede elaborarse una soluci\u00f3n similar a la que ya ensayamos con sumar complicar\u00eda innecesariamente el c\u00f3digo. Es preferible modificar la firma de la funci\u00f3n. Implementemos el problema resolviendo primero la llamada recursiva (en una funci\u00f3n diferente que llamaremos promediar_aux() ) y luego ensamblando: def promediar_aux(lista): suma = lista[0] cantidad = 1 if len(lista) > 1: suma_resto, cantidad_resto = promediar_aux(lista[1:]) suma += suma_resto cantidad += cantidad_resto return suma, cantidad Puede verse que esta funci\u00f3n cumple con las reglas de dise\u00f1o de recursividad que describimos antes. Con lo que no cumple esta funci\u00f3n es con la firma natural de la funci\u00f3n promediar() que quer\u00edamos dise\u00f1ar, ya que promediar_aux() devuelve dos cosas y no una. Esto no invalida nuestra soluci\u00f3n, pero la misma est\u00e1 incompleta. Lo que debemos hacer es implementar una funci\u00f3n wrapper (envoltorio) que lo que haga es operar como cara visible para le usuarie de la funci\u00f3n que hace realmente el trabajo. A esta funci\u00f3n s\u00ed la vamos a llamar promediar , ya que va a cumplir con la firma deseada: def promediar(lista): \"\"\"Devuelve el promedio de los elementos de una lista de n\u00fameros.\"\"\" def promediar_aux(lista): suma = lista[0] cantidad = 1 if len(lista) > 1: suma_resto, cantidad_resto = promediar_aux(lista[1:]) suma += suma_resto cantidad += cantidad_resto return suma, cantidad suma, cantidad = promediar_aux(lista) return suma / cantidad Notar que si bien la funci\u00f3n visible promediar no es recursiva, s\u00ed lo es la funci\u00f3n promediar_aux que es la que realiza el trabajo, por lo que el conjunto se considera recursivo. Observ\u00e1 que estamos definiendo la funci\u00f3n promediar_aux dentro de la funci\u00f3n promediar de manera que no resulte visible desde afuera (no la pod\u00e9s llamar desde afuera: as\u00ed como hay variables locales , \u00e9sta es una funci\u00f3n local ). Adem\u00e1s de para adaptar la firma de la funci\u00f3n recursiva, las funciones wrapper se suelen utilizar para simplificar el c\u00f3digo de las funciones recursivas. Por ejemplo, si quisi\u00e9ramos hacer validaciones de los par\u00e1metros, no querr\u00edamos que las mismas se reiteraran en cada iteraci\u00f3n recursiva porque consumir\u00edan recursos innecesarios. Entonces las podemos resolver en la funci\u00f3n wrapper, antes de empezar la recursi\u00f3n. Por ejemplo, hace un rato implementamos la potencia en forma recursiva con la restricci\u00f3n n >= 0 . Pero dado que b^n = (1/b)^(-n) podemos aprovechar el c\u00f3digo implementado para resolver para cualquier n entero. Podr\u00edamos modificar el c\u00f3digo de potencia() para incluir este caso, pero se reiterar\u00eda la comprobaci\u00f3n en cada nivel de la recursi\u00f3n. Para este caso resulta m\u00e1s sencillo construir una funci\u00f3n wrapper e incluir ah\u00ed todo lo que consideremos necesario. Habiendo renombrado la funci\u00f3n original como _potencia , nuestro wrapper ser\u00eda: def potencia(b, n): \"\"\"Precondici\u00f3n: n es entero Devuelve: b^n.\"\"\" if n < 0: b = 1 / b n = -n return _potencia(b, n)","title":"Modificaci\u00f3n de la firma"},{"location":"11_Recursion/03_Diseno_Recursivo/#limitaciones","text":"Si creamos una funci\u00f3n sin caso base , obtendremos el equivalente recursivo de un bucle infinito. \u00c9ste es un bucle infinito y corre para siempre. i = 0 while i < 10: suma = suma + i El bucle recursivo infinito, sin embargo, termina agotando la memoria. Esto se debe a que cada llamada recursiva agrega un elemento a la pila de llamadas a funciones y la memoria de nuestras computadoras no es infinita. En particular, en Python, para evitar que la memoria se termine, la pila de ejecuci\u00f3n de funciones tiene un l\u00edmite. Es decir, que si se ejecuta un c\u00f3digo como el que sigue: def inutil(n): return inutil(n - 1) Se obtendr\u00e1 un resultado como el siguiente: >>> inutil(1) File \"<stdin>\", line 2, in inutil File \"<stdin>\", line 2, in inutil (...) File \"<stdin>\", line 2, in inutil RecursionError: maximum recursion depth exceeded El l\u00edmite por omisi\u00f3n es de 1000 llamadas recursivas. Es posible modificar el tama\u00f1o m\u00e1ximo de la pila de recursi\u00f3n mediante la instrucci\u00f3n sys.setrecursionlimit(n) . Sin embargo, si se est\u00e1 alcanzando este l\u00edmite suele ser una buena idea pensar si realmente el algoritmo recursivo es el que mejor resuelve el problema.","title":"Limitaciones"},{"location":"11_Recursion/03_Diseno_Recursivo/#sabias-que","text":"Existen algunos lenguajes funcionales , como Haskell, ML, o Scheme, en los cuales la recursi\u00f3n es la \u00fanica forma de realizar un ciclo. Es decir, no existen construcciones while ni for . Estos lenguajes cuentan con optimizaci\u00f3n de recursi\u00f3n de cola, una optimizaci\u00f3n para que cuando se identifique que la recursi\u00f3n es de cola, no se apile el estado de la funci\u00f3n innecesariamente, evitando el consumo adicional de memoria mencionado anteriormente. La ejecuci\u00f3n de todas las funciones con recursi\u00f3n de cola vistas en esta unidad podr\u00eda ser optimizada por el compilador o int\u00e9rprete del lenguaje.","title":"Sab\u00edas que"},{"location":"11_Recursion/03_Diseno_Recursivo/#resumen","text":"A medida que se realizan llamadas a funciones, el estado de cada funci\u00f3n se almacena en la pila de ejecuci\u00f3n . Esto permite que sea posible que una funci\u00f3n se llame a s\u00ed misma, pero que las variables dentro de la funci\u00f3n tomen distintos valores. La recursi\u00f3n es el proceso en el cual una funci\u00f3n se invoca a s\u00ed misma. Este proceso permite crear un nuevo tipo de ciclos. Siempre que se escribe una funci\u00f3n recursiva es importante considerar el caso base (el que detendr\u00e1 la recursi\u00f3n) y el caso recursivo (el que realizar\u00e1 la llamada recursiva). Una funci\u00f3n recursiva sin caso base es equivalente a un bucle infinito. Una funci\u00f3n no es mejor ni peor por ser recursiva. En cada situaci\u00f3n a resolver puede ser conveniente utilizar una soluci\u00f3n recursiva o una iterativa. Para elegir una o la otra ser\u00e1 necesario analizar las caracter\u00edsticas de elegancia y eficiencia. Al dise\u00f1ar funciones recursivas muchas veces puede ser \u00fatil implementar una funci\u00f3n wrapper , por ejemplo para adaptar la firma de la funci\u00f3n, validar par\u00e1metros, inicializar datos o manejar excepciones. Contenidos | Anterior (2 Intro a la Recursi\u00f3n) | Pr\u00f3ximo (4 Pr\u00e1ctica de Recursi\u00f3n)","title":"Resumen"},{"location":"11_Recursion/05_EjerciciosRec/","text":"Contenidos | Anterior (3 Dise\u00f1o de algoritmos recursivos) | Pr\u00f3ximo (5 Regresi\u00f3n lineal) 11.4 Pr\u00e1ctica de Recursi\u00f3n Ejercicios Ejercicio 11.2: N\u00fameros triangulares Escrib\u00ed una funci\u00f3n que calcule recursivamente el n-\u00e9simo n\u00famero triangular (es decir, el n\u00famero 1 + 2 + 3 + ... + n ). Fijate que este ejercicio es un caso particular de la funci\u00f3n sumar_enteros(desde, hasta) que implementaste en el Ejercicio 7.6 . La implementaci\u00f3n que hiciste en el primer inciso de ese ejercicio es una forma de reemplazar la recursi\u00f3n por un ciclo. La implementaci\u00f3n que hiciste en el segundo inciso es mucho m\u00e1s eficiente. Ejercicio 11.3: D\u00edgitos Escrib\u00ed una funci\u00f3n recursiva que reciba un n\u00famero positivo, n, y devuelva la cantidad de d\u00edgitos que tiene. Ejercicio 11.4: Potencias Escrib\u00ed una funci\u00f3n recursiva que reciba 2 enteros, n y b , y devuelva True si n es potencia de b . Ejemplos: es_potencia(8, 2) -> True es_potencia(64, 4) -> True es_potencia(70, 10) -> False es_potencia(1, 2) -> True Ejercicio 11.5: Subcadenas Escrib\u00ed una funcion recursiva que reciba como par\u00e1metros dos cadenas a y b , y devuelva una lista con las posiciones en donde se encuentra b dentro de a . Ejemplo: posiciones_de('Un tete a tete con Tete', 'te') -> [3, 5, 10, 12, 21] Ejercicio 11.6: Paridad Escrib\u00ed dos funciones mutualmente recursivas par(n) e impar(n) que determinen la paridad del numero natural dado, usando solo que: 1 es impar. Un n\u00famero mayor que uno es impar (resp. par) si su antecesor es par (resp. impar). Ejercicio 11.7: M\u00e1ximo Escrib\u00ed una funcion recursiva que encuentre el mayor elemento de una lista (sin usar max() ). Ejercicio 11.8: Replicar Escrib\u00ed una funci\u00f3n recursiva para replicar los elementos de una lista una cantidad n de veces. Por ejemplo: replicar([1, 3, 3, 7], 2) -> ([1, 1, 3, 3, 3, 3, 7, 7]) Sugerencia: hac\u00e9 la recursi\u00f3n en el largo de la lista. Ejercicio 11.9: Pascal El tri\u00e1ngulo de Pascal es un arreglo triangular de n\u00fameros que se define de la siguiente manera: Las filas se enumeran desde n = 0 , de arriba hacia abajo. Los valores de cada fila se enumeran desde k = 0 (de izquierda a derecha). Los valores que se encuentran en los bordes del tri\u00e1ngulo son todos unos. Cualquier otro valor se calcula sumando los dos valores contiguos de la fila de arriba. Escrib\u00ed la funci\u00f3n recursiva pascal(n, k) que calcula el valor que se encuentra en la fila n y la columna k . Guard\u00e1 tu funci\u00f3n en el archivo larenga.py para entregar. Ejemplo: >>> pascal(5, 2) 10 Ejercicio 11.10: Combinatorios Escrib\u00ed una funci\u00f3n recursiva que reciba una lista de caracteres \u00fanicos, y un n\u00famero k , e imprima todas las posibles cadenas de longitud k formadas con los caracteres dados (permitiendo caracteres repetidos). Ejemplo: >>> combinaciones(['a', 'b', 'c'], 2) aa ab ac ba bb bc ca cb cc Ejercicio 11.11: B\u00fasqueda binaria Escrib\u00ed una funci\u00f3n recursiva que implemente la b\u00fasqueda binaria de un elemento e en una lista ordenada lista . La funci\u00f3n debe devolver simplemente True o False indicando si el elemento est\u00e1 o no en la lista. Para esto complet\u00e1 el siguiente c\u00f3digo: def bbinaria_rec(lista, e): if len(lista) == 0: res = False elif len(lista) == 1: res = lista[0] == e else: medio = len(lista)//2 # completar return res Guard\u00e1 tu soluci\u00f3n en el archivo bbin_rec.py . Ejercicio 11.12: Envolviendo a Fibonacci Como vimos, la implementaci\u00f3n recursiva inmediata del c\u00e1lculo del n\u00famero de Fibonacci (F(n) = F(n-1) + F_(n-2), F(0) = 0, F(1)= 1) es ineficiente porque muchas de las ramas calculan reiteradamente los mismos valores. Escrib\u00ed una funci\u00f3n fibonacci(n) que calcule el n -\u00e9simo n\u00famero de Fibonacci de forma recursiva pero que utilice un diccionario para almacenar los valores ya computados y no computarlos m\u00e1s de una vez. Observaci\u00f3n : Ser\u00e1 necesario implementar una funci\u00f3n wrapper (es decir, una funci\u00f3n que envuelva a otra) para cumplir con la firma de la funci\u00f3n pedida. Pod\u00e9s trabajar en un script en blanco o completar el siguiente c\u00f3digo. def fibonacci(n): \"\"\" Toma un entero positivo n y devuelve el n-\u00e9simo n\u00famero de Fibonacci donde F(0) = 0 y F(1) = 1. \"\"\" def fibonacci_aux(n, dict_fibo): \"\"\" Calcula el n-\u00e9simo n\u00famero de Fibonacci de forma recursiva utilizando un diccionario para almacenar los valores ya computados. dict_fibo es un diccionario que guarda en la clave 'k' el valor de F(k) \"\"\" if n in dict_fibo.keys(): F = dict_fibo[n] else: ?? # completar return ?? # completar dict_fibo = {0:0, 1:1} F, dict_fibo = fibonacci_aux(n, dict_fibo) return F Guardala en el archivo fibonacci_envuelto.py . Ejercicio 11.13: Hojas ISO y recursi\u00f3n La norma ISO 216 especifica tama\u00f1os de papel. Es el est\u00e1ndar que define el popular tama\u00f1o de papel A4 (210 mm de ancho y 297 mm de largo). Las hojas A0 miden 841 mm de ancho y 1189 mm de largo. A partir de la A0 las siguientes medidas, digamos la A(N+1), se definen doblando al medio la hoja A(N). Siempre se miden en mil\u00edmetros con n\u00fameros enteros: entonces la hoja A1 mide 594 mm de ancho (y no 594.5) por 841 mm de largo. Escrib\u00ed una funci\u00f3n recursiva que para una entrada N mayor que cero, devuelva el ancho y el largo de la hoja A(N) calculada recursivamente a partir de las medidas de la hoja A(N\u22121), usando la hoja A0 como caso base. Guardala en el archivo hojas_ISO.py . Contenidos | Anterior (3 Dise\u00f1o de algoritmos recursivos) | Pr\u00f3ximo (5 Regresi\u00f3n lineal)","title":"05 EjerciciosRec"},{"location":"11_Recursion/05_EjerciciosRec/#114-practica-de-recursion","text":"","title":"11.4 Pr\u00e1ctica de Recursi\u00f3n"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicios","text":"","title":"Ejercicios"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicio-112-numeros-triangulares","text":"Escrib\u00ed una funci\u00f3n que calcule recursivamente el n-\u00e9simo n\u00famero triangular (es decir, el n\u00famero 1 + 2 + 3 + ... + n ). Fijate que este ejercicio es un caso particular de la funci\u00f3n sumar_enteros(desde, hasta) que implementaste en el Ejercicio 7.6 . La implementaci\u00f3n que hiciste en el primer inciso de ese ejercicio es una forma de reemplazar la recursi\u00f3n por un ciclo. La implementaci\u00f3n que hiciste en el segundo inciso es mucho m\u00e1s eficiente.","title":"Ejercicio 11.2: N\u00fameros triangulares"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicio-113-digitos","text":"Escrib\u00ed una funci\u00f3n recursiva que reciba un n\u00famero positivo, n, y devuelva la cantidad de d\u00edgitos que tiene.","title":"Ejercicio 11.3: D\u00edgitos"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicio-114-potencias","text":"Escrib\u00ed una funci\u00f3n recursiva que reciba 2 enteros, n y b , y devuelva True si n es potencia de b . Ejemplos: es_potencia(8, 2) -> True es_potencia(64, 4) -> True es_potencia(70, 10) -> False es_potencia(1, 2) -> True","title":"Ejercicio 11.4: Potencias"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicio-115-subcadenas","text":"Escrib\u00ed una funcion recursiva que reciba como par\u00e1metros dos cadenas a y b , y devuelva una lista con las posiciones en donde se encuentra b dentro de a . Ejemplo: posiciones_de('Un tete a tete con Tete', 'te') -> [3, 5, 10, 12, 21]","title":"Ejercicio 11.5: Subcadenas"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicio-116-paridad","text":"Escrib\u00ed dos funciones mutualmente recursivas par(n) e impar(n) que determinen la paridad del numero natural dado, usando solo que: 1 es impar. Un n\u00famero mayor que uno es impar (resp. par) si su antecesor es par (resp. impar).","title":"Ejercicio 11.6: Paridad"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicio-117-maximo","text":"Escrib\u00ed una funcion recursiva que encuentre el mayor elemento de una lista (sin usar max() ).","title":"Ejercicio 11.7: M\u00e1ximo"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicio-118-replicar","text":"Escrib\u00ed una funci\u00f3n recursiva para replicar los elementos de una lista una cantidad n de veces. Por ejemplo: replicar([1, 3, 3, 7], 2) -> ([1, 1, 3, 3, 3, 3, 7, 7]) Sugerencia: hac\u00e9 la recursi\u00f3n en el largo de la lista.","title":"Ejercicio 11.8: Replicar"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicio-119-pascal","text":"El tri\u00e1ngulo de Pascal es un arreglo triangular de n\u00fameros que se define de la siguiente manera: Las filas se enumeran desde n = 0 , de arriba hacia abajo. Los valores de cada fila se enumeran desde k = 0 (de izquierda a derecha). Los valores que se encuentran en los bordes del tri\u00e1ngulo son todos unos. Cualquier otro valor se calcula sumando los dos valores contiguos de la fila de arriba. Escrib\u00ed la funci\u00f3n recursiva pascal(n, k) que calcula el valor que se encuentra en la fila n y la columna k . Guard\u00e1 tu funci\u00f3n en el archivo larenga.py para entregar. Ejemplo: >>> pascal(5, 2) 10","title":"Ejercicio 11.9: Pascal"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicio-1110-combinatorios","text":"Escrib\u00ed una funci\u00f3n recursiva que reciba una lista de caracteres \u00fanicos, y un n\u00famero k , e imprima todas las posibles cadenas de longitud k formadas con los caracteres dados (permitiendo caracteres repetidos). Ejemplo: >>> combinaciones(['a', 'b', 'c'], 2) aa ab ac ba bb bc ca cb cc","title":"Ejercicio 11.10: Combinatorios"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicio-1111-busqueda-binaria","text":"Escrib\u00ed una funci\u00f3n recursiva que implemente la b\u00fasqueda binaria de un elemento e en una lista ordenada lista . La funci\u00f3n debe devolver simplemente True o False indicando si el elemento est\u00e1 o no en la lista. Para esto complet\u00e1 el siguiente c\u00f3digo: def bbinaria_rec(lista, e): if len(lista) == 0: res = False elif len(lista) == 1: res = lista[0] == e else: medio = len(lista)//2 # completar return res Guard\u00e1 tu soluci\u00f3n en el archivo bbin_rec.py .","title":"Ejercicio 11.11: B\u00fasqueda binaria"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicio-1112-envolviendo-a-fibonacci","text":"Como vimos, la implementaci\u00f3n recursiva inmediata del c\u00e1lculo del n\u00famero de Fibonacci (F(n) = F(n-1) + F_(n-2), F(0) = 0, F(1)= 1) es ineficiente porque muchas de las ramas calculan reiteradamente los mismos valores. Escrib\u00ed una funci\u00f3n fibonacci(n) que calcule el n -\u00e9simo n\u00famero de Fibonacci de forma recursiva pero que utilice un diccionario para almacenar los valores ya computados y no computarlos m\u00e1s de una vez. Observaci\u00f3n : Ser\u00e1 necesario implementar una funci\u00f3n wrapper (es decir, una funci\u00f3n que envuelva a otra) para cumplir con la firma de la funci\u00f3n pedida. Pod\u00e9s trabajar en un script en blanco o completar el siguiente c\u00f3digo. def fibonacci(n): \"\"\" Toma un entero positivo n y devuelve el n-\u00e9simo n\u00famero de Fibonacci donde F(0) = 0 y F(1) = 1. \"\"\" def fibonacci_aux(n, dict_fibo): \"\"\" Calcula el n-\u00e9simo n\u00famero de Fibonacci de forma recursiva utilizando un diccionario para almacenar los valores ya computados. dict_fibo es un diccionario que guarda en la clave 'k' el valor de F(k) \"\"\" if n in dict_fibo.keys(): F = dict_fibo[n] else: ?? # completar return ?? # completar dict_fibo = {0:0, 1:1} F, dict_fibo = fibonacci_aux(n, dict_fibo) return F Guardala en el archivo fibonacci_envuelto.py .","title":"Ejercicio 11.12: Envolviendo a Fibonacci"},{"location":"11_Recursion/05_EjerciciosRec/#ejercicio-1113-hojas-iso-y-recursion","text":"La norma ISO 216 especifica tama\u00f1os de papel. Es el est\u00e1ndar que define el popular tama\u00f1o de papel A4 (210 mm de ancho y 297 mm de largo). Las hojas A0 miden 841 mm de ancho y 1189 mm de largo. A partir de la A0 las siguientes medidas, digamos la A(N+1), se definen doblando al medio la hoja A(N). Siempre se miden en mil\u00edmetros con n\u00fameros enteros: entonces la hoja A1 mide 594 mm de ancho (y no 594.5) por 841 mm de largo. Escrib\u00ed una funci\u00f3n recursiva que para una entrada N mayor que cero, devuelva el ancho y el largo de la hoja A(N) calculada recursivamente a partir de las medidas de la hoja A(N\u22121), usando la hoja A0 como caso base. Guardala en el archivo hojas_ISO.py . Contenidos | Anterior (3 Dise\u00f1o de algoritmos recursivos) | Pr\u00f3ximo (5 Regresi\u00f3n lineal)","title":"Ejercicio 11.13: Hojas ISO y recursi\u00f3n"},{"location":"11_Recursion/05_Regresion_Lineal/","text":"Contenidos | Anterior (4 Pr\u00e1ctica de Recursi\u00f3n) | Pr\u00f3ximo (6 Cierre de la clase de Recursi\u00f3n y Regresi\u00f3n) 11.5 Regresi\u00f3n lineal En esta secci\u00f3n vamos a trabajar con regresi\u00f3n lineal , tema que introducimos en este video . No es una clase con todos los fundamentos del tema, sino un acercamiento pr\u00e1ctico a las t\u00e9cnicas y sus formas de uso en Python. Para un desarrollo m\u00e1s profundo te recomendamos por ejemplo las notas de Andrew Ng . Regresi\u00f3n lineal simple Supongamos que queremos modelar la relaci\u00f3n entre dos variables reales mediante un modelo lineal. Y que vamos a ajustar los par\u00e1metros de ese modelos a partir de ciertos valores conocidos (mediciones, digamos). Es decir que vamos a estar pensando que las variables tienen una relaci\u00f3n lineal, Y = a*X + b , donde X es la variable explicativa (sus componentes se denominan independientes o regresores ), e Y es la variable a explicar (tambi\u00e9n denominada dependiente o regresando ). A partir de un conjunto de datos de tipo (x_i, y_i) , planteamos el modelo Y = a*X + b . En general el modelo no va a ser exacto, es decir, no se va a complir que y_i = a*x_i + b para los valores (x_i, y_i) (salvo que est\u00e9n, justamente, todos los valores sobre una l\u00ednea recta). En general, dec\u00edamos, vamos a tener que y_i = a*x_i + b + r_i donde, los valores r_i , llamados residuos , representan las diferencias entre los valores de la recta en cada valor de x que tenemos y los valores de y asociados. El problema de regresi\u00f3n lineal consiste en elegir los par\u00e1metros a, b de la recta (es decir, su pendiente y ordenada al origen), de manera que la recta sea la que mejor se adapte a los datos disponibles. import numpy as np import matplotlib.pyplot as plt x = np.array([55.0, 38, 68, 70, 53, 46, 11, 16, 20, 4]) y = np.array([153.0, 98, 214, 220, 167, 145, 41, 63, 65, 25]) g = plt.scatter(x = x, y = y) plt.title('scatterplot de los datos') plt.show() \u00bfQu\u00e9 quiere decir mejor ? Vamos a considerar el criterio de cuadrados m\u00ednimos. Criterio de cuadrados m\u00ednimos Vamos a elegir como mejor recta a la que minimice los residuos. M\u00e1s precisamente, vamos a elegir la recta de manera tal que la suma de los cuadrados de los residuos sea m\u00ednima. Anal\u00edticamente, buscamos a, b tales que minimicen la siguiente suma de cuadrados: Usar cuadrados m\u00ednimos tiene m\u00faltiples motivaciones que no podemos detallar adecuadamente ac\u00e1. Solo mencionaremos dos hechos importantes relacionados con su frecuente elecci\u00f3n: Por un lado, minimizar el error cuadr\u00e1tico medio puede resolverse derivando la f\u00f3rmula del error. Los que sepan algo de an\u00e1lisis matem\u00e1tico, recordar\u00e1n que la derivada nos permite encontrar m\u00ednimos y que la derivada de una funci\u00f3n cuadr\u00e1tica es una funci\u00f3n lineal. Por lo tanto, encontrar la recta que mejor ajusta los datos se reduce a buscar el cero de una derivada que en el fondo se reduce a resolver un sistema lineal, algo que sabemos hacer muy bien y muy r\u00e1pido. Si en lugar de minimizar la suma de los cuadrados de los residuos plante\u00e1ramos, por ejemplo, minimizar la suma de los valores absolutos de los residuos no podr\u00edamos encontrar la recta que mejor ajusta tan f\u00e1cilmente. Otro argumento muy fuerte, de naturaleza estad\u00edstica en este caso, es que si uno considera que los residuos son por ejemplo errores de medici\u00f3n y que tienen una distribuci\u00f3n normal (una gaussiana), entonces puede mostrarse que la recta que da el m\u00e9todo de los cuadrados m\u00ednimos es la recta de m\u00e1xima verosimilitud . Estas cosas se explican muy bien en el apunte de Andrew Ng que citamos antes. Record\u00e1 que en la Secci\u00f3n 5.2 vimos que calcular el promedio de estos errores cuadr\u00e1ticos es muy sencillo en numpy. Tambi\u00e9n pod\u00e9s usar la funci\u00f3n mean_squared_error del m\u00f3dulo sklearn.metrics que trae muchas m\u00e9tricas muy \u00fatiles. Ejemplo: el modelo de cuadrados m\u00ednimos Para los datos que graficamos antes, \u00e9sta es la mejor recta , es decir, la que minimiza la suma de los cuadrados de los residuos. Vamos a decir que esta recta es el ajuste lineal de los datos . \u00bfC\u00f3mo se encuentran estos coeficientes? Ajuste del modelo de cuadrados m\u00ednimos Como buscamos el m\u00ednimo de la expresi\u00f3n podemos derivar respecto de los par\u00e1metros a, b e igualar a cero para despejarlos. No es una cuenta d\u00edficil. El \u00fanico cero que va a tener la derivada se corresponde con un m\u00ednimo (porque la recta se puede ajustar tan mal como uno quiera ). De esta manera se obtienen las siguientes f\u00f3rmulas para el ajuste: def ajuste_lineal_simple(x,y): a = sum(((x - x.mean())*(y-y.mean()))) / sum(((x-x.mean())**2)) b = y.mean() - a*x.mean() return a, b Ejemplo: datos sint\u00e9ticos Veamos un ejemplo generado con datos sint\u00e9ticos. Generamos 50 datos para la variable x , y determinamos a la variable y con una relaci\u00f3n lineal m\u00e1s un error normal. import numpy as np N = 50 minx = 0 maxx = 500 x = np.random.uniform(minx, maxx, N) r = np.random.normal(0, 25, N) # residuos simulados y = 1.3*x + r g = plt.scatter(x = x, y = y) plt.title('gr\u00e1fico de dispersi\u00f3n de los datos') plt.xlabel('x') plt.ylabel('y') plt.show() Ahora ajustamos con las f\u00f3rmulas que vimos antes: a, b = ajuste_lineal_simple(x, y) grilla_x = np.linspace(start = minx, stop = maxx, num = 1000) grilla_y = grilla_x*a + b g = plt.scatter(x = x, y = y) plt.title('y ajuste lineal') plt.plot(grilla_x, grilla_y, c = 'green') plt.xlabel('x') plt.ylabel('y') plt.show() Ejercicio 11.14: precio_alquiler ~ superficie Consideramos datos de precios (en miles de pesos) de alquiler mensual de departamentos en el barrio de Caballito, CABA, y sus superficies (en metros cuadrados). Queremos modelar el precio de alquiler a partir de la superficie para este barrio. A veces este modelo se nota con precio_alquiler ~ superficie . Usando la funci\u00f3n que definimos antes, ajust\u00e1 los datos con una recta. Grafic\u00e1 los datos junto con la recta del ajuste. superficie = np.array([150.0, 120.0, 170.0, 80.0]) alquiler = np.array([35.0, 29.6, 37.4, 21.0]) Una forma de cuantificar cu\u00e1n bien ajusta la recta es considerar el promedio de los errores cuadr\u00e1ticos, llamado error cuadr\u00e1tico medio . errores = alquiler - (a*superficie + b) print(errores) print(\"ECM:\", (errores**2).mean()) Calcul\u00e1 el error cuadr\u00e1tico medio del ajuste que hiciste reci\u00e9n. Guard\u00e1 tu c\u00f3digo en el archivo alquiler.py para entregar. Ejemplo: relaci\u00f3n cuadr\u00e1tica Veamos qu\u00e9 pasa si los datos guardan en realidad una relaci\u00f3n cuadr\u00e1tica. Generemos aletoriamente variables independientes y dependientes con este tipo de relaci\u00f3n. np.random.seed(3141) # semilla para fijar la aleatoriedad N=50 indep_vars = np.random.uniform(size = N, low = 0, high = 10) r = np.random.normal(size = N, loc = 0.0, scale = 8.0) # residuos dep_vars = 2 + 3*indep_vars + 2*indep_vars**2 + r # relaci\u00f3n cuadr\u00e1tica Grafiquemos los datos obtenidos y, por comodidad, llam\u00e9moslos x e y . x = indep_vars y = dep_vars plt.scatter(x,y) plt.title('scatterplot de los datos') plt.show() Y ajustemos un modelo lineal (notado: y ~ x ) a estos datos. a, b = ajuste_lineal_simple(x, y) grilla_x = np.linspace(start = 0, stop = 10, num = 1000) grilla_y = grilla_x*a + b g = plt.scatter(x = x , y = y) plt.title('ajuste lineal') plt.plot(grilla_x, grilla_y, c = 'green') plt.show() Veamos cu\u00e1nto vale el error cuadr\u00e1tico medio. errores = y - (x*a + b) print(\"ECM\", (errores**2).mean()) Parte optativa: Ahora vamos a profundizar en algunos conceptos y a ver maneras alternativas de hacer las cosas. Lo que sigue es optativo. Ejemplo: prec\u00f3mputo de atributos adecuados Es natural pensar que aproximar una par\u00e1bola con un modelo lineal no es lo m\u00e1s sensato. Un modelo alternativo es usar como variable explicativa x^2 en vez de x . El c\u00f3mputo de xc = x^2 se realiza en un paso previo de forma que el modelo sigue siendo lineal (ahora lineal en x^2 ). Esto significa que el formalismo matem\u00e1tico para encontrar los coeficientes del nuevo modelo es el mismo que antes. xc = x**2 ap, bp = ajuste_lineal_simple(xc, y) grilla_y_p = (grilla_x**2)*ap + bp plt.scatter(x,y) plt.plot(grilla_x, grilla_y, c = 'green') plt.plot(grilla_x, grilla_y_p, c = 'red') plt.title('ajuste lineal con x^2') plt.show() Y si queremos cuantificar el error en este modelo: yhat = (x**2)*ap + bp # valores estimados residuos = y - yhat # diferencia entre el valor original y el estimado ecm = (residuos**2).mean() # error cuadr\u00e1tico medio print(\"ECM:\", ecm) Al usar x^2 en lugar de x mejora sustancialmente la bondad de ajuste del modelo (notado: y ~ x^2 ). Veremos pr\u00f3ximamente que podemos usar ambas x y x^2 como variables explicativas y obtener un ajuste a\u00fan mejor de los datos. Ra\u00edz del error cuadr\u00e1tico medio : Una alternativa al error cuadr\u00e1tico medio es su ra\u00edz cuadrada, conocida como root mean squared error (RMSE). La ventaja de esta medida de la bondad de ajuste de un modelo a los datos radica en que \u00e9sta se expresa en las misma unidades que la variable a explicar, y, mientras que el ECM (MSE) se expresa en unidades al cuadrado . Siendo la ra\u00edz una funci\u00f3n mon\u00f3tona, minimizar una m\u00e9trica o la otra es equivalente. Scikit-Learn La biblioteca scikit-learn tiene herramientas muy \u00fatiles para el an\u00e1lisis de datos y el desarrollo de modelos de aprendizaje autom\u00e1tico, aunque se mantiene relativamente alejada de la inferencia estad\u00edstica. En particular, para regresi\u00f3n lineal tiene el m\u00f3dulo linear_model , y en el siguiente ejemplo mostramos c\u00f3mo puede usarse. Para les que est\u00e9n habituades al lenguaje R, quiz\u00e1s les conviene usar la biblioteca stastmodels que tiene un funcionamiento m\u00e1s cercano. Al igual que el modelo de clustering que usamos en el Ejercicio 9.19 de teledetecci\u00f3n, el objeto de tipo LinearRegression de sklearn.liearmodel tambi\u00e9n tiene un m\u00e9todo fit() que permite ajustar el modelo a los datos y otro predict() que permite usar el modelo ajustado con nuevos datos. Ac\u00e1 rehacemos el primer ejemplo que dimos ( Secci\u00f3n 11.5 ), usando pandas y el m\u00f3dulo linear_model . import pandas as pd from sklearn import linear_model x = np.array([55.0, 38, 68, 70, 53, 46, 11, 16, 20, 4]) # mismos datos x, y y = np.array([153.0, 98, 214, 220, 167, 145, 41, 63, 65, 25]) datosxy = pd.DataFrame({'x': x, 'y': y}) # paso los datos a un dataframe ajus = linear_model.LinearRegression() # llamo al modelo de regresi\u00f3n lineal ajus.fit(datosxy[['x']], datosxy['y']) # ajusto el modelo grilla_x = np.linspace(start = 0, stop = 70, num = 1000) grilla_y = ajus.predict(grilla_x.reshape(-1,1)) datosxy.plot.scatter('x','y') plt.title('ajuste lineal usando sklearn') plt.plot(grilla_x, grilla_y, c = 'green') plt.show() Usamos el m\u00e9todo fit() para ajustar el modelo y el m\u00e9todo predict() para obtener los valores de y de la recta. Fijate que al m\u00e9todo fit le pasamos el Dataframe datosxy[['x']] y no la serie datosxy['x'] ya que el m\u00e9todo est\u00e1 preparado para trabajar con regresiones m\u00faltiples (es decir, ten\u00e9s muchos regresores). Regresi\u00f3n Lineal M\u00faltiple La regresi\u00f3n lineal m\u00faltiple tiene un planteo similar, pero con m\u00e1s variables explicativas. El modelo es el siguiente. Ejemplo: superficie y antig\u00fcedad Trabajamos nuevamente con los departamentos, ahora tambi\u00e9n conociendo su antig\u00fcedad, y la tomamos como otra variable explicativa. Ajustaremos un modelo que tenga en cuenta ambas variables, y lo notaremos: precio_alquiler ~ superficie + antig\u00fcedad superficie = np.array([150.0, 120.0, 170.0, 80.0]) alquiler = np.array([35.0, 29.6, 37.4, 21.0]) antig\u00fcedad = [50.0, 5.0, 25.0, 70.0] data_deptos = pd.DataFrame({'alquiler': alquiler, 'superficie': superficie, 'antig\u00fcedad': antig\u00fcedad}) X = pd.concat([data_deptos.superficie,data_deptos.antig\u00fcedad], axis = 1) ajuste_deptos = linear_model.LinearRegression() ajuste_deptos.fit(X,data_deptos.alquiler) errores = data_deptos.alquiler - (ajuste_deptos.predict(X)) print(errores) print(\"ECM:\", (errores**2).mean()) # error cuadr\u00e1tico medio Usando los atributos intercept_ y coef_ de ajuste_deptos escrib\u00ed a mano la f\u00f3rmula de la regresi\u00f3n m\u00faltiple obtenida y respond\u00e9 las siguientes preguntas respecto al modelo obtenido: - A mayor superficie, \u00bfaumenta o disminuye el precio? - A mayor antig\u00fcedad, \u00bfaumenta o disminuye el precio? - \u00bfCu\u00e1nto vale la ordenada al origen del modelo? Ejercicio 11.15: Peso espec\u00edfico Queremos estimar el peso espec\u00edfico de un metal (es decir, peso divido volumen, en unidades de g/cm\u00b3). Para esto, disponemos de barras de dicho metal, con base de 1cm\u00b2 y largos diversos, y de una balanza que tiene peque\u00f1os errores de medici\u00f3n (desconocidos). Vamos a estimar el peso espec\u00edfico R del metal de la siguiente manera: Sabemos que el volumen de una barra de largo m es m cm\u00b3, por lo que su peso deber\u00eda ser R*m . Queremos estimar R . Utilizando la balanza, tendremos los pesos aproximados de distintas barras, con ciertos errores de medici\u00f3n. Si ajustamos un modelo lineal a los datos de volumen y peso aproximado vamos a tener una buena aproximaci\u00f3n para R (la pendiente de la recta). Los datos de longitudes y pesos se encuentran en el archivo disponible ac\u00e1 . Carg\u00e1 los datos directamente con el enlace usando el siguiente c\u00f3digo. import requests import io enlace = 'https://raw.githubusercontent.com/python-unsam/Programacion_en_Python_UNSAM/master/Notas/11_Recursion/longitudes_y_pesos.csv' r = requests.get(enlace).content data_lyp = pd.read_csv(io.StringIO(r.decode('utf-8'))) Hac\u00e9 una regresi\u00f3n lineal simple con sklearn , con variable explicativa longitud y variable explicada peso ( peso ~ longitud ). Estim\u00e1 el peso espec\u00edfico del metal mirando el coeficiente obtenido. Grafic\u00e1 los datos junto con la recta del ajuste, y calcul\u00e1 el error cuadr\u00e1tico medio. Guard\u00e1 el c\u00f3digo en un archivo peso_especifico.py . Cuidado: por c\u00f3mo planteamos el problema, estamos ajustando una recta con ordenada al origen igual a cero. Para esto tendr\u00e1s que usar el par\u00e1metro fit_intercept = False en la declaraci\u00f3n de tu modelo. Ejercicio 11.16: Modelo cuadr\u00e1tico Volvamos ahora al ejemplo cuadr\u00e1tico de antes. La relaci\u00f3n entre x ( indep_vars ) e y ( dep_vars ) estaba dada por y = 2 + 3*x + 2*x**2 + r . Ya tratamos de ajustar regresiones simples tipo y = a*x + b y y = a*x^2 + b . Ajustemos ahora una regresi\u00f3n lineal m\u00faltiple, usando como regresores a x y a x^2 . Nos gustar\u00eda no generar datos aleatorios nuevamente sino usar los anteriores, ya generados, para poder comparar (los errores cuadr\u00e1ticos medios de) los tres modelos. x = indep_vars xc = x**2 y = dep_vars Para preparar los datos a usar como regresores (en este caso m\u00faltiple ser\u00e1n x y x^2 ) pod\u00e9s usar: X = np.concatenate((x.reshape(-1,1),xc.reshape(-1,1)),axis=1) Si te fij\u00e1s, el array X tiene un shape de (50, 2) . Esto se corresponde a cincuenta datos con dos atributos. Us\u00e1 un objeto lm = linear_model.LinearRegression() para comparar los ajustes obtenidos usando x como \u00fanica variable regresora, xc (los cuadrados) como \u00fanica variable regresora, o ambas en un modelo m\u00faltiple (notado: y ~ x + x^2 ). Imprim\u00ed para cada uno de los tres modelos, el error cuadr\u00e1tico medio y los coeficientes (ordenada al or\u00edgen y coeficientes de los regresores) obtenidos. \u00bfQu\u00e9 modelo ajusta mejor? \u00bfCu\u00e1l da coeficientes m\u00e1s similares a los originales? \u00bfQu\u00e9 pasar\u00eda si us\u00e1ramos un modelo de grado tres o cuatro? Grafic\u00e1 los datos originales y los tres ajustes en un solo gr\u00e1fico indicando adecuadamente los nombres de los modelos. Navaja de Ockham Al agregar covariables (regresores) a un modelo, el ajuste tiende a mejorar. Si ajusto un modelo con variables x1, x2, x3 para explicar una variable y no puedo obtener un peor ajuste que si lo ajusto usando solo las variables x1 y x2 ya que todo modelo con las dos variables es un caso particular del modelo con las tres (simplemente hay que poner el coeficiente de la tercera variable igual a cero). Por eso, en general, al agregar variables a un modelo, su error cuadr\u00e1tico disminuye. Sin embargo un modelo con mejor ajuste no es necesariamente mejor. El principio metodol\u00f3gico conocido como la navaja de Ockham nos indica que de un conjunto de variables explicativas debe seleccionarse la combinaci\u00f3n m\u00e1s reducida y simple posible. Esto ayuda a evitar fen\u00f3menos como el sobreajuste que causa problemas muy serios y a veces graciosos . Ejercicio 11.17: Modelos polinomiales para una relaci\u00f3n cuadr\u00e1tica Vimos en el Ejercicio 11.16 que los datos de ese ejercicio se ajustan mejor con una regresi\u00f3n m\u00faltiple (usando x y x^2 ) que una regresi\u00f3n simple (basada un una sola variable). Te proponemos ahora que te fijes qu\u00e9 ocurre si seguimos aumentando el grado de las potencias de x que admitimos en la regresi\u00f3n m\u00faltiple (es decir, usar x , x^2 ,..., etc. hasta x^n ). \u00bfSigue bajando el error cuadr\u00e1tico medio? \u00bfPueden considerarse mejores los modelos obtenidos? Para n entre 1 y 8 realiz\u00e1 un ajuste con un polinomio de grado n (que tiene n+1 par\u00e1metros, por la ordenada al or\u00edgen) e imprim\u00ed una salida como esta: ------------------------- Grado del polinomio: 1 Cantidad de par\u00e1metros: 2 ECM: 201.194 ------------------------ Grado del polinomio: 2 Cantidad de par\u00e1metros: 3 ECM: 36.325 ... ... Te recomendamos usar la siguiente funci\u00f3n pot() para generar las primeras potencias de x : def pot(x,n): X=x.reshape(-1,1) for i in range(n-1): X=np.concatenate((X,(x**(i+2)).reshape(-1,1)),axis=1) return X Ejercicio 11.18: selecci\u00f3n de modelos El criterio de informaci\u00f3n de Akaike es una medida de la calidad relativa de un modelo estad\u00edstico, para un conjunto dado de datos. Como tal, el AIC proporciona un medio para la comparaci\u00f3n de modelos. AIC maneja un trade-off entre la bondad de ajuste del modelo y la complejidad del mismo (medido en cantidad de par\u00e1metros). En el caso de la regresi\u00f3n lineal m\u00faltiple, puede computarse con la siguiente funci\u00f3n: def AIC(k, ecm, num_params): '''Calcula el AIC de una regresi\u00f3n lineal m\u00faltiple de 'num_params' par\u00e1metros, ajustada sobre una muestra de 'k' elementos, y que da lugar a un error cuadr\u00e1tico medio 'ecm'.''' aic = k * np.log(ecm) + 2 * num_params return aic Agreg\u00e1 al c\u00f3digo del ejercicio anterior el c\u00f3mputo del AIC para cada modelo. ------------------------- Grado del polinomio: 1 Cantidad de par\u00e1metros: 2 ECM: 201.194 AIC: 269.213 ------------------------ Grado del polinomio: 2 Cantidad de par\u00e1metros: 3 ECM: 36.325 AIC: 185.626 ... ... Cuando complejizamos el modelo mejorando el error cuadr\u00e1tico medio, pero sin disminuir el AIC, es probable que el modelo se est\u00e9 sobreajustando a los datos de entrenamiento. Si seleccionamos el modelo ya no por su bondad de ajuste (ECM) sino buscando el m\u00ednimo AIC \u00bfQu\u00e9 modelo queda seleccionado? Respod\u00e9 esta pregunta usando el comando np.argmin() para encontrar el grado del polinomio que minimiza el AIC y coment\u00e1 adecuadamente tu c\u00f3digo. Guardalo en el archivo selecci\u00f3n_modelos.py para entregar. Ejercicio 11.19: Datos para la evaluaci\u00f3n Otra alternativa para comparar modelos es evaluarlos en un conjunto de datos diferente al que usamos para entrenarlos. La pr\u00f3xima clase vamos a ver que sklearn tiene funciones que permiten partir autom\u00e1ticamente los datos en conjuntos de entrenamiento y evalauci\u00f3n . Por ahora supongamos que nos dan los siguientes datos frescos: N=50 #genero datos para evaluar x_test = np.random.uniform(size = N, low = 0, high = 10) r_test = np.random.normal(size = N, loc = 0.0, scale = 8.0) # residuos y_test = 2 + 3*x_test + 2*x_test**2 + r_test # misma relaci\u00f3n cuadr\u00e1tica Evalu\u00e1 los modelos que armaste antes usando el ECM sobre estos datos frescos. \u00bfQu\u00e9 modelo da un mejor ajuste? Estas t\u00e9cnicas de selecci\u00f3n de modelos usando datos de entrenamiento y evaluaci\u00f3n separados o usando el criterio de informaci\u00f3n de Akaike tratan de evitar usar modelos que se sobreajusten a los datos de entrenamiento. Este fen\u00f3meno, conocido como overfitting , puede causar problemas muy serios. Ejercicio 11.20: Altura y di\u00e1metro de \u00e1rboles. Queremos comparar las formas de las siguientes especies de \u00e1rboles en los parques de Buenos Aires: Jacarand\u00e1, Palo borracho rosado, Eucalipto, y Ceibo. Vamos a trabajar nuevamente con el archivo de arbolado porte\u00f1o en parques que ten\u00e9s en el archivo '../Data/arbolado-en-espacios-verdes.csv'. Carg\u00e1 los datos en un DataFrame data_arbolado_parques . Para cada especie, seleccion\u00e1 los datos correspondientes, realiz\u00e1 un ajuste lineal (sin ordenada al or\u00edgen) de la altura dependiendo del di\u00e1metro a la altura del pecho. Realiz\u00e1 un scatterplot de los datos de la especie junto con la recta de regresi\u00f3n lineal. Realiz\u00e1 un gr\u00e1fico comparando los cuatro modelos obtenidos. Guard\u00e1 el c\u00f3digo de este ejercicio en un archivo ajuste_arboles.py . Observaci\u00f3n : Como pod\u00e9s ver en los scatterplots, para \u00e1rboles m\u00e1s anchos hay mayor variabilidad de alturas que para \u00e1rboles angostos. Esto implica que el modelo va a ser m\u00e1s sensible a datos de \u00e1rboles anchos que a datos de \u00e1rboles angostos. Esta caraceter\u00edstica se llama heterocedasticidad y muchas veces es un problema para usar regresiones lineales. Por ejemplo, no es posible aplicar directamente tests de hip\u00f3tesis a los resultados obtenidos. Para explicarlo con un ejemplo: imagin\u00e1 que tenemos tres pares de datos ( DAP y altura para un \u00e1rbol angosto, para un \u00e1rbol mediano y para un \u00e1rbol muy ancho) y supongamos que hay una relaci\u00f3n lineal real que es la que estamos buscando estimar a partir de los datos. La altura del arbol angosto va a variar unos pocos cent\u00edmetros respecto a este modelo ideal mientras que la altura del \u00e1rbol ancho puede variar muchos metros. Esto hace que el residuo del \u00e1rbol grueso respecto al modelo ideal sea mucho mayor que el residuo del \u00e1rbol angosto y, por lo tanto, que su infuencia en los coeficientes estimados sea mayor tambi\u00e9n (recordemos que estamos minimizando la suma de estos residuos al cuadrado). Esto viola una de las hip\u00f3tesis de la regresi\u00f3n lineal (la homocedasticidad ) que dice que todos los residuos tienen la misma distribuci\u00f3n. En este caso contamos con una gran cantidad de datos y podemos aplicar de todas formas la regresi\u00f3n en el marco de un an\u00e1lisis exploratorio de los datos. Ejercicio 11.21: Gr\u00e1ficos de ajuste lineal con Seaborn Seleccion\u00e1 los datos correspondientes a las especies: Jacarand\u00e1, Palo borracho rosado, Eucalipto y Ceibo, todas en un mismo DataFrame, usando el siguiente filtro. Python filtro = data_arbolado_parques['nombre_com'].isin(esp_selec) Explor\u00e1 el comando de seaborn sns.regplot() , que ajusta el modelo lineal y lo grafica sin pasar por scikit learn. El par\u00e1metro order te permite hacer ajustes polinomiales. El ci se refiere al intervalo de confianza a sombrear. Para facilitar la comparaci\u00f3n que hiciste en el ejercicio anterior, grafic\u00e1 todos los ajustes juntos usando: python g = sns.FacetGrid(datos_selec_p, col = 'nombre_com') g.map(sns.regplot, 'diametro', 'altura_tot') Observaci\u00f3n : Nos quedaron afuera de esta clase temas importantes como sobreajuste ( Overfitting ), partici\u00f3n de los datos en conjuntos de entrenamiento y evaluaci\u00f3n, validaci\u00f3n cruzada, presencia de datos at\u00edpicos (outliers), tests de hip\u00f3tesis, selecci\u00f3n de modelos... No era nuestra idea dar estos contenidos sino mostrar un acercamiento pr\u00e1ctico desde Python al problema de la regresi\u00f3n lineal. Contenidos | Anterior (4 Pr\u00e1ctica de Recursi\u00f3n) | Pr\u00f3ximo (6 Cierre de la clase de Recursi\u00f3n y Regresi\u00f3n)","title":"05 Regresion Lineal"},{"location":"11_Recursion/05_Regresion_Lineal/#115-regresion-lineal","text":"En esta secci\u00f3n vamos a trabajar con regresi\u00f3n lineal , tema que introducimos en este video . No es una clase con todos los fundamentos del tema, sino un acercamiento pr\u00e1ctico a las t\u00e9cnicas y sus formas de uso en Python. Para un desarrollo m\u00e1s profundo te recomendamos por ejemplo las notas de Andrew Ng .","title":"11.5 Regresi\u00f3n lineal"},{"location":"11_Recursion/05_Regresion_Lineal/#regresion-lineal-simple","text":"Supongamos que queremos modelar la relaci\u00f3n entre dos variables reales mediante un modelo lineal. Y que vamos a ajustar los par\u00e1metros de ese modelos a partir de ciertos valores conocidos (mediciones, digamos). Es decir que vamos a estar pensando que las variables tienen una relaci\u00f3n lineal, Y = a*X + b , donde X es la variable explicativa (sus componentes se denominan independientes o regresores ), e Y es la variable a explicar (tambi\u00e9n denominada dependiente o regresando ). A partir de un conjunto de datos de tipo (x_i, y_i) , planteamos el modelo Y = a*X + b . En general el modelo no va a ser exacto, es decir, no se va a complir que y_i = a*x_i + b para los valores (x_i, y_i) (salvo que est\u00e9n, justamente, todos los valores sobre una l\u00ednea recta). En general, dec\u00edamos, vamos a tener que y_i = a*x_i + b + r_i donde, los valores r_i , llamados residuos , representan las diferencias entre los valores de la recta en cada valor de x que tenemos y los valores de y asociados. El problema de regresi\u00f3n lineal consiste en elegir los par\u00e1metros a, b de la recta (es decir, su pendiente y ordenada al origen), de manera que la recta sea la que mejor se adapte a los datos disponibles. import numpy as np import matplotlib.pyplot as plt x = np.array([55.0, 38, 68, 70, 53, 46, 11, 16, 20, 4]) y = np.array([153.0, 98, 214, 220, 167, 145, 41, 63, 65, 25]) g = plt.scatter(x = x, y = y) plt.title('scatterplot de los datos') plt.show() \u00bfQu\u00e9 quiere decir mejor ? Vamos a considerar el criterio de cuadrados m\u00ednimos.","title":"Regresi\u00f3n lineal simple"},{"location":"11_Recursion/05_Regresion_Lineal/#criterio-de-cuadrados-minimos","text":"Vamos a elegir como mejor recta a la que minimice los residuos. M\u00e1s precisamente, vamos a elegir la recta de manera tal que la suma de los cuadrados de los residuos sea m\u00ednima. Anal\u00edticamente, buscamos a, b tales que minimicen la siguiente suma de cuadrados: Usar cuadrados m\u00ednimos tiene m\u00faltiples motivaciones que no podemos detallar adecuadamente ac\u00e1. Solo mencionaremos dos hechos importantes relacionados con su frecuente elecci\u00f3n: Por un lado, minimizar el error cuadr\u00e1tico medio puede resolverse derivando la f\u00f3rmula del error. Los que sepan algo de an\u00e1lisis matem\u00e1tico, recordar\u00e1n que la derivada nos permite encontrar m\u00ednimos y que la derivada de una funci\u00f3n cuadr\u00e1tica es una funci\u00f3n lineal. Por lo tanto, encontrar la recta que mejor ajusta los datos se reduce a buscar el cero de una derivada que en el fondo se reduce a resolver un sistema lineal, algo que sabemos hacer muy bien y muy r\u00e1pido. Si en lugar de minimizar la suma de los cuadrados de los residuos plante\u00e1ramos, por ejemplo, minimizar la suma de los valores absolutos de los residuos no podr\u00edamos encontrar la recta que mejor ajusta tan f\u00e1cilmente. Otro argumento muy fuerte, de naturaleza estad\u00edstica en este caso, es que si uno considera que los residuos son por ejemplo errores de medici\u00f3n y que tienen una distribuci\u00f3n normal (una gaussiana), entonces puede mostrarse que la recta que da el m\u00e9todo de los cuadrados m\u00ednimos es la recta de m\u00e1xima verosimilitud . Estas cosas se explican muy bien en el apunte de Andrew Ng que citamos antes. Record\u00e1 que en la Secci\u00f3n 5.2 vimos que calcular el promedio de estos errores cuadr\u00e1ticos es muy sencillo en numpy. Tambi\u00e9n pod\u00e9s usar la funci\u00f3n mean_squared_error del m\u00f3dulo sklearn.metrics que trae muchas m\u00e9tricas muy \u00fatiles.","title":"Criterio de cuadrados m\u00ednimos"},{"location":"11_Recursion/05_Regresion_Lineal/#ejemplo-el-modelo-de-cuadrados-minimos","text":"Para los datos que graficamos antes, \u00e9sta es la mejor recta , es decir, la que minimiza la suma de los cuadrados de los residuos. Vamos a decir que esta recta es el ajuste lineal de los datos . \u00bfC\u00f3mo se encuentran estos coeficientes?","title":"Ejemplo: el modelo de cuadrados m\u00ednimos"},{"location":"11_Recursion/05_Regresion_Lineal/#ajuste-del-modelo-de-cuadrados-minimos","text":"Como buscamos el m\u00ednimo de la expresi\u00f3n podemos derivar respecto de los par\u00e1metros a, b e igualar a cero para despejarlos. No es una cuenta d\u00edficil. El \u00fanico cero que va a tener la derivada se corresponde con un m\u00ednimo (porque la recta se puede ajustar tan mal como uno quiera ). De esta manera se obtienen las siguientes f\u00f3rmulas para el ajuste: def ajuste_lineal_simple(x,y): a = sum(((x - x.mean())*(y-y.mean()))) / sum(((x-x.mean())**2)) b = y.mean() - a*x.mean() return a, b","title":"Ajuste del modelo de cuadrados m\u00ednimos"},{"location":"11_Recursion/05_Regresion_Lineal/#ejemplo-datos-sinteticos","text":"Veamos un ejemplo generado con datos sint\u00e9ticos. Generamos 50 datos para la variable x , y determinamos a la variable y con una relaci\u00f3n lineal m\u00e1s un error normal. import numpy as np N = 50 minx = 0 maxx = 500 x = np.random.uniform(minx, maxx, N) r = np.random.normal(0, 25, N) # residuos simulados y = 1.3*x + r g = plt.scatter(x = x, y = y) plt.title('gr\u00e1fico de dispersi\u00f3n de los datos') plt.xlabel('x') plt.ylabel('y') plt.show() Ahora ajustamos con las f\u00f3rmulas que vimos antes: a, b = ajuste_lineal_simple(x, y) grilla_x = np.linspace(start = minx, stop = maxx, num = 1000) grilla_y = grilla_x*a + b g = plt.scatter(x = x, y = y) plt.title('y ajuste lineal') plt.plot(grilla_x, grilla_y, c = 'green') plt.xlabel('x') plt.ylabel('y') plt.show()","title":"Ejemplo: datos sint\u00e9ticos"},{"location":"11_Recursion/05_Regresion_Lineal/#ejercicio-1114-precio_alquiler-superficie","text":"Consideramos datos de precios (en miles de pesos) de alquiler mensual de departamentos en el barrio de Caballito, CABA, y sus superficies (en metros cuadrados). Queremos modelar el precio de alquiler a partir de la superficie para este barrio. A veces este modelo se nota con precio_alquiler ~ superficie . Usando la funci\u00f3n que definimos antes, ajust\u00e1 los datos con una recta. Grafic\u00e1 los datos junto con la recta del ajuste. superficie = np.array([150.0, 120.0, 170.0, 80.0]) alquiler = np.array([35.0, 29.6, 37.4, 21.0]) Una forma de cuantificar cu\u00e1n bien ajusta la recta es considerar el promedio de los errores cuadr\u00e1ticos, llamado error cuadr\u00e1tico medio . errores = alquiler - (a*superficie + b) print(errores) print(\"ECM:\", (errores**2).mean()) Calcul\u00e1 el error cuadr\u00e1tico medio del ajuste que hiciste reci\u00e9n. Guard\u00e1 tu c\u00f3digo en el archivo alquiler.py para entregar.","title":"Ejercicio 11.14: precio_alquiler ~ superficie"},{"location":"11_Recursion/05_Regresion_Lineal/#ejemplo-relacion-cuadratica","text":"Veamos qu\u00e9 pasa si los datos guardan en realidad una relaci\u00f3n cuadr\u00e1tica. Generemos aletoriamente variables independientes y dependientes con este tipo de relaci\u00f3n. np.random.seed(3141) # semilla para fijar la aleatoriedad N=50 indep_vars = np.random.uniform(size = N, low = 0, high = 10) r = np.random.normal(size = N, loc = 0.0, scale = 8.0) # residuos dep_vars = 2 + 3*indep_vars + 2*indep_vars**2 + r # relaci\u00f3n cuadr\u00e1tica Grafiquemos los datos obtenidos y, por comodidad, llam\u00e9moslos x e y . x = indep_vars y = dep_vars plt.scatter(x,y) plt.title('scatterplot de los datos') plt.show() Y ajustemos un modelo lineal (notado: y ~ x ) a estos datos. a, b = ajuste_lineal_simple(x, y) grilla_x = np.linspace(start = 0, stop = 10, num = 1000) grilla_y = grilla_x*a + b g = plt.scatter(x = x , y = y) plt.title('ajuste lineal') plt.plot(grilla_x, grilla_y, c = 'green') plt.show() Veamos cu\u00e1nto vale el error cuadr\u00e1tico medio. errores = y - (x*a + b) print(\"ECM\", (errores**2).mean())","title":"Ejemplo: relaci\u00f3n cuadr\u00e1tica"},{"location":"11_Recursion/05_Regresion_Lineal/#parte-optativa","text":"Ahora vamos a profundizar en algunos conceptos y a ver maneras alternativas de hacer las cosas. Lo que sigue es optativo.","title":"Parte optativa:"},{"location":"11_Recursion/05_Regresion_Lineal/#ejemplo-precomputo-de-atributos-adecuados","text":"Es natural pensar que aproximar una par\u00e1bola con un modelo lineal no es lo m\u00e1s sensato. Un modelo alternativo es usar como variable explicativa x^2 en vez de x . El c\u00f3mputo de xc = x^2 se realiza en un paso previo de forma que el modelo sigue siendo lineal (ahora lineal en x^2 ). Esto significa que el formalismo matem\u00e1tico para encontrar los coeficientes del nuevo modelo es el mismo que antes. xc = x**2 ap, bp = ajuste_lineal_simple(xc, y) grilla_y_p = (grilla_x**2)*ap + bp plt.scatter(x,y) plt.plot(grilla_x, grilla_y, c = 'green') plt.plot(grilla_x, grilla_y_p, c = 'red') plt.title('ajuste lineal con x^2') plt.show() Y si queremos cuantificar el error en este modelo: yhat = (x**2)*ap + bp # valores estimados residuos = y - yhat # diferencia entre el valor original y el estimado ecm = (residuos**2).mean() # error cuadr\u00e1tico medio print(\"ECM:\", ecm) Al usar x^2 en lugar de x mejora sustancialmente la bondad de ajuste del modelo (notado: y ~ x^2 ). Veremos pr\u00f3ximamente que podemos usar ambas x y x^2 como variables explicativas y obtener un ajuste a\u00fan mejor de los datos. Ra\u00edz del error cuadr\u00e1tico medio : Una alternativa al error cuadr\u00e1tico medio es su ra\u00edz cuadrada, conocida como root mean squared error (RMSE). La ventaja de esta medida de la bondad de ajuste de un modelo a los datos radica en que \u00e9sta se expresa en las misma unidades que la variable a explicar, y, mientras que el ECM (MSE) se expresa en unidades al cuadrado . Siendo la ra\u00edz una funci\u00f3n mon\u00f3tona, minimizar una m\u00e9trica o la otra es equivalente.","title":"Ejemplo: prec\u00f3mputo de atributos adecuados"},{"location":"11_Recursion/05_Regresion_Lineal/#scikit-learn","text":"La biblioteca scikit-learn tiene herramientas muy \u00fatiles para el an\u00e1lisis de datos y el desarrollo de modelos de aprendizaje autom\u00e1tico, aunque se mantiene relativamente alejada de la inferencia estad\u00edstica. En particular, para regresi\u00f3n lineal tiene el m\u00f3dulo linear_model , y en el siguiente ejemplo mostramos c\u00f3mo puede usarse. Para les que est\u00e9n habituades al lenguaje R, quiz\u00e1s les conviene usar la biblioteca stastmodels que tiene un funcionamiento m\u00e1s cercano. Al igual que el modelo de clustering que usamos en el Ejercicio 9.19 de teledetecci\u00f3n, el objeto de tipo LinearRegression de sklearn.liearmodel tambi\u00e9n tiene un m\u00e9todo fit() que permite ajustar el modelo a los datos y otro predict() que permite usar el modelo ajustado con nuevos datos. Ac\u00e1 rehacemos el primer ejemplo que dimos ( Secci\u00f3n 11.5 ), usando pandas y el m\u00f3dulo linear_model . import pandas as pd from sklearn import linear_model x = np.array([55.0, 38, 68, 70, 53, 46, 11, 16, 20, 4]) # mismos datos x, y y = np.array([153.0, 98, 214, 220, 167, 145, 41, 63, 65, 25]) datosxy = pd.DataFrame({'x': x, 'y': y}) # paso los datos a un dataframe ajus = linear_model.LinearRegression() # llamo al modelo de regresi\u00f3n lineal ajus.fit(datosxy[['x']], datosxy['y']) # ajusto el modelo grilla_x = np.linspace(start = 0, stop = 70, num = 1000) grilla_y = ajus.predict(grilla_x.reshape(-1,1)) datosxy.plot.scatter('x','y') plt.title('ajuste lineal usando sklearn') plt.plot(grilla_x, grilla_y, c = 'green') plt.show() Usamos el m\u00e9todo fit() para ajustar el modelo y el m\u00e9todo predict() para obtener los valores de y de la recta. Fijate que al m\u00e9todo fit le pasamos el Dataframe datosxy[['x']] y no la serie datosxy['x'] ya que el m\u00e9todo est\u00e1 preparado para trabajar con regresiones m\u00faltiples (es decir, ten\u00e9s muchos regresores).","title":"Scikit-Learn"},{"location":"11_Recursion/05_Regresion_Lineal/#regresion-lineal-multiple","text":"La regresi\u00f3n lineal m\u00faltiple tiene un planteo similar, pero con m\u00e1s variables explicativas. El modelo es el siguiente.","title":"Regresi\u00f3n Lineal M\u00faltiple"},{"location":"11_Recursion/05_Regresion_Lineal/#ejemplo-superficie-y-antiguedad","text":"Trabajamos nuevamente con los departamentos, ahora tambi\u00e9n conociendo su antig\u00fcedad, y la tomamos como otra variable explicativa. Ajustaremos un modelo que tenga en cuenta ambas variables, y lo notaremos: precio_alquiler ~ superficie + antig\u00fcedad superficie = np.array([150.0, 120.0, 170.0, 80.0]) alquiler = np.array([35.0, 29.6, 37.4, 21.0]) antig\u00fcedad = [50.0, 5.0, 25.0, 70.0] data_deptos = pd.DataFrame({'alquiler': alquiler, 'superficie': superficie, 'antig\u00fcedad': antig\u00fcedad}) X = pd.concat([data_deptos.superficie,data_deptos.antig\u00fcedad], axis = 1) ajuste_deptos = linear_model.LinearRegression() ajuste_deptos.fit(X,data_deptos.alquiler) errores = data_deptos.alquiler - (ajuste_deptos.predict(X)) print(errores) print(\"ECM:\", (errores**2).mean()) # error cuadr\u00e1tico medio Usando los atributos intercept_ y coef_ de ajuste_deptos escrib\u00ed a mano la f\u00f3rmula de la regresi\u00f3n m\u00faltiple obtenida y respond\u00e9 las siguientes preguntas respecto al modelo obtenido: - A mayor superficie, \u00bfaumenta o disminuye el precio? - A mayor antig\u00fcedad, \u00bfaumenta o disminuye el precio? - \u00bfCu\u00e1nto vale la ordenada al origen del modelo?","title":"Ejemplo: superficie y antig\u00fcedad"},{"location":"11_Recursion/05_Regresion_Lineal/#ejercicio-1115-peso-especifico","text":"Queremos estimar el peso espec\u00edfico de un metal (es decir, peso divido volumen, en unidades de g/cm\u00b3). Para esto, disponemos de barras de dicho metal, con base de 1cm\u00b2 y largos diversos, y de una balanza que tiene peque\u00f1os errores de medici\u00f3n (desconocidos). Vamos a estimar el peso espec\u00edfico R del metal de la siguiente manera: Sabemos que el volumen de una barra de largo m es m cm\u00b3, por lo que su peso deber\u00eda ser R*m . Queremos estimar R . Utilizando la balanza, tendremos los pesos aproximados de distintas barras, con ciertos errores de medici\u00f3n. Si ajustamos un modelo lineal a los datos de volumen y peso aproximado vamos a tener una buena aproximaci\u00f3n para R (la pendiente de la recta). Los datos de longitudes y pesos se encuentran en el archivo disponible ac\u00e1 . Carg\u00e1 los datos directamente con el enlace usando el siguiente c\u00f3digo. import requests import io enlace = 'https://raw.githubusercontent.com/python-unsam/Programacion_en_Python_UNSAM/master/Notas/11_Recursion/longitudes_y_pesos.csv' r = requests.get(enlace).content data_lyp = pd.read_csv(io.StringIO(r.decode('utf-8'))) Hac\u00e9 una regresi\u00f3n lineal simple con sklearn , con variable explicativa longitud y variable explicada peso ( peso ~ longitud ). Estim\u00e1 el peso espec\u00edfico del metal mirando el coeficiente obtenido. Grafic\u00e1 los datos junto con la recta del ajuste, y calcul\u00e1 el error cuadr\u00e1tico medio. Guard\u00e1 el c\u00f3digo en un archivo peso_especifico.py . Cuidado: por c\u00f3mo planteamos el problema, estamos ajustando una recta con ordenada al origen igual a cero. Para esto tendr\u00e1s que usar el par\u00e1metro fit_intercept = False en la declaraci\u00f3n de tu modelo.","title":"Ejercicio 11.15: Peso espec\u00edfico"},{"location":"11_Recursion/05_Regresion_Lineal/#ejercicio-1116-modelo-cuadratico","text":"Volvamos ahora al ejemplo cuadr\u00e1tico de antes. La relaci\u00f3n entre x ( indep_vars ) e y ( dep_vars ) estaba dada por y = 2 + 3*x + 2*x**2 + r . Ya tratamos de ajustar regresiones simples tipo y = a*x + b y y = a*x^2 + b . Ajustemos ahora una regresi\u00f3n lineal m\u00faltiple, usando como regresores a x y a x^2 . Nos gustar\u00eda no generar datos aleatorios nuevamente sino usar los anteriores, ya generados, para poder comparar (los errores cuadr\u00e1ticos medios de) los tres modelos. x = indep_vars xc = x**2 y = dep_vars Para preparar los datos a usar como regresores (en este caso m\u00faltiple ser\u00e1n x y x^2 ) pod\u00e9s usar: X = np.concatenate((x.reshape(-1,1),xc.reshape(-1,1)),axis=1) Si te fij\u00e1s, el array X tiene un shape de (50, 2) . Esto se corresponde a cincuenta datos con dos atributos. Us\u00e1 un objeto lm = linear_model.LinearRegression() para comparar los ajustes obtenidos usando x como \u00fanica variable regresora, xc (los cuadrados) como \u00fanica variable regresora, o ambas en un modelo m\u00faltiple (notado: y ~ x + x^2 ). Imprim\u00ed para cada uno de los tres modelos, el error cuadr\u00e1tico medio y los coeficientes (ordenada al or\u00edgen y coeficientes de los regresores) obtenidos. \u00bfQu\u00e9 modelo ajusta mejor? \u00bfCu\u00e1l da coeficientes m\u00e1s similares a los originales? \u00bfQu\u00e9 pasar\u00eda si us\u00e1ramos un modelo de grado tres o cuatro? Grafic\u00e1 los datos originales y los tres ajustes en un solo gr\u00e1fico indicando adecuadamente los nombres de los modelos.","title":"Ejercicio 11.16: Modelo cuadr\u00e1tico"},{"location":"11_Recursion/05_Regresion_Lineal/#navaja-de-ockham","text":"Al agregar covariables (regresores) a un modelo, el ajuste tiende a mejorar. Si ajusto un modelo con variables x1, x2, x3 para explicar una variable y no puedo obtener un peor ajuste que si lo ajusto usando solo las variables x1 y x2 ya que todo modelo con las dos variables es un caso particular del modelo con las tres (simplemente hay que poner el coeficiente de la tercera variable igual a cero). Por eso, en general, al agregar variables a un modelo, su error cuadr\u00e1tico disminuye. Sin embargo un modelo con mejor ajuste no es necesariamente mejor. El principio metodol\u00f3gico conocido como la navaja de Ockham nos indica que de un conjunto de variables explicativas debe seleccionarse la combinaci\u00f3n m\u00e1s reducida y simple posible. Esto ayuda a evitar fen\u00f3menos como el sobreajuste que causa problemas muy serios y a veces graciosos .","title":"Navaja de Ockham"},{"location":"11_Recursion/05_Regresion_Lineal/#ejercicio-1117-modelos-polinomiales-para-una-relacion-cuadratica","text":"Vimos en el Ejercicio 11.16 que los datos de ese ejercicio se ajustan mejor con una regresi\u00f3n m\u00faltiple (usando x y x^2 ) que una regresi\u00f3n simple (basada un una sola variable). Te proponemos ahora que te fijes qu\u00e9 ocurre si seguimos aumentando el grado de las potencias de x que admitimos en la regresi\u00f3n m\u00faltiple (es decir, usar x , x^2 ,..., etc. hasta x^n ). \u00bfSigue bajando el error cuadr\u00e1tico medio? \u00bfPueden considerarse mejores los modelos obtenidos? Para n entre 1 y 8 realiz\u00e1 un ajuste con un polinomio de grado n (que tiene n+1 par\u00e1metros, por la ordenada al or\u00edgen) e imprim\u00ed una salida como esta: ------------------------- Grado del polinomio: 1 Cantidad de par\u00e1metros: 2 ECM: 201.194 ------------------------ Grado del polinomio: 2 Cantidad de par\u00e1metros: 3 ECM: 36.325 ... ... Te recomendamos usar la siguiente funci\u00f3n pot() para generar las primeras potencias de x : def pot(x,n): X=x.reshape(-1,1) for i in range(n-1): X=np.concatenate((X,(x**(i+2)).reshape(-1,1)),axis=1) return X","title":"Ejercicio 11.17: Modelos polinomiales para una relaci\u00f3n cuadr\u00e1tica"},{"location":"11_Recursion/05_Regresion_Lineal/#ejercicio-1118-seleccion-de-modelos","text":"El criterio de informaci\u00f3n de Akaike es una medida de la calidad relativa de un modelo estad\u00edstico, para un conjunto dado de datos. Como tal, el AIC proporciona un medio para la comparaci\u00f3n de modelos. AIC maneja un trade-off entre la bondad de ajuste del modelo y la complejidad del mismo (medido en cantidad de par\u00e1metros). En el caso de la regresi\u00f3n lineal m\u00faltiple, puede computarse con la siguiente funci\u00f3n: def AIC(k, ecm, num_params): '''Calcula el AIC de una regresi\u00f3n lineal m\u00faltiple de 'num_params' par\u00e1metros, ajustada sobre una muestra de 'k' elementos, y que da lugar a un error cuadr\u00e1tico medio 'ecm'.''' aic = k * np.log(ecm) + 2 * num_params return aic Agreg\u00e1 al c\u00f3digo del ejercicio anterior el c\u00f3mputo del AIC para cada modelo. ------------------------- Grado del polinomio: 1 Cantidad de par\u00e1metros: 2 ECM: 201.194 AIC: 269.213 ------------------------ Grado del polinomio: 2 Cantidad de par\u00e1metros: 3 ECM: 36.325 AIC: 185.626 ... ... Cuando complejizamos el modelo mejorando el error cuadr\u00e1tico medio, pero sin disminuir el AIC, es probable que el modelo se est\u00e9 sobreajustando a los datos de entrenamiento. Si seleccionamos el modelo ya no por su bondad de ajuste (ECM) sino buscando el m\u00ednimo AIC \u00bfQu\u00e9 modelo queda seleccionado? Respod\u00e9 esta pregunta usando el comando np.argmin() para encontrar el grado del polinomio que minimiza el AIC y coment\u00e1 adecuadamente tu c\u00f3digo. Guardalo en el archivo selecci\u00f3n_modelos.py para entregar.","title":"Ejercicio 11.18: selecci\u00f3n de modelos"},{"location":"11_Recursion/05_Regresion_Lineal/#ejercicio-1119-datos-para-la-evaluacion","text":"Otra alternativa para comparar modelos es evaluarlos en un conjunto de datos diferente al que usamos para entrenarlos. La pr\u00f3xima clase vamos a ver que sklearn tiene funciones que permiten partir autom\u00e1ticamente los datos en conjuntos de entrenamiento y evalauci\u00f3n . Por ahora supongamos que nos dan los siguientes datos frescos: N=50 #genero datos para evaluar x_test = np.random.uniform(size = N, low = 0, high = 10) r_test = np.random.normal(size = N, loc = 0.0, scale = 8.0) # residuos y_test = 2 + 3*x_test + 2*x_test**2 + r_test # misma relaci\u00f3n cuadr\u00e1tica Evalu\u00e1 los modelos que armaste antes usando el ECM sobre estos datos frescos. \u00bfQu\u00e9 modelo da un mejor ajuste? Estas t\u00e9cnicas de selecci\u00f3n de modelos usando datos de entrenamiento y evaluaci\u00f3n separados o usando el criterio de informaci\u00f3n de Akaike tratan de evitar usar modelos que se sobreajusten a los datos de entrenamiento. Este fen\u00f3meno, conocido como overfitting , puede causar problemas muy serios.","title":"Ejercicio 11.19: Datos para la evaluaci\u00f3n"},{"location":"11_Recursion/05_Regresion_Lineal/#ejercicio-1120-altura-y-diametro-de-arboles","text":"Queremos comparar las formas de las siguientes especies de \u00e1rboles en los parques de Buenos Aires: Jacarand\u00e1, Palo borracho rosado, Eucalipto, y Ceibo. Vamos a trabajar nuevamente con el archivo de arbolado porte\u00f1o en parques que ten\u00e9s en el archivo '../Data/arbolado-en-espacios-verdes.csv'. Carg\u00e1 los datos en un DataFrame data_arbolado_parques . Para cada especie, seleccion\u00e1 los datos correspondientes, realiz\u00e1 un ajuste lineal (sin ordenada al or\u00edgen) de la altura dependiendo del di\u00e1metro a la altura del pecho. Realiz\u00e1 un scatterplot de los datos de la especie junto con la recta de regresi\u00f3n lineal. Realiz\u00e1 un gr\u00e1fico comparando los cuatro modelos obtenidos. Guard\u00e1 el c\u00f3digo de este ejercicio en un archivo ajuste_arboles.py . Observaci\u00f3n : Como pod\u00e9s ver en los scatterplots, para \u00e1rboles m\u00e1s anchos hay mayor variabilidad de alturas que para \u00e1rboles angostos. Esto implica que el modelo va a ser m\u00e1s sensible a datos de \u00e1rboles anchos que a datos de \u00e1rboles angostos. Esta caraceter\u00edstica se llama heterocedasticidad y muchas veces es un problema para usar regresiones lineales. Por ejemplo, no es posible aplicar directamente tests de hip\u00f3tesis a los resultados obtenidos. Para explicarlo con un ejemplo: imagin\u00e1 que tenemos tres pares de datos ( DAP y altura para un \u00e1rbol angosto, para un \u00e1rbol mediano y para un \u00e1rbol muy ancho) y supongamos que hay una relaci\u00f3n lineal real que es la que estamos buscando estimar a partir de los datos. La altura del arbol angosto va a variar unos pocos cent\u00edmetros respecto a este modelo ideal mientras que la altura del \u00e1rbol ancho puede variar muchos metros. Esto hace que el residuo del \u00e1rbol grueso respecto al modelo ideal sea mucho mayor que el residuo del \u00e1rbol angosto y, por lo tanto, que su infuencia en los coeficientes estimados sea mayor tambi\u00e9n (recordemos que estamos minimizando la suma de estos residuos al cuadrado). Esto viola una de las hip\u00f3tesis de la regresi\u00f3n lineal (la homocedasticidad ) que dice que todos los residuos tienen la misma distribuci\u00f3n. En este caso contamos con una gran cantidad de datos y podemos aplicar de todas formas la regresi\u00f3n en el marco de un an\u00e1lisis exploratorio de los datos.","title":"Ejercicio 11.20: Altura y di\u00e1metro de \u00e1rboles."},{"location":"11_Recursion/05_Regresion_Lineal/#ejercicio-1121-graficos-de-ajuste-lineal-con-seaborn","text":"Seleccion\u00e1 los datos correspondientes a las especies: Jacarand\u00e1, Palo borracho rosado, Eucalipto y Ceibo, todas en un mismo DataFrame, usando el siguiente filtro. Python filtro = data_arbolado_parques['nombre_com'].isin(esp_selec) Explor\u00e1 el comando de seaborn sns.regplot() , que ajusta el modelo lineal y lo grafica sin pasar por scikit learn. El par\u00e1metro order te permite hacer ajustes polinomiales. El ci se refiere al intervalo de confianza a sombrear. Para facilitar la comparaci\u00f3n que hiciste en el ejercicio anterior, grafic\u00e1 todos los ajustes juntos usando: python g = sns.FacetGrid(datos_selec_p, col = 'nombre_com') g.map(sns.regplot, 'diametro', 'altura_tot') Observaci\u00f3n : Nos quedaron afuera de esta clase temas importantes como sobreajuste ( Overfitting ), partici\u00f3n de los datos en conjuntos de entrenamiento y evaluaci\u00f3n, validaci\u00f3n cruzada, presencia de datos at\u00edpicos (outliers), tests de hip\u00f3tesis, selecci\u00f3n de modelos... No era nuestra idea dar estos contenidos sino mostrar un acercamiento pr\u00e1ctico desde Python al problema de la regresi\u00f3n lineal. Contenidos | Anterior (4 Pr\u00e1ctica de Recursi\u00f3n) | Pr\u00f3ximo (6 Cierre de la clase de Recursi\u00f3n y Regresi\u00f3n)","title":"Ejercicio 11.21: Gr\u00e1ficos de ajuste lineal con Seaborn"},{"location":"11_Recursion/06_Cierre/","text":"Contenidos | Anterior (5 Regresi\u00f3n lineal) 11.6 Cierre de la clase de Recursi\u00f3n y Regresi\u00f3n En esta clase vimos el concepto de recursi\u00f3n y lo ejercitaste. Tambi\u00e9n estudiamos un poquito (o no tan poco) sobre el ajuste y uso de regresiones lineales en Python. Ya estamos cerrando este curso. La pr\u00f3xima clase ser\u00e1 la \u00faltima. En la clase de hoy te pedimos que entregues los siguientes archivos: El archivo larenga.py del Ejercicio 11.9 . El archivo bbin_rec.py del Ejercicio 11.11 . El archivo hojas_ISO.py del Ejercicio 11.13 . El archivo alquiler.py del Ejercicio 11.14 . Opcional: El archivo seleccion_modelos.py del Ejercicio 11.18 . Como de costumbre, complet\u00e1 por favor el formulario asociado a la clase y adjunt\u00e1 los archivos correspondientes. \u00c9sta es la \u00faltima semana en la que pod\u00e9s participar de la correcci\u00f3n de pares con el Ejercicio 11.13 . Contenidos | Anterior (5 Regresi\u00f3n lineal)","title":"06 Cierre"},{"location":"11_Recursion/06_Cierre/#116-cierre-de-la-clase-de-recursion-y-regresion","text":"En esta clase vimos el concepto de recursi\u00f3n y lo ejercitaste. Tambi\u00e9n estudiamos un poquito (o no tan poco) sobre el ajuste y uso de regresiones lineales en Python. Ya estamos cerrando este curso. La pr\u00f3xima clase ser\u00e1 la \u00faltima. En la clase de hoy te pedimos que entregues los siguientes archivos: El archivo larenga.py del Ejercicio 11.9 . El archivo bbin_rec.py del Ejercicio 11.11 . El archivo hojas_ISO.py del Ejercicio 11.13 . El archivo alquiler.py del Ejercicio 11.14 . Opcional: El archivo seleccion_modelos.py del Ejercicio 11.18 . Como de costumbre, complet\u00e1 por favor el formulario asociado a la clase y adjunt\u00e1 los archivos correspondientes. \u00c9sta es la \u00faltima semana en la que pod\u00e9s participar de la correcci\u00f3n de pares con el Ejercicio 11.13 . Contenidos | Anterior (5 Regresi\u00f3n lineal)","title":"11.6 Cierre de la clase de Recursi\u00f3n y Regresi\u00f3n"},{"location":"12_Ordenamiento/00_Resumen/","text":"Contenidos | Anterior (11 Recursi\u00f3n y regresi\u00f3n) 12. Ordenamiento Ordenar una lista de n\u00fameros es una de las tareas fundamentales que realiza un ordenador (tambi\u00e9n llamado computadora). Los algoritmos conceptualmente m\u00e1s sencillos tienen una complejidad computacional (en el peor caso) que crece de forma cuadr\u00e1tica (n^2) con la longitud, n, de la lista a ordenar. Veremos en detalle dos algoritmos sencillos: el algoritmo de selecci\u00f3n y el de inserci\u00f3n y luego divide and conquer que lleva a la idea de merge sort... 12.1 Introducci\u00f3n 12.2 Ordenamientos sencillos de listas 12.3 Divide y reinar\u00e1s 12.4 Algoritmos de clasificaci\u00f3n supervisada 12.5 Cierre de la clase de Ordenamiento Contenidos | Anterior (11 Recursi\u00f3n y regresi\u00f3n)","title":"00 Resumen"},{"location":"12_Ordenamiento/00_Resumen/#12-ordenamiento","text":"Ordenar una lista de n\u00fameros es una de las tareas fundamentales que realiza un ordenador (tambi\u00e9n llamado computadora). Los algoritmos conceptualmente m\u00e1s sencillos tienen una complejidad computacional (en el peor caso) que crece de forma cuadr\u00e1tica (n^2) con la longitud, n, de la lista a ordenar. Veremos en detalle dos algoritmos sencillos: el algoritmo de selecci\u00f3n y el de inserci\u00f3n y luego divide and conquer que lleva a la idea de merge sort... 12.1 Introducci\u00f3n 12.2 Ordenamientos sencillos de listas 12.3 Divide y reinar\u00e1s 12.4 Algoritmos de clasificaci\u00f3n supervisada 12.5 Cierre de la clase de Ordenamiento Contenidos | Anterior (11 Recursi\u00f3n y regresi\u00f3n)","title":"12. Ordenamiento"},{"location":"12_Ordenamiento/01_Introduccion/","text":"Contenidos | Pr\u00f3ximo (2 Ordenamientos sencillos de listas) 12.1 Introducci\u00f3n En este video damos una breve introducci\u00f3n a la clase. Luego vas a encontrar un video en cada secci\u00f3n. \u00a1Que disfrutes la clase! Contenidos | Pr\u00f3ximo (2 Ordenamientos sencillos de listas)","title":"01 Introduccion"},{"location":"12_Ordenamiento/01_Introduccion/#121-introduccion","text":"En este video damos una breve introducci\u00f3n a la clase. Luego vas a encontrar un video en cada secci\u00f3n. \u00a1Que disfrutes la clase! Contenidos | Pr\u00f3ximo (2 Ordenamientos sencillos de listas)","title":"12.1 Introducci\u00f3n"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/","text":"Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Divide y reinar\u00e1s) 12.2 Ordenamientos sencillos de listas Para esta secci\u00f3n tenemos un video introductorio . El problema del ordenamiento es tan fundamental que, a pesar de que Python ya lo hace con su m\u00e9todo sort() por ejemplo, nos interesa discutirlo. Hay una diversidad de soluciones para ordenar listas. Vamos a empezar viendo las m\u00e1s sencillas de escribir (que en general suelen ser las m\u00e1s caras). Ordenamiento por selecci\u00f3n El m\u00e9todo de ordenamiento por selecci\u00f3n se basa en la siguiente idea: La siguiente animaci\u00f3n muestra un algoritmo de ordenamiento por selecci\u00f3n (que busca el menor en cada paso, en lugar del mayor): Una implementaci\u00f3n en Python puede verse en el siguiente c\u00f3digo. def ord_seleccion(lista): \"\"\"Ordena una lista de elementos seg\u00fan el m\u00e9todo de selecci\u00f3n. Pre: los elementos de la lista deben ser comparables. Post: la lista est\u00e1 ordenada.\"\"\" # posici\u00f3n final del segmento a tratar n = len(lista) - 1 # mientras haya al menos 2 elementos para ordenar while n > 0: # posici\u00f3n del mayor valor del segmento p = buscar_max(lista, 0, n) # intercambiar el valor que est\u00e1 en p con el valor que # est\u00e1 en la \u00faltima posici\u00f3n del segmento lista[p], lista[n] = lista[n], lista[p] print(\"DEBUG: \", p, n, lista) # reducir el segmento en 1 n = n - 1 def buscar_max(lista, a, b): \"\"\"Devuelve la posici\u00f3n del m\u00e1ximo elemento en un segmento de lista de elementos comparables. La lista no debe ser vac\u00eda. a y b son las posiciones inicial y final del segmento\"\"\" pos_max = a for i in range(a + 1, b + 1): if lista[i] > lista[pos_max]: pos_max = i return pos_max La funci\u00f3n principal, ord_seleccion() es la encargada de recorrer la lista, ubicando el mayor elemento al final del segmento y luego reduciendo el segmento a analizar. La funci\u00f3n buscar_max() busca el mayor elemento de un segmento de la lista y devuelve su posici\u00f3n. A continuaci\u00f3n, algunas ejecuciones de prueba de ese c\u00f3digo: >>> lista = [3, 2, -1, 5, 0, 2] >>> ord_seleccion(lista) DEBUG: 3 5 [3, 2, -1, 2, 0, 5] DEBUG: 0 4 [0, 2, -1, 2, 3, 5] DEBUG: 1 3 [0, 2, -1, 2, 3, 5] DEBUG: 1 2 [0, -1, 2, 2, 3, 5] DEBUG: 0 1 [-1, 0, 2, 2, 3, 5] >>> lista [-1, 0, 2, 2, 3, 5] >>> lista = [] >>> ord_seleccion(lista) >>> l = [1] >>> ord_seleccion(lista) >>> lista [1] >>> lista = [1, 2, 3, 4, 5] >>> ord_seleccion(lista) DEBUG: 4 4 [1, 2, 3, 4, 5] DEBUG: 3 3 [1, 2, 3, 4, 5] DEBUG: 2 2 [1, 2, 3, 4, 5] DEBUG: 1 1 [1, 2, 3, 4, 5] Pod\u00e9s observar que incluso cuando la lista ya est\u00e1 ordenada, se la recorre buscando los mayores elementos y ubic\u00e1ndolos en la misma posici\u00f3n en la que se encuentran. Invariante en el ordenamiento por selecci\u00f3n Todo ordenamiento tiene un invariante que permite asegurarse de que cada paso que se toma va en la direcci\u00f3n de obtener una lista ordenada. En el caso del ordenamiento por selecci\u00f3n, el invariante es que los elementos en las posiciones desde n + 1 hasta el final de la lista est\u00e1n ordenados y son mayores que los elementos ubicados de 0 a n ; es decir que ya est\u00e1n en su posici\u00f3n definitiva. \u00bfCu\u00e1nto cuesta ordenar por selecci\u00f3n? Como se puede ver en el c\u00f3digo de la funci\u00f3n buscar_max , para buscar el m\u00e1ximo elemento en un segmento de lista se debe recorrer todo ese segmento, por lo que en nuestro caso debemos recorrer en el primer paso N elementos, en el segundo paso N-1 elementos, en el tercer paso N-2 elementos, etc. Cada visita a un elemento implica una cantidad constante y peque\u00f1a de comparaciones (que no depende de N ). Por lo tanto tenemos que T(N) ~ c * (2 + 3 + ... + N) ~ c * N * (N+1)/2 ~ N^2 O sea que ordenar por selecci\u00f3n una lista de tama\u00f1o N insume tiempo del orden de N^2 . Como ya mencionamos, este tiempo es independiente de si la lista estaba previamente ordenada o no. En cuanto al espacio utilizado, s\u00f3lo se tiene en memoria la lista que se desea ordenar y algunas variables de tama\u00f1o 1. Ordenamiento por inserci\u00f3n El m\u00e9todo de ordenamiento por inserci\u00f3n se basa en la siguiente idea: Una posible implementaci\u00f3n en Python de este algoritmo se incluye en el siguiente c\u00f3digo: def ord_insercion(lista): \"\"\"Ordena una lista de elementos seg\u00fan el m\u00e9todo de inserci\u00f3n. Pre: los elementos de la lista deben ser comparables. Post: la lista est\u00e1 ordenada.\"\"\" for i in range(len(lista) - 1): # Si el elemento de la posici\u00f3n i+1 est\u00e1 desordenado respecto # al de la posici\u00f3n i, reubicarlo dentro del segmento [0:i] if lista[i + 1] < lista[i]: reubicar(lista, i + 1) print(\"DEBUG: \", lista) def reubicar(lista, p): \"\"\"Reubica al elemento que est\u00e1 en la posici\u00f3n p de la lista dentro del segmento [0:p-1]. Pre: p tiene que ser una posicion v\u00e1lida de lista.\"\"\" v = lista[p] # Recorrer el segmento [0:p-1] de derecha a izquierda hasta # encontrar la posici\u00f3n j tal que lista[j-1] <= v < lista[j]. j = p while j > 0 and v < lista[j - 1]: # Desplazar los elementos hacia la derecha, dejando lugar # para insertar el elemento v donde corresponda. lista[j] = lista[j - 1] j -= 1 lista[j] = v La funci\u00f3n principal, ord_insercion() , recorre la lista desde el segundo elemento hasta el \u00faltimo, y cuando uno de estos elementos no est\u00e1 ordenado con respecto al anterior, llama a la funci\u00f3n auxiliar reubicar() , que se encarga de colocar el elemento en la posici\u00f3n que le corresponde. En la funci\u00f3n reubicar() se busca la posici\u00f3n correcta donde debe colocarse el elemento, a la vez que se van corriendo todos los elementos un lugar a la derecha, de modo que cuando se encuentra la posici\u00f3n, el valor a insertar reemplaza al valor que se encontraba all\u00ed anteriormente. En las siguientes ejecuciones puede verse que funciona correctamente. >>> lista = [3, 2, -1, 5, 0, 2] >>> ord_insercion(lista) DEBUG: [2, 3, -1, 5, 0, 2] DEBUG: [-1, 2, 3, 5, 0, 2] DEBUG: [-1, 2, 3, 5, 0, 2] DEBUG: [-1, 0, 2, 3, 5, 2] DEBUG: [-1, 0, 2, 2, 3, 5] >>> lista [-1, 0, 2, 2, 3, 5] >>> lista = [] >>> ord_insercion(lista) >>> lista = [1] >>> ord_insercion(lista) >>> lista [1] >>> lista = [1, 2, 3, 4, 5, 6] >>> ord_insercion(lista) DEBUG: [1, 2, 3, 4, 5, 6] DEBUG: [1, 2, 3, 4, 5, 6] DEBUG: [1, 2, 3, 4, 5, 6] DEBUG: [1, 2, 3, 4, 5, 6] DEBUG: [1, 2, 3, 4, 5, 6] >>> lista [1, 2, 3, 4, 5, 6] Invariante del ordenamiento por inserci\u00f3n En el ordenamiento por inserci\u00f3n, en cada paso se satisface que los elementos que se encuentran en el segmento de 0 a i est\u00e1n ordenados, de manera que agregar un nuevo elemento implica colocarlo en la posici\u00f3n correspondiente y el segmento seguir\u00e1 ordenado. \u00bfCu\u00e1nto cuesta ordenar por inserci\u00f3n? Del c\u00f3digo de ord_insercion() se puede ver que la funci\u00f3n principal avanza por la lista de izquierda a derecha, mientras que la funci\u00f3n reubicar() cambia los elementos de lugar de derecha a izquierda. Lo peor que le puede pasar a un elemento que est\u00e1 en la posici\u00f3n j es que deba ser ubicado al principio de la lista. Y lo peor que le puede pasar a una lista es que todos sus elementos deban ser reubicados. Por ejemplo, en la lista [10, 8, 6, 2, -2, -5] , todos los elementos deben ser reubicados al principio de la lista. En el primer paso, el segundo elemento se debe intercambiar con el primero; en el segundo paso, el tercer elemento se compara con el segundo y el primer elemento, y se ubica adelante de todo; en el tercer paso, el cuarto elemento se compara con el tercero, el segundo y el primer elemento, y se ubica adelante de todo; etc... T(N) ~ c * (2 + 3 + *s + N) ~ c * N * (N+1)/2 ~ N^2 Es decir que ordenar por inserci\u00f3n una lista de tama\u00f1o N puede insumir (en el peor caso) tiempo del orden de N^2 ( O(N^2) ). En cuanto al espacio utilizado, nuevamente s\u00f3lo se tiene en memoria la lista que se desea ordenar y algunas variables de tama\u00f1o 1. Inserci\u00f3n en una lista ordenada Resulta interesante observar que cuando la lista de entrada se encuentra ordenada, este algoritmo no hace ning\u00fan movimiento de elementos. Simplemente compara cada elemento con el anterior, y si es mayor sigue adelante. Es decir que para el caso de una lista de N elementos que se encuentra ordenada, el tiempo que insume el algoritmo de inserci\u00f3n es: T(N) ~ N . Resumen El ordenamiento por selecci\u00f3n es uno de los m\u00e1s sencillos, pero es bastante ineficiente: se basa en la idea de buscar el m\u00e1ximo en una secuencia, ubicarlo al final y seguir analizando la secuencia sin el \u00faltimo elemento. Tiene como ventaja que hace una baja cantidad de intercambios ( N ), pero como desventaja que necesita una alta cantidad de comparaciones ( N^2 ). Siempre tiene el mismo comportamiento. El ordenamiento por inserci\u00f3n es un algoritmo bastante intuitivo y se suele usar para ordenar en la vida real. Se basa en la idea de ir insertando ordenadamente : en cada paso se considera la inserci\u00f3n de un elemento m\u00e1s de secuencia y la inserci\u00f3n se empieza a hacer desde el final de los datos ya ordenados. Tiene como ventaja que en el caso de tener los datos ya ordenados no hace ning\u00fan intercambio (y hace s\u00f3lo N-1 comparaciones). En el peor caso, cuando la secuencia est\u00e1 invertida, se hace una gran cantidad de intercambios y comparaciones ( N^2 ). Si bien es un algoritmo ineficiente, para secuencias cortas el tiempo de ejecuci\u00f3n es bastante bueno. Ejercicios Ejercicio 12.1: Describ\u00ed los pasos del ordenamiento de la lista [0, 9, 3, 8, 5, 3, 2, 4] con los algoritmos de inserci\u00f3n y selecci\u00f3n. Ejercicio 12.2: burbujeo El ordenamiento por burbujeo se basa en una idea bastante sencilla. El algoritmo compara dos elementos contiguos de la lista y, si el orden es adecuado, los deja como est\u00e1n, si no, los intercambia. La repetici\u00f3n de este paso elemental (una burbuja) a lo largo de la lista (recorri\u00e9ndola desde el comienzo hasta el final) garantiza llevar el mayor elemento al final de la lista, pero no garantiza que el menor elemento haya quedado en el primer lugar. De hecho, el menor elemento solo se mueve un paso hacia la izquierda en una recorrida completa de la lista. Es por esto que estas recorridas se repiten sucesivas veces (\u00bfcu\u00e1ntas veces hace falta?) de manera de garantizar que la lista quede completamente ordenada. Como en el primer paso tenemos la garant\u00eda de que el mayor elemento qued\u00f3 al final de la lista, la segunda recorrida puede evitar llegar hasta esa \u00faltima posici\u00f3n. As\u00ed, cada recorrida es m\u00e1s corta que la anterior. En cada recorrida se comparan todos los pares de elementos sucesivos (en el rango correspondiente) y se intercambian si no est\u00e1n ordenados. Program\u00e1 una funci\u00f3n ord_burbujeo(lista) que implemente este m\u00e9todo de ordenamiento. \u00bfCu\u00e1ntas comparaciones realiza esta funci\u00f3n en una lista de largo n? Prob\u00e1 tu c\u00f3digo con las siguientes listas. lista_1 = [1, 2, -3, 8, 1, 5] lista_2 = [1, 2, 3, 4, 5] lista_3 = [0, 9, 3, 8, 5, 3, 2, 4] lista_4 = [10, 8, 6, 2, -2, -5] lista_5 = [2, 5, 1, 0] Guard\u00e1 tu soluci\u00f3n en el archivo burbujeo.py comentando la complejidad del algoritmo y c\u00f3mo la calculaste. Extra: \u00bfPod\u00e9s escribir una versi\u00f3n recursiva de este algoritmo? Ejercicio 12.3: ordernar a mano Eleg\u00ed dos listas de las 5 del ejercicio anterior y ordenalas a mano (con papel y l\u00e1piz) con los 3 m\u00e9todos: selecci\u00f3n, inserci\u00f3n y burbujeo. Ejercicio 12.4: experimento con 3 m\u00e9todos Hac\u00e9 una funci\u00f3n generar_lista(N) que genere una lista aleatoria de largo N con n\u00fameros enteros del 1 al 1000 (puede haber repeticiones). Modific\u00e1 el c\u00f3digo de las tres funciones para que cuenten cu\u00e1ntas comparaciones entre elementos de la lista realiza cada una. Por ejemplo, ord_seleccion realiza comparaciones (entre elementos de la lista) s\u00f3lo cuando llama a buscar_max(lista, a, b) y en ese caso realiza b-a comparaciones. Realiz\u00e1 un experimento que genere una lista de largo N y la ordene con los tres m\u00e9todos (burbujeo, inserci\u00f3n y selecci\u00f3n). Para N = 10, realiz\u00e1 k = 100 repeticiones del siguiente experimento. Generar una lista de largo N , ordenarlas con los tres m\u00e9todos y guardar la cantidad de operaciones. Al final, debe imprimir el promedio de comparaciones realizado por cada m\u00e9todo. Cuidado : us\u00e1 las mismas listas para los tres m\u00e9todos as\u00ed la comparaci\u00f3n es justa. Ejercicio 12.5: comparar m\u00e9todos gr\u00e1ficamente Vamos a tratar de comparar visualmente la cantidad de comparaciones que hacen estos algoritmos para diferentes largos de listas. Hac\u00e9 un programa comparaciones_ordenamiento.py que para N entre 1 y 256 genere una lista de largo N con n\u00fameros enteros del 1 al 1000 en orden aleatorio, calcule la cantidad de comparaciones realizadas por cada m\u00e9todo de ordenamiento y guarde estos resultados en tres vectores de largo 256: comparaciones_seleccion , comparaciones_insercion y comparaciones_burbujeo . Grafic\u00e1 estos tres vectores. Si las curvas se superponen, grafic\u00e1 una de ellas con l\u00ednea punteada para poder verlas bien. \u00bfC\u00f3mo dir\u00edas que crece la complejidad de estos m\u00e9todos? \u00bfPara cu\u00e1les depende de la lista a ordenar y para cu\u00e1les solamente depende del largo de la lista? Guard\u00e1 comparaciones_ordenamiento.py para seguir trabajando sobre \u00e9l y para entregarlo. \u00bfSe te ocurre un algoritmo de ordenamiento que sea sustancialmente mejor que estos? Ese ser\u00e1 el tema de la pr\u00f3xima secci\u00f3n. Extra: \u00bfLas curvas de complejidad quedaron suaves? \u00bfSe te ocurre c\u00f3mo hacer para suavizarlas? Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Divide y reinar\u00e1s)","title":"02 Ordenamiento sencillo"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#122-ordenamientos-sencillos-de-listas","text":"Para esta secci\u00f3n tenemos un video introductorio . El problema del ordenamiento es tan fundamental que, a pesar de que Python ya lo hace con su m\u00e9todo sort() por ejemplo, nos interesa discutirlo. Hay una diversidad de soluciones para ordenar listas. Vamos a empezar viendo las m\u00e1s sencillas de escribir (que en general suelen ser las m\u00e1s caras).","title":"12.2 Ordenamientos sencillos de listas"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#ordenamiento-por-seleccion","text":"El m\u00e9todo de ordenamiento por selecci\u00f3n se basa en la siguiente idea: La siguiente animaci\u00f3n muestra un algoritmo de ordenamiento por selecci\u00f3n (que busca el menor en cada paso, en lugar del mayor): Una implementaci\u00f3n en Python puede verse en el siguiente c\u00f3digo. def ord_seleccion(lista): \"\"\"Ordena una lista de elementos seg\u00fan el m\u00e9todo de selecci\u00f3n. Pre: los elementos de la lista deben ser comparables. Post: la lista est\u00e1 ordenada.\"\"\" # posici\u00f3n final del segmento a tratar n = len(lista) - 1 # mientras haya al menos 2 elementos para ordenar while n > 0: # posici\u00f3n del mayor valor del segmento p = buscar_max(lista, 0, n) # intercambiar el valor que est\u00e1 en p con el valor que # est\u00e1 en la \u00faltima posici\u00f3n del segmento lista[p], lista[n] = lista[n], lista[p] print(\"DEBUG: \", p, n, lista) # reducir el segmento en 1 n = n - 1 def buscar_max(lista, a, b): \"\"\"Devuelve la posici\u00f3n del m\u00e1ximo elemento en un segmento de lista de elementos comparables. La lista no debe ser vac\u00eda. a y b son las posiciones inicial y final del segmento\"\"\" pos_max = a for i in range(a + 1, b + 1): if lista[i] > lista[pos_max]: pos_max = i return pos_max La funci\u00f3n principal, ord_seleccion() es la encargada de recorrer la lista, ubicando el mayor elemento al final del segmento y luego reduciendo el segmento a analizar. La funci\u00f3n buscar_max() busca el mayor elemento de un segmento de la lista y devuelve su posici\u00f3n. A continuaci\u00f3n, algunas ejecuciones de prueba de ese c\u00f3digo: >>> lista = [3, 2, -1, 5, 0, 2] >>> ord_seleccion(lista) DEBUG: 3 5 [3, 2, -1, 2, 0, 5] DEBUG: 0 4 [0, 2, -1, 2, 3, 5] DEBUG: 1 3 [0, 2, -1, 2, 3, 5] DEBUG: 1 2 [0, -1, 2, 2, 3, 5] DEBUG: 0 1 [-1, 0, 2, 2, 3, 5] >>> lista [-1, 0, 2, 2, 3, 5] >>> lista = [] >>> ord_seleccion(lista) >>> l = [1] >>> ord_seleccion(lista) >>> lista [1] >>> lista = [1, 2, 3, 4, 5] >>> ord_seleccion(lista) DEBUG: 4 4 [1, 2, 3, 4, 5] DEBUG: 3 3 [1, 2, 3, 4, 5] DEBUG: 2 2 [1, 2, 3, 4, 5] DEBUG: 1 1 [1, 2, 3, 4, 5] Pod\u00e9s observar que incluso cuando la lista ya est\u00e1 ordenada, se la recorre buscando los mayores elementos y ubic\u00e1ndolos en la misma posici\u00f3n en la que se encuentran.","title":"Ordenamiento por selecci\u00f3n"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#invariante-en-el-ordenamiento-por-seleccion","text":"Todo ordenamiento tiene un invariante que permite asegurarse de que cada paso que se toma va en la direcci\u00f3n de obtener una lista ordenada. En el caso del ordenamiento por selecci\u00f3n, el invariante es que los elementos en las posiciones desde n + 1 hasta el final de la lista est\u00e1n ordenados y son mayores que los elementos ubicados de 0 a n ; es decir que ya est\u00e1n en su posici\u00f3n definitiva.","title":"Invariante en el ordenamiento por selecci\u00f3n"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#cuanto-cuesta-ordenar-por-seleccion","text":"Como se puede ver en el c\u00f3digo de la funci\u00f3n buscar_max , para buscar el m\u00e1ximo elemento en un segmento de lista se debe recorrer todo ese segmento, por lo que en nuestro caso debemos recorrer en el primer paso N elementos, en el segundo paso N-1 elementos, en el tercer paso N-2 elementos, etc. Cada visita a un elemento implica una cantidad constante y peque\u00f1a de comparaciones (que no depende de N ). Por lo tanto tenemos que T(N) ~ c * (2 + 3 + ... + N) ~ c * N * (N+1)/2 ~ N^2 O sea que ordenar por selecci\u00f3n una lista de tama\u00f1o N insume tiempo del orden de N^2 . Como ya mencionamos, este tiempo es independiente de si la lista estaba previamente ordenada o no. En cuanto al espacio utilizado, s\u00f3lo se tiene en memoria la lista que se desea ordenar y algunas variables de tama\u00f1o 1.","title":"\u00bfCu\u00e1nto cuesta ordenar por selecci\u00f3n?"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#ordenamiento-por-insercion","text":"El m\u00e9todo de ordenamiento por inserci\u00f3n se basa en la siguiente idea: Una posible implementaci\u00f3n en Python de este algoritmo se incluye en el siguiente c\u00f3digo: def ord_insercion(lista): \"\"\"Ordena una lista de elementos seg\u00fan el m\u00e9todo de inserci\u00f3n. Pre: los elementos de la lista deben ser comparables. Post: la lista est\u00e1 ordenada.\"\"\" for i in range(len(lista) - 1): # Si el elemento de la posici\u00f3n i+1 est\u00e1 desordenado respecto # al de la posici\u00f3n i, reubicarlo dentro del segmento [0:i] if lista[i + 1] < lista[i]: reubicar(lista, i + 1) print(\"DEBUG: \", lista) def reubicar(lista, p): \"\"\"Reubica al elemento que est\u00e1 en la posici\u00f3n p de la lista dentro del segmento [0:p-1]. Pre: p tiene que ser una posicion v\u00e1lida de lista.\"\"\" v = lista[p] # Recorrer el segmento [0:p-1] de derecha a izquierda hasta # encontrar la posici\u00f3n j tal que lista[j-1] <= v < lista[j]. j = p while j > 0 and v < lista[j - 1]: # Desplazar los elementos hacia la derecha, dejando lugar # para insertar el elemento v donde corresponda. lista[j] = lista[j - 1] j -= 1 lista[j] = v La funci\u00f3n principal, ord_insercion() , recorre la lista desde el segundo elemento hasta el \u00faltimo, y cuando uno de estos elementos no est\u00e1 ordenado con respecto al anterior, llama a la funci\u00f3n auxiliar reubicar() , que se encarga de colocar el elemento en la posici\u00f3n que le corresponde. En la funci\u00f3n reubicar() se busca la posici\u00f3n correcta donde debe colocarse el elemento, a la vez que se van corriendo todos los elementos un lugar a la derecha, de modo que cuando se encuentra la posici\u00f3n, el valor a insertar reemplaza al valor que se encontraba all\u00ed anteriormente. En las siguientes ejecuciones puede verse que funciona correctamente. >>> lista = [3, 2, -1, 5, 0, 2] >>> ord_insercion(lista) DEBUG: [2, 3, -1, 5, 0, 2] DEBUG: [-1, 2, 3, 5, 0, 2] DEBUG: [-1, 2, 3, 5, 0, 2] DEBUG: [-1, 0, 2, 3, 5, 2] DEBUG: [-1, 0, 2, 2, 3, 5] >>> lista [-1, 0, 2, 2, 3, 5] >>> lista = [] >>> ord_insercion(lista) >>> lista = [1] >>> ord_insercion(lista) >>> lista [1] >>> lista = [1, 2, 3, 4, 5, 6] >>> ord_insercion(lista) DEBUG: [1, 2, 3, 4, 5, 6] DEBUG: [1, 2, 3, 4, 5, 6] DEBUG: [1, 2, 3, 4, 5, 6] DEBUG: [1, 2, 3, 4, 5, 6] DEBUG: [1, 2, 3, 4, 5, 6] >>> lista [1, 2, 3, 4, 5, 6]","title":"Ordenamiento por inserci\u00f3n"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#invariante-del-ordenamiento-por-insercion","text":"En el ordenamiento por inserci\u00f3n, en cada paso se satisface que los elementos que se encuentran en el segmento de 0 a i est\u00e1n ordenados, de manera que agregar un nuevo elemento implica colocarlo en la posici\u00f3n correspondiente y el segmento seguir\u00e1 ordenado.","title":"Invariante del ordenamiento por inserci\u00f3n"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#cuanto-cuesta-ordenar-por-insercion","text":"Del c\u00f3digo de ord_insercion() se puede ver que la funci\u00f3n principal avanza por la lista de izquierda a derecha, mientras que la funci\u00f3n reubicar() cambia los elementos de lugar de derecha a izquierda. Lo peor que le puede pasar a un elemento que est\u00e1 en la posici\u00f3n j es que deba ser ubicado al principio de la lista. Y lo peor que le puede pasar a una lista es que todos sus elementos deban ser reubicados. Por ejemplo, en la lista [10, 8, 6, 2, -2, -5] , todos los elementos deben ser reubicados al principio de la lista. En el primer paso, el segundo elemento se debe intercambiar con el primero; en el segundo paso, el tercer elemento se compara con el segundo y el primer elemento, y se ubica adelante de todo; en el tercer paso, el cuarto elemento se compara con el tercero, el segundo y el primer elemento, y se ubica adelante de todo; etc... T(N) ~ c * (2 + 3 + *s + N) ~ c * N * (N+1)/2 ~ N^2 Es decir que ordenar por inserci\u00f3n una lista de tama\u00f1o N puede insumir (en el peor caso) tiempo del orden de N^2 ( O(N^2) ). En cuanto al espacio utilizado, nuevamente s\u00f3lo se tiene en memoria la lista que se desea ordenar y algunas variables de tama\u00f1o 1.","title":"\u00bfCu\u00e1nto cuesta ordenar por inserci\u00f3n?"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#insercion-en-una-lista-ordenada","text":"Resulta interesante observar que cuando la lista de entrada se encuentra ordenada, este algoritmo no hace ning\u00fan movimiento de elementos. Simplemente compara cada elemento con el anterior, y si es mayor sigue adelante. Es decir que para el caso de una lista de N elementos que se encuentra ordenada, el tiempo que insume el algoritmo de inserci\u00f3n es: T(N) ~ N .","title":"Inserci\u00f3n en una lista ordenada"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#resumen","text":"El ordenamiento por selecci\u00f3n es uno de los m\u00e1s sencillos, pero es bastante ineficiente: se basa en la idea de buscar el m\u00e1ximo en una secuencia, ubicarlo al final y seguir analizando la secuencia sin el \u00faltimo elemento. Tiene como ventaja que hace una baja cantidad de intercambios ( N ), pero como desventaja que necesita una alta cantidad de comparaciones ( N^2 ). Siempre tiene el mismo comportamiento. El ordenamiento por inserci\u00f3n es un algoritmo bastante intuitivo y se suele usar para ordenar en la vida real. Se basa en la idea de ir insertando ordenadamente : en cada paso se considera la inserci\u00f3n de un elemento m\u00e1s de secuencia y la inserci\u00f3n se empieza a hacer desde el final de los datos ya ordenados. Tiene como ventaja que en el caso de tener los datos ya ordenados no hace ning\u00fan intercambio (y hace s\u00f3lo N-1 comparaciones). En el peor caso, cuando la secuencia est\u00e1 invertida, se hace una gran cantidad de intercambios y comparaciones ( N^2 ). Si bien es un algoritmo ineficiente, para secuencias cortas el tiempo de ejecuci\u00f3n es bastante bueno.","title":"Resumen"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#ejercicios","text":"","title":"Ejercicios"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#ejercicio-121","text":"Describ\u00ed los pasos del ordenamiento de la lista [0, 9, 3, 8, 5, 3, 2, 4] con los algoritmos de inserci\u00f3n y selecci\u00f3n.","title":"Ejercicio 12.1:"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#ejercicio-122-burbujeo","text":"El ordenamiento por burbujeo se basa en una idea bastante sencilla. El algoritmo compara dos elementos contiguos de la lista y, si el orden es adecuado, los deja como est\u00e1n, si no, los intercambia. La repetici\u00f3n de este paso elemental (una burbuja) a lo largo de la lista (recorri\u00e9ndola desde el comienzo hasta el final) garantiza llevar el mayor elemento al final de la lista, pero no garantiza que el menor elemento haya quedado en el primer lugar. De hecho, el menor elemento solo se mueve un paso hacia la izquierda en una recorrida completa de la lista. Es por esto que estas recorridas se repiten sucesivas veces (\u00bfcu\u00e1ntas veces hace falta?) de manera de garantizar que la lista quede completamente ordenada. Como en el primer paso tenemos la garant\u00eda de que el mayor elemento qued\u00f3 al final de la lista, la segunda recorrida puede evitar llegar hasta esa \u00faltima posici\u00f3n. As\u00ed, cada recorrida es m\u00e1s corta que la anterior. En cada recorrida se comparan todos los pares de elementos sucesivos (en el rango correspondiente) y se intercambian si no est\u00e1n ordenados. Program\u00e1 una funci\u00f3n ord_burbujeo(lista) que implemente este m\u00e9todo de ordenamiento. \u00bfCu\u00e1ntas comparaciones realiza esta funci\u00f3n en una lista de largo n? Prob\u00e1 tu c\u00f3digo con las siguientes listas. lista_1 = [1, 2, -3, 8, 1, 5] lista_2 = [1, 2, 3, 4, 5] lista_3 = [0, 9, 3, 8, 5, 3, 2, 4] lista_4 = [10, 8, 6, 2, -2, -5] lista_5 = [2, 5, 1, 0] Guard\u00e1 tu soluci\u00f3n en el archivo burbujeo.py comentando la complejidad del algoritmo y c\u00f3mo la calculaste. Extra: \u00bfPod\u00e9s escribir una versi\u00f3n recursiva de este algoritmo?","title":"Ejercicio 12.2: burbujeo"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#ejercicio-123-ordernar-a-mano","text":"Eleg\u00ed dos listas de las 5 del ejercicio anterior y ordenalas a mano (con papel y l\u00e1piz) con los 3 m\u00e9todos: selecci\u00f3n, inserci\u00f3n y burbujeo.","title":"Ejercicio 12.3: ordernar a mano"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#ejercicio-124-experimento-con-3-metodos","text":"Hac\u00e9 una funci\u00f3n generar_lista(N) que genere una lista aleatoria de largo N con n\u00fameros enteros del 1 al 1000 (puede haber repeticiones). Modific\u00e1 el c\u00f3digo de las tres funciones para que cuenten cu\u00e1ntas comparaciones entre elementos de la lista realiza cada una. Por ejemplo, ord_seleccion realiza comparaciones (entre elementos de la lista) s\u00f3lo cuando llama a buscar_max(lista, a, b) y en ese caso realiza b-a comparaciones. Realiz\u00e1 un experimento que genere una lista de largo N y la ordene con los tres m\u00e9todos (burbujeo, inserci\u00f3n y selecci\u00f3n). Para N = 10, realiz\u00e1 k = 100 repeticiones del siguiente experimento. Generar una lista de largo N , ordenarlas con los tres m\u00e9todos y guardar la cantidad de operaciones. Al final, debe imprimir el promedio de comparaciones realizado por cada m\u00e9todo. Cuidado : us\u00e1 las mismas listas para los tres m\u00e9todos as\u00ed la comparaci\u00f3n es justa.","title":"Ejercicio 12.4: experimento con 3 m\u00e9todos"},{"location":"12_Ordenamiento/02_Ordenamiento_sencillo/#ejercicio-125-comparar-metodos-graficamente","text":"Vamos a tratar de comparar visualmente la cantidad de comparaciones que hacen estos algoritmos para diferentes largos de listas. Hac\u00e9 un programa comparaciones_ordenamiento.py que para N entre 1 y 256 genere una lista de largo N con n\u00fameros enteros del 1 al 1000 en orden aleatorio, calcule la cantidad de comparaciones realizadas por cada m\u00e9todo de ordenamiento y guarde estos resultados en tres vectores de largo 256: comparaciones_seleccion , comparaciones_insercion y comparaciones_burbujeo . Grafic\u00e1 estos tres vectores. Si las curvas se superponen, grafic\u00e1 una de ellas con l\u00ednea punteada para poder verlas bien. \u00bfC\u00f3mo dir\u00edas que crece la complejidad de estos m\u00e9todos? \u00bfPara cu\u00e1les depende de la lista a ordenar y para cu\u00e1les solamente depende del largo de la lista? Guard\u00e1 comparaciones_ordenamiento.py para seguir trabajando sobre \u00e9l y para entregarlo. \u00bfSe te ocurre un algoritmo de ordenamiento que sea sustancialmente mejor que estos? Ese ser\u00e1 el tema de la pr\u00f3xima secci\u00f3n. Extra: \u00bfLas curvas de complejidad quedaron suaves? \u00bfSe te ocurre c\u00f3mo hacer para suavizarlas? Contenidos | Anterior (1 Introducci\u00f3n) | Pr\u00f3ximo (3 Divide y reinar\u00e1s)","title":"Ejercicio 12.5: comparar m\u00e9todos gr\u00e1ficamente"},{"location":"12_Ordenamiento/03_Divide_and_Conquer/","text":"Contenidos | Anterior (2 Ordenamientos sencillos de listas) | Pr\u00f3ximo (4 Algoritmos de clasificaci\u00f3n supervisada) 12.3 Divide y reinar\u00e1s Para esta secci\u00f3n tenemos este video introductorio . El problema del ordenamiento es un problema fundamental y hay much\u00edsimos algoritmos que lo resuelven . Los m\u00e9todos de ordenamiento vistos en la secci\u00f3n anterior eran m\u00e9todos iterativos cuyo tiempo de ejecuci\u00f3n era cuadr\u00e1tico. Veremos ahora el merge sort que es un algoritmo un poco m\u00e1s complejo conceptualmente pero menos complejo computacionalmente. El algoritmo est\u00e1 basado en una idea muy fecunda en el dise\u00f1o de algoritmos eficientes que se denomina divide y reinar\u00e1s (\u00f3 divide and conquer en ingl\u00e9s). Divide y reinar\u00e1s es un paradigma de dise\u00f1o de algoritmos recursivos que trabaja partiendo (dividiendo) el problema original en subproblemas del mismo tipo pero m\u00e1s sencillos de resolver. Las soluciones de estos subproblemas luego se combinan para obtener una soluci\u00f3n del problema original. La correctitud de los algoritmos de este tipo suele probarse utilizando la inducci\u00f3n matem\u00e1tica y el c\u00e1lculo de su complejidad involucra la resoluci\u00f3n de ecuaciones de recurrencia cuyos detalles escapan el alcance de este curso. El algoritmo merge sort (u ordenamiento por mezcla) El merge sort se basa en la siguiente idea: Si la lista es peque\u00f1a (vac\u00eda o de tama\u00f1o 1) ya est\u00e1 ordenada y no hay nada que hacer. De lo contrario hacer lo siguiente: Dividir la lista al medio, formando dos sublistas de (aproximadamente) el mismo tama\u00f1o cada una. Ordenar cada una de esas dos sublistas (usando este mismo m\u00e9todo). Una vez que se ordenaron ambas sublistas, intercalarlas (mergearlas) de manera ordenada. Por ejemplo, si la lista original es [6, 7, -1, 0, 5, 2, 3, 8] deberemos ordenar recursivamente [6, 7, -1, 0] y [5, 2, 3, 8] con lo cual obtendremos [-1, 0, 6, 7] y [2, 3, 5, 8] . Si intercalamos ordenadamente las dos listas ordenadas obtenemos la soluci\u00f3n buscada: [-1, 0, 2, 3, 5, 6, 7, 8] . Veamos otro ejemplo con un gif animado: Dise\u00f1emos la funci\u00f3n merge_sort(lista) : Si lista es peque\u00f1a (vac\u00eda o de tama\u00f1o 1) ya est\u00e1 ordenada y no hay nada que hacer. Se devuelve lista original. De lo contrario: medio = len(lista) // 2 izq = merge_sort(lista[:medio]) der = merge_sort(lista[medio:]) Se devuelve merge(izq, der) . Falta s\u00f3lo dise\u00f1ar la funci\u00f3n merge : dadas dos listas ordenadas debe obtener una nueva lista que resulte de intercalar a ambas de manera ordenada: Utilizaremos dos \u00edndices, i y j , para recorrer cada una de las dos listas. Utilizaremos una tercera lista, resultado , donde almacenaremos el resultado. Mientras i sea menor que el largo de lista1 y j menor que el largo de lista2 , significa que hay elementos para comparar en ambas listas. Si el menor es el de lista1 : Agregar el elemento lista1[i] al final de la lista resultado . Incrementar el \u00edndice i . de lo contrario: Agregar el elemento lista2[j] al final de la lista resultado . Incrementar el \u00edndice j . Una vez que una de las dos listas se termina, simplemente hay que agregar todo lo que queda en la otra al final de la lista resultado . El c\u00f3digo resultante del dise\u00f1o de ambas funciones puede verse a continuaci\u00f3n: import random def merge_sort(lista): \"\"\"Ordena lista mediante el m\u00e9todo merge sort. Pre: lista debe contener elementos comparables. Devuelve: una nueva lista ordenada.\"\"\" if len(lista) < 2: lista_nueva = lista else: medio = len(lista) // 2 izq = merge_sort(lista[:medio]) der = merge_sort(lista[medio:]) lista_nueva = merge(izq, der) return lista_nueva def merge(lista1, lista2): \"\"\"Intercala los elementos de lista1 y lista2 de forma ordenada. Pre: lista1 y lista2 deben estar ordenadas. Devuelve: una lista con los elementos de lista1 y lista2.\"\"\" i, j = 0, 0 resultado = [] while(i < len(lista1) and j < len(lista2)): if (lista1[i] < lista2[j]): resultado.append(lista1[i]) i += 1 else: resultado.append(lista2[j]) j += 1 # Agregar lo que falta de una lista resultado += lista1[i:] resultado += lista2[j:] return resultado El m\u00e9todo divide y reinar\u00e1s que hemos usado para resolver el problema de ordenar una lista puede aplicarse tambi\u00e9n en otras situaciones. Hace falta que sea posible resolver el problema parti\u00e9ndolo en varios subproblemas de tama\u00f1o menor, resolver cada uno de esos subproblemas por separado aplicando la misma t\u00e9cnica (en nuestro caso ordenar por mezcla cada una de las dos sublistas), y finalmente juntar estas soluciones parciales en una soluci\u00f3n completa del problema mayor (en nuestro caso la intercalaci\u00f3n ordenada de las dos sublistas ordenadas). Como siempre sucede con las soluciones recursivas, debemos encontrar un caso base en el cual no se aplica la llamada recursiva (en nuestro caso: si la lista tiene largo cero o uno, ya est\u00e1 ordenada y no hay nada que hacer). Adem\u00e1s debemos asegurar que siempre se alcanza el caso base, y en nuestro caso aseguramos eso porque, si no estamos en el caso base, la lista se divide en mitades decrementando su longitud. El m\u00e9todo divide y reinar\u00e1s es fecundo y ha dado lugar a algoritmos muy eficientes para tareas muy dis\u00edmiles como multiplicar matrices, calcular la transformada de Fourier o realizar an\u00e1lisis sint\u00e1cticos (parsear). Ejemplo: \u00c1rbol de recursi\u00f3n Para representar gr\u00e1ficamente las llamadas recursivas de la funci\u00f3n merge_sort() podemos hacer un \u00e1rbol similar al que mostramos en la Secci\u00f3n 11.2 para la sucesi\u00f3n de Fibonacci. Esta vez, como queremos mostrar no s\u00f3lo las llamadas sino tambi\u00e9n lo que devuelve cada llamada, espejaremos el \u00e1rbol obteniendo un grafo. Ac\u00e1 mostramos el \u00e1rbol de recursi\u00f3n de merge_sort([3, 1, 0, 4, 2]) . \u00bfCu\u00e1nto cuesta el Merge sort ? Supongamos que tenemos que ordenar una lista de l longitud N . Observamos lo siguiente: Para intercalar dos listas de longitud N/2 hace falta recorrer ambas listas que en total tienen N elementos. La cantidad de operaciones resulta proporcional a N . Llamemos a * N a ese tiempo. Si llamamos T(N) al tiempo que tarda el algoritmo en ordenar una lista de longitud N , vemos que T(N) = 2 * T(N/2) + a * N . Adem\u00e1s, cuando la lista es peque\u00f1a, la operaci\u00f3n es de tiempo constante: T(1) = T(0) = b . Para simplificar la cuenta vamos a suponer que N = 2^k . T(N) = T(2^k) = 2 * T(2^(k-1)) + a * 2^k = 2 * ( 2 * T(2^(k-2)) + a * 2^(k-1)) + a * 2^k = 2^2 * T(2^(k-2)) + a * 2^k +a * 2^k . . . = 2^i * T(2^(k-i))+ i * a * 2^k . . . = 2^k * T(1) + k * a * 2^k = b * 2^k + k * a * 2^k Pero si N = 2^k entonces k = log2(N) , y por lo tanto hemos demostrado que: T(N) = b * N + a * N * log2(N). Como lo que nos interesa es aproximar el valor, diremos (despreciando el t\u00e9rmino de menor orden) que T(N) ~ N * log2(N) Dado que log2(N) es un n\u00famero mucho m\u00e1s peque\u00f1o que N , hemos mostrado entonces que el merge sort se porta mucho mejor (es decir, es m\u00e1s eficiente) que los tres m\u00e9todos de ordenamiento que discutimos en la secci\u00f3n anterior (que eran cuadr\u00e1ticos). Si analizamos el espacio que consume, vemos que a cada paso la funci\u00f3n merge genera una nueva lista cuya longitud es la suma de los tama\u00f1os de las dos listas, por lo que merge_sort usa el doble de espacio que la lista de entrada. Resumen Los m\u00e9todos de ordenamiento de selecci\u00f3n, inserci\u00f3n y burbujeo presentados en la secci\u00f3n anterior son m\u00e9todos conceptualmente sencillos pero costosos en cantidad de operaciones (intercambios y/o comparaciones). Sin embargo, es posible conseguir m\u00e9todos m\u00e1s eficientes usando algoritmos recursivos. El algoritmo merge sort consiste en dividir la lista a ordenar hasta que tenga 1 \u00f3 0 elementos y luego combinar la lista de forma ordenada. De esta manera se logra un tiempo proporcional a N * log2(N) . Ejercicios: Ejercicio 12.6: Orden\u00e1 la lista [6, 0, 3, 2, 5, 7, 4, 1] usando el m\u00e9todo merge sort. Dibuj\u00e1 el \u00e1rbol de recursi\u00f3n explicando las llamadas que se hacen en cada paso, y el orden en el que se realizan, como mostramos m\u00e1s arriba para la lista [3, 1, 0, 4, 2] . Ejercicio 12.7: Modific\u00e1 la funci\u00f3n merge_sort para que tambi\u00e9n devuelva la cantidad de comparaciones hechas. Rehac\u00e9 el \u00faltimo ejercicio de la secci\u00f3n anterior ( Ejercicio 12.5 ) incorporando el merge sort a la comparaci\u00f3n y al gr\u00e1fico. Describ\u00ed con tus palabras qu\u00e9 observas. Guard\u00e1 el archivo comparaciones_ordenamiento.py con estas modificaciones, para entregarlo. El m\u00f3dulo timeit Hay casos en que contar la cantidad de operaciones que un algoritmo realiza se vuelve muy engorroso. Una alternativa simple aunque menos exacta es medir su tiempo de ejecuci\u00f3n para problemas de distintos tama\u00f1os y estimar el orden del algoritmo a partir del cambio en el tiempo de ejecuci\u00f3n al cambiar el tama\u00f1o del problema. Existe un m\u00f3dulo llamado timeit que permite medir tiempos de ejecuci\u00f3n de c\u00f3digo Python. El comando timeit() del modulo timeit devuelve, en segundos, el tiempo de ejecuci\u00f3n total para el comando y n\u00famero de repeticiones especificadas. El c\u00f3digo a ejecutar y la cantidad de ejecuciones se pasan como par\u00e1metros. En esta secci\u00f3n, vamos a usarlo para comparar algoritmos de ordenamiento. En el siguiente ejemplo se le pide a Python una demora de 1 segundo (sleep(1)) y se le pide a timeit() que devuelva el tiempo de ejecuci\u00f3n de ese comando, ejecutado una sola vez). Prob\u00e1lo varias veces: In [1]: import time In [2]: import timeit as tt In [3]: tt.timeit('time.sleep(1)',number = 1) Out[3]: 1.0010360410087742 Notar\u00e1s que el tiempo de ejecuci\u00f3n est\u00e1 muy cerca del esperado (1 segundo), pero no es exactamente ese valor y adem\u00e1s hay cierta variacion entre repeticiones. Ahora evaluemos la siguiente expresi\u00f3n, que concatena en un string los primeros 100 n\u00fameros enteros. Ejecutala por lo menos diez veces y mir\u00e1 como var\u00eda la salida: In [4]: tt.timeit('\"-\".join(str(n) for n in range(100))', number = 1) Out[4]: 6.670000296551734e-05 Si medimos un proceso que tarda poco tiempo como en el \u00faltimo ejemplo, obtendremos resultados con una variabilidad de magnitud similar a la duraci\u00f3n del proceso. Si queremos comparar duraciones relativas es mejor medir procesos largos o, si se trata de un proceso corto, repetirlo muchas veces. Usando timeit() podemos hacer esto cambiando el parametro number . Prob\u00e1 lo siguiente: In [5]: tt.timeit('\"-\".join(str(n) for n in range(100))', number = 10000) Out[5]: 0.3018611848820001 Ahora comparemos la duraci\u00f3n de ese c\u00f3digo python con la duraci\u00f3n de otras expresiones que dan el mismo resultado. Ejecut\u00e1 cada una varias veces: In [6]: tt.timeit('\"-\".join(str(n) for n in range(100))', number = 10000) Out[6]: 0.3018611848820001 In [7]: tt.timeit('\"-\".join([str(n) for n in range(100)])', number = 10000) Out[7]: 0.2727368790656328 In [8]: tt.timeit('\"-\".join(map(str, range(100)))', number = 10000) Out[8]: 0.23702679807320237 Ejemplo: evaluar el m\u00e9todo de ordenamiento por selecci\u00f3n con timeit . Queremos evaluar cu\u00e1nto tarda del m\u00e9todo de ordenamiento por selecci\u00f3n para diferentes longitudes de la lista a ordenar. Para eso, primero generamos listas de longitudes entre 1 y 256. listas = [] for N in range(1, 256): listas.append(generar_lista(N)) Luego, definimos una funci\u00f3n \"wrapper\"\"(envoltorio) llamada experimento_timeit_seleccion(listas, num) que realiza un experimento usando timeit para evaluar el m\u00e9todo de selecci\u00f3n (repitiendo num veces) con las listas que le pasamos como par\u00e1metro, y devuelve en un vector los tiempos de ejecuci\u00f3n para cada lista. def experimento_timeit_seleccion(listas, num): \"\"\" Realiza un experimento usando timeit para evaluar el m\u00e9todo de selecci\u00f3n para ordenamiento de listas con las listas pasadas como entrada y devuelve los tiempos de ejecuci\u00f3n para cada lista en un vector. El par\u00e1metro 'listas' debe ser una lista de listas. El par\u00e1metro 'num' indica el n\u00famero de veces que repite el ordenamiento para cada lista. \"\"\" tiempos_seleccion = [] global lista for lista in listas: # eval\u00fao el m\u00e9todo de selecci\u00f3n # en una copia nueva para cada iteraci\u00f3n tiempo_seleccion = tt.timeit('ord_seleccion(lista.copy())', number = num, globals = globals()) # guardo el resultado tiempos_seleccion.append(tiempo_seleccion) # paso los tiempos a arrays tiempos_seleccion = np.array(tiempos_seleccion) return tiempos_seleccion El par\u00e1metro globals = globals() permite a timeit() acceder a las variables y funciones definidas en el namespace global en que se est\u00e1 ejecutando. El comando global lista hace que la variable lista que va recorriendo la lista de listas, sea global y por lo tanto accesible a timeit() . Y ahora realizamos el experimento y lo graficamos. tiempos_seleccion = experimento_timeit_seleccion(listas, 100) plt.plot(tiempos_seleccion) Ejercicio 12.8: La idea de este ejercicio es, nuevamente, comparar los algoritmos de ordenamiento que vimos hasta ahora pero usando timeit() en lugar de contando a mano la cantidad de operaciones. Junt\u00e1 en el archivo time_ordenamiento.py los m\u00e9todos de b\u00fasqueda del Ejercicio 12.7 . Antes de empezar el experimento, elimin\u00e1 de las funciones a medir todo c\u00f3digo no esencial, en particular los prints para debug. Consumen tiempo y no son parte del algoritmo. Tambi\u00e9n elimin\u00e1 las cuentas de comparaciones, que ahora no son necesarias. Escrib\u00ed un experimento que, tal como hiciste en el Ejercicio 12.5 , para N entre 1 y 256 genere una lista de largo N con n\u00fameros enteros del 1 al 1000, calcule el tiempo que tarda cada m\u00e9todo en ordenar la lista y guarde estos resultados en vectores de largo 256. En este caso, vas a tener que generar y guardar todas las listas a ser utilizadas antes de correr el experimento, para poder usar las mismas repetidas veces al evaluar cada m\u00e9todo. Defin\u00ed para eso una funci\u00f3n generar_listas(Nmax) que genere una lista de listas, una de cada longitud entre 1 y Nmax , con valores aleatorios entre 1 y 1000. Asegurate de evaluar todos los m\u00e9todos de ordenamiento con las mismas listas (siempre us\u00e1 copias para no ordenar listas que ya est\u00e1n ordenadas) y guardar esta informaci\u00f3n para poder mostrarla o usarla. Grafic\u00e1 los datos de tiempos de ejecuci\u00f3n en funci\u00f3n de las longitudes de las listas. \u00bfCoinciden las curvas con lo que hab\u00edas predicho estimando el n\u00famero de operaciones? Guard\u00e1 el archivo time_ordenamiento.py para entregarlo. Ejercicio 12.9: Opcional: Escrib\u00ed una funci\u00f3n merge3sort que funcione igual que el merge sort pero en lugar de dividir la lista de entrada en dos partes, la divida en tres partes. Deber\u00e1s escribir la funci\u00f3n merge3(lista1, lista2, lista3) . Prob\u00e1 tu funci\u00f3n en las siguientes listas: unalista = [1, 4, 3, 1, 7, 5] otralista = [7, 6, 5, 4, 3, 2, 1, 0] \u00bfC\u00f3mo te parece que se va a comportar este m\u00e9todo con respecto al merge sort original? Agreg\u00e1 este nuevo m\u00e9todo a la comparaci\u00f3n del ejercicio anterior. Contenidos | Anterior (2 Ordenamientos sencillos de listas) | Pr\u00f3ximo (4 Algoritmos de clasificaci\u00f3n supervisada)","title":"03 Divide and Conquer"},{"location":"12_Ordenamiento/03_Divide_and_Conquer/#123-divide-y-reinaras","text":"Para esta secci\u00f3n tenemos este video introductorio . El problema del ordenamiento es un problema fundamental y hay much\u00edsimos algoritmos que lo resuelven . Los m\u00e9todos de ordenamiento vistos en la secci\u00f3n anterior eran m\u00e9todos iterativos cuyo tiempo de ejecuci\u00f3n era cuadr\u00e1tico. Veremos ahora el merge sort que es un algoritmo un poco m\u00e1s complejo conceptualmente pero menos complejo computacionalmente. El algoritmo est\u00e1 basado en una idea muy fecunda en el dise\u00f1o de algoritmos eficientes que se denomina divide y reinar\u00e1s (\u00f3 divide and conquer en ingl\u00e9s). Divide y reinar\u00e1s es un paradigma de dise\u00f1o de algoritmos recursivos que trabaja partiendo (dividiendo) el problema original en subproblemas del mismo tipo pero m\u00e1s sencillos de resolver. Las soluciones de estos subproblemas luego se combinan para obtener una soluci\u00f3n del problema original. La correctitud de los algoritmos de este tipo suele probarse utilizando la inducci\u00f3n matem\u00e1tica y el c\u00e1lculo de su complejidad involucra la resoluci\u00f3n de ecuaciones de recurrencia cuyos detalles escapan el alcance de este curso.","title":"12.3 Divide y reinar\u00e1s"},{"location":"12_Ordenamiento/03_Divide_and_Conquer/#el-algoritmo-merge-sort-u-ordenamiento-por-mezcla","text":"El merge sort se basa en la siguiente idea: Si la lista es peque\u00f1a (vac\u00eda o de tama\u00f1o 1) ya est\u00e1 ordenada y no hay nada que hacer. De lo contrario hacer lo siguiente: Dividir la lista al medio, formando dos sublistas de (aproximadamente) el mismo tama\u00f1o cada una. Ordenar cada una de esas dos sublistas (usando este mismo m\u00e9todo). Una vez que se ordenaron ambas sublistas, intercalarlas (mergearlas) de manera ordenada. Por ejemplo, si la lista original es [6, 7, -1, 0, 5, 2, 3, 8] deberemos ordenar recursivamente [6, 7, -1, 0] y [5, 2, 3, 8] con lo cual obtendremos [-1, 0, 6, 7] y [2, 3, 5, 8] . Si intercalamos ordenadamente las dos listas ordenadas obtenemos la soluci\u00f3n buscada: [-1, 0, 2, 3, 5, 6, 7, 8] . Veamos otro ejemplo con un gif animado: Dise\u00f1emos la funci\u00f3n merge_sort(lista) : Si lista es peque\u00f1a (vac\u00eda o de tama\u00f1o 1) ya est\u00e1 ordenada y no hay nada que hacer. Se devuelve lista original. De lo contrario: medio = len(lista) // 2 izq = merge_sort(lista[:medio]) der = merge_sort(lista[medio:]) Se devuelve merge(izq, der) . Falta s\u00f3lo dise\u00f1ar la funci\u00f3n merge : dadas dos listas ordenadas debe obtener una nueva lista que resulte de intercalar a ambas de manera ordenada: Utilizaremos dos \u00edndices, i y j , para recorrer cada una de las dos listas. Utilizaremos una tercera lista, resultado , donde almacenaremos el resultado. Mientras i sea menor que el largo de lista1 y j menor que el largo de lista2 , significa que hay elementos para comparar en ambas listas. Si el menor es el de lista1 : Agregar el elemento lista1[i] al final de la lista resultado . Incrementar el \u00edndice i . de lo contrario: Agregar el elemento lista2[j] al final de la lista resultado . Incrementar el \u00edndice j . Una vez que una de las dos listas se termina, simplemente hay que agregar todo lo que queda en la otra al final de la lista resultado . El c\u00f3digo resultante del dise\u00f1o de ambas funciones puede verse a continuaci\u00f3n: import random def merge_sort(lista): \"\"\"Ordena lista mediante el m\u00e9todo merge sort. Pre: lista debe contener elementos comparables. Devuelve: una nueva lista ordenada.\"\"\" if len(lista) < 2: lista_nueva = lista else: medio = len(lista) // 2 izq = merge_sort(lista[:medio]) der = merge_sort(lista[medio:]) lista_nueva = merge(izq, der) return lista_nueva def merge(lista1, lista2): \"\"\"Intercala los elementos de lista1 y lista2 de forma ordenada. Pre: lista1 y lista2 deben estar ordenadas. Devuelve: una lista con los elementos de lista1 y lista2.\"\"\" i, j = 0, 0 resultado = [] while(i < len(lista1) and j < len(lista2)): if (lista1[i] < lista2[j]): resultado.append(lista1[i]) i += 1 else: resultado.append(lista2[j]) j += 1 # Agregar lo que falta de una lista resultado += lista1[i:] resultado += lista2[j:] return resultado El m\u00e9todo divide y reinar\u00e1s que hemos usado para resolver el problema de ordenar una lista puede aplicarse tambi\u00e9n en otras situaciones. Hace falta que sea posible resolver el problema parti\u00e9ndolo en varios subproblemas de tama\u00f1o menor, resolver cada uno de esos subproblemas por separado aplicando la misma t\u00e9cnica (en nuestro caso ordenar por mezcla cada una de las dos sublistas), y finalmente juntar estas soluciones parciales en una soluci\u00f3n completa del problema mayor (en nuestro caso la intercalaci\u00f3n ordenada de las dos sublistas ordenadas). Como siempre sucede con las soluciones recursivas, debemos encontrar un caso base en el cual no se aplica la llamada recursiva (en nuestro caso: si la lista tiene largo cero o uno, ya est\u00e1 ordenada y no hay nada que hacer). Adem\u00e1s debemos asegurar que siempre se alcanza el caso base, y en nuestro caso aseguramos eso porque, si no estamos en el caso base, la lista se divide en mitades decrementando su longitud. El m\u00e9todo divide y reinar\u00e1s es fecundo y ha dado lugar a algoritmos muy eficientes para tareas muy dis\u00edmiles como multiplicar matrices, calcular la transformada de Fourier o realizar an\u00e1lisis sint\u00e1cticos (parsear).","title":"El algoritmo merge sort (u ordenamiento por mezcla)"},{"location":"12_Ordenamiento/03_Divide_and_Conquer/#ejemplo-arbol-de-recursion","text":"Para representar gr\u00e1ficamente las llamadas recursivas de la funci\u00f3n merge_sort() podemos hacer un \u00e1rbol similar al que mostramos en la Secci\u00f3n 11.2 para la sucesi\u00f3n de Fibonacci. Esta vez, como queremos mostrar no s\u00f3lo las llamadas sino tambi\u00e9n lo que devuelve cada llamada, espejaremos el \u00e1rbol obteniendo un grafo. Ac\u00e1 mostramos el \u00e1rbol de recursi\u00f3n de merge_sort([3, 1, 0, 4, 2]) .","title":"Ejemplo: \u00c1rbol de recursi\u00f3n"},{"location":"12_Ordenamiento/03_Divide_and_Conquer/#cuanto-cuesta-el-merge-sort","text":"Supongamos que tenemos que ordenar una lista de l longitud N . Observamos lo siguiente: Para intercalar dos listas de longitud N/2 hace falta recorrer ambas listas que en total tienen N elementos. La cantidad de operaciones resulta proporcional a N . Llamemos a * N a ese tiempo. Si llamamos T(N) al tiempo que tarda el algoritmo en ordenar una lista de longitud N , vemos que T(N) = 2 * T(N/2) + a * N . Adem\u00e1s, cuando la lista es peque\u00f1a, la operaci\u00f3n es de tiempo constante: T(1) = T(0) = b . Para simplificar la cuenta vamos a suponer que N = 2^k . T(N) = T(2^k) = 2 * T(2^(k-1)) + a * 2^k = 2 * ( 2 * T(2^(k-2)) + a * 2^(k-1)) + a * 2^k = 2^2 * T(2^(k-2)) + a * 2^k +a * 2^k . . . = 2^i * T(2^(k-i))+ i * a * 2^k . . . = 2^k * T(1) + k * a * 2^k = b * 2^k + k * a * 2^k Pero si N = 2^k entonces k = log2(N) , y por lo tanto hemos demostrado que: T(N) = b * N + a * N * log2(N). Como lo que nos interesa es aproximar el valor, diremos (despreciando el t\u00e9rmino de menor orden) que T(N) ~ N * log2(N) Dado que log2(N) es un n\u00famero mucho m\u00e1s peque\u00f1o que N , hemos mostrado entonces que el merge sort se porta mucho mejor (es decir, es m\u00e1s eficiente) que los tres m\u00e9todos de ordenamiento que discutimos en la secci\u00f3n anterior (que eran cuadr\u00e1ticos). Si analizamos el espacio que consume, vemos que a cada paso la funci\u00f3n merge genera una nueva lista cuya longitud es la suma de los tama\u00f1os de las dos listas, por lo que merge_sort usa el doble de espacio que la lista de entrada.","title":"\u00bfCu\u00e1nto cuesta el Merge sort?"},{"location":"12_Ordenamiento/03_Divide_and_Conquer/#resumen","text":"Los m\u00e9todos de ordenamiento de selecci\u00f3n, inserci\u00f3n y burbujeo presentados en la secci\u00f3n anterior son m\u00e9todos conceptualmente sencillos pero costosos en cantidad de operaciones (intercambios y/o comparaciones). Sin embargo, es posible conseguir m\u00e9todos m\u00e1s eficientes usando algoritmos recursivos. El algoritmo merge sort consiste en dividir la lista a ordenar hasta que tenga 1 \u00f3 0 elementos y luego combinar la lista de forma ordenada. De esta manera se logra un tiempo proporcional a N * log2(N) .","title":"Resumen"},{"location":"12_Ordenamiento/03_Divide_and_Conquer/#ejercicios","text":"","title":"Ejercicios:"},{"location":"12_Ordenamiento/03_Divide_and_Conquer/#ejercicio-126","text":"Orden\u00e1 la lista [6, 0, 3, 2, 5, 7, 4, 1] usando el m\u00e9todo merge sort. Dibuj\u00e1 el \u00e1rbol de recursi\u00f3n explicando las llamadas que se hacen en cada paso, y el orden en el que se realizan, como mostramos m\u00e1s arriba para la lista [3, 1, 0, 4, 2] .","title":"Ejercicio 12.6:"},{"location":"12_Ordenamiento/03_Divide_and_Conquer/#ejercicio-127","text":"Modific\u00e1 la funci\u00f3n merge_sort para que tambi\u00e9n devuelva la cantidad de comparaciones hechas. Rehac\u00e9 el \u00faltimo ejercicio de la secci\u00f3n anterior ( Ejercicio 12.5 ) incorporando el merge sort a la comparaci\u00f3n y al gr\u00e1fico. Describ\u00ed con tus palabras qu\u00e9 observas. Guard\u00e1 el archivo comparaciones_ordenamiento.py con estas modificaciones, para entregarlo.","title":"Ejercicio 12.7:"},{"location":"12_Ordenamiento/03_Divide_and_Conquer/#el-modulo-timeit","text":"Hay casos en que contar la cantidad de operaciones que un algoritmo realiza se vuelve muy engorroso. Una alternativa simple aunque menos exacta es medir su tiempo de ejecuci\u00f3n para problemas de distintos tama\u00f1os y estimar el orden del algoritmo a partir del cambio en el tiempo de ejecuci\u00f3n al cambiar el tama\u00f1o del problema. Existe un m\u00f3dulo llamado timeit que permite medir tiempos de ejecuci\u00f3n de c\u00f3digo Python. El comando timeit() del modulo timeit devuelve, en segundos, el tiempo de ejecuci\u00f3n total para el comando y n\u00famero de repeticiones especificadas. El c\u00f3digo a ejecutar y la cantidad de ejecuciones se pasan como par\u00e1metros. En esta secci\u00f3n, vamos a usarlo para comparar algoritmos de ordenamiento. En el siguiente ejemplo se le pide a Python una demora de 1 segundo (sleep(1)) y se le pide a timeit() que devuelva el tiempo de ejecuci\u00f3n de ese comando, ejecutado una sola vez). Prob\u00e1lo varias veces: In [1]: import time In [2]: import timeit as tt In [3]: tt.timeit('time.sleep(1)',number = 1) Out[3]: 1.0010360410087742 Notar\u00e1s que el tiempo de ejecuci\u00f3n est\u00e1 muy cerca del esperado (1 segundo), pero no es exactamente ese valor y adem\u00e1s hay cierta variacion entre repeticiones. Ahora evaluemos la siguiente expresi\u00f3n, que concatena en un string los primeros 100 n\u00fameros enteros. Ejecutala por lo menos diez veces y mir\u00e1 como var\u00eda la salida: In [4]: tt.timeit('\"-\".join(str(n) for n in range(100))', number = 1) Out[4]: 6.670000296551734e-05 Si medimos un proceso que tarda poco tiempo como en el \u00faltimo ejemplo, obtendremos resultados con una variabilidad de magnitud similar a la duraci\u00f3n del proceso. Si queremos comparar duraciones relativas es mejor medir procesos largos o, si se trata de un proceso corto, repetirlo muchas veces. Usando timeit() podemos hacer esto cambiando el parametro number . Prob\u00e1 lo siguiente: In [5]: tt.timeit('\"-\".join(str(n) for n in range(100))', number = 10000) Out[5]: 0.3018611848820001 Ahora comparemos la duraci\u00f3n de ese c\u00f3digo python con la duraci\u00f3n de otras expresiones que dan el mismo resultado. Ejecut\u00e1 cada una varias veces: In [6]: tt.timeit('\"-\".join(str(n) for n in range(100))', number = 10000) Out[6]: 0.3018611848820001 In [7]: tt.timeit('\"-\".join([str(n) for n in range(100)])', number = 10000) Out[7]: 0.2727368790656328 In [8]: tt.timeit('\"-\".join(map(str, range(100)))', number = 10000) Out[8]: 0.23702679807320237","title":"El m\u00f3dulo timeit"},{"location":"12_Ordenamiento/03_Divide_and_Conquer/#ejemplo-evaluar-el-metodo-de-ordenamiento-por-seleccion-con-timeit","text":"Queremos evaluar cu\u00e1nto tarda del m\u00e9todo de ordenamiento por selecci\u00f3n para diferentes longitudes de la lista a ordenar. Para eso, primero generamos listas de longitudes entre 1 y 256. listas = [] for N in range(1, 256): listas.append(generar_lista(N)) Luego, definimos una funci\u00f3n \"wrapper\"\"(envoltorio) llamada experimento_timeit_seleccion(listas, num) que realiza un experimento usando timeit para evaluar el m\u00e9todo de selecci\u00f3n (repitiendo num veces) con las listas que le pasamos como par\u00e1metro, y devuelve en un vector los tiempos de ejecuci\u00f3n para cada lista. def experimento_timeit_seleccion(listas, num): \"\"\" Realiza un experimento usando timeit para evaluar el m\u00e9todo de selecci\u00f3n para ordenamiento de listas con las listas pasadas como entrada y devuelve los tiempos de ejecuci\u00f3n para cada lista en un vector. El par\u00e1metro 'listas' debe ser una lista de listas. El par\u00e1metro 'num' indica el n\u00famero de veces que repite el ordenamiento para cada lista. \"\"\" tiempos_seleccion = [] global lista for lista in listas: # eval\u00fao el m\u00e9todo de selecci\u00f3n # en una copia nueva para cada iteraci\u00f3n tiempo_seleccion = tt.timeit('ord_seleccion(lista.copy())', number = num, globals = globals()) # guardo el resultado tiempos_seleccion.append(tiempo_seleccion) # paso los tiempos a arrays tiempos_seleccion = np.array(tiempos_seleccion) return tiempos_seleccion El par\u00e1metro globals = globals() permite a timeit() acceder a las variables y funciones definidas en el namespace global en que se est\u00e1 ejecutando. El comando global lista hace que la variable lista que va recorriendo la lista de listas, sea global y por lo tanto accesible a timeit() . Y ahora realizamos el experimento y lo graficamos. tiempos_seleccion = experimento_timeit_seleccion(listas, 100) plt.plot(tiempos_seleccion)","title":"Ejemplo: evaluar el m\u00e9todo de ordenamiento por selecci\u00f3n con timeit."},{"location":"12_Ordenamiento/03_Divide_and_Conquer/#ejercicio-128","text":"La idea de este ejercicio es, nuevamente, comparar los algoritmos de ordenamiento que vimos hasta ahora pero usando timeit() en lugar de contando a mano la cantidad de operaciones. Junt\u00e1 en el archivo time_ordenamiento.py los m\u00e9todos de b\u00fasqueda del Ejercicio 12.7 . Antes de empezar el experimento, elimin\u00e1 de las funciones a medir todo c\u00f3digo no esencial, en particular los prints para debug. Consumen tiempo y no son parte del algoritmo. Tambi\u00e9n elimin\u00e1 las cuentas de comparaciones, que ahora no son necesarias. Escrib\u00ed un experimento que, tal como hiciste en el Ejercicio 12.5 , para N entre 1 y 256 genere una lista de largo N con n\u00fameros enteros del 1 al 1000, calcule el tiempo que tarda cada m\u00e9todo en ordenar la lista y guarde estos resultados en vectores de largo 256. En este caso, vas a tener que generar y guardar todas las listas a ser utilizadas antes de correr el experimento, para poder usar las mismas repetidas veces al evaluar cada m\u00e9todo. Defin\u00ed para eso una funci\u00f3n generar_listas(Nmax) que genere una lista de listas, una de cada longitud entre 1 y Nmax , con valores aleatorios entre 1 y 1000. Asegurate de evaluar todos los m\u00e9todos de ordenamiento con las mismas listas (siempre us\u00e1 copias para no ordenar listas que ya est\u00e1n ordenadas) y guardar esta informaci\u00f3n para poder mostrarla o usarla. Grafic\u00e1 los datos de tiempos de ejecuci\u00f3n en funci\u00f3n de las longitudes de las listas. \u00bfCoinciden las curvas con lo que hab\u00edas predicho estimando el n\u00famero de operaciones? Guard\u00e1 el archivo time_ordenamiento.py para entregarlo.","title":"Ejercicio 12.8:"},{"location":"12_Ordenamiento/03_Divide_and_Conquer/#ejercicio-129","text":"Opcional: Escrib\u00ed una funci\u00f3n merge3sort que funcione igual que el merge sort pero en lugar de dividir la lista de entrada en dos partes, la divida en tres partes. Deber\u00e1s escribir la funci\u00f3n merge3(lista1, lista2, lista3) . Prob\u00e1 tu funci\u00f3n en las siguientes listas: unalista = [1, 4, 3, 1, 7, 5] otralista = [7, 6, 5, 4, 3, 2, 1, 0] \u00bfC\u00f3mo te parece que se va a comportar este m\u00e9todo con respecto al merge sort original? Agreg\u00e1 este nuevo m\u00e9todo a la comparaci\u00f3n del ejercicio anterior. Contenidos | Anterior (2 Ordenamientos sencillos de listas) | Pr\u00f3ximo (4 Algoritmos de clasificaci\u00f3n supervisada)","title":"Ejercicio 12.9:"},{"location":"12_Ordenamiento/04_introduccion_al_AA/","text":"Contenidos | Anterior (3 Divide y reinar\u00e1s) | Pr\u00f3ximo (5 Cierre de la clase de Ordenamiento) 12.4 Algoritmos de clasificaci\u00f3n supervisada Para esta secci\u00f3n tenemos este video introductorio . En esta secci\u00f3n veremos un algoritmo de clasificaci\u00f3n. Un problema de clasificaci\u00f3n es un problema en el que tenemos algunas clases fijas (en nuestro ejemplo ser\u00e1n tres tipos de flores) y algunos atributos (medidas de los p\u00e9talos y s\u00e9palos, en nuestro ejemplo) a partir de los cuales queremos inferir la clase. T\u00edpicamente el algoritmo de clasificaci\u00f3n se entrena con alguna parte de los datos para que aprenda y luego se eval\u00faa cu\u00e1n bien aprendi\u00f3 con el resto de los datos. Para esto hace falta tener un conjunto de datos etiquetados (es decir, con la clase bien definida). Luego, si funciona bien, el algoritmo podr\u00e1 usarse para etiquetar nuevos datos de los que no se conoce la clase. En esta secci\u00f3n nos concentraremos en el entrenamiento y la evaluaci\u00f3n de los algoritmos. Trabajaremos con la librer\u00eda sklearn de python que est\u00e1 dise\u00f1ada para realizar tareas de aprendizaje autom\u00e1tico. La misma trae algunos conjuntos de datos de ejemplo. Trabajaremos con el cl\u00e1sico ejemplo de Clasificaci\u00f3n de Especies de flores Iris seg\u00fan medidas del p\u00e9talo y el s\u00e9palo. Veamos los datos from sklearn.datasets import load_iris iris_dataset = load_iris() Este dataset trae una serie de datos medidos de los p\u00e9talos y s\u00e9palos de 150 flores Iris y su clasificaci\u00f3n en tres especies (setosa, versicolor y virginica). La idea es usar algunos de los datos de flores para entrenar un algoritmo y ver si podemos deducir la especie de las otras flores (no clasificadas) usando solo sus medidas. El dataset es un diccionario con diferentes datos. Esencialmente en \"data\" tiene un array con las medidas de ancho y largo de p\u00e9talo y s\u00e9palo (atributos, o \"features\" en ingl\u00e9s) de 150 flores y en \"target\" tiene un numero (0, 1 \u00f3 2) que representa la especie de estas flores. Veamos un poco la estructura de estos datos. El diccionario tiene las siguientes claves: >>> print(\"Claves del diccionario iris_dataset:\\n\", iris_dataset.keys()) Claves del diccionario iris_dataset: dict_keys(['data', 'target', 'frame', 'target_names', 'DESCR', 'feature_names', 'filename']) Las flores se clasifican en tres: >>> print(\"Target names:\", iris_dataset['target_names']) Target names: ['setosa' 'versicolor' 'virginica'] Y los atributos son cuatro por cada flor: >>> print(\"Feature names:\\n\", iris_dataset['feature_names']) Feature names: ['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)'] Son 150 flores etiquetadas, con cuatro atributos cada una, en un array de numpy. Las etiquetas son 0, 1 y 2 y se guardan tambi\u00e9n en un array: >>> print(\"Type of data:\", type(iris_dataset['data'])) Type of data: <class 'numpy.ndarray'> >>> print(\"Shape of data:\", iris_dataset['data'].shape) Shape of data: (150, 4) >>> print(\"First five rows of data:\\n\", iris_dataset['data'][:5]) First five rows of data: [[5.1 3.5 1.4 0.2] [4.9 3. 1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2] [5. 3.6 1.4 0.2]] >>> print(\"Type of target:\", type(iris_dataset['target'])) Type of target: <class 'numpy.ndarray'> >>> print(\"Shape of target:\", iris_dataset['target'].shape) Shape of target: (150,) >>> print(\"Target:\\n\", iris_dataset['target']) Target: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2] Visualizaci\u00f3n de los datos Hagamos primero unos gr\u00e1ficos exploratorios para ver los datos y entender las correlaciones entre los atributos, usando un color diferente para cada especie de flor. import pandas as pd # creamos un dataframe de los datos de flores # etiquetamos las columnas usando las cadenas de iris_dataset.feature_names iris_dataframe = pd.DataFrame(iris_dataset['data'], columns = iris_dataset.feature_names) # y hacemos una matriz de gr\u00e1ficos de dispersi\u00f3n, asignando colores seg\u00fan la especie pd.plotting.scatter_matrix(iris_dataframe, c = iris_dataset['target'], figsize = (15, 15), marker = 'o', hist_kwds = {'bins': 20}, s = 60, alpha = 0.8) Notamos que una de las especies se distingue m\u00e1s f\u00e1cilmente de las otras dos, mientras que las otras presentan cierta superposici\u00f3n. Ejercicio 12.10: Seaborn Repet\u00ed el gr\u00e1fico anterior pero usando seaborn en lugar de pandas para graficar, y guard\u00e1 el c\u00f3digo correspondiente en un archivo iris_seaborn.py para entregarlo. Sugerencia: Usando iris_dataframe['target'] = iris_dataset['target'] , agreg\u00e1 al DataFrame el atributo target de cada flor para poder hacer un sns.pairplot() seteando hue sobre las especies de iris. Training y testing Como dijimos antes, vamos a entrenar un algoritmo y luego a evaluar su capacidad de clasificar. Para evitar sesgos y sobreajustes tenemos que partir al conjunto de datos en dos: una parte de los datos (training) ser\u00e1 de entrenamiento del algoritmo y otra parte (testing) ser\u00e1 usada para la evaluaci\u00f3n. La librer\u00eda sklearn trae funciones que hacen esta separaci\u00f3n (split) de forma aleatoria, como se ve a continuaci\u00f3n (en este caso fijamos una semilla con random_state = 0 , luego la sacaremos). Obviamente separamos tanto los atributos (features) como su clase (target). En este caso usaremos el 75% de los datos para entrenar y el 25% restante para evaluar. from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split( iris_dataset['data'], iris_dataset['target'], random_state = 0) >>> print(\"X_train shape:\", X_train.shape) >>> print(\"y_train shape:\", y_train.shape) X_train shape: (112, 4) y_train shape: (112,) >>> print(\"X_test shape:\", X_test.shape) >>> print(\"y_test shape:\", y_test.shape) X_test shape: (38, 4) y_test shape: (38,) Modelar Ahora vamos a construir nuestro primer modelo. Usaremos un algoritmo sencillo que se llama de \"vecinos m\u00e1s cercanos\" (K-nearest neighbors_ en ingl\u00e9s, ver wikipedia ). Lo entrenaremos con los datos de entrenamiento y al consultarle por un nuevo dato (de los de testing) lo que har\u00e1 el algoritmo es buscar al dato de entrenamiento m\u00e1s cercano en el espacio de atributos y asignarle al nuevo dato la especie de esa flor. En otras palabras: cuando le preguntemos por la especie de una flor nueva va a contestarnos con la especie de la flor \"m\u00e1s cercana\" en el espacio de atributos (ancho y largo del p\u00e9talo y el s\u00e9palo). De esta forma el espacio de atributos queda dividido en regiones a las que se asignar\u00e1 cada especie. En el siguiente gr\u00e1fico puede verse una partici\u00f3n de un espacio de dos atributos y tres clases considerando un vecino m\u00e1s cercano (k=1) y entrenado con los datos del gr\u00e1fico: A un nuevo punto en este plano el clasificador as\u00ed entrenado le asignar\u00e1 la clase correspondiente al color de fondo, que coincide con la clase del vecino m\u00e1s cercano. Creamos una instancia de la clase KNeighborsClassifier from sklearn.neighbors import KNeighborsClassifier knn = KNeighborsClassifier(n_neighbors = 1) Y la entrenamos con los datos de entrenamiento knn.fit(X_train, y_train) Listo, tenemos el clasificador entrenado. Ahora lo podemos usar para predecir la clase de una nueva flor a partir de sus cuatro medidas: >>> import numpy as np >>> X_new = np.array([[5, 2.9, 1, 0.2]]) >>> print(\"X_new.shape:\", X_new.shape) X_new.shape: (1, 4) Grafiquemos este nuevo punto en rojo y veamos su relaci\u00f3n con los datos de entrenamiento en dos de los atributos. import matplotlib.pyplot as plt plt.scatter(X_train[:, 1], X_train[:, 3], c = y_train) plt.scatter(X_new[:, 1], X_new[:, 3], c = 'red') Ac\u00e1 se ve que el punto rojo esta cerca de la clase \"setosa\". Utilicemos ahora el algoritmo knn entrenado para clasificar el punto X_new : >>> prediction = knn.predict(X_new) >>> print(\"Predicci\u00f3n:\", prediction) >>> print(\"Nombre de la Especie Predicha:\", iris_dataset['target_names'][prediction]) Predicci\u00f3n: [0] Nombre de la Especie Predicha: ['setosa'] Evaluaci\u00f3n del modelo Finalmente, usemos el 25% de los datos etiquetados que nos guardamos para evaluar cu\u00e1n bien funciona nuestro clasificador. >>> y_pred = knn.predict(X_test) >>> print(\"Predicciones para el conjunto de Test:\\n\", y_pred) >>> print(\"Etiquetas originales de este conjunto:\\n\", y_test) Predicciones para el conjunto de Test: [2 1 0 2 0 2 0 1 1 1 2 1 1 1 1 0 1 1 0 0 2 1 0 0 2 0 0 1 1 0 2 1 0 2 2 1 0 2] Etiquetas originales de este conjjuto: [2 1 0 2 0 2 0 1 1 1 2 1 1 1 1 0 1 1 0 0 2 1 0 0 2 0 0 1 1 0 2 1 0 2 2 1 0 1] Se ve que coinciden todos salvo el \u00faltimo. Podemos medir el \u00e9xito calculando la fracci\u00f3n de clasificaciones bien hechas (calculamos el promedio de \"1 si est\u00e1 bien, 0 si est\u00e1 mal\"): >>> print(y_pred == y_test) >>> print(\"Test set score: {:.2f}\".format(np.mean(y_pred == y_test))) [ True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True False] Test set score: 0.97 O, directamente, usando el m\u00e9todo score que ya viene en el clasificador: >>> print(\"Test set score: {:.2f}\".format(knn.score(X_test, y_test))) Test set score: 0.97 Pasando en limpio todo Lo que hicimos hasta ahora fue: 1) Separar los datos en dos conjuntos: train y test. 2) Definir un clasificador knn y entrenarlo con los datos de training. 3) Evaluar el clasificador con los datos de testing. X_train, X_test, y_train, y_test = train_test_split( iris_dataset['data'], iris_dataset['target']) knn = KNeighborsClassifier(n_neighbors = 1) knn.fit(X_train, y_train) print(\"Test set score: {:.2f}\".format(knn.score(X_test, y_test))) Observ\u00e1 que en este \u00faltimo fragmento de c\u00f3digo el split en test y train es aleatorio, y va a dar resultados (scores) diferentes cada vez que lo corramos. Ejercicios: Ejercicio 12.11: Le\u00e9 sobre los clasificadores basados en arboles de decisi\u00f3n y luego us\u00e1 el objeto clasificador clf (definido a continuaci\u00f3n) como se us\u00f3 knn en el ejemplo anterior (es decir, entren\u00e1 el clasificador sobre el conjunto train y evalu\u00e1lo sobre el conjunto test). Tanto knn como clf son clasificadores y heredan los m\u00e9todos \"fit\", \"predict\" y \"score\" de forma que su uso es casi id\u00e9ntico. Ventajas del polimorfismo, del que hablamos antes (ver Ejercicio 9.7 ). \u00bfQu\u00e9 clasificador di\u00f3 mejores resultados? from sklearn.tree import DecisionTreeClassifier clf = DecisionTreeClassifier() Ejercicio 12.12: La comparaci\u00f3n anterior de los dos clasificadores puede resultar injusta ya que est\u00e1 basada en una partici\u00f3n del conjunto de datos en test y train que podr\u00eda darle ventaja a uno u otro clasificador, arbitrariamente. Para evitar esto, repet\u00ed 100 veces lo siguiente y calcul\u00e1 el promedio de los scores: a) Partici\u00f3n del conjunto original en test y train aleatoriamente (sin fijar la semilla). b) Entrenamiento de ambos modelos (knn y clf) con el conjunto train resultante. c) Evaluaci\u00f3n de ambos clasifcadores (score) con el conjunto test resultante. \u00bfTe anim\u00e1s a agregar tambi\u00e9n un clasificador de Random Forest ? Imprim\u00ed el promedio de los scores obtenidos y guard\u00e1 el c\u00f3digo en el archivo clasificadores.py para entregar. Contenidos | Anterior (3 Divide y reinar\u00e1s) | Pr\u00f3ximo (5 Cierre de la clase de Ordenamiento)","title":"04 introduccion al AA"},{"location":"12_Ordenamiento/04_introduccion_al_AA/#124-algoritmos-de-clasificacion-supervisada","text":"Para esta secci\u00f3n tenemos este video introductorio . En esta secci\u00f3n veremos un algoritmo de clasificaci\u00f3n. Un problema de clasificaci\u00f3n es un problema en el que tenemos algunas clases fijas (en nuestro ejemplo ser\u00e1n tres tipos de flores) y algunos atributos (medidas de los p\u00e9talos y s\u00e9palos, en nuestro ejemplo) a partir de los cuales queremos inferir la clase. T\u00edpicamente el algoritmo de clasificaci\u00f3n se entrena con alguna parte de los datos para que aprenda y luego se eval\u00faa cu\u00e1n bien aprendi\u00f3 con el resto de los datos. Para esto hace falta tener un conjunto de datos etiquetados (es decir, con la clase bien definida). Luego, si funciona bien, el algoritmo podr\u00e1 usarse para etiquetar nuevos datos de los que no se conoce la clase. En esta secci\u00f3n nos concentraremos en el entrenamiento y la evaluaci\u00f3n de los algoritmos. Trabajaremos con la librer\u00eda sklearn de python que est\u00e1 dise\u00f1ada para realizar tareas de aprendizaje autom\u00e1tico. La misma trae algunos conjuntos de datos de ejemplo. Trabajaremos con el cl\u00e1sico ejemplo de Clasificaci\u00f3n de Especies de flores Iris seg\u00fan medidas del p\u00e9talo y el s\u00e9palo.","title":"12.4 Algoritmos de clasificaci\u00f3n supervisada"},{"location":"12_Ordenamiento/04_introduccion_al_AA/#veamos-los-datos","text":"from sklearn.datasets import load_iris iris_dataset = load_iris() Este dataset trae una serie de datos medidos de los p\u00e9talos y s\u00e9palos de 150 flores Iris y su clasificaci\u00f3n en tres especies (setosa, versicolor y virginica). La idea es usar algunos de los datos de flores para entrenar un algoritmo y ver si podemos deducir la especie de las otras flores (no clasificadas) usando solo sus medidas. El dataset es un diccionario con diferentes datos. Esencialmente en \"data\" tiene un array con las medidas de ancho y largo de p\u00e9talo y s\u00e9palo (atributos, o \"features\" en ingl\u00e9s) de 150 flores y en \"target\" tiene un numero (0, 1 \u00f3 2) que representa la especie de estas flores. Veamos un poco la estructura de estos datos. El diccionario tiene las siguientes claves: >>> print(\"Claves del diccionario iris_dataset:\\n\", iris_dataset.keys()) Claves del diccionario iris_dataset: dict_keys(['data', 'target', 'frame', 'target_names', 'DESCR', 'feature_names', 'filename']) Las flores se clasifican en tres: >>> print(\"Target names:\", iris_dataset['target_names']) Target names: ['setosa' 'versicolor' 'virginica'] Y los atributos son cuatro por cada flor: >>> print(\"Feature names:\\n\", iris_dataset['feature_names']) Feature names: ['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)'] Son 150 flores etiquetadas, con cuatro atributos cada una, en un array de numpy. Las etiquetas son 0, 1 y 2 y se guardan tambi\u00e9n en un array: >>> print(\"Type of data:\", type(iris_dataset['data'])) Type of data: <class 'numpy.ndarray'> >>> print(\"Shape of data:\", iris_dataset['data'].shape) Shape of data: (150, 4) >>> print(\"First five rows of data:\\n\", iris_dataset['data'][:5]) First five rows of data: [[5.1 3.5 1.4 0.2] [4.9 3. 1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2] [5. 3.6 1.4 0.2]] >>> print(\"Type of target:\", type(iris_dataset['target'])) Type of target: <class 'numpy.ndarray'> >>> print(\"Shape of target:\", iris_dataset['target'].shape) Shape of target: (150,) >>> print(\"Target:\\n\", iris_dataset['target']) Target: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2]","title":"Veamos los datos"},{"location":"12_Ordenamiento/04_introduccion_al_AA/#visualizacion-de-los-datos","text":"Hagamos primero unos gr\u00e1ficos exploratorios para ver los datos y entender las correlaciones entre los atributos, usando un color diferente para cada especie de flor. import pandas as pd # creamos un dataframe de los datos de flores # etiquetamos las columnas usando las cadenas de iris_dataset.feature_names iris_dataframe = pd.DataFrame(iris_dataset['data'], columns = iris_dataset.feature_names) # y hacemos una matriz de gr\u00e1ficos de dispersi\u00f3n, asignando colores seg\u00fan la especie pd.plotting.scatter_matrix(iris_dataframe, c = iris_dataset['target'], figsize = (15, 15), marker = 'o', hist_kwds = {'bins': 20}, s = 60, alpha = 0.8) Notamos que una de las especies se distingue m\u00e1s f\u00e1cilmente de las otras dos, mientras que las otras presentan cierta superposici\u00f3n.","title":"Visualizaci\u00f3n de los datos"},{"location":"12_Ordenamiento/04_introduccion_al_AA/#ejercicio-1210-seaborn","text":"Repet\u00ed el gr\u00e1fico anterior pero usando seaborn en lugar de pandas para graficar, y guard\u00e1 el c\u00f3digo correspondiente en un archivo iris_seaborn.py para entregarlo. Sugerencia: Usando iris_dataframe['target'] = iris_dataset['target'] , agreg\u00e1 al DataFrame el atributo target de cada flor para poder hacer un sns.pairplot() seteando hue sobre las especies de iris.","title":"Ejercicio 12.10: Seaborn"},{"location":"12_Ordenamiento/04_introduccion_al_AA/#training-y-testing","text":"Como dijimos antes, vamos a entrenar un algoritmo y luego a evaluar su capacidad de clasificar. Para evitar sesgos y sobreajustes tenemos que partir al conjunto de datos en dos: una parte de los datos (training) ser\u00e1 de entrenamiento del algoritmo y otra parte (testing) ser\u00e1 usada para la evaluaci\u00f3n. La librer\u00eda sklearn trae funciones que hacen esta separaci\u00f3n (split) de forma aleatoria, como se ve a continuaci\u00f3n (en este caso fijamos una semilla con random_state = 0 , luego la sacaremos). Obviamente separamos tanto los atributos (features) como su clase (target). En este caso usaremos el 75% de los datos para entrenar y el 25% restante para evaluar. from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split( iris_dataset['data'], iris_dataset['target'], random_state = 0) >>> print(\"X_train shape:\", X_train.shape) >>> print(\"y_train shape:\", y_train.shape) X_train shape: (112, 4) y_train shape: (112,) >>> print(\"X_test shape:\", X_test.shape) >>> print(\"y_test shape:\", y_test.shape) X_test shape: (38, 4) y_test shape: (38,)","title":"Training y testing"},{"location":"12_Ordenamiento/04_introduccion_al_AA/#modelar","text":"Ahora vamos a construir nuestro primer modelo. Usaremos un algoritmo sencillo que se llama de \"vecinos m\u00e1s cercanos\" (K-nearest neighbors_ en ingl\u00e9s, ver wikipedia ). Lo entrenaremos con los datos de entrenamiento y al consultarle por un nuevo dato (de los de testing) lo que har\u00e1 el algoritmo es buscar al dato de entrenamiento m\u00e1s cercano en el espacio de atributos y asignarle al nuevo dato la especie de esa flor. En otras palabras: cuando le preguntemos por la especie de una flor nueva va a contestarnos con la especie de la flor \"m\u00e1s cercana\" en el espacio de atributos (ancho y largo del p\u00e9talo y el s\u00e9palo). De esta forma el espacio de atributos queda dividido en regiones a las que se asignar\u00e1 cada especie. En el siguiente gr\u00e1fico puede verse una partici\u00f3n de un espacio de dos atributos y tres clases considerando un vecino m\u00e1s cercano (k=1) y entrenado con los datos del gr\u00e1fico: A un nuevo punto en este plano el clasificador as\u00ed entrenado le asignar\u00e1 la clase correspondiente al color de fondo, que coincide con la clase del vecino m\u00e1s cercano. Creamos una instancia de la clase KNeighborsClassifier from sklearn.neighbors import KNeighborsClassifier knn = KNeighborsClassifier(n_neighbors = 1) Y la entrenamos con los datos de entrenamiento knn.fit(X_train, y_train) Listo, tenemos el clasificador entrenado. Ahora lo podemos usar para predecir la clase de una nueva flor a partir de sus cuatro medidas: >>> import numpy as np >>> X_new = np.array([[5, 2.9, 1, 0.2]]) >>> print(\"X_new.shape:\", X_new.shape) X_new.shape: (1, 4) Grafiquemos este nuevo punto en rojo y veamos su relaci\u00f3n con los datos de entrenamiento en dos de los atributos. import matplotlib.pyplot as plt plt.scatter(X_train[:, 1], X_train[:, 3], c = y_train) plt.scatter(X_new[:, 1], X_new[:, 3], c = 'red') Ac\u00e1 se ve que el punto rojo esta cerca de la clase \"setosa\". Utilicemos ahora el algoritmo knn entrenado para clasificar el punto X_new : >>> prediction = knn.predict(X_new) >>> print(\"Predicci\u00f3n:\", prediction) >>> print(\"Nombre de la Especie Predicha:\", iris_dataset['target_names'][prediction]) Predicci\u00f3n: [0] Nombre de la Especie Predicha: ['setosa']","title":"Modelar"},{"location":"12_Ordenamiento/04_introduccion_al_AA/#evaluacion-del-modelo","text":"Finalmente, usemos el 25% de los datos etiquetados que nos guardamos para evaluar cu\u00e1n bien funciona nuestro clasificador. >>> y_pred = knn.predict(X_test) >>> print(\"Predicciones para el conjunto de Test:\\n\", y_pred) >>> print(\"Etiquetas originales de este conjunto:\\n\", y_test) Predicciones para el conjunto de Test: [2 1 0 2 0 2 0 1 1 1 2 1 1 1 1 0 1 1 0 0 2 1 0 0 2 0 0 1 1 0 2 1 0 2 2 1 0 2] Etiquetas originales de este conjjuto: [2 1 0 2 0 2 0 1 1 1 2 1 1 1 1 0 1 1 0 0 2 1 0 0 2 0 0 1 1 0 2 1 0 2 2 1 0 1] Se ve que coinciden todos salvo el \u00faltimo. Podemos medir el \u00e9xito calculando la fracci\u00f3n de clasificaciones bien hechas (calculamos el promedio de \"1 si est\u00e1 bien, 0 si est\u00e1 mal\"): >>> print(y_pred == y_test) >>> print(\"Test set score: {:.2f}\".format(np.mean(y_pred == y_test))) [ True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True True False] Test set score: 0.97 O, directamente, usando el m\u00e9todo score que ya viene en el clasificador: >>> print(\"Test set score: {:.2f}\".format(knn.score(X_test, y_test))) Test set score: 0.97","title":"Evaluaci\u00f3n del modelo"},{"location":"12_Ordenamiento/04_introduccion_al_AA/#pasando-en-limpio-todo","text":"Lo que hicimos hasta ahora fue: 1) Separar los datos en dos conjuntos: train y test. 2) Definir un clasificador knn y entrenarlo con los datos de training. 3) Evaluar el clasificador con los datos de testing. X_train, X_test, y_train, y_test = train_test_split( iris_dataset['data'], iris_dataset['target']) knn = KNeighborsClassifier(n_neighbors = 1) knn.fit(X_train, y_train) print(\"Test set score: {:.2f}\".format(knn.score(X_test, y_test))) Observ\u00e1 que en este \u00faltimo fragmento de c\u00f3digo el split en test y train es aleatorio, y va a dar resultados (scores) diferentes cada vez que lo corramos.","title":"Pasando en limpio todo"},{"location":"12_Ordenamiento/04_introduccion_al_AA/#ejercicios","text":"","title":"Ejercicios:"},{"location":"12_Ordenamiento/04_introduccion_al_AA/#ejercicio-1211","text":"Le\u00e9 sobre los clasificadores basados en arboles de decisi\u00f3n y luego us\u00e1 el objeto clasificador clf (definido a continuaci\u00f3n) como se us\u00f3 knn en el ejemplo anterior (es decir, entren\u00e1 el clasificador sobre el conjunto train y evalu\u00e1lo sobre el conjunto test). Tanto knn como clf son clasificadores y heredan los m\u00e9todos \"fit\", \"predict\" y \"score\" de forma que su uso es casi id\u00e9ntico. Ventajas del polimorfismo, del que hablamos antes (ver Ejercicio 9.7 ). \u00bfQu\u00e9 clasificador di\u00f3 mejores resultados? from sklearn.tree import DecisionTreeClassifier clf = DecisionTreeClassifier()","title":"Ejercicio 12.11:"},{"location":"12_Ordenamiento/04_introduccion_al_AA/#ejercicio-1212","text":"La comparaci\u00f3n anterior de los dos clasificadores puede resultar injusta ya que est\u00e1 basada en una partici\u00f3n del conjunto de datos en test y train que podr\u00eda darle ventaja a uno u otro clasificador, arbitrariamente. Para evitar esto, repet\u00ed 100 veces lo siguiente y calcul\u00e1 el promedio de los scores: a) Partici\u00f3n del conjunto original en test y train aleatoriamente (sin fijar la semilla). b) Entrenamiento de ambos modelos (knn y clf) con el conjunto train resultante. c) Evaluaci\u00f3n de ambos clasifcadores (score) con el conjunto test resultante. \u00bfTe anim\u00e1s a agregar tambi\u00e9n un clasificador de Random Forest ? Imprim\u00ed el promedio de los scores obtenidos y guard\u00e1 el c\u00f3digo en el archivo clasificadores.py para entregar. Contenidos | Anterior (3 Divide y reinar\u00e1s) | Pr\u00f3ximo (5 Cierre de la clase de Ordenamiento)","title":"Ejercicio 12.12:"},{"location":"12_Ordenamiento/05_Cierre/","text":"Contenidos | Anterior (4 Algoritmos de clasificaci\u00f3n supervisada) 12.5 Cierre de la clase de Ordenamiento En la clase de hoy te pedimos que entregues los siguientes archivos: El archivo burbujeo.py del Ejercicio 12.2 . El archivo comparaciones_ordenamiento.py del Ejercicio 12.7 . El archivo time_ordenamiento.py del Ejercicio 12.8 . El archivo iris_seaborn.py del Ejercicio 12.10 . Opcionalmente, el archivo clasificadores.py del Ejercicio 12.12 . Como de costumbre, complet\u00e1 por favor el formulario asociado a la clase y adjunt\u00e1 los archivos correspondientes. Gracias! Contenidos | Anterior (4 Algoritmos de clasificaci\u00f3n supervisada)","title":"05 Cierre"},{"location":"12_Ordenamiento/05_Cierre/#125-cierre-de-la-clase-de-ordenamiento","text":"En la clase de hoy te pedimos que entregues los siguientes archivos: El archivo burbujeo.py del Ejercicio 12.2 . El archivo comparaciones_ordenamiento.py del Ejercicio 12.7 . El archivo time_ordenamiento.py del Ejercicio 12.8 . El archivo iris_seaborn.py del Ejercicio 12.10 . Opcionalmente, el archivo clasificadores.py del Ejercicio 12.12 . Como de costumbre, complet\u00e1 por favor el formulario asociado a la clase y adjunt\u00e1 los archivos correspondientes. Gracias! Contenidos | Anterior (4 Algoritmos de clasificaci\u00f3n supervisada)","title":"12.5 Cierre de la clase de Ordenamiento"}]}