<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://matiaslopez.github.io/python_unsam_test/08_Fechas_Carpetas_y_Pandas/06_Series_Temporales/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>06 Series Temporales - Programación en Python</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ABC123"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-ABC123');
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-light bg-light">
            <div class="container">
                <a class="navbar-brand" href="../..">Programación en Python</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Inicio</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Unidades <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../01_Introduccion/00_Resumen/" class="dropdown-item">01 - Introducción</a>
</li>
                                    
<li>
    <a href="../../02_Estructuras_y_Funciones/00_Resumen/" class="dropdown-item">02 - Estructuras y funciones</a>
</li>
                                    
<li>
    <a href="../../03_Datos/00_Resumen/" class="dropdown-item">03 - Trabajando con datos</a>
</li>
                                    
<li>
    <a href="../../04_Listas_y_Listas/00_Resumen/" class="dropdown-item">04 - Algoritmos sobre listas y comprensión de listas</a>
</li>
                                    
<li>
    <a href="../../05_Random_Plt_Dbg/00_Resumen/" class="dropdown-item">05 - Aleatoridad</a>
</li>
                                    
<li>
    <a href="../../06_Organizacion_y_Complejidad/00_Resumen/" class="dropdown-item">06 - Complejidad y Organización de programas</a>
</li>
                                    
<li>
    <a href="../../07_Plt_Especificacion_y_Documentacion/00_Resumen/" class="dropdown-item">07 - Diseño, especificación, documentación y estilo</a>
</li>
                                    
<li>
    <a href="../00_Resumen/" class="dropdown-item">08 - Fechas, Carpetas y Pandas</a>
</li>
                                    
<li>
    <a href="../../09_Clases_y_Objetos/00_Resumen/" class="dropdown-item">09 - Clases y objetos</a>
</li>
                                    
<li>
    <a href="../../10_Generadores_e_Iteradores/00_Resumen/" class="dropdown-item">10 - Generadores e iteradores</a>
</li>
                                    
<li>
    <a href="../../11_Recursion/00_Resumen/" class="dropdown-item">11 - Recursión y regresión</a>
</li>
                                    
<li>
    <a href="../../12_Ordenamiento/00_Resumen/" class="dropdown-item">12 - Ordenamiento</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Buscar
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Tabla de contenidos">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#86-series-temporales" class="nav-link">8.6 Series temporales</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#analisis-y-visualizacion-de-series-temporales" class="nav-link">Análisis y visualización de series temporales.</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#lectura-de-archivos-temporales" class="nav-link">Lectura de archivos temporales</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#ondas-de-marea-en-el-rio-de-la-plata" class="nav-link">Ondas de marea en el Río de la Plata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#vientos-y-ondas-de-tormenta-en-el-rio-de-la-plata" class="nav-link">Vientos y ondas de tormenta en el Río de la Plata</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#parte-optativa" class="nav-link">Parte optativa</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#analisis-por-medio-de-transformadas-de-fourier" class="nav-link">Análisis por medio de transformadas de Fourier</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#un-poco-mas-avanzados" class="nav-link">Un poco más avanzados:</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<p><a href="../Contenidos.md">Contenidos</a> | <a href="../05_Pandas/">Anterior (5 Introducción a Pandas)</a> | <a href="../07_Cierre/">Próximo (7 Cierre de la clase)</a></p>
<h1 id="86-series-temporales">8.6 Series temporales</h1>
<p>Para esta Sección contamos con el valioso aporte de <a href="https://inta.gob.ar/personas/bruzzone.octavio">Octavio Bruzzone</a>. Octavio da dos cursos de posgrado excelentes sobre Series Temporales en Python. Uno se enfoca en los análisis en el dominio del tiempo y el otro en el dominio de las frecuencias. Generosamente nos compartió algunas ideas para este trabajo práctico.</p>
<p>Esta sección tiene un breve <a href="https://youtu.be/fLdVsU12sR8">video introductorio</a> sobre los datos y lo que hay que hacer en este TP.</p>
<h2 id="analisis-y-visualizacion-de-series-temporales">Análisis y visualización de series temporales.</h2>
<p>En este práctico vamos a visualizar y analizar datos de mareas en el Río de la Plata. Tiene una primera parte que esperamos que todes hagan y una segunda parte, más larga y compleja, optativa. Trabajá en el archivo <code>mareas_fft.py</code>.</p>
<p>Para comenzar, copiate <a href="../OBS_SHN_SF-BA.csv">el archivo</a> con datos de mareas en los puertos de San Fernando y Buenos Aires a tu carpeta <code>Data</code></p>
<h2 id="lectura-de-archivos-temporales">Lectura de archivos temporales</h2>
<pre><code class="language-python">import pandas as pd

df = pd.read_csv('../Data/OBS_SHN_SF-BA.csv')
</code></pre>
<p>Observá los datos:</p>
<pre><code class="language-python">&gt;&gt;&gt; df.head()
                  Time  H_SF   H_BA
0  2011-01-01 00:00:00   NaN   92.0
1  2011-01-01 01:00:00   NaN  110.0
2  2011-01-01 02:00:00   NaN  124.0
3  2011-01-01 03:00:00   NaN  132.0
4  2011-01-01 04:00:00   NaN  136.0

&gt;&gt;&gt; df.index
RangeIndex(start=0, stop=35064, step=1)
</code></pre>
<p>Este archivo tiene alturas del agua en el puerto de San Fernando (columna <code>H_SF</code>) y en el puerto de Buenos Aires (columna <code>H_BA</code>) medidas en centímetros.
Tiene un dato por hora (columna <code>Time</code>) durante cuatro años.
En los primeros registros se observa algo muy frecuente con este tipo de archivos: tiene muchos datos faltantes.</p>
<p>El índice de un dataframe nos da información de su estructura. En este caso, está representando el número de línea del archivo que leímos. Pero un índice puede aportarnos más información relevante para nuestro problema, por lo que la propuesta es que el índice debería ser el instante en le que se tomó cada muestra ('Time').</p>
<p>Para esto tenemos que decirle a la función <code>read_csv</code> dos cosas:
* por un lado que use la columna 'Time' como índice (index_col = ['Time']) y
* por el otro que la interprete como un timestamp (parse_dates = True).</p>
<pre><code class="language-python">df = pd.read_csv('../Data/OBS_SHN_SF-BA.csv', index_col=['Time'], parse_dates=True)
</code></pre>
<p>Observá la diferencia:</p>
<pre><code class="language-python">&gt;&gt;&gt; df.head()
                     H_SF   H_BA
Time
2011-01-01 00:00:00   NaN   92.0
2011-01-01 01:00:00   NaN  110.0
2011-01-01 02:00:00   NaN  124.0
2011-01-01 03:00:00   NaN  132.0
2011-01-01 04:00:00   NaN  136.0

&gt;&gt;&gt; df.index
DatetimeIndex(['2011-01-01 00:00:00', '2011-01-01 01:00:00',
               ...
               '2014-12-31 22:00:00', '2014-12-31 23:00:00'],
              dtype='datetime64[ns]', name='Time', length=35064, freq=None)
</code></pre>
<p>Que el índice sea temporal nos da una versatilidad genial para trabajar con estos datos.
Probá por ejemplo los siguientes comandos:</p>
<pre><code class="language-python">&gt;&gt;&gt; df['1-18-2014 9:00':'1-18-2014 18:00']
                     H_SF  H_BA
Time
2014-01-18 09:00:00  85.0  67.0
2014-01-18 10:00:00  79.0  60.0
2014-01-18 11:00:00  73.0  49.0
2014-01-18 12:00:00  65.0  43.0
2014-01-18 13:00:00  59.0  36.0
2014-01-18 14:00:00  53.0  29.0
2014-01-18 15:00:00  48.0  22.0
2014-01-18 16:00:00  42.0  18.0
2014-01-18 17:00:00  36.0  33.0
2014-01-18 18:00:00  40.0  67.0
</code></pre>
<p>Probá también <code>df['2-19-2014']</code> (observá que el formato de fechas que se usa es el de EEUU), y <code>df['12-25-2014':]</code>.</p>
<h2 id="ondas-de-marea-en-el-rio-de-la-plata">Ondas de marea en el Río de la Plata</h2>
<p>Grafiquemos estos últimos datos:</p>
<pre><code class="language-python">df['12-25-2014':].plot()
</code></pre>
<p align="center">
<img src="./Figure175144.png">
</p>

<p>Acá se ven tres fenómenos interesantes:
* Hay 14 picos en 7 días, esto corresponde a la frecuencia <em>semidiurna</em> de las mareas. Cada poco más de 12hs tenemos un ciclo con pleamar y bajamar. Dos ciclos por día.
* Por otra parte, se ve que las mareas en San Fernando están retrasadas respecto a las de Buenos Aires.
Esto se debe a que las ondas de marea vienen del océano atlántico y se propagan por el estuario del río de la Plata, pasando primero por Buenos Aires y llegando luego, con retraso, a San Fernando. En ciertas condiciones esta onda de mareas puede llegar a la ciudad de Rosario, aunque se va atenuando en su viaje desde el atlántico.</p>
<ul>
<li>Finalmente, hay una marcada diferencia entre la altura registrada en San Fernando y la de Buenos Aires. Esto se debe a que las dos escalas, a partir de las que se registran los datos, tienen ceros que no están nivelados.</li>
</ul>
<p>En este práctico nos proponemos estudiar la propagación de esta <em>onda de marea</em> que es generada por la atracción gravitacional que ejercen la luna y el sol sobre el agua. Vamos a usar una transformada de Fourier que nos permite estudiar las frecuencias predominantes en la serie de alturas. Las mareas se verán claramente porque estos efectos astronómicos son regulares y tienen frecuencias invariantes.</p>
<h2 id="vientos-y-ondas-de-tormenta-en-el-rio-de-la-plata">Vientos y ondas de tormenta en el Río de la Plata</h2>
<p>Si miramos un gráfico un poco más extendido en el tiempo vamos a ver que las alturas no solo fluctúan con las mareas semidiurnas sino que la componente meteorológica (vientos principalmente, que generan <em>ondas de tormenta</em>) modifica las alturas de manera muy considerable.</p>
<p>El siguiente comando genera un gráfico entre el 15 de octubre de 2014 y el 15 de diciembre del mismo año.</p>
<pre><code class="language-python">df['10-15-2014':'12-15-2014'].plot()
</code></pre>
<p align="center">
<img src="./Figure175349.png">
</p>

<p>En ese gráfico se puede observar cómo una sudestada a principios de noviembre elevó el nivel del estuario más de un metro durante casi tres días. Las dos fotos que siguen son justamente de esa sudestada. Fueron tomadas el primero de noviembre por Gustavo Castaing.</p>
<p align="center">
<img src="https://64.media.tumblr.com/22e647b1e723d132c7c00668bae1ecd0/tumblr_ned8qqsPig1rf9hn3o1_1280.jpg" width="500"> <img src="https://images.clarin.com/2014/11/01/r1MQfoi37g_1256x620.jpg" width="500">
</p>

<p>Así como el viento del sudeste empuja el agua del mar hacia adentro del estuario y genera crecidas, los vientos del norte o el oeste también impulsan desplazamientos del agua del estuario, en este caso generando bajantes. En las siguientes dos fotos puede verse una bajante capturada por Juan Pablo Martínez Bigozzi el 19 de junio del 2019.</p>
<p align="center">
<img src="./bajante19062019.jpg" width="500"> <img src="./bajante219062019.jpg" width="500">
</p>

<p>La transformada de Fourier no resultará muy útil para ver estas <em>ondas de tormenta</em>. Como carecen de regularidad, no aparecerán claramente en el espectro de frecuencias.</p>
<h3 id="ejercicio-810">Ejercicio 8.10:</h3>
<p>Trabajemos con una copia de este fragmento:</p>
<pre><code class="language-python">dh = df['12-25-2014':].copy()
</code></pre>
<p>Podemos desplazar (shift en inglés) una Serie de Pandas usando el método <code>ds.shift(pasos)</code>. Además, podemos subir o bajar su gráfico sumando una constante a todas las mediciones <code>ds + cte</code>.</p>
<p>Finalmente podemos unir dos series en un DataFrame de manera muy simple, para poder graficarlas juntas. Si concatenamos estas operaciones obtenemos algo así:</p>
<pre><code class="language-python">delta_t = 0 # tiempo que tarda la marea entre ambos puertos
delta_h = 0 # diferencia de los ceros de escala entre ambos puertos
pd.DataFrame([dh['H_SF'].shift(delta_t) - delta_h, dh['H_BA']]).T.plot()
</code></pre>
<p align="center">
<img src="./Figure175447.png">
</p>

<p>Buscá los valores de <code>delta_t</code> (es un número entero, son pasos) y <code>delta_h</code> (puede tener decimales, es un float) que hacen que los dos gráficos se vean lo más similares posible.</p>
<p>Guardá tu código en el archivo <code>mareas_a_mano.py</code> para entregar.</p>
<h3 id="correlacion-con-desplazamientos">Correlación con desplazamientos</h3>
<p>El siguiente código calcula y grafica el <a href="https://es.wikipedia.org/wiki/Coeficiente_de_correlaci%C3%B3n_de_Pearson">coeficiente de correlación <em>r</em> de Pearson</a> entre la serie de alturas en Buenos Aires y la de San Fernando desplazada temporalmente.</p>
<pre><code class="language-python">import numpy as np
import pandas as pd
from scipy.stats import pearsonr
import matplotlib.pyplot as plt

# Levanto las dos series
df=pd.read_csv('../Data/OBS_SHN_SF-BA.csv',index_col=['Time'],parse_dates=True)
# Me quedo con un fregmento
dh=df['10-01-2014':].copy()

# Selecciono los intervalos que voy a usar para desplazar SF
shifts = np.arange(-12,13)
# Genero un vector donde guardar los coeficientes de correlacion para cada deslpazamiento
corrs = np.zeros(shifts.shape)
for i, sh in enumerate(shifts):
    #guardo el coeficiente de correlación r entre de SF desplazada con BA original.
    corrs[i] = pearsonr(dh['H_SF'].shift(sh)[12:-12],dh['H_BA'][12:-12])[0]
# ploteo los resultados   
plt.plot(shifts, corrs)
</code></pre>
<h3 id="ejercicio-811-interpolacion">Ejercicio 8.11: Interpolación</h3>
<p>Este ejemplo muestra una manera de interplolar la serie de manera de poder usar desplazamientos menores a una hora.</p>
<pre><code class="language-python"># Cada cuarto de hora
df=pd.read_csv('../Data/OBS_SHN_SF-BA.csv',index_col=['Time'],parse_dates=True)
dh =df['10-01-2014':].copy() #ultimo trimestre
freq_horaria = 4 # 4 para 15min, 60 para 1min
cant_horas = 24
N = cant_horas * freq_horaria
#resampleo cada tantos minutos
dh = dh.resample(f'{int(60/freq_horaria)}T').mean()
#rellenos los NaNs suavemente
dh =dh.interpolate(method='quadratic')
# genero vector de desplazamientos (enteros)
ishifts = np.arange(-N,N+1)
# y su desplamiento horario asociado
shifts=ishifts/freq_horaria
# finalmente calculo las correlaciones correspondientes
corrs = np.zeros(shifts.shape)
for i, sh in enumerate(ishifts):
    corrs[i] = pearsonr(dh['H_SF'].shift(sh)[N:-N],dh['H_BA'][N:-N])[0]
# y grafico
plt.plot(shifts, corrs)
</code></pre>
<p>El comando <code>np.argmax(corrs)</code> se puede usar para devolver la coordenada de la máxima correlación. Esa posición del vector <code>shifts</code> indicará a cuántas horas corresponde ese desplazamiento. Si lo corremos con esta interpolación cada 15 minutos propuesta en el código, obtendremos que la onda tarda una hora en llegar a San Fernando. Usando una interpolación más fina, ¿podés estimar el desfazaje en minutos? A nosotros nos dio 57 minutos.</p>
<h2 id="parte-optativa">Parte optativa</h2>
<p>En lo que sigue vamos a usar herramientas matemáticas para hacer un análisis similar al que hicimos recién de manera <em>artesanal</em>. Para una onda sinusoidal, el desplazamiento horizontal corresponde a una diferencia de fase y el desplazamiento vertical es simplemente una constante aditiva. Vamos a descomponer la serie de alturas observadas del agua por medio de la transformada de Fourier.</p>
<p>Las ondas de marea se mueven lentamente y tardan cierto tiempo en llegar de un puerto a otro. En lo que sigue vamos a ver cómo calcular el tiempo que le toma a esta onda en desplazarse de Buenos Aires hasta San Fernando.</p>
<p><strong>Lo que sigue es optativo</strong>.</p>
<h2 id="analisis-por-medio-de-transformadas-de-fourier">Análisis por medio de transformadas de Fourier</h2>
<p>La transformada de Fourier descompone una señal en una suma de senos y cosenos (sinusoides) con diferentes frecuencias y amplitudes.</p>
<p>Esta animación ilustra gráficamente el proceso de la transformada de Fourier.</p>
<p align="center">
<img src="./cuadrada.gif">
</p>

<p>La transformada da, para cada frecuencia, un número complejo <code>a + bi</code> que puede pensarse como un vector <code>(a,b)</code> en el plano. La parte real va a multiplicar un coseno con la frecuencia indicada y la parte imaginaria un seno con la misma frecuencia. La magnitud (o amplitud, o potencia) de la señal en esa frecuencia se corresponde con el largo del vector <code>(a, b)</code>.</p>
<p align="center">
<img src="./vectorial.jpg">
</p>

<p>La fase (o desplazamiento del máximo respecto del origen de las coordenadas), se corresponde con ángulo que forma este vector <code>(a, b)</code> con el semieje de los reales positivos.</p>
<p align="center">
<img src="./phase_shift.png" width="300">
</p>

<p>Aquí, la variable theta (θ) representa el desplazamiento de fase de la curva azul (respecto a la roja que tiene desplazamiento nulo). Esta <em>fase</em> suele medirse en radianes, correspondiendo 2*π a un ciclo completo de desfasaje.</p>
<p>Vamos a aplicar estas herramientas al análisis de la propagación de la onda de marea por el estuario del plata.</p>
<h3 id="preparacion-de-modulos-y-datos">Preparación de módulos y datos</h3>
<p>Vamos a usar los siguientes módulos:</p>
<pre><code class="language-python">from scipy import signal # para procesar señales
import numpy as np
import matplotlib.pyplot as plt
</code></pre>
<p>Seleccionemos las dos series como vectores de numpy (con el método <code>to_numpy()</code>).</p>
<pre><code class="language-python">inicio = '2014-01'
fin = '2014-06'
alturas_sf = df[inicio:fin]['H_SF'].to_numpy()
alturas_ba = df[inicio:fin]['H_BA'].to_numpy()
</code></pre>
<p>Primero definamos una función que calcule la transformada de Fourier para datos horarios y considerando como unidad de frecuencia los días (descartamos la mitad de los coeficientes de la transformada porque los datos son reales y no complejos). Podés tomarla como una caja negra por ahora...</p>
<pre><code class="language-python">def calcular_fft(y, freq_sampleo = 24.0):
    '''y debe ser un vector con números reales
    representando datos de una serie temporal.
    freq_sampleo está seteado para considerar 24 datos por unidad.
    Devuelve dos vectores, uno de frecuencias 
    y otro con la transformada propiamente.
    La transformada contiene los valores complejos
    que se corresponden con respectivas frecuencias.'''
    N = len(y)
    freq = np.fft.fftfreq(N, d = 1/freq_sampleo)[:N//2]
    tran = (np.fft.fft(y)/N)[:N//2]
    return freq, tran
</code></pre>
<p>Para poder analizar una onda por medio de su transformada de Fourier, es necesario que la onda sea periódica. Puede pasar que no sea el caso y que una onda tenga tendencia lineal, en ese caso podríamos usar la función <code>scipy.signal.detrend()</code>.</p>
<p align="center">
<img src="./detrend.png" width="300">
</p>

<p>En nuestro caso supondremos que la marea media se mantuvo estable a lo largo del período de estudio, así que no tenemos que hacerle este procesamiento intermedio.</p>
<h3 id="espectro-de-potencia-y-de-angulos-para-san-fernando">Espectro de potencia y de ángulos para San Fernando</h3>
<p>Primero calculamos la transformada de las alturas de San Fernando.</p>
<pre><code class="language-python">freq_sf, fft_sf = calcular_fft(alturas_sf)
</code></pre>
<p>Si quisiéramos graficar <code>freq_sf</code> contra <code>fft_sf</code> no podríamos ver mucho ya que <code>fft_sf</code> contiene números complejos.</p>
<p>La potencia (o amplitud) para cada frecuencia se calcula como el módulo del número complejo correspondiente (para la frecuencia <code>freq_sf[i]</code> y la potencia es <code>abs(fft_sf[i])</code>). Al graficar esto podemos ver la amplitud de los sinusoides para cada frecuencia. Este gráfico se llama el <em>espectro de potencias</em> de la onda original.</p>
<pre><code class="language-python">plt.plot(freq_sf, np.abs(fft_sf))
plt.xlabel(&quot;Frecuencia&quot;)
plt.ylabel(&quot;Potencia (energía)&quot;)
plt.show()
</code></pre>
<p align="center">
<img src="./Figure175811_.png">
</p>

<p>A simple vista se observan dos picos, uno en frecuencia 0 (constante relacionada con el cero de escala) y otro pico cercano a la frecuencia 2 (frecuencia semidiurna) que está relacionado con la onda de mareas.</p>
<p>El pico en la primera posición efectivamente se corresponde con la frecuencia 0 y su amplitud es:</p>
<pre><code class="language-python">&gt;&gt;&gt; freq_sf[0]
0.0
&gt;&gt;&gt; np.abs(fft_sf[0])
111.83
</code></pre>
<p>A partir de esto podemos decir que las alturas del río en San Fernando durante este período oscilan alrededor de los 111.8 cm de altura.</p>
<p>Para analizar precisamente el pico semidiurno podemos usar <code>find_peaks</code> que provee<code>scipy.signal</code> para evitar hacerlo a ojo. Vamos a pedir aquellos picos que tengan al menos cierta diferencia con su entorno (prominencia), un buen valor para esto es el 8. Podés probar otros valores y observar el resultado.</p>
<pre><code class="language-python">&gt;&gt;&gt; print(signal.find_peaks(np.abs(fft_sf), prominence = 8))
(array([350]), {'prominences': array([11.4554514]), 'left_bases': array([307]), 'right_bases': array([2109])})
</code></pre>
<p>Esta respuesta nos indica que hay un pico con la prominencia solicitada (al menos 8), que tiene un magnitud de 11.45 y que corresponde a la posición 350 del vector.</p>
<pre><code class="language-python">&gt;&gt;&gt; freq_sf[350]
1.93
</code></pre>
<p>La frecuencia relacionada con esa posición es cercana a dos, como ya habíamos observado en el gráfico (dos ciclos por día). Podemos distinguir los picos agregando un punto rojo y mirando más de cerca el área de interés:</p>
<pre><code class="language-python">plt.plot(freq_sf, np.abs(fft_sf))
plt.xlabel(&quot;Frecuencia&quot;)
plt.ylabel(&quot;Potencia (energía)&quot;)
plt.xlim(0,4)
plt.ylim(0,20)
# me quedo solo con el último pico
pico_sf = signal.find_peaks(np.abs(fft_sf), prominence = 8)[0][-1]
# es el pico a analizar, el de la onda de mareas
# marco ese pico con un circulito rojo
plt.scatter(freq_sf[pico_sf], np.abs(fft_sf)[pico_sf], facecolor = 'r')
plt.show()
</code></pre>
<p align="center">
<img src="./Figure175902_.png">
</p>

<p>Estos gráficos permiten interpretar que si descomponemos la curva de alturas en San Fernando como suma de sinusoidales, el sinusoide con frecuencia 1.93 tiene una magnitud considerablemente llamativa. No es casualidad que este sea un punto distinguido: se trata de la frecuencia de las mareas lunares.</p>
<p>Ahora viene la parte un poco más sutíl: <strong>el análisis de las fases</strong>. Si conocemos la fase de estas componentes en dos puertos distintos, podremos estimar el tiempo que tarda en desplazarse la marea de uno a otro.</p>
<p>Para calcular la fase (entre -π y π) de dicha componente (la que ubicamos en la posición 350) en el puerto de San Fernando, podemos simplemente usar <code>np.angle()</code> y pasarle el número complejo en cuestión:</p>
<p align="center">
<img src="./vectorial.jpg">
</p>

<pre><code class="language-python">&gt;&gt;&gt; ang_sf = np.angle(fft_sf)[pico_sf]
&gt;&gt;&gt; print(ang_sf)
1.4849
</code></pre>
<p>Obtenemos un valor cercano a pi/2. Recordemos que 2<em>pi corresponde a un desfasaje de un ciclo completo de la curva. Como nuestra curva de estudio tiene una frecuencia diaria ligeramente inferior a 2 (freq_sf[350]~1.93), 2</em>pi corresponde a 24/1.93 horas ~ 12.44 horas. Por lo tanto la fase obtenida con angSF[350] corresponde a un retardo de</p>
<pre><code class="language-python">&gt;&gt;&gt; ang_sf * 24 / (2 * np.pi * freq_sf[350])
2.93
</code></pre>
<p>Es decir, este sinusoide está desfasado poco menos de 3hs respecto al seno <em>neutro</em>.</p>
<h3 id="espectro-de-potencia-y-de-angulos-para-buenos-aires">Espectro de potencia y de ángulos para Buenos Aires</h3>
<p>Repitamos velozmente el procedimiento para el puerto de Buenos Aires y analicemos las diferencias.</p>
<pre><code class="language-python">freq_ba, fft_ba = calcular_fft(alturas_ba)
plt.plot(freq_ba, np.abs(fft_ba))
plt.xlabel(&quot;Frecuencia&quot;)
plt.ylabel(&quot;Potencia (energía)&quot;)
plt.xlim(0,4)
plt.ylim(0,20)
# me quedo solo con el último pico
pico_ba = signal.find_peaks(np.abs(fft_ba), prominence = 8)[0][-1]
#se grafican los picos como circulitos rojos
plt.scatter(freq_ba[pico_ba], np.abs(fft_ba)[pico_ba], facecolor='r')
plt.title(&quot;Espectro de Potencias Bs.As.&quot;)
plt.show()
</code></pre>
<p><img alt="Figura" src="../Figure175932_.png" /></p>
<p>Si buscamos la constante alrededor de la que oscilan las mareas según el nivel del puerto de Buenos Aires obtenemos:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.abs(fft_ba[0])
88.21
</code></pre>
<p>Con este resultado es sencillo obtener una estimación para la diferencia de alturas de los ceros de escala entre ambos puertos.</p>
<p><em>Pregunta 1:</em> ¿Cuál es la diferencia de altura media entre los puertos obtenida de esta forma? </p>
<p><em>Pregunta 2:</em> ¿De qué otra forma se puede estimar el valor medio de un puerto? ¿Cuánto da la diferencia con este otro método?</p>
<p>Por otra parte, si observamos que el espectro de potencia vemos que los picos en ambos puertos son súmamente similares.</p>
<pre><code class="language-python">&gt;&gt;&gt; print(signal.find_peaks(np.abs(fft_ba), prominence=8))
(array([350]), {'prominences': array([12.67228046]), 'left_bases': array([279]), 'right_bases': array([1000])})
</code></pre>
<p>Las mareas de Buenos Aires tiene una componente de máxima amplitud en la  frecuencia 1.93 (misma que San Fernando) y con una magnitud de 12.67 (bastante similar a la magnitud correspondiente en San Fernando). Resta estudiar la fase de la curva de los datos de <code>df_ba</code> en esta frecuencia para poder determinar con precisión la diferencia de fase entre ambos puertos para ondas de marea. Primero calculamos el ángulo de la componente correspondiente y luego lo convertimos en horas usando el factor <code>ang2h</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; ang_ba = np.angle(fft_ba)[pico_ba]
&gt;&gt;&gt; print(ang_ba)
1.96
&gt;&gt;&gt; freq = freq_ba[pico_ba]
&gt;&gt;&gt; ang2h = 24 / (2*np.pi*freq)
&gt;&gt;&gt; ang_ba * ang2h
3.8786004708135566
</code></pre>
<p>Por lo tanto, el retardo de la onda de mareas puede calcularse usando</p>
<pre><code class="language-python">(ang_ba - ang_sf) * ang2h
</code></pre>
<h3 id="ejercicio-812-desfasajes">Ejercicio 8.12: Desfasajes</h3>
<p>En la Pregunta 1 estimaste el desfasaje vertical entre los ceros de escala de los puertos analizados.
Ahora tenés que estimar el desfasaje temporal de las ondas de marea entre ambos puertos.
¿A cuántos minutos corresponde aproximadamente el tiempo que tarda la onda de mareas en llegar del puerto de Buenos Aires al de San Fernando?</p>
<p>Usá estos datos para volver a hacer el gráfico del <a href="./#ejercicio-810">Ejercicio 8.10</a> (vas a tener que redondear a horas enteras el delay temporal).</p>
<h2 id="un-poco-mas-avanzados">Un poco más avanzados:</h2>
<h3 id="ejercicio-813-otros-puertos">Ejercicio 8.13: Otros puertos</h3>
<p>Usando el <a href="../OBS_Zarate_2013A.csv">archivo con datos del Puerto de Zárate</a>, estimá el tiempo (expresado en horas y minutos) que le toma a la onda de marea llegar de Buenos Aires a Zárate.</p>
<p>Obviamente la onda llega atenuada a Zárate. ¿Cómo se refleja esta atenuación en la transformada? ¿Podés cuantificar esta atenuación?</p>
<p>Guardá lo que hayas hecho hasta acá en el archivo <code>mareas_fft.py</code> para entregar.</p>
<h3 id="ejercicio-814-otros-periodos">Ejercicio 8.14: Otros períodos</h3>
<p>El primer análisis se realizó con el primer semestre del 2014 ya que no tiene ni datos faltantes ni outliers. Este ejercicio es una invitación a explorar estos problemas tan frecuentes.</p>
<ul>
<li>¿Se puede comparar Zárate con San Fernando usando todos los datso de Zárate? ¿Cómo se comporta San Fernando en esas fechas?</li>
<li>¿Se pueden usar las series completas de BA y SF para calcular el desfasaje de la onda de mareas? ¿Qué son las alturas negativas? ¿Tienen sentido?</li>
</ul>
<p>La siguiente función completa datos faltantes y corrige pequeños problemas en los índices. Es un poco brutal tratar así un DataFrame: es conveniente mirar los datos antes de completar faltantes. Lo dejamos como puntero a diferentes  métodos muy útiles para la limpieza de series.</p>
<pre><code class="language-python">def reparar(df):
    df = df.interpolate()
    df = df.resample('H').mean()
    df = df.fillna(method = 'ffill')
    return df
</code></pre>
<p><a href="../Contenidos.md">Contenidos</a> | <a href="../05_Pandas/">Anterior (5 Introducción a Pandas)</a> | <a href="../07_Cierre/">Próximo (7 Cierre de la clase)</a></p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentación construida con <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Buscar</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Cerrar</span></button>
            </div>
            <div class="modal-body">
                <p>Desde aquí puede buscar estos documentos. Ingrese sus términos de búsqueda a continuación.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Buscando..." id="mkdocs-search-query" title="Escriba el término de búsqueda aquí">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No se encontraron resultados"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Atajos de teclado</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Cerrar</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Teclas</th>
                    <th>Acción</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Abrir esta ayuda</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Página siguiente</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Página anterior</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Buscar</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
