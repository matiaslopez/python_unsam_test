<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://matiaslopez.github.io/python_unsam_test/05_Random_Plt_Dbg/02_NumPy_Arrays/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>02 NumPy Arrays - Programación en Python</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ABC123"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-ABC123');
        </script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-light bg-light">
            <div class="container">
                <a class="navbar-brand" href="../..">Programación en Python</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Inicio</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Unidades <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../01_Introduccion/00_Resumen/" class="dropdown-item">01 - Introducción</a>
</li>
                                    
<li>
    <a href="../../02_Estructuras_y_Funciones/00_Resumen/" class="dropdown-item">02 - Estructuras y funciones</a>
</li>
                                    
<li>
    <a href="../../03_Datos/00_Resumen/" class="dropdown-item">03 - Trabajando con datos</a>
</li>
                                    
<li>
    <a href="../../04_Listas_y_Listas/00_Resumen/" class="dropdown-item">04 - Algoritmos sobre listas y comprensión de listas</a>
</li>
                                    
<li>
    <a href="../00_Resumen/" class="dropdown-item">05 - Aleatoridad</a>
</li>
                                    
<li>
    <a href="../../06_Organizacion_y_Complejidad/00_Resumen/" class="dropdown-item">06 - Complejidad y Organización de programas</a>
</li>
                                    
<li>
    <a href="../../07_Plt_Especificacion_y_Documentacion/00_Resumen/" class="dropdown-item">07 - Diseño, especificación, documentación y estilo</a>
</li>
                                    
<li>
    <a href="../../08_Fechas_Carpetas_y_Pandas/00_Resumen/" class="dropdown-item">08 - Fechas, Carpetas y Pandas</a>
</li>
                                    
<li>
    <a href="../../09_Clases_y_Objetos/00_Resumen/" class="dropdown-item">09 - Clases y objetos</a>
</li>
                                    
<li>
    <a href="../../10_Generadores_e_Iteradores/00_Resumen/" class="dropdown-item">10 - Generadores e iteradores</a>
</li>
                                    
<li>
    <a href="../../11_Recursion/00_Resumen/" class="dropdown-item">11 - Recursión y regresión</a>
</li>
                                    
<li>
    <a href="../../12_Ordenamiento/00_Resumen/" class="dropdown-item">12 - Ordenamiento</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Buscar
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Tabla de contenidos">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#52-numpy" class="nav-link">5.2 NumPy</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#instalar-e-importar-numpy" class="nav-link">Instalar e importar numpy</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#cual-es-la-diferencia-entre-listas-y-arreglos" class="nav-link">¿Cuál es la diferencia entre listas y arreglos?</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#arreglos-n-dimensionales" class="nav-link">Arreglos n-dimensionales</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#mas-informacion-sobre-arreglos" class="nav-link">Más información sobre arreglos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#crear-un-arreglo-basico" class="nav-link">Crear un arreglo básico</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#agregar-borrar-y-ordenar-elementos" class="nav-link">Agregar, borrar y ordenar elementos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#conocer-el-tamano-dimensiones-y-forma-de-un-arreglo" class="nav-link">Conocer el tamaño, dimensiones y forma de un arreglo</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#cambiar-la-forma-de-un-arreglo" class="nav-link">Cambiar la forma de un arreglo</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#agregar-un-nuevo-eje-a-un-arreglo" class="nav-link">Agregar un nuevo eje a un arreglo</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#indices-y-rebanadas" class="nav-link">Índices y rebanadas</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#crear-arreglos-usando-datos-existentes" class="nav-link">Crear arreglos usando datos existentes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#operaciones-basicas-sobre-arreglos" class="nav-link">Operaciones básicas sobre arreglos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#broadcasting" class="nav-link">Broadcasting</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#operaciones-un-poco-mas-complejas" class="nav-link">Operaciones un poco más complejas</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#crear-matrices" class="nav-link">Crear matrices</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#formulas-matematicas" class="nav-link">Fórmulas matemáticas</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#guardar-y-cargar-objetos-de-numpy" class="nav-link">Guardar y cargar objetos de numpy</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<p><a href="../Contenidos.md">Contenidos</a> | <a href="../01_Random/">Anterior (1 Random)</a> | <a href="../03_Figuritas/">Próximo (3 El album de Figuritas)</a></p>
<h1 id="52-numpy">5.2 NumPy</h1>
<p>Esta es una introducción a la biblioteca NumPy (<strong>Numerical Python</strong>) de Python. Se trata de una colección de módulos de código abierto que tiene aplicaciones en casi todos los campos de las ciencias y de la ingeniería. Es el estándar para trabajar con datos numéricos en Python. Muchas otras bibliotecas y módulos de Python como Pandas, SciPy, Matplotlib, scikit-learn, scikit-image usan numpy.</p>
<p>Esta biblioteca permite trabajar cómodamente con matrices multidimensionales por medio del tipo <strong>ndarray</strong>, un objeto n-dimensional homogéneo (es decir, con todas sus entradas del mismo tipo), y con métodos para operar eficientemente sobre él. numpy puede usarse para una amplia variedad de operaciones matemáticas sobre matrices. Le agrega a Python estructuras de datos muy potentes sobre las que puedés hacer cálculos y operar matemáticamente con eficiencia y a un alto nivel.</p>
<h2 id="instalar-e-importar-numpy">Instalar e importar numpy</h2>
<p>Cuando quieras usar numpy en Python, primero tenés que importarlo:</p>
<pre><code class="language-python">import numpy as np
</code></pre>
<p>Acortamos <code>numpy</code> a <code>np</code> para ahorrar tiempo y mantener el código estandarizado. Todes escriben <code>np</code>.</p>
<p>Si no lo tenés instalado (te dará un error al importarlo) podés instalarlo escribiendo alguno de los siguientes comandos, según corresponda:</p>
<pre><code class="language-bash">conda install numpy
pip install numpy
pip3 install numpy
</code></pre>
<h2 id="cual-es-la-diferencia-entre-listas-y-arreglos">¿Cuál es la diferencia entre listas y arreglos?</h2>
<p>numpy ofrece varias formas muy eficientes de crear vectores y manipular datos numéricos. Mientras que una lista de Python puede contener diferentes tipos de datos en su interior, los elementos de un vector numpy serán todos del mismo tipo. De esta forma numpy garantiza un muy alto rendimiento en las operaicones matemáticas.</p>
<p>Además, los arreglos están pensados para tener un tamaño fijo, mientras que las listas están diseñadas para agregar y sacar elementos. Son estructuras de datos similares desde un punto de vista superficial, pero muy diferentes en cuanto a las posibilidades que brindan. </p>
<p>Las operaciones matemáticas sobre vectores de numpy son más rápidas que sobre listas. Además los vectores ocupan menos memoria que las listas análogas. En cambio, modificar el tamaño de una lista es algo muy sencillo mientras que el de un vector es costoso. Y combinar diferentes tipos de datos es sencillo en las listas pero imposible en los vectores de numpy.</p>
<h2 id="arreglos-n-dimensionales">Arreglos n-dimensionales</h2>
<p>Los vectores (unidimensionales) y matrices (bidimensiones) se generalizan a arreglos n-dimensionales. Esta estructura de datos es la central de la biblioteca numpy. Un arreglo (<code>ndarray</code>) tiene una grilla de valores (datos crudos) junto con información sobre cómo ubicarlos y cómo interpretarlos. Los elementos de esta grilla pueden ser indexados de diversas maneras y, como ya dijimos, son todos del mismo tipo. Este tipo es frecuentemente abreviado como <code>dtype</code> (por data type).</p>
<p>Un arreglo puede ser indexado por tuplas de enteros no negativos, por variables booleanas, por otro arreglo o por enteros. El rango (<code>rank</code>) de un arreglo es su número de dimensiones. Su forma (<code>shape</code>) es una tupla de enteros que dice su tamaño en cada dimensión.</p>
<p>Una forma de inicializar un arreglo de numpy es mediante una lista de números. Esto nos da un vector (arreglo de dimensión uno). Usando listas anidadas, podemos definir arreglos de más altas dimensiones.</p>
<p>Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5, 6])
</code></pre>
<p>o:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
</code></pre>
<p>Podemos acceder a los elementos de un arreglo usando corchetes. Acordate que los índices comienzan a contar en 0. Esto significa que si querés acceder al primer elemento, vas a acceder al elemento “0”.</p>
<pre><code class="language-python">&gt;&gt;&gt; print(a[0]) # si tiene múltiples dimensiones, esto me da una &quot;rebanada&quot; de una dimensión menos
[1 2 3 4]
&gt;&gt;&gt; print(a[2]) # otra rebanada
[ 9, 10, 11, 12]
&gt;&gt;&gt; print(a[2][3]) # accedo al cuarto elemento del tercer vector de a
12
&gt;&gt;&gt; print(a[2,3]) # o, equivalentemente, accedo al elemento en la tercera fila y cuarta columna de a
12
</code></pre>
<h2 id="mas-informacion-sobre-arreglos">Más información sobre arreglos</h2>
<p>Ocasionalmente vas a ver que alguien se refiere a un arreglo como un  “ndarray” que es una forma breve de decir arreglo n-dimensional. Un arreglo n-dimensional es simplemente un arreglo con n dimensiones. Recordemos que cuando son unidimensionales los llamamos vectores y si son bidimensionales los llamamos matrices.</p>
<p><strong>¿Qué atributos tiene un arreglo?</strong></p>
<p>Un arreglo es usualmente un contenedor de tamaño fijo de elementos del mismo tipo. Su forma (shape) es una tupla de enteros no negativos que especifica el tamaño del arreglo en cada dimensión. Un arreglo tiene tantas dimensiones como coordenadas en la tupla.</p>
<p>En numpy, las dimensiones se llaman <strong>axes</strong> (ejes). Esto significa que si tenés un arreglo bidimensional que se ve así:</p>
<pre><code>[[0., 0., 0.],
 [1., 1., 1.]]
</code></pre>
<p>el arreglo tendrá dos ejes. El primer eje tiene tamaño dos, el segundo tamaño tres (sí, se cuentan primero filas, luego columnas).</p>
<p>De la misma forma que los otros objetos contenedores de Python, los elementos de un arreglo pueden ser accedidos y modificados usando índices y rebanadas.</p>
<h2 id="crear-un-arreglo-basico">Crear un arreglo básico</h2>
<p>Para crear un arreglo de numpy podés usar la función <code>np.array()</code>.
Lo único que necesitás es pasarle una lista. Si querés, podés especificar el tipo de datos que querés que tenga. </p>
<pre><code class="language-python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; a = np.array([1, 2, 3])
</code></pre>
<p>Vamos a representar la creación con este gráfico:</p>
<p><img alt="./np_array.png" src="../np_array.png" /></p>
<p><em>Ojo, estas visualizaciones son simplificaciones para representar lo que esta pasando y darte un entendimiento básico de los conceptos y mecanismos de numpy. Los arreglos y sus operaciones tienen aspectos más complejos que los que quedan capturados en estos dibujitos.</em></p>
<p>Además de crear un arreglo a partir de una secuencia de elementos, podés crear un arreglo lleno de <code>0</code>’s:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.zeros(2)
array([0., 0.])
</code></pre>
<p>O uno lleno de <code>1</code>’s:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.ones(2)
array([1., 1.])
</code></pre>
<p>¡O incluso uno no inicializado! La función <code>empty</code> crea un arreglo cuyo contenido inicial depende del estado de la memoria. Lo bueno de usar <code>empty</code> en lugar de <code>zeros</code> (o <code>ones</code>) es la velocidad - al no inicilizar los valores no perdemos tiempo. ¡Pero asegurate de ponerle valores con sentido luego!</p>
<pre><code class="language-python">&gt;&gt;&gt; # Crea un arreglo con dos elementos
&gt;&gt;&gt; np.empty(2)
array([ 3.14, 42.  ])  # puede variar
</code></pre>
<p>También podés crear vectores a partir de un rango de valores:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.arange(4)
array([0, 1, 2, 3])
</code></pre>
<p>También un vector que contiene elementos equiespaciados, especificando el <strong>primer número</strong>, el <strong>límite</strong>, y el <strong>paso</strong>.</p>
<pre><code class="language-python">&gt;&gt;&gt; np.arange(2, 9, 2) # o np.arange(2, 10, 2)
array([2, 4, 6, 8])
</code></pre>
<p>El límite derecho nunca está en la lista. </p>
<p>También podés usar <code>np.linspace()</code> para crear un vector de valores equiespaciados especificando el <strong>primer número</strong>, el <strong>último número</strong>, y la <strong>cantidad</strong> de elementos:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.linspace(0, 10, num=5)
array([ 0. ,  2.5,  5. ,  7.5, 10. ])
</code></pre>
<h3 id="ejercicio-57-arange-y-linspace">Ejercicio 5.7: arange() y linspace()</h3>
<p>Generá un vector que tenga los números impares entre el 1 y el 19 inclusive usando <code>arange()</code>. Repetí el ejercicio usando <code>linspace()</code>. ¿Qué diferencia hay en el resultado?</p>
<p><strong>Especificar el tipo de datos</strong></p>
<p>Si no lo especificás, el tipo de datos (por omisión) de los arreglos es el punto flotante (<code>np.float64</code>). Sin embargo, podés explicitar otro tipo de datos usando la palabra clave <code>dtype</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; x = np.ones(2, dtype=np.int64)
&gt;&gt;&gt; x
array([1, 1])
</code></pre>
<p>En estos dos casos el 64 de los tipos de datos se refiere a la cantidad de bits usados para representar el número en el sistema binario: 64 bits. </p>
<h2 id="agregar-borrar-y-ordenar-elementos">Agregar, borrar y ordenar elementos</h2>
<p>Ordenar un vector es sencillo usando <code>np.sort()</code>. 
Por ejemplo, si comenzás con este vector:</p>
<pre><code class="language-python">&gt;&gt;&gt; arr = np.array([2, 1, 5, 3, 7, 4, 6, 8])
</code></pre>
<p>Podés ordenar sus elementos con:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.sort(arr)
array([1, 2, 3, 4, 5, 6, 7, 8])
</code></pre>
<p>Fijate que el vector <code>arr</code> quedó desordenado. <code>sort</code> simplemente devolvió una copia ordenada de los datos pero no modificó el original.</p>
<p>Otra operación usual es la concatenación. Si empezás con estos dos vectores:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = np.array([1, 2, 3, 4])
&gt;&gt;&gt; b = np.array([5, 6, 7, 8])
</code></pre>
<p>los podés concatenar usado <code>np.concatenate()</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; np.concatenate((a, b))
array([1, 2, 3, 4, 5, 6, 7, 8])
</code></pre>
<p>Un ejemplo un poco más complejo es el siguiente:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; y = np.array([[5, 6]])
</code></pre>
<p>Los podés concatenar usando:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.concatenate((x, y), axis=0)
array([[1, 2],
 [3, 4],
 [5, 6]])
</code></pre>
<h2 id="conocer-el-tamano-dimensiones-y-forma-de-un-arreglo">Conocer el tamaño, dimensiones y forma de un arreglo</h2>
<p><code>ndarray.ndim</code> te dice la cantidad de ejes (o dimensiones) del arreglo.</p>
<p><code>ndarray.shape</code> te va a dar una tupla de enteros que indican la cantidad de elementos en cada eje. Si tenés una matriz con 2 filas y 3 columnas de va a dar <code>(2, 3)</code>.</p>
<p><code>ndarray.size</code> te dice la cantidad de elementos (cantidad de números) de tu arreglo. Es el producto de la tupla <code>shape</code>. En el ejemplo del renglón anterior, el <code>size</code> es 6.</p>
<p>Por ejemplo, si creás este arreglo de tres dimensiones:</p>
<pre><code class="language-python">&gt;&gt;&gt; array_ejemplo = np.array([[[0, 1, 2, 3],
...                            [4, 5, 6, 7]],
...
...                           [[0, 1, 2, 3],
...                            [4, 5, 6, 7]],
...
...                           [[0 ,1 ,2, 3],
...                            [4, 5, 6, 7]]])
</code></pre>
<p>Vas a tener</p>
<pre><code class="language-python">&gt;&gt;&gt; array_ejemplo.ndim # cantidad de dimensiones
3
&gt;&gt;&gt; array_ejemplo.shape # cantidad de elementos en cada eje 
(3, 2, 4)
&gt;&gt;&gt; array_ejemplo.size # total de elementos 3*2*4
24
</code></pre>
<h2 id="cambiar-la-forma-de-un-arreglo">Cambiar la forma de un arreglo</h2>
<p>Usando <code>arr.reshape()</code> le podés dar una nueva forma a tu arreglo sin cambiar los datos. Solo tené en cuenta que antes y después del reshape el arreglo tiene que tener la misma cantidad de elementos. Por ejemplo, si comenzás con un arreglo con 12 elementos, tendrás que asegurarte que el nuevo arreglo siga teniendo 12 elementos.</p>
<p>Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = np.arange(6)
&gt;&gt;&gt; print(a)
[0 1 2 3 4 5]
</code></pre>
<p>Podés usar <code>reshape()</code> para cambiarle la forma y que en lugar de ser un vector de 6 elementos, sea una matriz de 3 filas y dos columnas:</p>
<pre><code class="language-python">&gt;&gt;&gt; b = a.reshape(3, 2)
&gt;&gt;&gt; print(b)
[[0 1]
 [2 3]
 [4 5]]
</code></pre>
<h2 id="agregar-un-nuevo-eje-a-un-arreglo">Agregar un nuevo eje a un arreglo</h2>
<p>A veces pasa que tenemos un vector con n elementos y necesitamos pensarlo como una matriz de una fila y n columnas o de n filas y una columna. Podés usar <code>np.newaxis</code> para agregarle dimensiones a un vector existente.</p>
<p>Usando <code>np.newaxis</code> una vez podés incrementar la dimensión de tu arreglo en uno. Por ejemplo podés pasar de un vector a una matriz o de una matriz a un arreglo tridimensional, etc.</p>
<p>Por ejemplo, si comenzás con este vector:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5, 6])
&gt;&gt;&gt; a.shape
(6,)
</code></pre>
<p>Podés usar <code>np.newaxis</code> para agregarle una dimensión y convertirlo en un vector fila:</p>
<pre><code class="language-python">&gt;&gt;&gt; vec_fila = a[np.newaxis, :]
&gt;&gt;&gt; vec_fila.shape
(1, 6)
</code></pre>
<p>O, para convertirlo en un vector columna, podés unsertar un eje en la segunda  dimensión:</p>
<pre><code class="language-python">&gt;&gt;&gt; vec_col = a[:, np.newaxis]
&gt;&gt;&gt; vec_col.shape
(6, 1)
</code></pre>
<h2 id="indices-y-rebanadas">Índices y rebanadas</h2>
<p>Podés indexar y rebanar arreglos de numpy como hicimos con las listas.</p>
<p>Para obtener elementos de un arreglo, lo más sencillo es usar los índices para seleccionar los que queremos conservar.</p>
<pre><code class="language-python">&gt;&gt;&gt; data = np.array([1, 2, 3])
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; data[1]
2
&gt;&gt;&gt; data[0:2]
array([1, 2])
&gt;&gt;&gt; data[1:]
array([2, 3])
&gt;&gt;&gt; data[-2:]
array([2, 3])
</code></pre>
<p>Lo podés visualizar así:</p>
<p><img alt="./np_indexing.png" src="../np_indexing.png" /></p>
<p>Otra operación muy útil es seleccionar los elementos que cumplen cierta condición. Por ejemplo, si comenzás con un arreglo así:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
</code></pre>
<p>Podés imprimir todos los valores menores que cinco.</p>
<pre><code class="language-python">&gt;&gt;&gt; print(a[a &lt; 5])
[1 2 3 4]
</code></pre>
<p>También podés seleccionar, por ejemplo, aquellos elementos mayores o iguales que 5 y usar el resultado para indexar el arreglo.</p>
<pre><code class="language-python">&gt;&gt;&gt; five_up = (a &gt;= 5)
&gt;&gt;&gt; print(a[five_up])
[ 5  6  7  8  9 10 11 12]
</code></pre>
<p>Es interesante que <code>five_up</code> da un arreglo de valores booleanos. <code>True</code> si satisface la condición y <code>False</code> si no la satisface.</p>
<p>Podés seleccionar los elementos pares:</p>
<pre><code class="language-python">&gt;&gt;&gt; pares = a[a%2==0]
&gt;&gt;&gt; print(pares)
[ 2  4  6  8 10 12]
</code></pre>
<p>Usando los operadores lógicos <code>&amp;</code> y <code>|</code> podés combinar dos o más condiciones.</p>
<p>Ya sea para seleccionar elementos directamente:</p>
<pre><code class="language-python">&gt;&gt;&gt; c = a[(a &gt; 2) &amp; (a &lt; 11)]
&gt;&gt;&gt; print(c)
[ 3  4  5  6  7  8  9 10]
</code></pre>
<p>o para definir una nueva variable booleana:</p>
<pre><code class="language-python">&gt;&gt;&gt; five_up = (a &gt; 5) | (a == 5)
&gt;&gt;&gt; print(five_up)
[[False False False False]
 [ True  True  True  True]
 [ True  True  True True]]
</code></pre>
<p>Finalmente, podés usar <code>np.nonzero()</code> para obtener las coordenadas de ciertos elementos de un arreglo.</p>
<p>Si empezamos con este arreglo:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
</code></pre>
<p>Podés usar <code>np.nonzero()</code> para imprimir los índices de los elementos que son, digamos, menores que 5:</p>
<pre><code class="language-python">&gt;&gt;&gt; b = np.nonzero(a &lt; 5)
&gt;&gt;&gt; print(b)
(array([0, 0, 0, 0]), array([0, 1, 2, 3]))
</code></pre>
<p>En este ejemplo, la respuesta es una tupla de arreglos: uno por cada dimensión. El primer arreglo representa las filas de los elementos que satisfacen la condición y el segundo sus columnas.</p>
<p>Si querés generar la lista de coordenadas donde se encuentran estos elementos, podés zipear los arreglos, convertir el resultado en una lista e imprimirla:</p>
<pre><code class="language-python">&gt;&gt;&gt; lista_de_coordenadas = list(zip(b[0], b[1]))
</code></pre>
<p>Surge naturalmente la pregunta: ¿porqué tengo que convertir el objeto <code>zip</code> a una lista? Veremos en la segunda mitad de la materia más detalles sobre <em>generadores</em> en Python para entender exactamente lo que está pasando aquí. Simplemente digamos que al zipear <code>b[0]</code> y <code>b[1]</code> no se genera la lista realmente, sino potencialmente. Sólo al solicitar sus elementos (iterando sobre ello o con <code>list</code>) se generan realmente las coordenadas.</p>
<pre><code class="language-python">&gt;&gt;&gt; for coord in lista_de_coordenadas:
...     print(coord)
(0, 0)
(0, 1)
(0, 2)
(0, 3)
</code></pre>
<p>Podés usar <code>np.nonzero()</code> para imprimir o seleccionar los elementos del arreglo que son menores que 5:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(a[b])
[1 2 3 4]
</code></pre>
<p>Si la condición que ponés no la satisface ningún elemento del arreglo entonces el arreglo de índices que obtenés con <code>np.nonzero()</code> será vacío. Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; no_hay = np.nonzero(a == 42)
&gt;&gt;&gt; print(no_hay)
(array([], dtype=int64), array([], dtype=int64))
</code></pre>
<h2 id="crear-arreglos-usando-datos-existentes">Crear arreglos usando datos existentes</h2>
<p>Es sencillo crear un nuevo arreglo usando una sección de otro arreglo.</p>
<p>Suponete que tenés este:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = np.array([1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
</code></pre>
<p>Podés crear otro arreglo a partir de una sección de <code>a</code>, simplemente especificando qué parte querés.</p>
<pre><code class="language-python">&gt;&gt;&gt; arr1 = a[3:8]
&gt;&gt;&gt; arr1
array([4, 5, 6, 7, 8])
</code></pre>
<p>Es importante saber que este método genera una <em>vista</em> del arreglo original y no una verdadera copia. Si modificás un elemento de la vista, ¡también se modificará en el original!</p>
<pre><code class="language-python">&gt;&gt;&gt; arr1[0] = 44
&gt;&gt;&gt; print(a)
[ 1  2  3 44  5  6  7  8  9 10]
</code></pre>
<p>El concepto de <em>vista</em> es importante para entender lo que está pasando. Las operaciones más frecuentes devuelven vistas y no copias. Esto ahorra memoria y es más veloz, pero si no lo sabés puede traerte problemas.</p>
<p>Veamos este ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
</code></pre>
<p>Ahora creamos <code>b1</code> a partir de una rebanada de <code>a</code> y modificamos su primer elemento. ¡Esto va a modificar el elemento correspondiente de <code>a</code> también!</p>
<pre><code class="language-python">&gt;&gt;&gt; b1 = a[0, :]
&gt;&gt;&gt; b1
array([1, 2, 3, 4])
&gt;&gt;&gt; b1[0] = 99
&gt;&gt;&gt; b1
array([99,  2,  3,  4])
&gt;&gt;&gt; a
array([[99,  2,  3,  4],
 [ 5,  6,  7,  8],
 [ 9, 10, 11, 12]])
</code></pre>
<p>Podés usar el método <code>copy</code> para copiar los datos. Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; b2 = a[1, :].copy()
&gt;&gt;&gt; b2
array([5, 6, 7, 8])
&gt;&gt;&gt; b2[0] = 95
&gt;&gt;&gt; b2
array([95,  6,  7,  8])
&gt;&gt;&gt; a # ¡no se modifica el 5!
array([[99,  2,  3,  4],
 [ 5,  6,  7,  8],
 [ 9, 10, 11, 12]])
</code></pre>
<h2 id="operaciones-basicas-sobre-arreglos">Operaciones básicas sobre arreglos</h2>
<p>Una vez que sabés crear arreglos podés empezar a trabajar con ellos. Imaginemos que tenés dos arreglos, uno llamados “data” y otro llamado “ones”.</p>
<p><img alt="./np_array_dataones.png" src="../np_array_dataones.png" /></p>
<p>Podés sumarlos con el signo más.</p>
<pre><code class="language-python">&gt;&gt;&gt; data = np.array([1, 2])
&gt;&gt;&gt; ones = np.ones(2, dtype=int)
&gt;&gt;&gt; data + ones
array([2, 3])
</code></pre>
<p><img alt="./np_data_plus_ones.png" src="../np_data_plus_ones.png" /></p>
<p>Obviamente, podés hacer otras operaciones.</p>
<pre><code class="language-python">&gt;&gt;&gt; data - ones
array([0, 1])
&gt;&gt;&gt; data * data
array([1, 4])
&gt;&gt;&gt; data / data
array([1., 1.])
</code></pre>
<p><img alt="./np_sub_mult_divide.png" src="../np_sub_mult_divide.png" /></p>
<p>Estas operaciones básicas son simples con numpy. Si querés calcular la suma de los elementos del arreglo, podés usar <code>sum()</code>. Esto funciona para vectores, matrices y arreglos de dimensión más alta también.</p>
<pre><code class="language-python">&gt;&gt;&gt; a = np.array([1, 2, 3, 4])
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; a.sum()
10
</code></pre>
<p>Para sumar los valores por fila o por columna en una matriz, simplemente tenés que especificar el eje sobre el que se hará la suma.</p>
<p>Si tenés la matriz:</p>
<pre><code class="language-python">&gt;&gt;&gt; b = np.array([[1, 1], [2, 2]])
</code></pre>
<p>podés sumar los datos de cada columna con:</p>
<pre><code class="language-python">&gt;&gt;&gt; b.sum(axis=0)
array([3, 3])
</code></pre>
<p>y los datos de cada fila usando:</p>
<pre><code class="language-python">&gt;&gt;&gt; b.sum(axis=1)
array([2, 4])
</code></pre>
<h2 id="broadcasting">Broadcasting</h2>
<p>Hay veces en que necesitás realizar una operación entre un arreglo y un número (en matemática le decimos, un <em>escalar</em>). Por ejemplo tenés un vector con distancias en millas (lo llamamos "data") y lo necesitás convertir a distancias en kilómetros. Podés hacer esta operación así:</p>
<pre><code class="language-python">&gt;&gt;&gt; data = np.array([1.0, 2.0])
&gt;&gt;&gt; data * 1.6
array([1.6, 3.2])
</code></pre>
<p><img alt="./np_multiply_broadcasting.png" src="../np_multiply_broadcasting.png" /></p>
<p>numpy entiende que la multiplicación debe ocurrir en cada celda del vector. Este concepto se llama <strong>broadcasting</strong>. El mecanismo de broadcasting le permite a numpy realizar operaciones en arreglos de diferente tamaño, pero los tamaños deben ser compatibles. Por ejemplo si ambos arreglos tienen el mismo tamaño o si uno tiene tamaño 1 (escalar). Si los tamaños no son compatibles, te va a dar un <code>ValueError</code>.</p>
<h2 id="operaciones-un-poco-mas-complejas">Operaciones un poco más complejas</h2>
<p>numpy también te permite realizar operaciones que resumen los datos. Además de  <code>min</code>, <code>max</code>, y <code>sum</code>, podés usar  <code>mean</code> para obtener el promedio, <code>prod</code> para calcular el producto, <code>std</code> para obtener el desvío estándar de los datos, y más.</p>
<pre><code class="language-python">&gt;&gt;&gt; data.max()
2.0
&gt;&gt;&gt; data.min()
1.0
&gt;&gt;&gt; data.sum()
3.0
</code></pre>
<p><img alt="./np_aggregation.png" src="../np_aggregation.png" /></p>
<p>Supongamos que tenemos un arreglo, llamado “a”</p>
<pre><code class="language-python">&gt;&gt;&gt; a = np.array([[0.45053314, 0.17296777, 0.34376245, 0.5510652],
...               [0.54627315, 0.05093587, 0.40067661, 0.55645993],
...               [0.12697628, 0.82485143, 0.26590556, 0.56917101]])
</code></pre>
<p>Es usual procesar los datos por fila o por columna. Si no lo aclarás, numpy procesa los datos de todo el arreglo. Para encontrar la suma o el mínimo del  arreglo, usá:</p>
<pre><code class="language-python">&gt;&gt;&gt; a.sum()
4.8595784
</code></pre>
<p>O:</p>
<pre><code class="language-python">&gt;&gt;&gt; a.min()
0.05093587
</code></pre>
<p>Podés especificar qué eje querés considerar. Por ejemplo, para calcular el mínimo de cada columna especificás <code>axis=0</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; a.min(axis=0)
array([0.12697628, 0.05093587, 0.26590556, 0.5510652 ])
</code></pre>
<p>Son cuatro valores, porque la matriz tiene cuatro columnas. </p>
<h2 id="crear-matrices">Crear matrices</h2>
<p>Podés usar listas de listas para crear arreglos bidimensionales (matrices).</p>
<pre><code class="language-python">&gt;&gt;&gt; data = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; data
array([[1, 2],
 [3, 4]])
</code></pre>
<p><img alt="./np_create_matrix.png" src="../np_create_matrix.png" /></p>
<p>Las técnicas de indexación y rebanadas son muy útiles para manipular matrices:</p>
<pre><code class="language-python">&gt;&gt;&gt; data = np.array([[1, 2], [3, 4], [5, 6]])
&gt;&gt;&gt; data[0, 1]
2
&gt;&gt;&gt; data[1:3]
array([[3, 4], [5, 6]])
&gt;&gt;&gt; data[0:2, 0]
array([1, 3])
</code></pre>
<p><img alt="./np_matrix_indexing.png" src="../np_matrix_indexing.png" /></p>
<p>Podés procesar los datos de matrices como lo hicimos con vectores:</p>
<pre><code class="language-python">&gt;&gt;&gt; data.max()
6
&gt;&gt;&gt; data.min()
1
&gt;&gt;&gt; data.sum()
21
</code></pre>
<p><img alt="./np_matrix_aggregation.png" src="../np_matrix_aggregation.png" /></p>
<p>Podés procesar todos, o hacerlo por fila o por columna usando el parámetro  <code>axis</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; data = np.array([[1, 2], [5, 3], [4, 6]])
&gt;&gt;&gt; data.max(axis=0)
array([5, 6])
&gt;&gt;&gt; data.max(axis=1)
array([2, 5, 6])
</code></pre>
<p><img alt="./np_matrix_aggregation_row.png" src="../np_matrix_aggregation_row.png" /></p>
<p>Una vez que tenés tus matrices creadas, podés hacer artimética con pares de matrices del mismo tamaño.</p>
<pre><code class="language-python">&gt;&gt;&gt; data = np.array([[1, 2], [3, 4]])
&gt;&gt;&gt; ones = np.array([[1, 1], [1, 1]])
&gt;&gt;&gt; data + ones
array([[2, 3],
 [4, 5]])
</code></pre>
<p><img alt="./np_matrix_arithmetic.png" src="../np_matrix_arithmetic.png" /></p>
<p>También se pueden sumar matrices de tamaños diferentes, pero sólo si una de ellas tiene una sola fila o una sola columna. En este caso, numpy va a usar las reglas de <em>broadcast</em> para la operación.</p>
<pre><code class="language-python">&gt;&gt;&gt; data = np.array([[1, 2], [3, 4], [5, 6]])
&gt;&gt;&gt; ones_row = np.array([[1, 1]])
&gt;&gt;&gt; data + ones_row
array([[2, 3],
 [4, 5],
 [6, 7]])
</code></pre>
<p><img alt="./np_matrix_broadcasting.png" src="../np_matrix_broadcasting.png" /></p>
<p>Tené en cuenta que cuando numpy imprime arreglos n-dimensionales, el último eje se itera más rápido y el primero más lento. Por ejemplo:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.ones((4, 3, 2))
array([[[1., 1.],
 [1., 1.],
 [1., 1.]],

 [[1., 1.],
 [1., 1.],
 [1., 1.]],

 [[1., 1.],
 [1., 1.],
 [1., 1.]],

 [[1., 1.],
 [1., 1.],
 [1., 1.]]])
</code></pre>
<p>Es frecuente que querramos inicializar los valores de una matriz. numpy ofrece las funciones <code>ones()</code> y <code>zeros()</code>, así como también la clase <code>random.Generator</code> que genera número aleatorios. Sólo hay que pasarle la cantidad de elementos que queremos generar:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.ones(3)
array([1., 1., 1.])
&gt;&gt;&gt; np.zeros(3)
array([0., 0., 0.])
&gt;&gt;&gt; np.random.random(3)
array([0.63696169, 0.26978671, 0.04097352]) # puede variar
</code></pre>
<p><img alt="./np_ones_zeros_random.png" src="../np_ones_zeros_random.png" /></p>
<p>También podés usar  <code>ones()</code>, <code>zeros()</code>, y <code>random()</code> para crear matrices, si le pasás una tupla describiendo la forma de la matriz:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.ones((3, 2))
array([[1., 1.],
 [1., 1.],
 [1., 1.]])
&gt;&gt;&gt; np.zeros((3, 2))
array([[0., 0.],
 [0., 0.],
 [0., 0.]])
&gt;&gt;&gt; np.random.random((3, 2))
array([[0.01652764, 0.81327024],
 [0.91275558, 0.60663578],
 [0.72949656, 0.54362499]])  # puede variar
</code></pre>
<p><img alt="./np_ones_zeros_matrix.png" src="../np_ones_zeros_matrix.png" /></p>
<p>Esta idea se generaliza a dimensiones más altas.</p>
<h2 id="formulas-matematicas">Fórmulas matemáticas</h2>
<p>La facilidad para implementar fórmulas matemáticas sobre un arreglo es una de las características de numpy que lo hacen tan ampliamente usado en la comunidad científica de Python.</p>
<p>Por ejemplo, ésta es la fórmula del error cuadrático medio:</p>
<p><img alt="./np_MSE_formula.png" src="../np_MSE_formula.png" /></p>
<p>Implementar esta fórmula es simple y directo con numpy:</p>
<p><img alt="./np_MSE_implementation.png" src="../np_MSE_implementation.png" /></p>
<p>Lo genial de esta abstracción es que <code>predictions</code> y <code>labels</code> puede tener uno o mil valores. Sólo tienen que tener el mismo tamaño para que todo funcione.</p>
<p>Lo podés visulalizar así:</p>
<p><img alt="./np_mse_viz1.png" src="../np_mse_viz1.png" /></p>
<p>En este ejemplo, tanto las predicciones como las etiquetas tienen tres valores. Es decir <code>n</code> vale tres. Luego de hacer la resta los valores se elevan al cuadrado. Luego numpy suma los valores, divide por tres, y el resultado es el error de esa predicción y puede usarse como un <em>puntaje</em> que mide la calidad del modelo que predice.</p>
<p><img alt="./np_mse_viz2.png" src="../np_mse_viz2.png" /> <img alt="./np_MSE_explanation2.png" src="../np_MSE_explanation2.png" /></p>
<h2 id="guardar-y-cargar-objetos-de-numpy">Guardar y cargar objetos de numpy</h2>
<p>Si seguís usando Python después de este curso, es muy probable que en cierto punto quieras guardar tus matrices (o arreglos n-dimensionales) para cargarlas en otro momento sin tener que volver a correr el código que las genera. Hay un par de formas de guardar objetos de numpy. Los objetos ndarray pueden guardarse y leerse de disco con las funciones <code>loadtxt</code> y <code>savetxt</code> usando archivos de texto (tienen la ventaja de que los podés ver con un editor de textos como el <a href="https://www.sublimetext.com/">sublime</a> o <a href="https://www.geany.org/">geany</a>), y con las funciones <code>load</code> y <code>save</code> que guardan archivos binarios con extensión <strong>.npy</strong>.
Los archivos <strong>.npy</strong> guardan los datos, la forma, el tipo del arreglo y otra información necesaria que permiten reconstruirlos correctamente, incluso en otra máquina con otra arquitectura.</p>
<p>Es sencillo guardar un arreglo con <code>np.save()</code>. Solo asegurate de especificar el arreglo que querés guardar y el nombre del archivo. Por ejemplo, si creás este vector:</p>
<pre><code class="language-python">&gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5, 6])
</code></pre>
<p>Lo podés guardar en “filename.npy” con:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.save('filename', a)
</code></pre>
<p>Y lo podés cargar con  <code>np.load()</code> para reconstruir tu vector.</p>
<pre><code class="language-python">&gt;&gt;&gt; b = np.load('filename.npy')
</code></pre>
<p>Para verificarlo, usá:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(b)
[1 2 3 4 5 6]
</code></pre>
<p>En formato de texto plano, lo podés guardar como <strong>.csv</strong> o <strong>.txt</strong> con <code>np.savetxt</code>.</p>
<p>Por ejemplo, si tenés este vector:</p>
<pre><code class="language-python">&gt;&gt;&gt; csv_arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
</code></pre>
<p>lo podés guardar en un archivo .csv con nombre “new_file.csv” así:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.savetxt('new_file.csv', csv_arr)
</code></pre>
<p>Y lo podés cargar fácilmente usando <code>loadtxt()</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; np.loadtxt('new_file.csv')
array([1., 2., 3., 4., 5., 6., 7., 8.])
</code></pre>
<p>Las funciones <code>savetxt()</code> y <code>loadtxt()</code> aceptan parámetros adicionales para especificar el encabezado y los delimitadores. Si bien los archivos de texto son sencillos para compartir, los archivos .npy (y .npz) son más pequeños y se leen más rápidamente. </p>
<h3 id="ejercicio-58-guardar-temperaturas">Ejercicio 5.8: Guardar temperaturas</h3>
<p>Ampliá el código de <code>termometro.py</code> que escribiste en el <a href="../01_Random/#ejercicio-56-gaussiana">Ejercicio 5.6</a> para que guarde el vector con las temperaturas simuladas en el directorio <code>Data</code> de tu carpeta de ejercicios, en un archivo llamado <code>Temperaturas.npy</code>. Hacé que corra 999 veces en lugar de solo 99.</p>
<h3 id="ejercicio-59-empezando-a-plotear">Ejercicio 5.9: Empezando a plotear</h3>
<p>En un rato vamos a empezar a hacer gráficos con Python. Aquí solo un botón de muestra.</p>
<p>Escribí un archivo <code>plotear_temperaturas.py</code> que lea el archivo de datos  <code>Temperaturas.npy</code> con 999 mediciones simuladas que creaste recién y, usando el siguiente ejemplo, hacé un histograma de las temperaturas simuladas:</p>
<pre><code class="language-python">import matplotlib.pyplot as plt
plt.hist(temperaturas,bins=25)
plt.show() #el show no hace falta en algunos entornos. A veces lo omitiremos.
</code></pre>
<p>Ajustá la cantidad de <em>bins</em> para que el gráfico se vea lo mejor posible.</p>
<p><a href="../Contenidos.md">Contenidos</a> | <a href="../01_Random/">Anterior (1 Random)</a> | <a href="../03_Figuritas/">Próximo (3 El album de Figuritas)</a></p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentación construida con <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Buscar</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Cerrar</span></button>
            </div>
            <div class="modal-body">
                <p>Desde aquí puede buscar estos documentos. Ingrese sus términos de búsqueda a continuación.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Buscando..." id="mkdocs-search-query" title="Escriba el término de búsqueda aquí">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No se encontraron resultados"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Atajos de teclado</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Cerrar</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Teclas</th>
                    <th>Acción</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Abrir esta ayuda</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Página siguiente</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Página anterior</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Buscar</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
